// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AWSV4Signature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.access_key.is_some() {
            state.serialize_entry("accessKey", &self.access_key)?;
        }
        if self.access_key_id.is_some() {
            state.serialize_entry("accessKeyId", &self.access_key_id)?;
        }
        if self.access_key_version.is_some() {
            state.serialize_entry("accessKeyVersion", &self.access_key_version)?;
        }
        if self.origin_region.is_some() {
            state.serialize_entry("originRegion", &self.origin_region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "node-groups",
    feature = "node-templates",
    feature = "region-commitments",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if self.accelerator_type.is_some() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorTopologiesInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerator_topology_infos.is_empty() {
            state.serialize_entry("acceleratorTopologyInfos", &self.accelerator_topology_infos)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorTopologiesInfoAcceleratorTopologyInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_topology.is_some() {
            state.serialize_entry("acceleratorTopology", &self.accelerator_topology)?;
        }
        if !self.info_per_topology_states.is_empty() {
            state.serialize_entry("infoPerTopologyStates", &self.info_per_topology_states)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::AcceleratorTopologiesInfoAcceleratorTopologyInfoInfoPerTopologyState
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.maximum_cards_per_instance.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumCardsPerInstance",
                &__With(&self.maximum_cards_per_instance),
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerator_types.is_empty() {
            state.serialize_entry("acceleratorTypes", &self.accelerator_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "accelerator-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::accelerator_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AccessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.external_ipv_6.is_some() {
            state.serialize_entry("externalIpv6", &self.external_ipv_6)?;
        }
        if self.external_ipv_6_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "externalIpv6PrefixLength",
                &__With(&self.external_ipv_6_prefix_length),
            )?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.nat_ip.is_some() {
            state.serialize_entry("natIP", &self.nat_ip)?;
        }
        if self.network_tier.is_some() {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if self.public_ptr_domain_name.is_some() {
            state.serialize_entry("publicPtrDomainName", &self.public_ptr_domain_name)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.set_public_ptr.is_some() {
            state.serialize_entry("setPublicPtr", &self.set_public_ptr)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "addresses", feature = "global-addresses",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Address {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.address.is_some() {
            state.serialize_entry("address", &self.address)?;
        }
        if self.address_type.is_some() {
            state.serialize_entry("addressType", &self.address_type)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_version.is_some() {
            state.serialize_entry("ipVersion", &self.ip_version)?;
        }
        if self.ipv_6_endpoint_type.is_some() {
            state.serialize_entry("ipv6EndpointType", &self.ipv_6_endpoint_type)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.network_tier.is_some() {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if self.prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("prefixLength", &__With(&self.prefix_length))?;
        }
        if self.purpose.is_some() {
            state.serialize_entry("purpose", &self.purpose)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.users.is_empty() {
            state.serialize_entry("users", &self.users)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AddressAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::address_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::address_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "addresses", feature = "global-addresses",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AddressList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "addresses", feature = "global-addresses",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::address_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "addresses", feature = "global-addresses",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::address_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AddressesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.addresses.is_empty() {
            state.serialize_entry("addresses", &self.addresses)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::addresses_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::addresses_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AdvancedMachineFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_nested_virtualization.is_some() {
            state.serialize_entry(
                "enableNestedVirtualization",
                &self.enable_nested_virtualization,
            )?;
        }
        if self.enable_uefi_networking.is_some() {
            state.serialize_entry("enableUefiNetworking", &self.enable_uefi_networking)?;
        }
        if self.performance_monitoring_unit.is_some() {
            state.serialize_entry(
                "performanceMonitoringUnit",
                &self.performance_monitoring_unit,
            )?;
        }
        if self.threads_per_core.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("threadsPerCore", &__With(&self.threads_per_core))?;
        }
        if self.turbo_mode.is_some() {
            state.serialize_entry("turboMode", &self.turbo_mode)?;
        }
        if self.visible_core_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("visibleCoreCount", &__With(&self.visible_core_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AliasIpRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.subnetwork_range_name.is_some() {
            state.serialize_entry("subnetworkRangeName", &self.subnetwork_range_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationAggregateReservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.in_use_resources.is_empty() {
            state.serialize_entry("inUseResources", &self.in_use_resources)?;
        }
        if !self.reserved_resources.is_empty() {
            state.serialize_entry("reservedResources", &self.reserved_resources)?;
        }
        if self.vm_family.is_some() {
            state.serialize_entry("vmFamily", &self.vm_family)?;
        }
        if self.workload_type.is_some() {
            state.serialize_entry("workloadType", &self.workload_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationAggregateReservationReservedResourceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator.is_some() {
            state.serialize_entry("accelerator", &self.accelerator)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::AllocationAggregateReservationReservedResourceInfoAccelerator
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if self.accelerator_type.is_some() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationReservationSharingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service_share_type.is_some() {
            state.serialize_entry("serviceShareType", &self.service_share_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.health_info.is_some() {
            state.serialize_entry("healthInfo", &self.health_info)?;
        }
        if self.reservation_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "reservationBlockCount",
                &__With(&self.reservation_block_count),
            )?;
        }
        if self.reservation_maintenance.is_some() {
            state.serialize_entry("reservationMaintenance", &self.reservation_maintenance)?;
        }
        if self.specific_sku_allocation.is_some() {
            state.serialize_entry("specificSkuAllocation", &self.specific_sku_allocation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationResourceStatusHealthInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.degraded_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("degradedBlockCount", &__With(&self.degraded_block_count))?;
        }
        if self.health_status.is_some() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if self.healthy_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyBlockCount", &__With(&self.healthy_block_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationResourceStatusSpecificSKUAllocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_instance_template_id.is_some() {
            state.serialize_entry(
                "sourceInstanceTemplateId",
                &self.source_instance_template_id,
            )?;
        }
        if !self.utilizations.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("utilizations", &__With(&self.utilizations))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.interface.is_some() {
            state.serialize_entry("interface", &self.interface)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationSpecificSKUAllocationReservedInstanceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if !self.local_ssds.is_empty() {
            state.serialize_entry("localSsds", &self.local_ssds)?;
        }
        if self.location_hint.is_some() {
            state.serialize_entry("locationHint", &self.location_hint)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AllocationSpecificSKUReservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.assured_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("assuredCount", &__With(&self.assured_count))?;
        }
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.in_use_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("inUseCount", &__With(&self.in_use_count))?;
        }
        if self.instance_properties.is_some() {
            state.serialize_entry("instanceProperties", &self.instance_properties)?;
        }
        if self.source_instance_template.is_some() {
            state.serialize_entry("sourceInstanceTemplate", &self.source_instance_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AttachedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if self.boot.is_some() {
            state.serialize_entry("boot", &self.boot)?;
        }
        if self.device_name.is_some() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.force_attach.is_some() {
            state.serialize_entry("forceAttach", &self.force_attach)?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.index.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.initialize_params.is_some() {
            state.serialize_entry("initializeParams", &self.initialize_params)?;
        }
        if self.interface.is_some() {
            state.serialize_entry("interface", &self.interface)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.saved_state.is_some() {
            state.serialize_entry("savedState", &self.saved_state)?;
        }
        if self.shielded_instance_initial_state.is_some() {
            state.serialize_entry(
                "shieldedInstanceInitialState",
                &self.shielded_instance_initial_state,
            )?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AttachedDiskInitializeParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_name.is_some() {
            state.serialize_entry("diskName", &self.disk_name)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.disk_type.is_some() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.on_update_action.is_some() {
            state.serialize_entry("onUpdateAction", &self.on_update_action)?;
        }
        if self.provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("provisionedIops", &__With(&self.provisioned_iops))?;
        }
        if self.provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "provisionedThroughput",
                &__With(&self.provisioned_throughput),
            )?;
        }
        if !self.replica_zones.is_empty() {
            state.serialize_entry("replicaZones", &self.replica_zones)?;
        }
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.source_image.is_some() {
            state.serialize_entry("sourceImage", &self.source_image)?;
        }
        if self.source_image_encryption_key.is_some() {
            state.serialize_entry(
                "sourceImageEncryptionKey",
                &self.source_image_encryption_key,
            )?;
        }
        if self.source_snapshot.is_some() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if self.source_snapshot_encryption_key.is_some() {
            state.serialize_entry(
                "sourceSnapshotEncryptionKey",
                &self.source_snapshot_encryption_key,
            )?;
        }
        if self.storage_pool.is_some() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "firewall-policies",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AuditConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audit_log_configs.is_empty() {
            state.serialize_entry("auditLogConfigs", &self.audit_log_configs)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "firewall-policies",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AuditLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.exempted_members.is_empty() {
            state.serialize_entry("exemptedMembers", &self.exempted_members)?;
        }
        if self.log_type.is_some() {
            state.serialize_entry("logType", &self.log_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Autoscaler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.autoscaling_policy.is_some() {
            state.serialize_entry("autoscalingPolicy", &self.autoscaling_policy)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.recommended_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("recommendedSize", &__With(&self.recommended_size))?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.scaling_schedule_status.is_empty() {
            state.serialize_entry("scalingScheduleStatus", &self.scaling_schedule_status)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_details.is_empty() {
            state.serialize_entry("statusDetails", &self.status_details)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalerAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscaler_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscaler_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalerList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscaler_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscaler_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalerStatusDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalersScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.autoscalers.is_empty() {
            state.serialize_entry("autoscalers", &self.autoscalers)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscalers_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::autoscalers_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cool_down_period_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("coolDownPeriodSec", &__With(&self.cool_down_period_sec))?;
        }
        if self.cpu_utilization.is_some() {
            state.serialize_entry("cpuUtilization", &self.cpu_utilization)?;
        }
        if !self.custom_metric_utilizations.is_empty() {
            state.serialize_entry("customMetricUtilizations", &self.custom_metric_utilizations)?;
        }
        if self.load_balancing_utilization.is_some() {
            state.serialize_entry("loadBalancingUtilization", &self.load_balancing_utilization)?;
        }
        if self.max_num_replicas.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxNumReplicas", &__With(&self.max_num_replicas))?;
        }
        if self.min_num_replicas.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNumReplicas", &__With(&self.min_num_replicas))?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.scale_in_control.is_some() {
            state.serialize_entry("scaleInControl", &self.scale_in_control)?;
        }
        if !self.scaling_schedules.is_empty() {
            state.serialize_entry("scalingSchedules", &self.scaling_schedules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicyCpuUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.predictive_method.is_some() {
            state.serialize_entry("predictiveMethod", &self.predictive_method)?;
        }
        if self.utilization_target.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("utilizationTarget", &__With(&self.utilization_target))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicyCustomMetricUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if self.single_instance_assignment.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "singleInstanceAssignment",
                &__With(&self.single_instance_assignment),
            )?;
        }
        if self.utilization_target.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("utilizationTarget", &__With(&self.utilization_target))?;
        }
        if self.utilization_target_type.is_some() {
            state.serialize_entry("utilizationTargetType", &self.utilization_target_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicyLoadBalancingUtilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.utilization_target.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("utilizationTarget", &__With(&self.utilization_target))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicyScaleInControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_scaled_in_replicas.is_some() {
            state.serialize_entry("maxScaledInReplicas", &self.max_scaled_in_replicas)?;
        }
        if self.time_window_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("timeWindowSec", &__With(&self.time_window_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::AutoscalingPolicyScalingSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disabled.is_some() {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.duration_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("durationSec", &__With(&self.duration_sec))?;
        }
        if self.min_required_replicas.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minRequiredReplicas", &__With(&self.min_required_replicas))?;
        }
        if self.schedule.is_some() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Backend {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.balancing_mode.is_some() {
            state.serialize_entry("balancingMode", &self.balancing_mode)?;
        }
        if self.capacity_scaler.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("capacityScaler", &__With(&self.capacity_scaler))?;
        }
        if !self.custom_metrics.is_empty() {
            state.serialize_entry("customMetrics", &self.custom_metrics)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.failover.is_some() {
            state.serialize_entry("failover", &self.failover)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if self.max_connections.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxConnections", &__With(&self.max_connections))?;
        }
        if self.max_connections_per_endpoint.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxConnectionsPerEndpoint",
                &__With(&self.max_connections_per_endpoint),
            )?;
        }
        if self.max_connections_per_instance.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxConnectionsPerInstance",
                &__With(&self.max_connections_per_instance),
            )?;
        }
        if self.max_rate.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRate", &__With(&self.max_rate))?;
        }
        if self.max_rate_per_endpoint.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRatePerEndpoint", &__With(&self.max_rate_per_endpoint))?;
        }
        if self.max_rate_per_instance.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRatePerInstance", &__With(&self.max_rate_per_instance))?;
        }
        if self.max_utilization.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxUtilization", &__With(&self.max_utilization))?;
        }
        if self.preference.is_some() {
            state.serialize_entry("preference", &self.preference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bucket_name.is_some() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if self.cdn_policy.is_some() {
            state.serialize_entry("cdnPolicy", &self.cdn_policy)?;
        }
        if self.compression_mode.is_some() {
            state.serialize_entry("compressionMode", &self.compression_mode)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if !self.custom_response_headers.is_empty() {
            state.serialize_entry("customResponseHeaders", &self.custom_response_headers)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.edge_security_policy.is_some() {
            state.serialize_entry("edgeSecurityPolicy", &self.edge_security_policy)?;
        }
        if self.enable_cdn.is_some() {
            state.serialize_entry("enableCdn", &self.enable_cdn)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.load_balancing_scheme.is_some() {
            state.serialize_entry("loadBalancingScheme", &self.load_balancing_scheme)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.used_by.is_empty() {
            state.serialize_entry("usedBy", &self.used_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketCdnPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bypass_cache_on_request_headers.is_empty() {
            state.serialize_entry(
                "bypassCacheOnRequestHeaders",
                &self.bypass_cache_on_request_headers,
            )?;
        }
        if self.cache_key_policy.is_some() {
            state.serialize_entry("cacheKeyPolicy", &self.cache_key_policy)?;
        }
        if self.cache_mode.is_some() {
            state.serialize_entry("cacheMode", &self.cache_mode)?;
        }
        if self.client_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("clientTtl", &__With(&self.client_ttl))?;
        }
        if self.default_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("defaultTtl", &__With(&self.default_ttl))?;
        }
        if self.max_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxTtl", &__With(&self.max_ttl))?;
        }
        if self.negative_caching.is_some() {
            state.serialize_entry("negativeCaching", &self.negative_caching)?;
        }
        if !self.negative_caching_policy.is_empty() {
            state.serialize_entry("negativeCachingPolicy", &self.negative_caching_policy)?;
        }
        if self.request_coalescing.is_some() {
            state.serialize_entry("requestCoalescing", &self.request_coalescing)?;
        }
        if self.serve_while_stale.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("serveWhileStale", &__With(&self.serve_while_stale))?;
        }
        if self.signed_url_cache_max_age_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "signedUrlCacheMaxAgeSec",
                &__With(&self.signed_url_cache_max_age_sec),
            )?;
        }
        if !self.signed_url_key_names.is_empty() {
            state.serialize_entry("signedUrlKeyNames", &self.signed_url_key_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketCdnPolicyBypassCacheOnRequestHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.header_name.is_some() {
            state.serialize_entry("headerName", &self.header_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketCdnPolicyCacheKeyPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.include_http_headers.is_empty() {
            state.serialize_entry("includeHttpHeaders", &self.include_http_headers)?;
        }
        if !self.query_string_whitelist.is_empty() {
            state.serialize_entry("queryStringWhitelist", &self.query_string_whitelist)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketCdnPolicyNegativeCachingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("code", &__With(&self.code))?;
        }
        if self.ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ttl", &__With(&self.ttl))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_bucket_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_bucket_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-buckets")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendBucketUsedBy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reference.is_some() {
            state.serialize_entry("reference", &self.reference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendCustomMetric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dry_run.is_some() {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if self.max_utilization.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxUtilization", &__With(&self.max_utilization))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.affinity_cookie_ttl_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "affinityCookieTtlSec",
                &__With(&self.affinity_cookie_ttl_sec),
            )?;
        }
        if !self.backends.is_empty() {
            state.serialize_entry("backends", &self.backends)?;
        }
        if self.cdn_policy.is_some() {
            state.serialize_entry("cdnPolicy", &self.cdn_policy)?;
        }
        if self.circuit_breakers.is_some() {
            state.serialize_entry("circuitBreakers", &self.circuit_breakers)?;
        }
        if self.compression_mode.is_some() {
            state.serialize_entry("compressionMode", &self.compression_mode)?;
        }
        if self.connection_draining.is_some() {
            state.serialize_entry("connectionDraining", &self.connection_draining)?;
        }
        if self.connection_tracking_policy.is_some() {
            state.serialize_entry("connectionTrackingPolicy", &self.connection_tracking_policy)?;
        }
        if self.consistent_hash.is_some() {
            state.serialize_entry("consistentHash", &self.consistent_hash)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if !self.custom_metrics.is_empty() {
            state.serialize_entry("customMetrics", &self.custom_metrics)?;
        }
        if !self.custom_request_headers.is_empty() {
            state.serialize_entry("customRequestHeaders", &self.custom_request_headers)?;
        }
        if !self.custom_response_headers.is_empty() {
            state.serialize_entry("customResponseHeaders", &self.custom_response_headers)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.edge_security_policy.is_some() {
            state.serialize_entry("edgeSecurityPolicy", &self.edge_security_policy)?;
        }
        if self.enable_cdn.is_some() {
            state.serialize_entry("enableCDN", &self.enable_cdn)?;
        }
        if self.external_managed_migration_state.is_some() {
            state.serialize_entry(
                "externalManagedMigrationState",
                &self.external_managed_migration_state,
            )?;
        }
        if self.external_managed_migration_testing_percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "externalManagedMigrationTestingPercentage",
                &__With(&self.external_managed_migration_testing_percentage),
            )?;
        }
        if self.failover_policy.is_some() {
            state.serialize_entry("failoverPolicy", &self.failover_policy)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.ha_policy.is_some() {
            state.serialize_entry("haPolicy", &self.ha_policy)?;
        }
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if self.iap.is_some() {
            state.serialize_entry("iap", &self.iap)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_address_selection_policy.is_some() {
            state.serialize_entry(
                "ipAddressSelectionPolicy",
                &self.ip_address_selection_policy,
            )?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.load_balancing_scheme.is_some() {
            state.serialize_entry("loadBalancingScheme", &self.load_balancing_scheme)?;
        }
        if !self.locality_lb_policies.is_empty() {
            state.serialize_entry("localityLbPolicies", &self.locality_lb_policies)?;
        }
        if self.locality_lb_policy.is_some() {
            state.serialize_entry("localityLbPolicy", &self.locality_lb_policy)?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.max_stream_duration.is_some() {
            state.serialize_entry("maxStreamDuration", &self.max_stream_duration)?;
        }
        if !self.metadatas.is_empty() {
            state.serialize_entry("metadatas", &self.metadatas)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.outlier_detection.is_some() {
            state.serialize_entry("outlierDetection", &self.outlier_detection)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.protocol.is_some() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.security_settings.is_some() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.service_bindings.is_empty() {
            state.serialize_entry("serviceBindings", &self.service_bindings)?;
        }
        if self.service_lb_policy.is_some() {
            state.serialize_entry("serviceLbPolicy", &self.service_lb_policy)?;
        }
        if self.session_affinity.is_some() {
            state.serialize_entry("sessionAffinity", &self.session_affinity)?;
        }
        if self.strong_session_affinity_cookie.is_some() {
            state.serialize_entry(
                "strongSessionAffinityCookie",
                &self.strong_session_affinity_cookie,
            )?;
        }
        if self.subsetting.is_some() {
            state.serialize_entry("subsetting", &self.subsetting)?;
        }
        if self.timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("timeoutSec", &__With(&self.timeout_sec))?;
        }
        if self.tls_settings.is_some() {
            state.serialize_entry("tlsSettings", &self.tls_settings)?;
        }
        if !self.used_by.is_empty() {
            state.serialize_entry("usedBy", &self.used_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceCdnPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bypass_cache_on_request_headers.is_empty() {
            state.serialize_entry(
                "bypassCacheOnRequestHeaders",
                &self.bypass_cache_on_request_headers,
            )?;
        }
        if self.cache_key_policy.is_some() {
            state.serialize_entry("cacheKeyPolicy", &self.cache_key_policy)?;
        }
        if self.cache_mode.is_some() {
            state.serialize_entry("cacheMode", &self.cache_mode)?;
        }
        if self.client_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("clientTtl", &__With(&self.client_ttl))?;
        }
        if self.default_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("defaultTtl", &__With(&self.default_ttl))?;
        }
        if self.max_ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxTtl", &__With(&self.max_ttl))?;
        }
        if self.negative_caching.is_some() {
            state.serialize_entry("negativeCaching", &self.negative_caching)?;
        }
        if !self.negative_caching_policy.is_empty() {
            state.serialize_entry("negativeCachingPolicy", &self.negative_caching_policy)?;
        }
        if self.request_coalescing.is_some() {
            state.serialize_entry("requestCoalescing", &self.request_coalescing)?;
        }
        if self.serve_while_stale.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("serveWhileStale", &__With(&self.serve_while_stale))?;
        }
        if self.signed_url_cache_max_age_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "signedUrlCacheMaxAgeSec",
                &__With(&self.signed_url_cache_max_age_sec),
            )?;
        }
        if !self.signed_url_key_names.is_empty() {
            state.serialize_entry("signedUrlKeyNames", &self.signed_url_key_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceCdnPolicyBypassCacheOnRequestHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.header_name.is_some() {
            state.serialize_entry("headerName", &self.header_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceCdnPolicyNegativeCachingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("code", &__With(&self.code))?;
        }
        if self.ttl.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ttl", &__With(&self.ttl))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceConnectionTrackingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.connection_persistence_on_unhealthy_backends.is_some() {
            state.serialize_entry(
                "connectionPersistenceOnUnhealthyBackends",
                &self.connection_persistence_on_unhealthy_backends,
            )?;
        }
        if self.enable_strong_affinity.is_some() {
            state.serialize_entry("enableStrongAffinity", &self.enable_strong_affinity)?;
        }
        if self.idle_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("idleTimeoutSec", &__With(&self.idle_timeout_sec))?;
        }
        if self.tracking_mode.is_some() {
            state.serialize_entry("trackingMode", &self.tracking_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceCustomMetric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dry_run.is_some() {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceFailoverPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disable_connection_drain_on_failover.is_some() {
            state.serialize_entry(
                "disableConnectionDrainOnFailover",
                &self.disable_connection_drain_on_failover,
            )?;
        }
        if self.drop_traffic_if_unhealthy.is_some() {
            state.serialize_entry("dropTrafficIfUnhealthy", &self.drop_traffic_if_unhealthy)?;
        }
        if self.failover_ratio.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("failoverRatio", &__With(&self.failover_ratio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceGroupHealth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.health_status.is_empty() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceHAPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fast_ip_move.is_some() {
            state.serialize_entry("fastIPMove", &self.fast_ip_move)?;
        }
        if self.leader.is_some() {
            state.serialize_entry("leader", &self.leader)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceHAPolicyLeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backend_group.is_some() {
            state.serialize_entry("backendGroup", &self.backend_group)?;
        }
        if self.network_endpoint.is_some() {
            state.serialize_entry("networkEndpoint", &self.network_endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceHAPolicyLeaderNetworkEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceHttpCookie {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceIAP {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.oauth_2_client_id.is_some() {
            state.serialize_entry("oauth2ClientId", &self.oauth_2_client_id)?;
        }
        if self.oauth_2_client_secret.is_some() {
            state.serialize_entry("oauth2ClientSecret", &self.oauth_2_client_secret)?;
        }
        if self.oauth_2_client_secret_sha_256.is_some() {
            state.serialize_entry(
                "oauth2ClientSecretSha256",
                &self.oauth_2_client_secret_sha_256,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceListUsable {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_list_usable::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_service_list_usable::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceLocalityLoadBalancingPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_policy.is_some() {
            state.serialize_entry("customPolicy", &self.custom_policy)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.data.is_some() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceLocalityLoadBalancingPolicyConfigPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self.optional_fields.is_empty() {
            state.serialize_entry("optionalFields", &self.optional_fields)?;
        }
        if self.optional_mode.is_some() {
            state.serialize_entry("optionalMode", &self.optional_mode)?;
        }
        if self.sample_rate.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sampleRate", &__With(&self.sample_rate))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backend_service.is_some() {
            state.serialize_entry("backendService", &self.backend_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceTlsSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.authentication_config.is_some() {
            state.serialize_entry("authenticationConfig", &self.authentication_config)?;
        }
        if self.sni.is_some() {
            state.serialize_entry("sni", &self.sni)?;
        }
        if !self.subject_alt_names.is_empty() {
            state.serialize_entry("subjectAltNames", &self.subject_alt_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceTlsSettingsSubjectAltName {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dns_name.is_some() {
            state.serialize_entry("dnsName", &self.dns_name)?;
        }
        if self.uniform_resource_identifier.is_some() {
            state.serialize_entry(
                "uniformResourceIdentifier",
                &self.uniform_resource_identifier,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServiceUsedBy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reference.is_some() {
            state.serialize_entry("reference", &self.reference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BackendServicesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backend_services.is_empty() {
            state.serialize_entry("backendServices", &self.backend_services)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_services_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "backend-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::backend_services_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BfdPacket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.authentication_present.is_some() {
            state.serialize_entry("authenticationPresent", &self.authentication_present)?;
        }
        if self.control_plane_independent.is_some() {
            state.serialize_entry("controlPlaneIndependent", &self.control_plane_independent)?;
        }
        if self.demand.is_some() {
            state.serialize_entry("demand", &self.demand)?;
        }
        if self.diagnostic.is_some() {
            state.serialize_entry("diagnostic", &self.diagnostic)?;
        }
        if self.r#final.is_some() {
            state.serialize_entry("final", &self.r#final)?;
        }
        if self.length.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if self.min_echo_rx_interval_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "minEchoRxIntervalMs",
                &__With(&self.min_echo_rx_interval_ms),
            )?;
        }
        if self.min_rx_interval_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minRxIntervalMs", &__With(&self.min_rx_interval_ms))?;
        }
        if self.min_tx_interval_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minTxIntervalMs", &__With(&self.min_tx_interval_ms))?;
        }
        if self.multiplier.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("multiplier", &__With(&self.multiplier))?;
        }
        if self.multipoint.is_some() {
            state.serialize_entry("multipoint", &self.multipoint)?;
        }
        if self.my_discriminator.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("myDiscriminator", &__With(&self.my_discriminator))?;
        }
        if self.poll.is_some() {
            state.serialize_entry("poll", &self.poll)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.version.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if self.your_discriminator.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("yourDiscriminator", &__With(&self.your_discriminator))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BfdStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bfd_session_initialization_mode.is_some() {
            state.serialize_entry(
                "bfdSessionInitializationMode",
                &self.bfd_session_initialization_mode,
            )?;
        }
        if self.config_update_timestamp_micros.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "configUpdateTimestampMicros",
                &__With(&self.config_update_timestamp_micros),
            )?;
        }
        if self.control_packet_counts.is_some() {
            state.serialize_entry("controlPacketCounts", &self.control_packet_counts)?;
        }
        if !self.control_packet_intervals.is_empty() {
            state.serialize_entry("controlPacketIntervals", &self.control_packet_intervals)?;
        }
        if self.local_diagnostic.is_some() {
            state.serialize_entry("localDiagnostic", &self.local_diagnostic)?;
        }
        if self.local_state.is_some() {
            state.serialize_entry("localState", &self.local_state)?;
        }
        if self.negotiated_local_control_tx_interval_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "negotiatedLocalControlTxIntervalMs",
                &__With(&self.negotiated_local_control_tx_interval_ms),
            )?;
        }
        if self.rx_packet.is_some() {
            state.serialize_entry("rxPacket", &self.rx_packet)?;
        }
        if self.tx_packet.is_some() {
            state.serialize_entry("txPacket", &self.tx_packet)?;
        }
        if self.uptime_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("uptimeMs", &__With(&self.uptime_ms))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BfdStatusPacketCounts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.num_rx.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numRx", &__With(&self.num_rx))?;
        }
        if self.num_rx_rejected.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numRxRejected", &__With(&self.num_rx_rejected))?;
        }
        if self.num_rx_successful.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numRxSuccessful", &__With(&self.num_rx_successful))?;
        }
        if self.num_tx.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numTx", &__With(&self.num_tx))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BgpRoute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.as_paths.is_empty() {
            state.serialize_entry("asPaths", &self.as_paths)?;
        }
        if !self.communities.is_empty() {
            state.serialize_entry("communities", &self.communities)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if self.med.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("med", &__With(&self.med))?;
        }
        if self.origin.is_some() {
            state.serialize_entry("origin", &self.origin)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BgpRouteAsPath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.asns.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("asns", &__With(&self.asns))?;
        }
        if !self.asns32.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("asns32", &__With(&self.asns32))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BgpRouteNetworkLayerReachabilityInformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.path_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pathId", &__With(&self.path_id))?;
        }
        if self.prefix.is_some() {
            state.serialize_entry("prefix", &self.prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "firewall-policies",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Binding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.members.is_empty() {
            state.serialize_entry("members", &self.members)?;
        }
        if self.role.is_some() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkInsertDiskResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_consistency_group_policy.is_some() {
            state.serialize_entry(
                "sourceConsistencyGroupPolicy",
                &self.source_consistency_group_policy,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkInsertInstanceResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.instance_properties.is_some() {
            state.serialize_entry("instanceProperties", &self.instance_properties)?;
        }
        if self.location_policy.is_some() {
            state.serialize_entry("locationPolicy", &self.location_policy)?;
        }
        if self.min_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minCount", &__With(&self.min_count))?;
        }
        if self.name_pattern.is_some() {
            state.serialize_entry("namePattern", &self.name_pattern)?;
        }
        if !self.per_instance_properties.is_empty() {
            state.serialize_entry("perInstanceProperties", &self.per_instance_properties)?;
        }
        if self.source_instance_template.is_some() {
            state.serialize_entry("sourceInstanceTemplate", &self.source_instance_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkInsertInstanceResourcePerInstanceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hostname.is_some() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkInsertOperationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.created_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("createdVmCount", &__With(&self.created_vm_count))?;
        }
        if self.deleted_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deletedVmCount", &__With(&self.deleted_vm_count))?;
        }
        if self.failed_to_create_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "failedToCreateVmCount",
                &__With(&self.failed_to_create_vm_count),
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.target_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetVmCount", &__With(&self.target_vm_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkZoneSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CacheInvalidationRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cache_tags.is_empty() {
            state.serialize_entry("cacheTags", &self.cache_tags)?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CacheKeyPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.include_host.is_some() {
            state.serialize_entry("includeHost", &self.include_host)?;
        }
        if !self.include_http_headers.is_empty() {
            state.serialize_entry("includeHttpHeaders", &self.include_http_headers)?;
        }
        if !self.include_named_cookies.is_empty() {
            state.serialize_entry("includeNamedCookies", &self.include_named_cookies)?;
        }
        if self.include_protocol.is_some() {
            state.serialize_entry("includeProtocol", &self.include_protocol)?;
        }
        if self.include_query_string.is_some() {
            state.serialize_entry("includeQueryString", &self.include_query_string)?;
        }
        if !self.query_string_blacklist.is_empty() {
            state.serialize_entry("queryStringBlacklist", &self.query_string_blacklist)?;
        }
        if !self.query_string_whitelist.is_empty() {
            state.serialize_entry("queryStringWhitelist", &self.query_string_whitelist)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CircuitBreakers {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_connections.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxConnections", &__With(&self.max_connections))?;
        }
        if self.max_pending_requests.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxPendingRequests", &__With(&self.max_pending_requests))?;
        }
        if self.max_requests.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRequests", &__With(&self.max_requests))?;
        }
        if self.max_requests_per_connection.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxRequestsPerConnection",
                &__With(&self.max_requests_per_connection),
            )?;
        }
        if self.max_retries.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRetries", &__With(&self.max_retries))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Commitment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_renew.is_some() {
            state.serialize_entry("autoRenew", &self.auto_renew)?;
        }
        if self.category.is_some() {
            state.serialize_entry("category", &self.category)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.custom_end_timestamp.is_some() {
            state.serialize_entry("customEndTimestamp", &self.custom_end_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.end_timestamp.is_some() {
            state.serialize_entry("endTimestamp", &self.end_timestamp)?;
        }
        if !self.existing_reservations.is_empty() {
            state.serialize_entry("existingReservations", &self.existing_reservations)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.license_resource.is_some() {
            state.serialize_entry("licenseResource", &self.license_resource)?;
        }
        if !self.merge_source_commitments.is_empty() {
            state.serialize_entry("mergeSourceCommitments", &self.merge_source_commitments)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.plan.is_some() {
            state.serialize_entry("plan", &self.plan)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.reservations.is_empty() {
            state.serialize_entry("reservations", &self.reservations)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.split_source_commitment.is_some() {
            state.serialize_entry("splitSourceCommitment", &self.split_source_commitment)?;
        }
        if self.start_timestamp.is_some() {
            state.serialize_entry("startTimestamp", &self.start_timestamp)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_message.is_some() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CommitmentAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitment_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitment_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CommitmentList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitment_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitment_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CommitmentResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_term_eligibility_end_timestamp.is_some() {
            state.serialize_entry(
                "customTermEligibilityEndTimestamp",
                &self.custom_term_eligibility_end_timestamp,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CommitmentsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.commitments.is_empty() {
            state.serialize_entry("commitments", &self.commitments)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitments_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::commitments_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConfidentialInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.confidential_instance_type.is_some() {
            state.serialize_entry("confidentialInstanceType", &self.confidential_instance_type)?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConnectionDraining {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.draining_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("drainingTimeoutSec", &__With(&self.draining_timeout_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConsistentHashLoadBalancerSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http_cookie.is_some() {
            state.serialize_entry("httpCookie", &self.http_cookie)?;
        }
        if self.http_header_name.is_some() {
            state.serialize_entry("httpHeaderName", &self.http_header_name)?;
        }
        if self.minimum_ring_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minimumRingSize", &__With(&self.minimum_ring_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ConsistentHashLoadBalancerSettingsHttpCookie {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CorsPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allow_credentials.is_some() {
            state.serialize_entry("allowCredentials", &self.allow_credentials)?;
        }
        if !self.allow_headers.is_empty() {
            state.serialize_entry("allowHeaders", &self.allow_headers)?;
        }
        if !self.allow_methods.is_empty() {
            state.serialize_entry("allowMethods", &self.allow_methods)?;
        }
        if !self.allow_origin_regexes.is_empty() {
            state.serialize_entry("allowOriginRegexes", &self.allow_origin_regexes)?;
        }
        if !self.allow_origins.is_empty() {
            state.serialize_entry("allowOrigins", &self.allow_origins)?;
        }
        if self.disabled.is_some() {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self.expose_headers.is_empty() {
            state.serialize_entry("exposeHeaders", &self.expose_headers)?;
        }
        if self.max_age.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxAge", &__With(&self.max_age))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cross-site-networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CrossSiteNetwork {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cross-site-networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CrossSiteNetworkList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cross-site-networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::cross_site_network_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "cross-site-networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::cross_site_network_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomErrorResponsePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_response_rules.is_empty() {
            state.serialize_entry("errorResponseRules", &self.error_response_rules)?;
        }
        if self.error_service.is_some() {
            state.serialize_entry("errorService", &self.error_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomErrorResponsePolicyCustomErrorResponseRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.match_response_codes.is_empty() {
            state.serialize_entry("matchResponseCodes", &self.match_response_codes)?;
        }
        if self.override_response_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "overrideResponseCode",
                &__With(&self.override_response_code),
            )?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "disks",
    feature = "image-family-views",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-disks",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "snapshots",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomerEncryptionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kms_key_name.is_some() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.kms_key_service_account.is_some() {
            state.serialize_entry("kmsKeyServiceAccount", &self.kms_key_service_account)?;
        }
        if self.raw_key.is_some() {
            state.serialize_entry("rawKey", &self.raw_key)?;
        }
        if self.rsa_encrypted_key.is_some() {
            state.serialize_entry("rsaEncryptedKey", &self.rsa_encrypted_key)?;
        }
        if self.sha256.is_some() {
            state.serialize_entry("sha256", &self.sha256)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomerEncryptionKeyProtectedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Date {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.day.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("day", &__With(&self.day))?;
        }
        if self.month.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("month", &__With(&self.month))?;
        }
        if self.year.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("year", &__With(&self.year))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "accelerator-types",
    feature = "disk-types",
    feature = "image-family-views",
    feature = "images",
    feature = "machine-types",
    feature = "node-types",
    feature = "region-disk-types",
    feature = "region-zones",
    feature = "regions",
    feature = "storage-pool-types",
    feature = "zones",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeprecationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.obsolete.is_some() {
            state.serialize_entry("obsolete", &self.obsolete)?;
        }
        if self.replacement.is_some() {
            state.serialize_entry("replacement", &self.replacement)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Disk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.access_mode.is_some() {
            state.serialize_entry("accessMode", &self.access_mode)?;
        }
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.async_primary_disk.is_some() {
            state.serialize_entry("asyncPrimaryDisk", &self.async_primary_disk)?;
        }
        if !self.async_secondary_disks.is_empty() {
            state.serialize_entry("asyncSecondaryDisks", &self.async_secondary_disks)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.last_attach_timestamp.is_some() {
            state.serialize_entry("lastAttachTimestamp", &self.last_attach_timestamp)?;
        }
        if self.last_detach_timestamp.is_some() {
            state.serialize_entry("lastDetachTimestamp", &self.last_detach_timestamp)?;
        }
        if !self.license_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("licenseCodes", &__With(&self.license_codes))?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.location_hint.is_some() {
            state.serialize_entry("locationHint", &self.location_hint)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.options.is_some() {
            state.serialize_entry("options", &self.options)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.physical_block_size_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "physicalBlockSizeBytes",
                &__With(&self.physical_block_size_bytes),
            )?;
        }
        if self.provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("provisionedIops", &__With(&self.provisioned_iops))?;
        }
        if self.provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "provisionedThroughput",
                &__With(&self.provisioned_throughput),
            )?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.replica_zones.is_empty() {
            state.serialize_entry("replicaZones", &self.replica_zones)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if self.source_consistency_group_policy.is_some() {
            state.serialize_entry(
                "sourceConsistencyGroupPolicy",
                &self.source_consistency_group_policy,
            )?;
        }
        if self.source_consistency_group_policy_id.is_some() {
            state.serialize_entry(
                "sourceConsistencyGroupPolicyId",
                &self.source_consistency_group_policy_id,
            )?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.source_disk_id.is_some() {
            state.serialize_entry("sourceDiskId", &self.source_disk_id)?;
        }
        if self.source_image.is_some() {
            state.serialize_entry("sourceImage", &self.source_image)?;
        }
        if self.source_image_encryption_key.is_some() {
            state.serialize_entry(
                "sourceImageEncryptionKey",
                &self.source_image_encryption_key,
            )?;
        }
        if self.source_image_id.is_some() {
            state.serialize_entry("sourceImageId", &self.source_image_id)?;
        }
        if self.source_instant_snapshot.is_some() {
            state.serialize_entry("sourceInstantSnapshot", &self.source_instant_snapshot)?;
        }
        if self.source_instant_snapshot_id.is_some() {
            state.serialize_entry("sourceInstantSnapshotId", &self.source_instant_snapshot_id)?;
        }
        if self.source_snapshot.is_some() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if self.source_snapshot_encryption_key.is_some() {
            state.serialize_entry(
                "sourceSnapshotEncryptionKey",
                &self.source_snapshot_encryption_key,
            )?;
        }
        if self.source_snapshot_id.is_some() {
            state.serialize_entry("sourceSnapshotId", &self.source_snapshot_id)?;
        }
        if self.source_storage_object.is_some() {
            state.serialize_entry("sourceStorageObject", &self.source_storage_object)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.storage_pool.is_some() {
            state.serialize_entry("storagePool", &self.storage_pool)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.users.is_empty() {
            state.serialize_entry("users", &self.users)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskAsyncReplication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consistency_group_policy.is_some() {
            state.serialize_entry("consistencyGroupPolicy", &self.consistency_group_policy)?;
        }
        if self.consistency_group_policy_id.is_some() {
            state.serialize_entry(
                "consistencyGroupPolicyId",
                &self.consistency_group_policy_id,
            )?;
        }
        if self.disk.is_some() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if self.disk_id.is_some() {
            state.serialize_entry("diskId", &self.disk_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskAsyncReplicationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.async_replication_disk.is_some() {
            state.serialize_entry("asyncReplicationDisk", &self.async_replication_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskInstantiationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if self.custom_image.is_some() {
            state.serialize_entry("customImage", &self.custom_image)?;
        }
        if self.device_name.is_some() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if self.instantiate_from.is_some() {
            state.serialize_entry("instantiateFrom", &self.instantiate_from)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskMoveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.destination_zone.is_some() {
            state.serialize_entry("destinationZone", &self.destination_zone)?;
        }
        if self.target_disk.is_some() {
            state.serialize_entry("targetDisk", &self.target_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.async_primary_disk.is_some() {
            state.serialize_entry("asyncPrimaryDisk", &self.async_primary_disk)?;
        }
        if !self.async_secondary_disks.is_empty() {
            state.serialize_entry("asyncSecondaryDisks", &self.async_secondary_disks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskResourceStatusAsyncReplicationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disk-types", feature = "region-disk-types",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.default_disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("defaultDiskSizeGb", &__With(&self.default_disk_size_gb))?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.valid_disk_size.is_some() {
            state.serialize_entry("validDiskSize", &self.valid_disk_size)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DiskTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_types.is_empty() {
            state.serialize_entry("diskTypes", &self.disk_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disk_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksAddResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksRemoveResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksResizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disks_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::disks_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksStartAsyncReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.async_secondary_disk.is_some() {
            state.serialize_entry("asyncSecondaryDisk", &self.async_secondary_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisksStopGroupAsyncReplicationResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource_policy.is_some() {
            state.serialize_entry("resourcePolicy", &self.resource_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::DisplayDevice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_display.is_some() {
            state.serialize_entry("enableDisplay", &self.enable_display)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DistributionPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target_shape.is_some() {
            state.serialize_entry("targetShape", &self.target_shape)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DistributionPolicyZoneConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-services",
    feature = "future-reservations",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-templates",
    feature = "instances",
    feature = "licenses",
    feature = "machine-images",
    feature = "node-groups",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-notification-endpoints",
    feature = "region-url-maps",
    feature = "reservations",
    feature = "url-maps",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Duration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.nanos.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("nanos", &__With(&self.nanos))?;
        }
        if self.seconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("seconds", &__With(&self.seconds))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ErrorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.domain.is_some() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.metadatas.is_empty() {
            state.serialize_entry("metadatas", &self.metadatas)?;
        }
        if self.reason.is_some() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExchangedPeeringRoute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dest_range.is_some() {
            state.serialize_entry("destRange", &self.dest_range)?;
        }
        if self.imported.is_some() {
            state.serialize_entry("imported", &self.imported)?;
        }
        if self.next_hop_region.is_some() {
            state.serialize_entry("nextHopRegion", &self.next_hop_region)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExchangedPeeringRoutesList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::exchanged_peering_routes_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::exchanged_peering_routes_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "firewall-policies",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "region-security-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Expr {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.expression.is_some() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.title.is_some() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "external-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExternalVpnGateway {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.interfaces.is_empty() {
            state.serialize_entry("interfaces", &self.interfaces)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.redundancy_type.is_some() {
            state.serialize_entry("redundancyType", &self.redundancy_type)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "external-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExternalVpnGatewayInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "external-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ExternalVpnGatewayList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "external-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::external_vpn_gateway_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "external-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::external_vpn_gateway_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "image-family-views",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FileContentBuffer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.content.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if self.file_type.is_some() {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewalls",
    feature = "instances",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Firewall {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed.is_empty() {
            state.serialize_entry("allowed", &self.allowed)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if !self.denied.is_empty() {
            state.serialize_entry("denied", &self.denied)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.destination_ranges.is_empty() {
            state.serialize_entry("destinationRanges", &self.destination_ranges)?;
        }
        if self.direction.is_some() {
            state.serialize_entry("direction", &self.direction)?;
        }
        if self.disabled.is_some() {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.source_ranges.is_empty() {
            state.serialize_entry("sourceRanges", &self.source_ranges)?;
        }
        if !self.source_service_accounts.is_empty() {
            state.serialize_entry("sourceServiceAccounts", &self.source_service_accounts)?;
        }
        if !self.source_tags.is_empty() {
            state.serialize_entry("sourceTags", &self.source_tags)?;
        }
        if !self.target_service_accounts.is_empty() {
            state.serialize_entry("targetServiceAccounts", &self.target_service_accounts)?;
        }
        if !self.target_tags.is_empty() {
            state.serialize_entry("targetTags", &self.target_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewalls",
    feature = "instances",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall::Allowed {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_protocol.is_some() {
            state.serialize_entry("IPProtocol", &self.ip_protocol)?;
        }
        if !self.ports.is_empty() {
            state.serialize_entry("ports", &self.ports)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewalls",
    feature = "instances",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall::Denied {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_protocol.is_some() {
            state.serialize_entry("IPProtocol", &self.ip_protocol)?;
        }
        if !self.ports.is_empty() {
            state.serialize_entry("ports", &self.ports)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "firewalls")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "firewalls")]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "firewalls")]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewalls",
    feature = "instances",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewalls",
    feature = "instances",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPoliciesListAssociationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.associations.is_empty() {
            state.serialize_entry("associations", &self.associations)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPoliciesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.firewall_policies.is_empty() {
            state.serialize_entry("firewallPolicies", &self.firewall_policies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_policies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_policies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "network-firewall-policies",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.associations.is_empty() {
            state.serialize_entry("associations", &self.associations)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.packet_mirroring_rules.is_empty() {
            state.serialize_entry("packetMirroringRules", &self.packet_mirroring_rules)?;
        }
        if self.parent.is_some() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.policy_type.is_some() {
            state.serialize_entry("policyType", &self.policy_type)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.rule_tuple_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ruleTupleCount", &__With(&self.rule_tuple_count))?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "network-firewall-policies",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyAssociation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attachment_target.is_some() {
            state.serialize_entry("attachmentTarget", &self.attachment_target)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.firewall_policy_id.is_some() {
            state.serialize_entry("firewallPolicyId", &self.firewall_policy_id)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "network-firewall-policies",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "network-firewall-policies",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_policy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "network-firewall-policies",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::firewall_policy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "instances",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.action.is_some() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.direction.is_some() {
            state.serialize_entry("direction", &self.direction)?;
        }
        if self.disabled.is_some() {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.enable_logging.is_some() {
            state.serialize_entry("enableLogging", &self.enable_logging)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.rule_name.is_some() {
            state.serialize_entry("ruleName", &self.rule_name)?;
        }
        if self.rule_tuple_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ruleTupleCount", &__With(&self.rule_tuple_count))?;
        }
        if self.security_profile_group.is_some() {
            state.serialize_entry("securityProfileGroup", &self.security_profile_group)?;
        }
        if !self.target_resources.is_empty() {
            state.serialize_entry("targetResources", &self.target_resources)?;
        }
        if !self.target_secure_tags.is_empty() {
            state.serialize_entry("targetSecureTags", &self.target_secure_tags)?;
        }
        if !self.target_service_accounts.is_empty() {
            state.serialize_entry("targetServiceAccounts", &self.target_service_accounts)?;
        }
        if self.tls_inspect.is_some() {
            state.serialize_entry("tlsInspect", &self.tls_inspect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "instances",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyRuleMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dest_address_groups.is_empty() {
            state.serialize_entry("destAddressGroups", &self.dest_address_groups)?;
        }
        if !self.dest_fqdns.is_empty() {
            state.serialize_entry("destFqdns", &self.dest_fqdns)?;
        }
        if !self.dest_ip_ranges.is_empty() {
            state.serialize_entry("destIpRanges", &self.dest_ip_ranges)?;
        }
        if self.dest_network_type.is_some() {
            state.serialize_entry("destNetworkType", &self.dest_network_type)?;
        }
        if !self.dest_region_codes.is_empty() {
            state.serialize_entry("destRegionCodes", &self.dest_region_codes)?;
        }
        if !self.dest_threat_intelligences.is_empty() {
            state.serialize_entry("destThreatIntelligences", &self.dest_threat_intelligences)?;
        }
        if !self.layer_4_configs.is_empty() {
            state.serialize_entry("layer4Configs", &self.layer_4_configs)?;
        }
        if !self.src_address_groups.is_empty() {
            state.serialize_entry("srcAddressGroups", &self.src_address_groups)?;
        }
        if !self.src_fqdns.is_empty() {
            state.serialize_entry("srcFqdns", &self.src_fqdns)?;
        }
        if !self.src_ip_ranges.is_empty() {
            state.serialize_entry("srcIpRanges", &self.src_ip_ranges)?;
        }
        if self.src_network_type.is_some() {
            state.serialize_entry("srcNetworkType", &self.src_network_type)?;
        }
        if !self.src_networks.is_empty() {
            state.serialize_entry("srcNetworks", &self.src_networks)?;
        }
        if !self.src_region_codes.is_empty() {
            state.serialize_entry("srcRegionCodes", &self.src_region_codes)?;
        }
        if !self.src_secure_tags.is_empty() {
            state.serialize_entry("srcSecureTags", &self.src_secure_tags)?;
        }
        if !self.src_threat_intelligences.is_empty() {
            state.serialize_entry("srcThreatIntelligences", &self.src_threat_intelligences)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "instances",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyRuleMatcherLayer4Config {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_protocol.is_some() {
            state.serialize_entry("ipProtocol", &self.ip_protocol)?;
        }
        if !self.ports.is_empty() {
            state.serialize_entry("ports", &self.ports)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "firewall-policies",
    feature = "instances",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "region-network-firewall-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FirewallPolicyRuleSecureTag {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "autoscalers",
    feature = "instance-group-managers",
    feature = "region-autoscalers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::FixedOrPercent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.calculated.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("calculated", &__With(&self.calculated))?;
        }
        if self.fixed.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("fixed", &__With(&self.fixed))?;
        }
        if self.percent.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("percent", &__With(&self.percent))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "forwarding-rules", feature = "global-forwarding-rules",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_address.is_some() {
            state.serialize_entry("IPAddress", &self.ip_address)?;
        }
        if self.ip_protocol.is_some() {
            state.serialize_entry("IPProtocol", &self.ip_protocol)?;
        }
        if self.all_ports.is_some() {
            state.serialize_entry("allPorts", &self.all_ports)?;
        }
        if self.allow_global_access.is_some() {
            state.serialize_entry("allowGlobalAccess", &self.allow_global_access)?;
        }
        if self.allow_psc_global_access.is_some() {
            state.serialize_entry("allowPscGlobalAccess", &self.allow_psc_global_access)?;
        }
        if self.backend_service.is_some() {
            state.serialize_entry("backendService", &self.backend_service)?;
        }
        if self.base_forwarding_rule.is_some() {
            state.serialize_entry("baseForwardingRule", &self.base_forwarding_rule)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self
            .external_managed_backend_bucket_migration_state
            .is_some()
        {
            state.serialize_entry(
                "externalManagedBackendBucketMigrationState",
                &self.external_managed_backend_bucket_migration_state,
            )?;
        }
        if self
            .external_managed_backend_bucket_migration_testing_percentage
            .is_some()
        {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "externalManagedBackendBucketMigrationTestingPercentage",
                &__With(&self.external_managed_backend_bucket_migration_testing_percentage),
            )?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_collection.is_some() {
            state.serialize_entry("ipCollection", &self.ip_collection)?;
        }
        if self.ip_version.is_some() {
            state.serialize_entry("ipVersion", &self.ip_version)?;
        }
        if self.is_mirroring_collector.is_some() {
            state.serialize_entry("isMirroringCollector", &self.is_mirroring_collector)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.load_balancing_scheme.is_some() {
            state.serialize_entry("loadBalancingScheme", &self.load_balancing_scheme)?;
        }
        if !self.metadata_filters.is_empty() {
            state.serialize_entry("metadataFilters", &self.metadata_filters)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.network_tier.is_some() {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if self.no_automate_dns_zone.is_some() {
            state.serialize_entry("noAutomateDnsZone", &self.no_automate_dns_zone)?;
        }
        if self.port_range.is_some() {
            state.serialize_entry("portRange", &self.port_range)?;
        }
        if !self.ports.is_empty() {
            state.serialize_entry("ports", &self.ports)?;
        }
        if self.psc_connection_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pscConnectionId", &__With(&self.psc_connection_id))?;
        }
        if self.psc_connection_status.is_some() {
            state.serialize_entry("pscConnectionStatus", &self.psc_connection_status)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self.service_directory_registrations.is_empty() {
            state.serialize_entry(
                "serviceDirectoryRegistrations",
                &self.service_directory_registrations,
            )?;
        }
        if self.service_label.is_some() {
            state.serialize_entry("serviceLabel", &self.service_label)?;
        }
        if self.service_name.is_some() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.source_ip_ranges.is_empty() {
            state.serialize_entry("sourceIpRanges", &self.source_ip_ranges)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRuleAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rule_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rule_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "forwarding-rules", feature = "global-forwarding-rules",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRuleList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "forwarding-rules", feature = "global-forwarding-rules",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rule_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "forwarding-rules", feature = "global-forwarding-rules",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rule_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRuleReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.forwarding_rule.is_some() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "forwarding-rules", feature = "global-forwarding-rules",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRuleServiceDirectoryRegistration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.namespace.is_some() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.service_directory_region.is_some() {
            state.serialize_entry("serviceDirectoryRegion", &self.service_directory_region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ForwardingRulesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.forwarding_rules.is_empty() {
            state.serialize_entry("forwardingRules", &self.forwarding_rules)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rules_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "forwarding-rules")]
#[doc(hidden)]
impl serde::ser::Serialize for super::forwarding_rules_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aggregate_reservation.is_some() {
            state.serialize_entry("aggregateReservation", &self.aggregate_reservation)?;
        }
        if self.auto_created_reservations_delete_time.is_some() {
            state.serialize_entry(
                "autoCreatedReservationsDeleteTime",
                &self.auto_created_reservations_delete_time,
            )?;
        }
        if self.auto_created_reservations_duration.is_some() {
            state.serialize_entry(
                "autoCreatedReservationsDuration",
                &self.auto_created_reservations_duration,
            )?;
        }
        if self.auto_delete_auto_created_reservations.is_some() {
            state.serialize_entry(
                "autoDeleteAutoCreatedReservations",
                &self.auto_delete_auto_created_reservations,
            )?;
        }
        if self.commitment_info.is_some() {
            state.serialize_entry("commitmentInfo", &self.commitment_info)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deployment_type.is_some() {
            state.serialize_entry("deploymentType", &self.deployment_type)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enable_emergent_maintenance.is_some() {
            state.serialize_entry(
                "enableEmergentMaintenance",
                &self.enable_emergent_maintenance,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.name_prefix.is_some() {
            state.serialize_entry("namePrefix", &self.name_prefix)?;
        }
        if self.planning_status.is_some() {
            state.serialize_entry("planningStatus", &self.planning_status)?;
        }
        if self.reservation_mode.is_some() {
            state.serialize_entry("reservationMode", &self.reservation_mode)?;
        }
        if self.reservation_name.is_some() {
            state.serialize_entry("reservationName", &self.reservation_name)?;
        }
        if self.scheduling_type.is_some() {
            state.serialize_entry("schedulingType", &self.scheduling_type)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.share_settings.is_some() {
            state.serialize_entry("shareSettings", &self.share_settings)?;
        }
        if self.specific_reservation_required.is_some() {
            state.serialize_entry(
                "specificReservationRequired",
                &self.specific_reservation_required,
            )?;
        }
        if self.specific_sku_properties.is_some() {
            state.serialize_entry("specificSkuProperties", &self.specific_sku_properties)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.time_window.is_some() {
            state.serialize_entry("timeWindow", &self.time_window)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationCommitmentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.commitment_name.is_some() {
            state.serialize_entry("commitmentName", &self.commitment_name)?;
        }
        if self.commitment_plan.is_some() {
            state.serialize_entry("commitmentPlan", &self.commitment_plan)?;
        }
        if self.previous_commitment_terms.is_some() {
            state.serialize_entry("previousCommitmentTerms", &self.previous_commitment_terms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationSpecificSKUProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_properties.is_some() {
            state.serialize_entry("instanceProperties", &self.instance_properties)?;
        }
        if self.source_instance_template.is_some() {
            state.serialize_entry("sourceInstanceTemplate", &self.source_instance_template)?;
        }
        if self.total_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalCount", &__With(&self.total_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.amendment_status.is_some() {
            state.serialize_entry("amendmentStatus", &self.amendment_status)?;
        }
        if !self.auto_created_reservations.is_empty() {
            state.serialize_entry("autoCreatedReservations", &self.auto_created_reservations)?;
        }
        if self.existing_matching_usage_info.is_some() {
            state.serialize_entry(
                "existingMatchingUsageInfo",
                &self.existing_matching_usage_info,
            )?;
        }
        if self.fulfilled_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("fulfilledCount", &__With(&self.fulfilled_count))?;
        }
        if self.last_known_good_state.is_some() {
            state.serialize_entry("lastKnownGoodState", &self.last_known_good_state)?;
        }
        if self.lock_time.is_some() {
            state.serialize_entry("lockTime", &self.lock_time)?;
        }
        if self.procurement_status.is_some() {
            state.serialize_entry("procurementStatus", &self.procurement_status)?;
        }
        if self.specific_sku_properties.is_some() {
            state.serialize_entry("specificSkuProperties", &self.specific_sku_properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationStatusExistingMatchingUsageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationStatusLastKnownGoodState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.existing_matching_usage_info.is_some() {
            state.serialize_entry(
                "existingMatchingUsageInfo",
                &self.existing_matching_usage_info,
            )?;
        }
        if self.future_reservation_specs.is_some() {
            state.serialize_entry("futureReservationSpecs", &self.future_reservation_specs)?;
        }
        if self.lock_time.is_some() {
            state.serialize_entry("lockTime", &self.lock_time)?;
        }
        if self.name_prefix.is_some() {
            state.serialize_entry("namePrefix", &self.name_prefix)?;
        }
        if self.procurement_status.is_some() {
            state.serialize_entry("procurementStatus", &self.procurement_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::FutureReservationStatusLastKnownGoodStateFutureReservationSpecs
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.share_settings.is_some() {
            state.serialize_entry("shareSettings", &self.share_settings)?;
        }
        if self.specific_sku_properties.is_some() {
            state.serialize_entry("specificSkuProperties", &self.specific_sku_properties)?;
        }
        if self.time_window.is_some() {
            state.serialize_entry("timeWindow", &self.time_window)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationStatusSpecificSKUProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.source_instance_template_id.is_some() {
            state.serialize_entry(
                "sourceInstanceTemplateId",
                &self.source_instance_template_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationTimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationsAggregatedListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_aggregated_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_aggregated_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FutureReservationsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.future_reservations.is_empty() {
            state.serialize_entry("futureReservations", &self.future_reservations)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "future-reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::future_reservations_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GRPCHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.grpc_service_name.is_some() {
            state.serialize_entry("grpcServiceName", &self.grpc_service_name)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GRPCTLSHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.grpc_service_name.is_some() {
            state.serialize_entry("grpcServiceName", &self.grpc_service_name)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalAddressesMoveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.destination_address.is_some() {
            state.serialize_entry("destinationAddress", &self.destination_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalNetworkEndpointGroupsAttachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalNetworkEndpointGroupsDetachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalOrganizationSetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "external-vpn-gateways",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "images",
    feature = "interconnects",
    feature = "machine-images",
    feature = "security-policies",
    feature = "snapshots",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "images",
    feature = "instance-templates",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-firewall-policies",
    feature = "snapshots",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalSetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-commitments",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GroupMaintenanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_maintenance_ongoing_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "instanceMaintenanceOngoingCount",
                &__With(&self.instance_maintenance_ongoing_count),
            )?;
        }
        if self.instance_maintenance_pending_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "instanceMaintenancePendingCount",
                &__With(&self.instance_maintenance_pending_count),
            )?;
        }
        if self.maintenance_ongoing_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maintenanceOngoingCount",
                &__With(&self.maintenance_ongoing_count),
            )?;
        }
        if self.maintenance_pending_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maintenancePendingCount",
                &__With(&self.maintenance_pending_count),
            )?;
        }
        if self.scheduling_type.is_some() {
            state.serialize_entry("schedulingType", &self.scheduling_type)?;
        }
        if self.subblock_infra_maintenance_ongoing_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "subblockInfraMaintenanceOngoingCount",
                &__With(&self.subblock_infra_maintenance_ongoing_count),
            )?;
        }
        if self.subblock_infra_maintenance_pending_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "subblockInfraMaintenancePendingCount",
                &__With(&self.subblock_infra_maintenance_pending_count),
            )?;
        }
        if self.upcoming_group_maintenance.is_some() {
            state.serialize_entry("upcomingGroupMaintenance", &self.upcoming_group_maintenance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GuestAttributes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.query_path.is_some() {
            state.serialize_entry("queryPath", &self.query_path)?;
        }
        if self.query_value.is_some() {
            state.serialize_entry("queryValue", &self.query_value)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.variable_key.is_some() {
            state.serialize_entry("variableKey", &self.variable_key)?;
        }
        if self.variable_value.is_some() {
            state.serialize_entry("variableValue", &self.variable_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GuestAttributesEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.namespace.is_some() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GuestAttributesValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "disks",
    feature = "image-family-views",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-disks",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "snapshots",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::GuestOsFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HTTP2HealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.request_path.is_some() {
            state.serialize_entry("requestPath", &self.request_path)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HTTPHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.request_path.is_some() {
            state.serialize_entry("requestPath", &self.request_path)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HTTPSHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.request_path.is_some() {
            state.serialize_entry("requestPath", &self.request_path)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.check_interval_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("checkIntervalSec", &__With(&self.check_interval_sec))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.grpc_health_check.is_some() {
            state.serialize_entry("grpcHealthCheck", &self.grpc_health_check)?;
        }
        if self.grpc_tls_health_check.is_some() {
            state.serialize_entry("grpcTlsHealthCheck", &self.grpc_tls_health_check)?;
        }
        if self.healthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyThreshold", &__With(&self.healthy_threshold))?;
        }
        if self.http_2_health_check.is_some() {
            state.serialize_entry("http2HealthCheck", &self.http_2_health_check)?;
        }
        if self.http_health_check.is_some() {
            state.serialize_entry("httpHealthCheck", &self.http_health_check)?;
        }
        if self.https_health_check.is_some() {
            state.serialize_entry("httpsHealthCheck", &self.https_health_check)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.source_regions.is_empty() {
            state.serialize_entry("sourceRegions", &self.source_regions)?;
        }
        if self.ssl_health_check.is_some() {
            state.serialize_entry("sslHealthCheck", &self.ssl_health_check)?;
        }
        if self.tcp_health_check.is_some() {
            state.serialize_entry("tcpHealthCheck", &self.tcp_health_check)?;
        }
        if self.timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("timeoutSec", &__With(&self.timeout_sec))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.unhealthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unhealthyThreshold", &__With(&self.unhealthy_threshold))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_check_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_check_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
    feature = "target-pools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.health_check.is_some() {
            state.serialize_entry("healthCheck", &self.health_check)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-health-check-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if self.health_status_aggregation_policy.is_some() {
            state.serialize_entry(
                "healthStatusAggregationPolicy",
                &self.health_status_aggregation_policy,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.network_endpoint_groups.is_empty() {
            state.serialize_entry("networkEndpointGroups", &self.network_endpoint_groups)?;
        }
        if !self.notification_endpoints.is_empty() {
            state.serialize_entry("notificationEndpoints", &self.notification_endpoints)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckServiceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.health_check_service.is_some() {
            state.serialize_entry("healthCheckService", &self.health_check_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-health-check-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthCheckServicesList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-health-check-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_check_services_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-health-check-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_check_services_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthChecksAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_checks_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_checks_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthChecksScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_checks_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::health_checks_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-services",
    feature = "region-backend-services",
    feature = "target-pools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.forwarding_rule.is_some() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if self.forwarding_rule_ip.is_some() {
            state.serialize_entry("forwardingRuleIp", &self.forwarding_rule_ip)?;
        }
        if self.health_state.is_some() {
            state.serialize_entry("healthState", &self.health_state)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if self.ipv_6_health_state.is_some() {
            state.serialize_entry("ipv6HealthState", &self.ipv_6_health_state)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.weight.is_some() {
            state.serialize_entry("weight", &self.weight)?;
        }
        if self.weight_error.is_some() {
            state.serialize_entry("weightError", &self.weight_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HealthStatusForNetworkEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backend_service.is_some() {
            state.serialize_entry("backendService", &self.backend_service)?;
        }
        if self.forwarding_rule.is_some() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if self.health_check.is_some() {
            state.serialize_entry("healthCheck", &self.health_check)?;
        }
        if self.health_check_service.is_some() {
            state.serialize_entry("healthCheckService", &self.health_check_service)?;
        }
        if self.health_state.is_some() {
            state.serialize_entry("healthState", &self.health_state)?;
        }
        if self.ipv_6_health_state.is_some() {
            state.serialize_entry("ipv6HealthState", &self.ipv_6_health_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Help {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.links.is_empty() {
            state.serialize_entry("links", &self.links)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HelpLink {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HostRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.hosts.is_empty() {
            state.serialize_entry("hosts", &self.hosts)?;
        }
        if self.path_matcher.is_some() {
            state.serialize_entry("pathMatcher", &self.path_matcher)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpFaultAbort {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http_status.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("httpStatus", &__With(&self.http_status))?;
        }
        if self.percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("percentage", &__With(&self.percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpFaultDelay {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fixed_delay.is_some() {
            state.serialize_entry("fixedDelay", &self.fixed_delay)?;
        }
        if self.percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("percentage", &__With(&self.percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpFaultInjection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.abort.is_some() {
            state.serialize_entry("abort", &self.abort)?;
        }
        if self.delay.is_some() {
            state.serialize_entry("delay", &self.delay)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpHeaderAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_headers_to_add.is_empty() {
            state.serialize_entry("requestHeadersToAdd", &self.request_headers_to_add)?;
        }
        if !self.request_headers_to_remove.is_empty() {
            state.serialize_entry("requestHeadersToRemove", &self.request_headers_to_remove)?;
        }
        if !self.response_headers_to_add.is_empty() {
            state.serialize_entry("responseHeadersToAdd", &self.response_headers_to_add)?;
        }
        if !self.response_headers_to_remove.is_empty() {
            state.serialize_entry("responseHeadersToRemove", &self.response_headers_to_remove)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpHeaderMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.exact_match.is_some() {
            state.serialize_entry("exactMatch", &self.exact_match)?;
        }
        if self.header_name.is_some() {
            state.serialize_entry("headerName", &self.header_name)?;
        }
        if self.invert_match.is_some() {
            state.serialize_entry("invertMatch", &self.invert_match)?;
        }
        if self.prefix_match.is_some() {
            state.serialize_entry("prefixMatch", &self.prefix_match)?;
        }
        if self.present_match.is_some() {
            state.serialize_entry("presentMatch", &self.present_match)?;
        }
        if self.range_match.is_some() {
            state.serialize_entry("rangeMatch", &self.range_match)?;
        }
        if self.regex_match.is_some() {
            state.serialize_entry("regexMatch", &self.regex_match)?;
        }
        if self.suffix_match.is_some() {
            state.serialize_entry("suffixMatch", &self.suffix_match)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpHeaderOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.header_name.is_some() {
            state.serialize_entry("headerName", &self.header_name)?;
        }
        if self.header_value.is_some() {
            state.serialize_entry("headerValue", &self.header_value)?;
        }
        if self.replace.is_some() {
            state.serialize_entry("replace", &self.replace)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "http-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.check_interval_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("checkIntervalSec", &__With(&self.check_interval_sec))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.healthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyThreshold", &__With(&self.healthy_threshold))?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.request_path.is_some() {
            state.serialize_entry("requestPath", &self.request_path)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("timeoutSec", &__With(&self.timeout_sec))?;
        }
        if self.unhealthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unhealthyThreshold", &__With(&self.unhealthy_threshold))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "http-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpHealthCheckList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "http-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::http_health_check_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "http-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::http_health_check_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpQueryParameterMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.exact_match.is_some() {
            state.serialize_entry("exactMatch", &self.exact_match)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.present_match.is_some() {
            state.serialize_entry("presentMatch", &self.present_match)?;
        }
        if self.regex_match.is_some() {
            state.serialize_entry("regexMatch", &self.regex_match)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRedirectAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host_redirect.is_some() {
            state.serialize_entry("hostRedirect", &self.host_redirect)?;
        }
        if self.https_redirect.is_some() {
            state.serialize_entry("httpsRedirect", &self.https_redirect)?;
        }
        if self.path_redirect.is_some() {
            state.serialize_entry("pathRedirect", &self.path_redirect)?;
        }
        if self.prefix_redirect.is_some() {
            state.serialize_entry("prefixRedirect", &self.prefix_redirect)?;
        }
        if self.redirect_response_code.is_some() {
            state.serialize_entry("redirectResponseCode", &self.redirect_response_code)?;
        }
        if self.strip_query.is_some() {
            state.serialize_entry("stripQuery", &self.strip_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRetryPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.num_retries.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numRetries", &__With(&self.num_retries))?;
        }
        if self.per_try_timeout.is_some() {
            state.serialize_entry("perTryTimeout", &self.per_try_timeout)?;
        }
        if !self.retry_conditions.is_empty() {
            state.serialize_entry("retryConditions", &self.retry_conditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRouteAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cors_policy.is_some() {
            state.serialize_entry("corsPolicy", &self.cors_policy)?;
        }
        if self.fault_injection_policy.is_some() {
            state.serialize_entry("faultInjectionPolicy", &self.fault_injection_policy)?;
        }
        if self.max_stream_duration.is_some() {
            state.serialize_entry("maxStreamDuration", &self.max_stream_duration)?;
        }
        if self.request_mirror_policy.is_some() {
            state.serialize_entry("requestMirrorPolicy", &self.request_mirror_policy)?;
        }
        if self.retry_policy.is_some() {
            state.serialize_entry("retryPolicy", &self.retry_policy)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if self.url_rewrite.is_some() {
            state.serialize_entry("urlRewrite", &self.url_rewrite)?;
        }
        if !self.weighted_backend_services.is_empty() {
            state.serialize_entry("weightedBackendServices", &self.weighted_backend_services)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRouteRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_error_response_policy.is_some() {
            state.serialize_entry(
                "customErrorResponsePolicy",
                &self.custom_error_response_policy,
            )?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.header_action.is_some() {
            state.serialize_entry("headerAction", &self.header_action)?;
        }
        if !self.match_rules.is_empty() {
            state.serialize_entry("matchRules", &self.match_rules)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.route_action.is_some() {
            state.serialize_entry("routeAction", &self.route_action)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.url_redirect.is_some() {
            state.serialize_entry("urlRedirect", &self.url_redirect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpRouteRuleMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.full_path_match.is_some() {
            state.serialize_entry("fullPathMatch", &self.full_path_match)?;
        }
        if !self.header_matches.is_empty() {
            state.serialize_entry("headerMatches", &self.header_matches)?;
        }
        if self.ignore_case.is_some() {
            state.serialize_entry("ignoreCase", &self.ignore_case)?;
        }
        if !self.metadata_filters.is_empty() {
            state.serialize_entry("metadataFilters", &self.metadata_filters)?;
        }
        if self.path_template_match.is_some() {
            state.serialize_entry("pathTemplateMatch", &self.path_template_match)?;
        }
        if self.prefix_match.is_some() {
            state.serialize_entry("prefixMatch", &self.prefix_match)?;
        }
        if !self.query_parameter_matches.is_empty() {
            state.serialize_entry("queryParameterMatches", &self.query_parameter_matches)?;
        }
        if self.regex_match.is_some() {
            state.serialize_entry("regexMatch", &self.regex_match)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "https-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpsHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.check_interval_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("checkIntervalSec", &__With(&self.check_interval_sec))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.healthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyThreshold", &__With(&self.healthy_threshold))?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.request_path.is_some() {
            state.serialize_entry("requestPath", &self.request_path)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("timeoutSec", &__With(&self.timeout_sec))?;
        }
        if self.unhealthy_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("unhealthyThreshold", &__With(&self.unhealthy_threshold))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "https-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HttpsHealthCheckList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "https-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::https_health_check_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "https-health-checks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::https_health_check_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "image-family-views", feature = "images",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.archive_size_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("archiveSizeBytes", &__With(&self.archive_size_bytes))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if self.family.is_some() {
            state.serialize_entry("family", &self.family)?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.image_encryption_key.is_some() {
            state.serialize_entry("imageEncryptionKey", &self.image_encryption_key)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.license_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("licenseCodes", &__With(&self.license_codes))?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.raw_disk.is_some() {
            state.serialize_entry("rawDisk", &self.raw_disk)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.shielded_instance_initial_state.is_some() {
            state.serialize_entry(
                "shieldedInstanceInitialState",
                &self.shielded_instance_initial_state,
            )?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.source_disk_encryption_key.is_some() {
            state.serialize_entry("sourceDiskEncryptionKey", &self.source_disk_encryption_key)?;
        }
        if self.source_disk_id.is_some() {
            state.serialize_entry("sourceDiskId", &self.source_disk_id)?;
        }
        if self.source_image.is_some() {
            state.serialize_entry("sourceImage", &self.source_image)?;
        }
        if self.source_image_encryption_key.is_some() {
            state.serialize_entry(
                "sourceImageEncryptionKey",
                &self.source_image_encryption_key,
            )?;
        }
        if self.source_image_id.is_some() {
            state.serialize_entry("sourceImageId", &self.source_image_id)?;
        }
        if self.source_snapshot.is_some() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if self.source_snapshot_encryption_key.is_some() {
            state.serialize_entry(
                "sourceSnapshotEncryptionKey",
                &self.source_snapshot_encryption_key,
            )?;
        }
        if self.source_snapshot_id.is_some() {
            state.serialize_entry("sourceSnapshotId", &self.source_snapshot_id)?;
        }
        if self.source_type.is_some() {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.storage_locations.is_empty() {
            state.serialize_entry("storageLocations", &self.storage_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "image-family-views", feature = "images",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::image::RawDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.container_type.is_some() {
            state.serialize_entry("containerType", &self.container_type)?;
        }
        if self.sha_1_checksum.is_some() {
            state.serialize_entry("sha1Checksum", &self.sha_1_checksum)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "image-family-views")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImageFamilyView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImageList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::image_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::image_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "image-family-views", feature = "images",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImageParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "image-family-views",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InitialStateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dbs.is_empty() {
            state.serialize_entry("dbs", &self.dbs)?;
        }
        if !self.dbxs.is_empty() {
            state.serialize_entry("dbxs", &self.dbxs)?;
        }
        if !self.keks.is_empty() {
            state.serialize_entry("keks", &self.keks)?;
        }
        if self.pk.is_some() {
            state.serialize_entry("pk", &self.pk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.can_ip_forward.is_some() {
            state.serialize_entry("canIpForward", &self.can_ip_forward)?;
        }
        if self.confidential_instance_config.is_some() {
            state.serialize_entry(
                "confidentialInstanceConfig",
                &self.confidential_instance_config,
            )?;
        }
        if self.cpu_platform.is_some() {
            state.serialize_entry("cpuPlatform", &self.cpu_platform)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deletion_protection.is_some() {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.display_device.is_some() {
            state.serialize_entry("displayDevice", &self.display_device)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if self.hostname.is_some() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance_encryption_key.is_some() {
            state.serialize_entry("instanceEncryptionKey", &self.instance_encryption_key)?;
        }
        if self.key_revocation_action_type.is_some() {
            state.serialize_entry("keyRevocationActionType", &self.key_revocation_action_type)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.last_start_timestamp.is_some() {
            state.serialize_entry("lastStartTimestamp", &self.last_start_timestamp)?;
        }
        if self.last_stop_timestamp.is_some() {
            state.serialize_entry("lastStopTimestamp", &self.last_stop_timestamp)?;
        }
        if self.last_suspended_timestamp.is_some() {
            state.serialize_entry("lastSuspendedTimestamp", &self.last_suspended_timestamp)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.private_ipv_6_google_access.is_some() {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv_6_google_access)?;
        }
        if self.reservation_affinity.is_some() {
            state.serialize_entry("reservationAffinity", &self.reservation_affinity)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.service_accounts.is_empty() {
            state.serialize_entry("serviceAccounts", &self.service_accounts)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if self.shielded_instance_integrity_policy.is_some() {
            state.serialize_entry(
                "shieldedInstanceIntegrityPolicy",
                &self.shielded_instance_integrity_policy,
            )?;
        }
        if self.source_machine_image.is_some() {
            state.serialize_entry("sourceMachineImage", &self.source_machine_image)?;
        }
        if self.source_machine_image_encryption_key.is_some() {
            state.serialize_entry(
                "sourceMachineImageEncryptionKey",
                &self.source_machine_image_encryption_key,
            )?;
        }
        if self.start_restricted.is_some() {
            state.serialize_entry("startRestricted", &self.start_restricted)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_message.is_some() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceConsumptionData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consumption_info.is_some() {
            state.serialize_entry("consumptionInfo", &self.consumption_info)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceConsumptionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.guest_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("guestCpus", &__With(&self.guest_cpus))?;
        }
        if self.local_ssd_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("localSsdGb", &__With(&self.local_ssd_gb))?;
        }
        if self.memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if self.min_node_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.named_ports.is_empty() {
            state.serialize_entry("namedPorts", &self.named_ports)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManager {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_instances_config.is_some() {
            state.serialize_entry("allInstancesConfig", &self.all_instances_config)?;
        }
        if !self.auto_healing_policies.is_empty() {
            state.serialize_entry("autoHealingPolicies", &self.auto_healing_policies)?;
        }
        if self.base_instance_name.is_some() {
            state.serialize_entry("baseInstanceName", &self.base_instance_name)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.current_actions.is_some() {
            state.serialize_entry("currentActions", &self.current_actions)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.distribution_policy.is_some() {
            state.serialize_entry("distributionPolicy", &self.distribution_policy)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance_flexibility_policy.is_some() {
            state.serialize_entry(
                "instanceFlexibilityPolicy",
                &self.instance_flexibility_policy,
            )?;
        }
        if self.instance_group.is_some() {
            state.serialize_entry("instanceGroup", &self.instance_group)?;
        }
        if self.instance_lifecycle_policy.is_some() {
            state.serialize_entry("instanceLifecyclePolicy", &self.instance_lifecycle_policy)?;
        }
        if self.instance_template.is_some() {
            state.serialize_entry("instanceTemplate", &self.instance_template)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.list_managed_instances_results.is_some() {
            state.serialize_entry(
                "listManagedInstancesResults",
                &self.list_managed_instances_results,
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.named_ports.is_empty() {
            state.serialize_entry("namedPorts", &self.named_ports)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.resource_policies.is_some() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.standby_policy.is_some() {
            state.serialize_entry("standbyPolicy", &self.standby_policy)?;
        }
        if self.stateful_policy.is_some() {
            state.serialize_entry("statefulPolicy", &self.stateful_policy)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.target_pools.is_empty() {
            state.serialize_entry("targetPools", &self.target_pools)?;
        }
        if self.target_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetSize", &__With(&self.target_size))?;
        }
        if self.target_stopped_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetStoppedSize", &__With(&self.target_stopped_size))?;
        }
        if self.target_suspended_size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetSuspendedSize", &__With(&self.target_suspended_size))?;
        }
        if self.update_policy.is_some() {
            state.serialize_entry("updatePolicy", &self.update_policy)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerActionsSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.abandoning.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("abandoning", &__With(&self.abandoning))?;
        }
        if self.creating.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("creating", &__With(&self.creating))?;
        }
        if self.creating_without_retries.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "creatingWithoutRetries",
                &__With(&self.creating_without_retries),
            )?;
        }
        if self.deleting.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deleting", &__With(&self.deleting))?;
        }
        if self.none.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("none", &__With(&self.none))?;
        }
        if self.recreating.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("recreating", &__With(&self.recreating))?;
        }
        if self.refreshing.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("refreshing", &__With(&self.refreshing))?;
        }
        if self.restarting.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("restarting", &__With(&self.restarting))?;
        }
        if self.resuming.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("resuming", &__With(&self.resuming))?;
        }
        if self.starting.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("starting", &__With(&self.starting))?;
        }
        if self.stopping.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("stopping", &__With(&self.stopping))?;
        }
        if self.suspending.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("suspending", &__With(&self.suspending))?;
        }
        if self.verifying.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("verifying", &__With(&self.verifying))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerAllInstancesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerAutoHealingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.health_check.is_some() {
            state.serialize_entry("healthCheck", &self.health_check)?;
        }
        if self.initial_delay_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("initialDelaySec", &__With(&self.initial_delay_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerInstanceFlexibilityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_selections.is_empty() {
            state.serialize_entry("instanceSelections", &self.instance_selections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_types.is_empty() {
            state.serialize_entry("machineTypes", &self.machine_types)?;
        }
        if self.rank.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("rank", &__With(&self.rank))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerInstanceLifecyclePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.default_action_on_failure.is_some() {
            state.serialize_entry("defaultActionOnFailure", &self.default_action_on_failure)?;
        }
        if self.force_update_on_repair.is_some() {
            state.serialize_entry("forceUpdateOnRepair", &self.force_update_on_repair)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerResizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.requested_run_duration.is_some() {
            state.serialize_entry("requestedRunDuration", &self.requested_run_duration)?;
        }
        if self.resize_by.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("resizeBy", &__With(&self.resize_by))?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerResizeRequestStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.last_attempt.is_some() {
            state.serialize_entry("lastAttempt", &self.last_attempt)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_resize_request_status::Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_resize_request_status::error::Errors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_manager_resize_request_status::error::errors::ErrorDetails
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if self.help.is_some() {
            state.serialize_entry("help", &self.help)?;
        }
        if self.localized_message.is_some() {
            state.serialize_entry("localizedMessage", &self.localized_message)?;
        }
        if self.quota_info.is_some() {
            state.serialize_entry("quotaInfo", &self.quota_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerResizeRequestStatusLastAttempt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_manager_resize_request_status_last_attempt::Error
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_manager_resize_request_status_last_attempt::error::Errors
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if self.help.is_some() {
            state.serialize_entry("help", &self.help)?;
        }
        if self.localized_message.is_some() {
            state.serialize_entry("localizedMessage", &self.localized_message)?;
        }
        if self.quota_info.is_some() {
            state.serialize_entry("quotaInfo", &self.quota_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerResizeRequestsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_manager_resize_requests_list_response::Warning
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_manager_resize_requests_list_response::warning::Data
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerResourcePolicies {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.workload_policy.is_some() {
            state.serialize_entry("workloadPolicy", &self.workload_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStandbyPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.initial_delay_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("initialDelaySec", &__With(&self.initial_delay_sec))?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_instances_config.is_some() {
            state.serialize_entry("allInstancesConfig", &self.all_instances_config)?;
        }
        if self.autoscaler.is_some() {
            state.serialize_entry("autoscaler", &self.autoscaler)?;
        }
        if self.is_stable.is_some() {
            state.serialize_entry("isStable", &self.is_stable)?;
        }
        if self.stateful.is_some() {
            state.serialize_entry("stateful", &self.stateful)?;
        }
        if self.version_target.is_some() {
            state.serialize_entry("versionTarget", &self.version_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStatusAllInstancesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.current_revision.is_some() {
            state.serialize_entry("currentRevision", &self.current_revision)?;
        }
        if self.effective.is_some() {
            state.serialize_entry("effective", &self.effective)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStatusStateful {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.has_stateful_config.is_some() {
            state.serialize_entry("hasStatefulConfig", &self.has_stateful_config)?;
        }
        if self.per_instance_configs.is_some() {
            state.serialize_entry("perInstanceConfigs", &self.per_instance_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStatusStatefulPerInstanceConfigs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_effective.is_some() {
            state.serialize_entry("allEffective", &self.all_effective)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerStatusVersionTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.is_reached.is_some() {
            state.serialize_entry("isReached", &self.is_reached)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerUpdatePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_redistribution_type.is_some() {
            state.serialize_entry(
                "instanceRedistributionType",
                &self.instance_redistribution_type,
            )?;
        }
        if self.max_surge.is_some() {
            state.serialize_entry("maxSurge", &self.max_surge)?;
        }
        if self.max_unavailable.is_some() {
            state.serialize_entry("maxUnavailable", &self.max_unavailable)?;
        }
        if self.minimal_action.is_some() {
            state.serialize_entry("minimalAction", &self.minimal_action)?;
        }
        if self.most_disruptive_allowed_action.is_some() {
            state.serialize_entry(
                "mostDisruptiveAllowedAction",
                &self.most_disruptive_allowed_action,
            )?;
        }
        if self.replacement_method.is_some() {
            state.serialize_entry("replacementMethod", &self.replacement_method)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagerVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_template.is_some() {
            state.serialize_entry("instanceTemplate", &self.instance_template)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.target_size.is_some() {
            state.serialize_entry("targetSize", &self.target_size)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersAbandonInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersApplyUpdatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_instances.is_some() {
            state.serialize_entry("allInstances", &self.all_instances)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.minimal_action.is_some() {
            state.serialize_entry("minimalAction", &self.minimal_action)?;
        }
        if self.most_disruptive_allowed_action.is_some() {
            state.serialize_entry(
                "mostDisruptiveAllowedAction",
                &self.most_disruptive_allowed_action,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersCreateInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersDeleteInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.skip_instances_on_validation_error.is_some() {
            state.serialize_entry(
                "skipInstancesOnValidationError",
                &self.skip_instances_on_validation_error,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersDeletePerInstanceConfigsReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersListErrorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersListManagedInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.managed_instances.is_empty() {
            state.serialize_entry("managedInstances", &self.managed_instances)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersListPerInstanceConfigsResp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_managers_list_per_instance_configs_resp::Warning
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::instance_group_managers_list_per_instance_configs_resp::warning::Data
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersPatchPerInstanceConfigsReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_instance_configs.is_empty() {
            state.serialize_entry("perInstanceConfigs", &self.per_instance_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersRecreateInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersResumeInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_group_managers.is_empty() {
            state.serialize_entry("instanceGroupManagers", &self.instance_group_managers)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_managers_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_group_managers_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersSetInstanceTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_template.is_some() {
            state.serialize_entry("instanceTemplate", &self.instance_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersSetTargetPoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.target_pools.is_empty() {
            state.serialize_entry("targetPools", &self.target_pools)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersStartInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersStopInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.force_stop.is_some() {
            state.serialize_entry("forceStop", &self.force_stop)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersSuspendInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.force_suspend.is_some() {
            state.serialize_entry("forceSuspend", &self.force_suspend)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupManagersUpdatePerInstanceConfigsReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_instance_configs.is_empty() {
            state.serialize_entry("perInstanceConfigs", &self.per_instance_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsAddInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsListInstances {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_groups_list_instances::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_groups_list_instances::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_state.is_some() {
            state.serialize_entry("instanceState", &self.instance_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsRemoveInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_groups.is_empty() {
            state.serialize_entry("instanceGroups", &self.instance_groups)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_groups_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_groups_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceGroupsSetNamedPortsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.named_ports.is_empty() {
            state.serialize_entry("namedPorts", &self.named_ports)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceListReferrers {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_list_referrers::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_list_referrers::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceManagedByIgmError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.instance_action_details.is_some() {
            state.serialize_entry("instanceActionDetails", &self.instance_action_details)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceManagedByIgmErrorInstanceActionDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.action.is_some() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceManagedByIgmErrorManagedInstanceError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceMoveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.destination_zone.is_some() {
            state.serialize_entry("destinationZone", &self.destination_zone)?;
        }
        if self.target_instance.is_some() {
            state.serialize_entry("targetInstance", &self.target_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request_valid_for_duration.is_some() {
            state.serialize_entry("requestValidForDuration", &self.request_valid_for_duration)?;
        }
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.can_ip_forward.is_some() {
            state.serialize_entry("canIpForward", &self.can_ip_forward)?;
        }
        if self.confidential_instance_config.is_some() {
            state.serialize_entry(
                "confidentialInstanceConfig",
                &self.confidential_instance_config,
            )?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if self.key_revocation_action_type.is_some() {
            state.serialize_entry("keyRevocationActionType", &self.key_revocation_action_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.private_ipv_6_google_access.is_some() {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv_6_google_access)?;
        }
        if self.reservation_affinity.is_some() {
            state.serialize_entry("reservationAffinity", &self.reservation_affinity)?;
        }
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.service_accounts.is_empty() {
            state.serialize_entry("serviceAccounts", &self.service_accounts)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancePropertiesPatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-groups", feature = "target-pools",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-settings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-settings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceSettingsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.properties.is_some() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.source_instance.is_some() {
            state.serialize_entry("sourceInstance", &self.source_instance)?;
        }
        if self.source_instance_params.is_some() {
            state.serialize_entry("sourceInstanceParams", &self.source_instance_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceTemplateAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_template_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_template_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceTemplateList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_template_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_template_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceTemplatesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_templates.is_empty() {
            state.serialize_entry("instanceTemplates", &self.instance_templates)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_templates_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instance-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instance_templates_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstanceWithNamedPorts {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.named_ports.is_empty() {
            state.serialize_entry("namedPorts", &self.named_ports)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesAddResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesBulkInsertOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_location_status.is_empty() {
            state.serialize_entry("perLocationStatus", &self.per_location_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesGetEffectiveFirewallsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.firewall_policys.is_empty() {
            state.serialize_entry("firewallPolicys", &self.firewall_policys)?;
        }
        if !self.firewalls.is_empty() {
            state.serialize_entry("firewalls", &self.firewalls)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.packet_mirroring_rules.is_empty() {
            state.serialize_entry("packetMirroringRules", &self.packet_mirroring_rules)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesRemoveResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesReportHostAsFaultyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disruption_schedule.is_some() {
            state.serialize_entry("disruptionSchedule", &self.disruption_schedule)?;
        }
        if !self.fault_reasons.is_empty() {
            state.serialize_entry("faultReasons", &self.fault_reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesReportHostAsFaultyRequestFaultReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.behavior.is_some() {
            state.serialize_entry("behavior", &self.behavior)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instances_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instances_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetMachineResourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetMachineTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetMinCpuPlatformRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetNameRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.current_name.is_some() {
            state.serialize_entry("currentName", &self.current_name)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetSecurityPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesSetServiceAccountRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.email.is_some() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesStartWithEncryptionKeyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instant-snapshots", feature = "region-instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstantSnapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.source_disk_id.is_some() {
            state.serialize_entry("sourceDiskId", &self.source_disk_id)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstantSnapshotAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshot_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshot_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instant-snapshots", feature = "region-instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstantSnapshotList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instant-snapshots", feature = "region-instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshot_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instant-snapshots", feature = "region-instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshot_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instant-snapshots", feature = "region-instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstantSnapshotResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.storage_size_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("storageSizeBytes", &__With(&self.storage_size_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstantSnapshotsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instant_snapshots.is_empty() {
            state.serialize_entry("instantSnapshots", &self.instant_snapshots)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshots_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instant-snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::instant_snapshots_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Int64RangeMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.range_end.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("rangeEnd", &__With(&self.range_end))?;
        }
        if self.range_start.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("rangeStart", &__With(&self.range_start))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Interconnect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aai_enabled.is_some() {
            state.serialize_entry("aaiEnabled", &self.aai_enabled)?;
        }
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.application_aware_interconnect.is_some() {
            state.serialize_entry(
                "applicationAwareInterconnect",
                &self.application_aware_interconnect,
            )?;
        }
        if !self.available_features.is_empty() {
            state.serialize_entry("availableFeatures", &self.available_features)?;
        }
        if !self.circuit_infos.is_empty() {
            state.serialize_entry("circuitInfos", &self.circuit_infos)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.customer_name.is_some() {
            state.serialize_entry("customerName", &self.customer_name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.expected_outages.is_empty() {
            state.serialize_entry("expectedOutages", &self.expected_outages)?;
        }
        if self.google_ip_address.is_some() {
            state.serialize_entry("googleIpAddress", &self.google_ip_address)?;
        }
        if self.google_reference_id.is_some() {
            state.serialize_entry("googleReferenceId", &self.google_reference_id)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.interconnect_attachments.is_empty() {
            state.serialize_entry("interconnectAttachments", &self.interconnect_attachments)?;
        }
        if !self.interconnect_groups.is_empty() {
            state.serialize_entry("interconnectGroups", &self.interconnect_groups)?;
        }
        if self.interconnect_type.is_some() {
            state.serialize_entry("interconnectType", &self.interconnect_type)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.link_type.is_some() {
            state.serialize_entry("linkType", &self.link_type)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.macsec.is_some() {
            state.serialize_entry("macsec", &self.macsec)?;
        }
        if self.macsec_enabled.is_some() {
            state.serialize_entry("macsecEnabled", &self.macsec_enabled)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.noc_contact_email.is_some() {
            state.serialize_entry("nocContactEmail", &self.noc_contact_email)?;
        }
        if self.operational_status.is_some() {
            state.serialize_entry("operationalStatus", &self.operational_status)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.peer_ip_address.is_some() {
            state.serialize_entry("peerIpAddress", &self.peer_ip_address)?;
        }
        if self.provisioned_link_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "provisionedLinkCount",
                &__With(&self.provisioned_link_count),
            )?;
        }
        if self.remote_location.is_some() {
            state.serialize_entry("remoteLocation", &self.remote_location)?;
        }
        if !self.requested_features.is_empty() {
            state.serialize_entry("requestedFeatures", &self.requested_features)?;
        }
        if self.requested_link_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("requestedLinkCount", &__With(&self.requested_link_count))?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.subzone.is_some() {
            state.serialize_entry("subzone", &self.subzone)?;
        }
        if !self.wire_groups.is_empty() {
            state.serialize_entry("wireGroups", &self.wire_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectApplicationAwareInterconnect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bandwidth_percentage_policy.is_some() {
            state.serialize_entry(
                "bandwidthPercentagePolicy",
                &self.bandwidth_percentage_policy,
            )?;
        }
        if self.profile_description.is_some() {
            state.serialize_entry("profileDescription", &self.profile_description)?;
        }
        if !self.shape_average_percentages.is_empty() {
            state.serialize_entry("shapeAveragePercentages", &self.shape_average_percentages)?;
        }
        if self.strict_priority_policy.is_some() {
            state.serialize_entry("strictPriorityPolicy", &self.strict_priority_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectApplicationAwareInterconnectBandwidthPercentage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.percentage.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("percentage", &__With(&self.percentage))?;
        }
        if self.traffic_class.is_some() {
            state.serialize_entry("trafficClass", &self.traffic_class)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectApplicationAwareInterconnectBandwidthPercentagePolicy
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bandwidth_percentages.is_empty() {
            state.serialize_entry("bandwidthPercentages", &self.bandwidth_percentages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectApplicationAwareInterconnectStrictPriorityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.attachment_group.is_some() {
            state.serialize_entry("attachmentGroup", &self.attachment_group)?;
        }
        if self.bandwidth.is_some() {
            state.serialize_entry("bandwidth", &self.bandwidth)?;
        }
        if !self.candidate_ipv_6_subnets.is_empty() {
            state.serialize_entry("candidateIpv6Subnets", &self.candidate_ipv_6_subnets)?;
        }
        if !self.candidate_subnets.is_empty() {
            state.serialize_entry("candidateSubnets", &self.candidate_subnets)?;
        }
        if self.cloud_router_ip_address.is_some() {
            state.serialize_entry("cloudRouterIpAddress", &self.cloud_router_ip_address)?;
        }
        if self.cloud_router_ipv_6_address.is_some() {
            state.serialize_entry("cloudRouterIpv6Address", &self.cloud_router_ipv_6_address)?;
        }
        if self.cloud_router_ipv_6_interface_id.is_some() {
            state.serialize_entry(
                "cloudRouterIpv6InterfaceId",
                &self.cloud_router_ipv_6_interface_id,
            )?;
        }
        if self.configuration_constraints.is_some() {
            state.serialize_entry("configurationConstraints", &self.configuration_constraints)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.customer_router_ip_address.is_some() {
            state.serialize_entry("customerRouterIpAddress", &self.customer_router_ip_address)?;
        }
        if self.customer_router_ipv_6_address.is_some() {
            state.serialize_entry(
                "customerRouterIpv6Address",
                &self.customer_router_ipv_6_address,
            )?;
        }
        if self.customer_router_ipv_6_interface_id.is_some() {
            state.serialize_entry(
                "customerRouterIpv6InterfaceId",
                &self.customer_router_ipv_6_interface_id,
            )?;
        }
        if self.dataplane_version.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataplaneVersion", &__With(&self.dataplane_version))?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.edge_availability_domain.is_some() {
            state.serialize_entry("edgeAvailabilityDomain", &self.edge_availability_domain)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if self.google_reference_id.is_some() {
            state.serialize_entry("googleReferenceId", &self.google_reference_id)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.interconnect.is_some() {
            state.serialize_entry("interconnect", &self.interconnect)?;
        }
        if !self.ipsec_internal_addresses.is_empty() {
            state.serialize_entry("ipsecInternalAddresses", &self.ipsec_internal_addresses)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.l_2_forwarding.is_some() {
            state.serialize_entry("l2Forwarding", &self.l_2_forwarding)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.mtu.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("mtu", &__With(&self.mtu))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.operational_status.is_some() {
            state.serialize_entry("operationalStatus", &self.operational_status)?;
        }
        if self.pairing_key.is_some() {
            state.serialize_entry("pairingKey", &self.pairing_key)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.partner_asn.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("partnerAsn", &__With(&self.partner_asn))?;
        }
        if self.partner_metadata.is_some() {
            state.serialize_entry("partnerMetadata", &self.partner_metadata)?;
        }
        if self.private_interconnect_info.is_some() {
            state.serialize_entry("privateInterconnectInfo", &self.private_interconnect_info)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.remote_service.is_some() {
            state.serialize_entry("remoteService", &self.remote_service)?;
        }
        if self.router.is_some() {
            state.serialize_entry("router", &self.router)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.subnet_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("subnetLength", &__With(&self.subnet_length))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.vlan_tag_8021_q.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vlanTag8021q", &__With(&self.vlan_tag_8021_q))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "interconnect-attachments",
    feature = "interconnect-remote-locations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentConfigurationConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bgp_md_5.is_some() {
            state.serialize_entry("bgpMd5", &self.bgp_md_5)?;
        }
        if !self.bgp_peer_asn_ranges.is_empty() {
            state.serialize_entry("bgpPeerAsnRanges", &self.bgp_peer_asn_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "interconnect-attachments",
    feature = "interconnect-remote-locations",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if self.min.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attachments.is_empty() {
            state.serialize_entry("attachments", &self.attachments)?;
        }
        if self.configured.is_some() {
            state.serialize_entry("configured", &self.configured)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if self.interconnect_group.is_some() {
            state.serialize_entry("interconnectGroup", &self.interconnect_group)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.logical_structure.is_some() {
            state.serialize_entry("logicalStructure", &self.logical_structure)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attachment.is_some() {
            state.serialize_entry("attachment", &self.attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupConfigured {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.availability_sla.is_some() {
            state.serialize_entry("availabilitySla", &self.availability_sla)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupConfiguredAvailabilitySLA {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.effective_sla.is_some() {
            state.serialize_entry("effectiveSla", &self.effective_sla)?;
        }
        if !self.intended_sla_blockers.is_empty() {
            state.serialize_entry("intendedSlaBlockers", &self.intended_sla_blockers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentGroupConfiguredAvailabilitySLAIntendedSlaBlockers
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attachments.is_empty() {
            state.serialize_entry("attachments", &self.attachments)?;
        }
        if self.blocker_type.is_some() {
            state.serialize_entry("blockerType", &self.blocker_type)?;
        }
        if self.documentation_link.is_some() {
            state.serialize_entry("documentationLink", &self.documentation_link)?;
        }
        if self.explanation.is_some() {
            state.serialize_entry("explanation", &self.explanation)?;
        }
        if !self.metros.is_empty() {
            state.serialize_entry("metros", &self.metros)?;
        }
        if !self.regions.is_empty() {
            state.serialize_entry("regions", &self.regions)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupIntent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.availability_sla.is_some() {
            state.serialize_entry("availabilitySla", &self.availability_sla)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupLogicalStructure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.regions.is_empty() {
            state.serialize_entry("regions", &self.regions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupLogicalStructureRegion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metros.is_empty() {
            state.serialize_entry("metros", &self.metros)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupLogicalStructureRegionMetro {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.facilities.is_empty() {
            state.serialize_entry("facilities", &self.facilities)?;
        }
        if self.metro.is_some() {
            state.serialize_entry("metro", &self.metro)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentGroupLogicalStructureRegionMetroFacility
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.facility.is_some() {
            state.serialize_entry("facility", &self.facility)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentGroupLogicalStructureRegionMetroFacilityZone
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attachments.is_empty() {
            state.serialize_entry("attachments", &self.attachments)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupsGetOperationalStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_groups_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_groups_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentGroupsOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attachment_statuses.is_empty() {
            state.serialize_entry("attachmentStatuses", &self.attachment_statuses)?;
        }
        if self.configured.is_some() {
            state.serialize_entry("configured", &self.configured)?;
        }
        if self.group_status.is_some() {
            state.serialize_entry("groupStatus", &self.group_status)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if self.operational.is_some() {
            state.serialize_entry("operational", &self.operational)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentGroupsOperationalStatusAttachmentStatus
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.attachment.is_some() {
            state.serialize_entry("attachment", &self.attachment)?;
        }
        if self.is_active.is_some() {
            state.serialize_entry("isActive", &self.is_active)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentL2Forwarding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.appliance_mappings.is_empty() {
            state.serialize_entry("applianceMappings", &self.appliance_mappings)?;
        }
        if self.default_appliance_ip_address.is_some() {
            state.serialize_entry(
                "defaultApplianceIpAddress",
                &self.default_appliance_ip_address,
            )?;
        }
        if self.geneve_header.is_some() {
            state.serialize_entry("geneveHeader", &self.geneve_header)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.tunnel_endpoint_ip_address.is_some() {
            state.serialize_entry("tunnelEndpointIpAddress", &self.tunnel_endpoint_ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentL2ForwardingApplianceMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.appliance_ip_address.is_some() {
            state.serialize_entry("applianceIpAddress", &self.appliance_ip_address)?;
        }
        if !self.inner_vlan_to_appliance_mappings.is_empty() {
            state.serialize_entry(
                "innerVlanToApplianceMappings",
                &self.inner_vlan_to_appliance_mappings,
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectAttachmentL2ForwardingApplianceMappingInnerVlanToApplianceMapping
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.inner_appliance_ip_address.is_some() {
            state.serialize_entry("innerApplianceIpAddress", &self.inner_appliance_ip_address)?;
        }
        if !self.inner_vlan_tags.is_empty() {
            state.serialize_entry("innerVlanTags", &self.inner_vlan_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentL2ForwardingGeneveHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.vni.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vni", &__With(&self.vni))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachment_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentPartnerMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interconnect_name.is_some() {
            state.serialize_entry("interconnectName", &self.interconnect_name)?;
        }
        if self.partner_name.is_some() {
            state.serialize_entry("partnerName", &self.partner_name)?;
        }
        if self.portal_url.is_some() {
            state.serialize_entry("portalUrl", &self.portal_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentPrivateInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.tag8021q.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("tag8021q", &__With(&self.tag8021q))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectAttachmentsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.interconnect_attachments.is_empty() {
            state.serialize_entry("interconnectAttachments", &self.interconnect_attachments)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachments_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_attachments_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectCircuitInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.customer_demarc_id.is_some() {
            state.serialize_entry("customerDemarcId", &self.customer_demarc_id)?;
        }
        if self.google_circuit_id.is_some() {
            state.serialize_entry("googleCircuitId", &self.google_circuit_id)?;
        }
        if self.google_demarc_id.is_some() {
            state.serialize_entry("googleDemarcId", &self.google_demarc_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnostics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.arp_caches.is_empty() {
            state.serialize_entry("arpCaches", &self.arp_caches)?;
        }
        if self.bundle_aggregation_type.is_some() {
            state.serialize_entry("bundleAggregationType", &self.bundle_aggregation_type)?;
        }
        if self.bundle_operational_status.is_some() {
            state.serialize_entry("bundleOperationalStatus", &self.bundle_operational_status)?;
        }
        if !self.links.is_empty() {
            state.serialize_entry("links", &self.links)?;
        }
        if self.mac_address.is_some() {
            state.serialize_entry("macAddress", &self.mac_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnosticsARPEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.mac_address.is_some() {
            state.serialize_entry("macAddress", &self.mac_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnosticsLinkLACPStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.google_system_id.is_some() {
            state.serialize_entry("googleSystemId", &self.google_system_id)?;
        }
        if self.neighbor_system_id.is_some() {
            state.serialize_entry("neighborSystemId", &self.neighbor_system_id)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnosticsLinkOpticalPower {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.value.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnosticsLinkStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.arp_caches.is_empty() {
            state.serialize_entry("arpCaches", &self.arp_caches)?;
        }
        if self.circuit_id.is_some() {
            state.serialize_entry("circuitId", &self.circuit_id)?;
        }
        if self.google_demarc.is_some() {
            state.serialize_entry("googleDemarc", &self.google_demarc)?;
        }
        if self.lacp_status.is_some() {
            state.serialize_entry("lacpStatus", &self.lacp_status)?;
        }
        if self.macsec.is_some() {
            state.serialize_entry("macsec", &self.macsec)?;
        }
        if self.operational_status.is_some() {
            state.serialize_entry("operationalStatus", &self.operational_status)?;
        }
        if self.receiving_optical_power.is_some() {
            state.serialize_entry("receivingOpticalPower", &self.receiving_optical_power)?;
        }
        if self.transmitting_optical_power.is_some() {
            state.serialize_entry("transmittingOpticalPower", &self.transmitting_optical_power)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "interconnect-groups", feature = "interconnects",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectDiagnosticsMacsecStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ckn.is_some() {
            state.serialize_entry("ckn", &self.ckn)?;
        }
        if self.operational.is_some() {
            state.serialize_entry("operational", &self.operational)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.configured.is_some() {
            state.serialize_entry("configured", &self.configured)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.interconnects.is_empty() {
            state.serialize_entry("interconnects", &self.interconnects)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.physical_structure.is_some() {
            state.serialize_entry("physicalStructure", &self.physical_structure)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupConfigured {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.topology_capability.is_some() {
            state.serialize_entry("topologyCapability", &self.topology_capability)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupConfiguredTopologyCapability {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intended_capability_blockers.is_empty() {
            state.serialize_entry(
                "intendedCapabilityBlockers",
                &self.intended_capability_blockers,
            )?;
        }
        if self.supported_sla.is_some() {
            state.serialize_entry("supportedSla", &self.supported_sla)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::InterconnectGroupConfiguredTopologyCapabilityIntendedCapabilityBlockers
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.blocker_type.is_some() {
            state.serialize_entry("blockerType", &self.blocker_type)?;
        }
        if self.documentation_link.is_some() {
            state.serialize_entry("documentationLink", &self.documentation_link)?;
        }
        if self.explanation.is_some() {
            state.serialize_entry("explanation", &self.explanation)?;
        }
        if !self.facilities.is_empty() {
            state.serialize_entry("facilities", &self.facilities)?;
        }
        if !self.interconnects.is_empty() {
            state.serialize_entry("interconnects", &self.interconnects)?;
        }
        if !self.metros.is_empty() {
            state.serialize_entry("metros", &self.metros)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupIntent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.topology_capability.is_some() {
            state.serialize_entry("topologyCapability", &self.topology_capability)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupInterconnect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interconnect.is_some() {
            state.serialize_entry("interconnect", &self.interconnect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupPhysicalStructure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metros.is_empty() {
            state.serialize_entry("metros", &self.metros)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupPhysicalStructureMetros {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.facilities.is_empty() {
            state.serialize_entry("facilities", &self.facilities)?;
        }
        if self.metro.is_some() {
            state.serialize_entry("metro", &self.metro)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupPhysicalStructureMetrosFacilities {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.facility.is_some() {
            state.serialize_entry("facility", &self.facility)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupPhysicalStructureMetrosFacilitiesZones {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.interconnects.is_empty() {
            state.serialize_entry("interconnects", &self.interconnects)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsCreateMembers {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent_mismatch_behavior.is_some() {
            state.serialize_entry("intentMismatchBehavior", &self.intent_mismatch_behavior)?;
        }
        if !self.interconnects.is_empty() {
            state.serialize_entry("interconnects", &self.interconnects)?;
        }
        if self.template_interconnect.is_some() {
            state.serialize_entry("templateInterconnect", &self.template_interconnect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsCreateMembersInterconnectInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.customer_name.is_some() {
            state.serialize_entry("customerName", &self.customer_name)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.facility.is_some() {
            state.serialize_entry("facility", &self.facility)?;
        }
        if self.interconnect_type.is_some() {
            state.serialize_entry("interconnectType", &self.interconnect_type)?;
        }
        if self.link_type.is_some() {
            state.serialize_entry("linkType", &self.link_type)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.noc_contact_email.is_some() {
            state.serialize_entry("nocContactEmail", &self.noc_contact_email)?;
        }
        if self.remote_location.is_some() {
            state.serialize_entry("remoteLocation", &self.remote_location)?;
        }
        if !self.requested_features.is_empty() {
            state.serialize_entry("requestedFeatures", &self.requested_features)?;
        }
        if self.requested_link_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("requestedLinkCount", &__With(&self.requested_link_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsCreateMembersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsGetOperationalStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_groups_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_groups_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsOperationalStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.configured.is_some() {
            state.serialize_entry("configured", &self.configured)?;
        }
        if self.group_status.is_some() {
            state.serialize_entry("groupStatus", &self.group_status)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.interconnect_statuses.is_empty() {
            state.serialize_entry("interconnectStatuses", &self.interconnect_statuses)?;
        }
        if self.operational.is_some() {
            state.serialize_entry("operational", &self.operational)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectGroupsOperationalStatusInterconnectStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.diagnostics.is_some() {
            state.serialize_entry("diagnostics", &self.diagnostics)?;
        }
        if self.interconnect.is_some() {
            state.serialize_entry("interconnect", &self.interconnect)?;
        }
        if self.is_active.is_some() {
            state.serialize_entry("isActive", &self.is_active)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.address.is_some() {
            state.serialize_entry("address", &self.address)?;
        }
        if self.availability_zone.is_some() {
            state.serialize_entry("availabilityZone", &self.availability_zone)?;
        }
        if !self.available_features.is_empty() {
            state.serialize_entry("availableFeatures", &self.available_features)?;
        }
        if !self.available_link_types.is_empty() {
            state.serialize_entry("availableLinkTypes", &self.available_link_types)?;
        }
        if self.city.is_some() {
            state.serialize_entry("city", &self.city)?;
        }
        if self.continent.is_some() {
            state.serialize_entry("continent", &self.continent)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if !self.cross_site_interconnect_infos.is_empty() {
            state.serialize_entry(
                "crossSiteInterconnectInfos",
                &self.cross_site_interconnect_infos,
            )?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.facility_provider.is_some() {
            state.serialize_entry("facilityProvider", &self.facility_provider)?;
        }
        if self.facility_provider_facility_id.is_some() {
            state.serialize_entry(
                "facilityProviderFacilityId",
                &self.facility_provider_facility_id,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.peeringdb_facility_id.is_some() {
            state.serialize_entry("peeringdbFacilityId", &self.peeringdb_facility_id)?;
        }
        if !self.region_infos.is_empty() {
            state.serialize_entry("regionInfos", &self.region_infos)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self
            .single_region_production_critical_peer_locations
            .is_empty()
        {
            state.serialize_entry(
                "singleRegionProductionCriticalPeerLocations",
                &self.single_region_production_critical_peer_locations,
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.supports_pzs.is_some() {
            state.serialize_entry("supportsPzs", &self.supports_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectLocationCrossSiteInterconnectInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.city.is_some() {
            state.serialize_entry("city", &self.city)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectLocationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_location_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_location_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectLocationRegionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expected_rtt_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("expectedRttMs", &__With(&self.expected_rtt_ms))?;
        }
        if self.l_2_forwarding_enabled.is_some() {
            state.serialize_entry("l2ForwardingEnabled", &self.l_2_forwarding_enabled)?;
        }
        if self.location_presence.is_some() {
            state.serialize_entry("locationPresence", &self.location_presence)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectMacsec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fail_open.is_some() {
            state.serialize_entry("failOpen", &self.fail_open)?;
        }
        if !self.pre_shared_keys.is_empty() {
            state.serialize_entry("preSharedKeys", &self.pre_shared_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectMacsecConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pre_shared_keys.is_empty() {
            state.serialize_entry("preSharedKeys", &self.pre_shared_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectMacsecConfigPreSharedKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cak.is_some() {
            state.serialize_entry("cak", &self.cak)?;
        }
        if self.ckn.is_some() {
            state.serialize_entry("ckn", &self.ckn)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectMacsecPreSharedKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectOutageNotification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.affected_circuits.is_empty() {
            state.serialize_entry("affectedCircuits", &self.affected_circuits)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.end_time.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("endTime", &__With(&self.end_time))?;
        }
        if self.issue_type.is_some() {
            state.serialize_entry("issueType", &self.issue_type)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.start_time.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("startTime", &__With(&self.start_time))?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectRemoteLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.address.is_some() {
            state.serialize_entry("address", &self.address)?;
        }
        if self.attachment_configuration_constraints.is_some() {
            state.serialize_entry(
                "attachmentConfigurationConstraints",
                &self.attachment_configuration_constraints,
            )?;
        }
        if self.city.is_some() {
            state.serialize_entry("city", &self.city)?;
        }
        if self.constraints.is_some() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if self.continent.is_some() {
            state.serialize_entry("continent", &self.continent)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.facility_provider.is_some() {
            state.serialize_entry("facilityProvider", &self.facility_provider)?;
        }
        if self.facility_provider_facility_id.is_some() {
            state.serialize_entry(
                "facilityProviderFacilityId",
                &self.facility_provider_facility_id,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.lacp.is_some() {
            state.serialize_entry("lacp", &self.lacp)?;
        }
        if self.max_lag_size_100_gbps.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxLagSize100Gbps", &__With(&self.max_lag_size_100_gbps))?;
        }
        if self.max_lag_size_10_gbps.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxLagSize10Gbps", &__With(&self.max_lag_size_10_gbps))?;
        }
        if self.max_lag_size_400_gbps.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxLagSize400Gbps", &__With(&self.max_lag_size_400_gbps))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.peeringdb_facility_id.is_some() {
            state.serialize_entry("peeringdbFacilityId", &self.peeringdb_facility_id)?;
        }
        if !self.permitted_connections.is_empty() {
            state.serialize_entry("permittedConnections", &self.permitted_connections)?;
        }
        if self.remote_service.is_some() {
            state.serialize_entry("remoteService", &self.remote_service)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectRemoteLocationConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.port_pair_remote_location.is_some() {
            state.serialize_entry("portPairRemoteLocation", &self.port_pair_remote_location)?;
        }
        if self.port_pair_vlan.is_some() {
            state.serialize_entry("portPairVlan", &self.port_pair_vlan)?;
        }
        if self.subnet_length_range.is_some() {
            state.serialize_entry("subnetLengthRange", &self.subnet_length_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectRemoteLocationConstraintsSubnetLengthRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("max", &__With(&self.max))?;
        }
        if self.min.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("min", &__With(&self.min))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectRemoteLocationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_remote_location_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::interconnect_remote_location_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectRemoteLocationPermittedConnections {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interconnect_location.is_some() {
            state.serialize_entry("interconnectLocation", &self.interconnect_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectsGetDiagnosticsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "interconnects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InterconnectsGetMacsecConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "licenses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::License {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.allowed_replacement_licenses.is_empty() {
            state.serialize_entry(
                "allowedReplacementLicenses",
                &self.allowed_replacement_licenses,
            )?;
        }
        if self.appendable_to_disk.is_some() {
            state.serialize_entry("appendableToDisk", &self.appendable_to_disk)?;
        }
        if self.charges_use_fee.is_some() {
            state.serialize_entry("chargesUseFee", &self.charges_use_fee)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.incompatible_licenses.is_empty() {
            state.serialize_entry("incompatibleLicenses", &self.incompatible_licenses)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.license_code.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("licenseCode", &__With(&self.license_code))?;
        }
        if self.minimum_retention.is_some() {
            state.serialize_entry("minimumRetention", &self.minimum_retention)?;
        }
        if self.multi_tenant_only.is_some() {
            state.serialize_entry("multiTenantOnly", &self.multi_tenant_only)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.os_license.is_some() {
            state.serialize_entry("osLicense", &self.os_license)?;
        }
        if self.removable_from_disk.is_some() {
            state.serialize_entry("removableFromDisk", &self.removable_from_disk)?;
        }
        if !self.required_coattached_licenses.is_empty() {
            state.serialize_entry(
                "requiredCoattachedLicenses",
                &self.required_coattached_licenses,
            )?;
        }
        if self.resource_requirements.is_some() {
            state.serialize_entry("resourceRequirements", &self.resource_requirements)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.sole_tenant_only.is_some() {
            state.serialize_entry("soleTenantOnly", &self.sole_tenant_only)?;
        }
        if self.transferable.is_some() {
            state.serialize_entry("transferable", &self.transferable)?;
        }
        if self.update_timestamp.is_some() {
            state.serialize_entry("updateTimestamp", &self.update_timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "license-codes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LicenseCode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.license_alias.is_empty() {
            state.serialize_entry("licenseAlias", &self.license_alias)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.transferable.is_some() {
            state.serialize_entry("transferable", &self.transferable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "license-codes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LicenseCodeLicenseAlias {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LicenseResourceCommitment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.amount.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("amount", &__With(&self.amount))?;
        }
        if self.cores_per_license.is_some() {
            state.serialize_entry("coresPerLicense", &self.cores_per_license)?;
        }
        if self.license.is_some() {
            state.serialize_entry("license", &self.license)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "licenses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LicenseResourceRequirements {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_guest_cpu_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minGuestCpuCount", &__With(&self.min_guest_cpu_count))?;
        }
        if self.min_memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minMemoryMb", &__With(&self.min_memory_mb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "licenses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LicensesListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "licenses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::licenses_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "licenses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::licenses_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "node-groups", feature = "node-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocalDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disk_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.disk_type.is_some() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocalizedMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.locale.is_some() {
            state.serialize_entry("locale", &self.locale)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.target_shape.is_some() {
            state.serialize_entry("targetShape", &self.target_shape)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocationPolicyLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.constraints.is_some() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if self.preference.is_some() {
            state.serialize_entry("preference", &self.preference)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocationPolicyLocationConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxCount", &__With(&self.max_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.guest_flush.is_some() {
            state.serialize_entry("guestFlush", &self.guest_flush)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance_properties.is_some() {
            state.serialize_entry("instanceProperties", &self.instance_properties)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.machine_image_encryption_key.is_some() {
            state.serialize_entry(
                "machineImageEncryptionKey",
                &self.machine_image_encryption_key,
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self.saved_disks.is_empty() {
            state.serialize_entry("savedDisks", &self.saved_disks)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.source_disk_encryption_keys.is_empty() {
            state.serialize_entry(
                "sourceDiskEncryptionKeys",
                &self.source_disk_encryption_keys,
            )?;
        }
        if self.source_instance.is_some() {
            state.serialize_entry("sourceInstance", &self.source_instance)?;
        }
        if self.source_instance_properties.is_some() {
            state.serialize_entry("sourceInstanceProperties", &self.source_instance_properties)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.storage_locations.is_empty() {
            state.serialize_entry("storageLocations", &self.storage_locations)?;
        }
        if self.total_storage_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalStorageBytes", &__With(&self.total_storage_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineImageList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_image_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_image_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.guest_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("guestCpus", &__With(&self.guest_cpus))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.image_space_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("imageSpaceGb", &__With(&self.image_space_gb))?;
        }
        if self.is_shared_cpu.is_some() {
            state.serialize_entry("isSharedCpu", &self.is_shared_cpu)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.maximum_persistent_disks.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisks",
                &__With(&self.maximum_persistent_disks),
            )?;
        }
        if self.maximum_persistent_disks_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisksSizeGb",
                &__With(&self.maximum_persistent_disks_size_gb),
            )?;
        }
        if self.memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type::Accelerators {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.guest_accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "guestAcceleratorCount",
                &__With(&self.guest_accelerator_count),
            )?;
        }
        if self.guest_accelerator_type.is_some() {
            state.serialize_entry("guestAcceleratorType", &self.guest_accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_types.is_empty() {
            state.serialize_entry("machineTypes", &self.machine_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.current_action.is_some() {
            state.serialize_entry("currentAction", &self.current_action)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.instance_health.is_empty() {
            state.serialize_entry("instanceHealth", &self.instance_health)?;
        }
        if self.instance_status.is_some() {
            state.serialize_entry("instanceStatus", &self.instance_status)?;
        }
        if self.last_attempt.is_some() {
            state.serialize_entry("lastAttempt", &self.last_attempt)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.preserved_state_from_config.is_some() {
            state.serialize_entry(
                "preservedStateFromConfig",
                &self.preserved_state_from_config,
            )?;
        }
        if self.preserved_state_from_policy.is_some() {
            state.serialize_entry(
                "preservedStateFromPolicy",
                &self.preserved_state_from_policy,
            )?;
        }
        if self.properties_from_flexibility_policy.is_some() {
            state.serialize_entry(
                "propertiesFromFlexibilityPolicy",
                &self.properties_from_flexibility_policy,
            )?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedInstanceInstanceHealth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.detailed_health_state.is_some() {
            state.serialize_entry("detailedHealthState", &self.detailed_health_state)?;
        }
        if self.health_check.is_some() {
            state.serialize_entry("healthCheck", &self.health_check)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedInstanceLastAttempt {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.errors.is_some() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::managed_instance_last_attempt::Errors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::managed_instance_last_attempt::errors::Errors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::managed_instance_last_attempt::errors::errors::ErrorDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if self.help.is_some() {
            state.serialize_entry("help", &self.help)?;
        }
        if self.localized_message.is_some() {
            state.serialize_entry("localizedMessage", &self.localized_message)?;
        }
        if self.quota_info.is_some() {
            state.serialize_entry("quotaInfo", &self.quota_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedInstancePropertiesFromFlexibilityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedInstanceVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_template.is_some() {
            state.serialize_entry("instanceTemplate", &self.instance_template)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "projects",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Metadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "projects",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::metadata::Items {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "forwarding-rules",
    feature = "global-forwarding-rules",
    feature = "region-url-maps",
    feature = "url-maps",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::MetadataFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.filter_labels.is_empty() {
            state.serialize_entry("filterLabels", &self.filter_labels)?;
        }
        if self.filter_match_criteria.is_some() {
            state.serialize_entry("filterMatchCriteria", &self.filter_match_criteria)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "forwarding-rules",
    feature = "global-forwarding-rules",
    feature = "region-url-maps",
    feature = "url-maps",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::MetadataFilterLabelMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NamedPort {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NatIpInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nat_ip_info_mappings.is_empty() {
            state.serialize_entry("natIpInfoMappings", &self.nat_ip_info_mappings)?;
        }
        if self.nat_name.is_some() {
            state.serialize_entry("natName", &self.nat_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NatIpInfoNatIpInfoMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.nat_ip.is_some() {
            state.serialize_entry("natIp", &self.nat_ip)?;
        }
        if self.usage.is_some() {
            state.serialize_entry("usage", &self.usage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NatIpInfoResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.result.is_empty() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Network {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.i_pv_4_range.is_some() {
            state.serialize_entry("IPv4Range", &self.i_pv_4_range)?;
        }
        if self.auto_create_subnetworks.is_some() {
            state.serialize_entry("autoCreateSubnetworks", &self.auto_create_subnetworks)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enable_ula_internal_ipv_6.is_some() {
            state.serialize_entry("enableUlaInternalIpv6", &self.enable_ula_internal_ipv_6)?;
        }
        if self.firewall_policy.is_some() {
            state.serialize_entry("firewallPolicy", &self.firewall_policy)?;
        }
        if self.gateway_i_pv_4.is_some() {
            state.serialize_entry("gatewayIPv4", &self.gateway_i_pv_4)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.internal_ipv_6_range.is_some() {
            state.serialize_entry("internalIpv6Range", &self.internal_ipv_6_range)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.mtu.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("mtu", &__With(&self.mtu))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network_firewall_policy_enforcement_order.is_some() {
            state.serialize_entry(
                "networkFirewallPolicyEnforcementOrder",
                &self.network_firewall_policy_enforcement_order,
            )?;
        }
        if self.network_profile.is_some() {
            state.serialize_entry("networkProfile", &self.network_profile)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self.peerings.is_empty() {
            state.serialize_entry("peerings", &self.peerings)?;
        }
        if self.routing_config.is_some() {
            state.serialize_entry("routingConfig", &self.routing_config)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_endpoints.is_empty() {
            state.serialize_entry("connectionEndpoints", &self.connection_endpoints)?;
        }
        if self.connection_preference.is_some() {
            state.serialize_entry("connectionPreference", &self.connection_preference)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.producer_accept_lists.is_empty() {
            state.serialize_entry("producerAcceptLists", &self.producer_accept_lists)?;
        }
        if !self.producer_reject_lists.is_empty() {
            state.serialize_entry("producerRejectLists", &self.producer_reject_lists)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkAttachmentAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachment_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachment_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkAttachmentConnectedEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if self.project_id_or_num.is_some() {
            state.serialize_entry("projectIdOrNum", &self.project_id_or_num)?;
        }
        if !self.secondary_ip_cidr_ranges.is_empty() {
            state.serialize_entry("secondaryIpCidrRanges", &self.secondary_ip_cidr_ranges)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.subnetwork_cidr_range.is_some() {
            state.serialize_entry("subnetworkCidrRange", &self.subnetwork_cidr_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkAttachmentList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachment_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachment_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkAttachmentsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_attachments.is_empty() {
            state.serialize_entry("networkAttachments", &self.network_attachments)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachments_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_attachments_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEdgeSecurityService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEdgeSecurityServiceAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_edge_security_service_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_edge_security_service_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEdgeSecurityServicesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_edge_security_services.is_empty() {
            state.serialize_entry(
                "networkEdgeSecurityServices",
                &self.network_edge_security_services,
            )?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_edge_security_services_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-edge-security-services")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_edge_security_services_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.client_destination_port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "clientDestinationPort",
                &__With(&self.client_destination_port),
            )?;
        }
        if self.fqdn.is_some() {
            state.serialize_entry("fqdn", &self.fqdn)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if self.app_engine.is_some() {
            state.serialize_entry("appEngine", &self.app_engine)?;
        }
        if self.cloud_function.is_some() {
            state.serialize_entry("cloudFunction", &self.cloud_function)?;
        }
        if self.cloud_run.is_some() {
            state.serialize_entry("cloudRun", &self.cloud_run)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.default_port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("defaultPort", &__With(&self.default_port))?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.network_endpoint_type.is_some() {
            state.serialize_entry("networkEndpointType", &self.network_endpoint_type)?;
        }
        if self.psc_data.is_some() {
            state.serialize_entry("pscData", &self.psc_data)?;
        }
        if self.psc_target_service.is_some() {
            state.serialize_entry("pscTargetService", &self.psc_target_service)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_group_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_group_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupAppEngine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.url_mask.is_some() {
            state.serialize_entry("urlMask", &self.url_mask)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupCloudFunction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.function.is_some() {
            state.serialize_entry("function", &self.function)?;
        }
        if self.url_mask.is_some() {
            state.serialize_entry("urlMask", &self.url_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupCloudRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.tag.is_some() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if self.url_mask.is_some() {
            state.serialize_entry("urlMask", &self.url_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_group_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_group_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupPscData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consumer_psc_address.is_some() {
            state.serialize_entry("consumerPscAddress", &self.consumer_psc_address)?;
        }
        if self.producer_port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("producerPort", &__With(&self.producer_port))?;
        }
        if self.psc_connection_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pscConnectionId", &__With(&self.psc_connection_id))?;
        }
        if self.psc_connection_status.is_some() {
            state.serialize_entry("pscConnectionStatus", &self.psc_connection_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupsAttachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupsDetachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupsListEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.health_status.is_some() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupsListNetworkEndpoints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_groups_list_network_endpoints::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::network_endpoint_groups_list_network_endpoints::warning::Data
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointGroupsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoint_groups.is_empty() {
            state.serialize_entry("networkEndpointGroups", &self.network_endpoint_groups)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_groups_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_endpoint_groups_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-network-endpoint-groups",
    feature = "network-endpoint-groups",
    feature = "region-network-endpoint-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkEndpointWithHealthStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.healths.is_empty() {
            state.serialize_entry("healths", &self.healths)?;
        }
        if self.network_endpoint.is_some() {
            state.serialize_entry("networkEndpoint", &self.network_endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkFirewallPolicyAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_firewall_policy_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_firewall_policy_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_configs.is_empty() {
            state.serialize_entry("accessConfigs", &self.access_configs)?;
        }
        if !self.alias_ip_ranges.is_empty() {
            state.serialize_entry("aliasIpRanges", &self.alias_ip_ranges)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.igmp_query.is_some() {
            state.serialize_entry("igmpQuery", &self.igmp_query)?;
        }
        if self.internal_ipv_6_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "internalIpv6PrefixLength",
                &__With(&self.internal_ipv_6_prefix_length),
            )?;
        }
        if !self.ipv_6_access_configs.is_empty() {
            state.serialize_entry("ipv6AccessConfigs", &self.ipv_6_access_configs)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.network_attachment.is_some() {
            state.serialize_entry("networkAttachment", &self.network_attachment)?;
        }
        if self.network_ip.is_some() {
            state.serialize_entry("networkIP", &self.network_ip)?;
        }
        if self.nic_type.is_some() {
            state.serialize_entry("nicType", &self.nic_type)?;
        }
        if self.parent_nic_name.is_some() {
            state.serialize_entry("parentNicName", &self.parent_nic_name)?;
        }
        if self.queue_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("queueCount", &__With(&self.queue_count))?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if self.vlan.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vlan", &__With(&self.vlan))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPeering {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_create_routes.is_some() {
            state.serialize_entry("autoCreateRoutes", &self.auto_create_routes)?;
        }
        if self.connection_status.is_some() {
            state.serialize_entry("connectionStatus", &self.connection_status)?;
        }
        if self.exchange_subnet_routes.is_some() {
            state.serialize_entry("exchangeSubnetRoutes", &self.exchange_subnet_routes)?;
        }
        if self.export_custom_routes.is_some() {
            state.serialize_entry("exportCustomRoutes", &self.export_custom_routes)?;
        }
        if self.export_subnet_routes_with_public_ip.is_some() {
            state.serialize_entry(
                "exportSubnetRoutesWithPublicIp",
                &self.export_subnet_routes_with_public_ip,
            )?;
        }
        if self.import_custom_routes.is_some() {
            state.serialize_entry("importCustomRoutes", &self.import_custom_routes)?;
        }
        if self.import_subnet_routes_with_public_ip.is_some() {
            state.serialize_entry(
                "importSubnetRoutesWithPublicIp",
                &self.import_subnet_routes_with_public_ip,
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.peer_mtu.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("peerMtu", &__With(&self.peer_mtu))?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_details.is_some() {
            state.serialize_entry("stateDetails", &self.state_details)?;
        }
        if self.update_strategy.is_some() {
            state.serialize_entry("updateStrategy", &self.update_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPeeringConnectionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consensus_state.is_some() {
            state.serialize_entry("consensusState", &self.consensus_state)?;
        }
        if self.traffic_configuration.is_some() {
            state.serialize_entry("trafficConfiguration", &self.traffic_configuration)?;
        }
        if self.update_strategy.is_some() {
            state.serialize_entry("updateStrategy", &self.update_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPeeringConnectionStatusConsensusState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.delete_status.is_some() {
            state.serialize_entry("deleteStatus", &self.delete_status)?;
        }
        if self.update_status.is_some() {
            state.serialize_entry("updateStatus", &self.update_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPeeringConnectionStatusTrafficConfiguration {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.export_custom_routes_to_peer.is_some() {
            state.serialize_entry(
                "exportCustomRoutesToPeer",
                &self.export_custom_routes_to_peer,
            )?;
        }
        if self.export_subnet_routes_with_public_ip_to_peer.is_some() {
            state.serialize_entry(
                "exportSubnetRoutesWithPublicIpToPeer",
                &self.export_subnet_routes_with_public_ip_to_peer,
            )?;
        }
        if self.import_custom_routes_from_peer.is_some() {
            state.serialize_entry(
                "importCustomRoutesFromPeer",
                &self.import_custom_routes_from_peer,
            )?;
        }
        if self.import_subnet_routes_with_public_ip_from_peer.is_some() {
            state.serialize_entry(
                "importSubnetRoutesWithPublicIpFromPeer",
                &self.import_subnet_routes_with_public_ip_from_peer,
            )?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPerformanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.total_egress_bandwidth_tier.is_some() {
            state.serialize_entry(
                "totalEgressBandwidthTier",
                &self.total_egress_bandwidth_tier,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.features.is_some() {
            state.serialize_entry("features", &self.features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.profile_type.is_some() {
            state.serialize_entry("profileType", &self.profile_type)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkProfileLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.scope.is_some() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkProfileNetworkFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.address_purposes.is_empty() {
            state.serialize_entry("addressPurposes", &self.address_purposes)?;
        }
        if self.allow_alias_ip_ranges.is_some() {
            state.serialize_entry("allowAliasIpRanges", &self.allow_alias_ip_ranges)?;
        }
        if self.allow_auto_mode_subnet.is_some() {
            state.serialize_entry("allowAutoModeSubnet", &self.allow_auto_mode_subnet)?;
        }
        if self.allow_class_d_firewalls.is_some() {
            state.serialize_entry("allowClassDFirewalls", &self.allow_class_d_firewalls)?;
        }
        if self.allow_cloud_nat.is_some() {
            state.serialize_entry("allowCloudNat", &self.allow_cloud_nat)?;
        }
        if self.allow_cloud_router.is_some() {
            state.serialize_entry("allowCloudRouter", &self.allow_cloud_router)?;
        }
        if self.allow_default_nic_attachment.is_some() {
            state.serialize_entry(
                "allowDefaultNicAttachment",
                &self.allow_default_nic_attachment,
            )?;
        }
        if self.allow_external_ip_access.is_some() {
            state.serialize_entry("allowExternalIpAccess", &self.allow_external_ip_access)?;
        }
        if self.allow_interconnect.is_some() {
            state.serialize_entry("allowInterconnect", &self.allow_interconnect)?;
        }
        if self.allow_ip_forwarding.is_some() {
            state.serialize_entry("allowIpForwarding", &self.allow_ip_forwarding)?;
        }
        if self.allow_load_balancing.is_some() {
            state.serialize_entry("allowLoadBalancing", &self.allow_load_balancing)?;
        }
        if self.allow_multi_nic_in_same_network.is_some() {
            state.serialize_entry(
                "allowMultiNicInSameNetwork",
                &self.allow_multi_nic_in_same_network,
            )?;
        }
        if self.allow_multicast.is_some() {
            state.serialize_entry("allowMulticast", &self.allow_multicast)?;
        }
        if self.allow_ncc.is_some() {
            state.serialize_entry("allowNcc", &self.allow_ncc)?;
        }
        if self.allow_network_migration.is_some() {
            state.serialize_entry("allowNetworkMigration", &self.allow_network_migration)?;
        }
        if self.allow_packet_mirroring.is_some() {
            state.serialize_entry("allowPacketMirroring", &self.allow_packet_mirroring)?;
        }
        if self.allow_private_google_access.is_some() {
            state.serialize_entry(
                "allowPrivateGoogleAccess",
                &self.allow_private_google_access,
            )?;
        }
        if self.allow_psc.is_some() {
            state.serialize_entry("allowPsc", &self.allow_psc)?;
        }
        if self.allow_same_network_unicast.is_some() {
            state.serialize_entry("allowSameNetworkUnicast", &self.allow_same_network_unicast)?;
        }
        if self.allow_static_routes.is_some() {
            state.serialize_entry("allowStaticRoutes", &self.allow_static_routes)?;
        }
        if self.allow_sub_interfaces.is_some() {
            state.serialize_entry("allowSubInterfaces", &self.allow_sub_interfaces)?;
        }
        if self.allow_vpc_peering.is_some() {
            state.serialize_entry("allowVpcPeering", &self.allow_vpc_peering)?;
        }
        if self.allow_vpn.is_some() {
            state.serialize_entry("allowVpn", &self.allow_vpn)?;
        }
        if !self.interface_types.is_empty() {
            state.serialize_entry("interfaceTypes", &self.interface_types)?;
        }
        if self.multicast.is_some() {
            state.serialize_entry("multicast", &self.multicast)?;
        }
        if !self.subnet_purposes.is_empty() {
            state.serialize_entry("subnetPurposes", &self.subnet_purposes)?;
        }
        if !self.subnet_stack_types.is_empty() {
            state.serialize_entry("subnetStackTypes", &self.subnet_stack_types)?;
        }
        if !self.subnetwork_purposes.is_empty() {
            state.serialize_entry("subnetworkPurposes", &self.subnetwork_purposes)?;
        }
        if !self.subnetwork_stack_types.is_empty() {
            state.serialize_entry("subnetworkStackTypes", &self.subnetwork_stack_types)?;
        }
        if self.unicast.is_some() {
            state.serialize_entry("unicast", &self.unicast)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkProfileProfileType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network_type.is_some() {
            state.serialize_entry("networkType", &self.network_type)?;
        }
        if self.rdma_subtype.is_some() {
            state.serialize_entry("rdmaSubtype", &self.rdma_subtype)?;
        }
        if self.ull_subtype.is_some() {
            state.serialize_entry("ullSubtype", &self.ull_subtype)?;
        }
        if self.vpc_subtype.is_some() {
            state.serialize_entry("vpcSubtype", &self.vpc_subtype)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkProfilesListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_profiles_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "network-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for super::network_profiles_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkRoutingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bgp_always_compare_med.is_some() {
            state.serialize_entry("bgpAlwaysCompareMed", &self.bgp_always_compare_med)?;
        }
        if self.bgp_best_path_selection_mode.is_some() {
            state.serialize_entry(
                "bgpBestPathSelectionMode",
                &self.bgp_best_path_selection_mode,
            )?;
        }
        if self.bgp_inter_region_cost.is_some() {
            state.serialize_entry("bgpInterRegionCost", &self.bgp_inter_region_cost)?;
        }
        if self.effective_bgp_always_compare_med.is_some() {
            state.serialize_entry(
                "effectiveBgpAlwaysCompareMed",
                &self.effective_bgp_always_compare_med,
            )?;
        }
        if self.effective_bgp_inter_region_cost.is_some() {
            state.serialize_entry(
                "effectiveBgpInterRegionCost",
                &self.effective_bgp_inter_region_cost,
            )?;
        }
        if self.routing_mode.is_some() {
            state.serialize_entry("routingMode", &self.routing_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksAddPeeringRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_create_routes.is_some() {
            state.serialize_entry("autoCreateRoutes", &self.auto_create_routes)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network_peering.is_some() {
            state.serialize_entry("networkPeering", &self.network_peering)?;
        }
        if self.peer_network.is_some() {
            state.serialize_entry("peerNetwork", &self.peer_network)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksGetEffectiveFirewallsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.firewall_policys.is_empty() {
            state.serialize_entry("firewallPolicys", &self.firewall_policys)?;
        }
        if !self.firewalls.is_empty() {
            state.serialize_entry("firewalls", &self.firewalls)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.packet_mirroring_rules.is_empty() {
            state.serialize_entry("packetMirroringRules", &self.packet_mirroring_rules)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksRemovePeeringRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksRequestRemovePeeringRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "networks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NetworksUpdatePeeringRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network_peering.is_some() {
            state.serialize_entry("networkPeering", &self.network_peering)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.autoscaling_policy.is_some() {
            state.serialize_entry("autoscalingPolicy", &self.autoscaling_policy)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.location_hint.is_some() {
            state.serialize_entry("locationHint", &self.location_hint)?;
        }
        if self.maintenance_interval.is_some() {
            state.serialize_entry("maintenanceInterval", &self.maintenance_interval)?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if self.maintenance_window.is_some() {
            state.serialize_entry("maintenanceWindow", &self.maintenance_window)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.node_template.is_some() {
            state.serialize_entry("nodeTemplate", &self.node_template)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.share_settings.is_some() {
            state.serialize_entry("shareSettings", &self.share_settings)?;
        }
        if self.size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_group_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_group_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupAutoscalingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_nodes.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxNodes", &__With(&self.max_nodes))?;
        }
        if self.min_nodes.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodes", &__With(&self.min_nodes))?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_group_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_group_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupMaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.maintenance_duration.is_some() {
            state.serialize_entry("maintenanceDuration", &self.maintenance_duration)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupNode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if self.consumed_resources.is_some() {
            state.serialize_entry("consumedResources", &self.consumed_resources)?;
        }
        if self.cpu_overcommit_type.is_some() {
            state.serialize_entry("cpuOvercommitType", &self.cpu_overcommit_type)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self.instance_consumption_data.is_empty() {
            state.serialize_entry("instanceConsumptionData", &self.instance_consumption_data)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.node_type.is_some() {
            state.serialize_entry("nodeType", &self.node_type)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.server_binding.is_some() {
            state.serialize_entry("serverBinding", &self.server_binding)?;
        }
        if self.server_id.is_some() {
            state.serialize_entry("serverId", &self.server_id)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.total_resources.is_some() {
            state.serialize_entry("totalResources", &self.total_resources)?;
        }
        if self.upcoming_maintenance.is_some() {
            state.serialize_entry("upcomingMaintenance", &self.upcoming_maintenance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsAddNodesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.additional_node_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("additionalNodeCount", &__With(&self.additional_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsDeleteNodesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsListNodes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_groups_list_nodes::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_groups_list_nodes::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsPerformMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_groups.is_empty() {
            state.serialize_entry("nodeGroups", &self.node_groups)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_groups_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_groups_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsSetNodeTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.node_template.is_some() {
            state.serialize_entry("nodeTemplate", &self.node_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeGroupsSimulateMaintenanceEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if self.cpu_overcommit_type.is_some() {
            state.serialize_entry("cpuOvercommitType", &self.cpu_overcommit_type)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.node_affinity_labels.is_empty() {
            state.serialize_entry("nodeAffinityLabels", &self.node_affinity_labels)?;
        }
        if self.node_type.is_some() {
            state.serialize_entry("nodeType", &self.node_type)?;
        }
        if self.node_type_flexibility.is_some() {
            state.serialize_entry("nodeTypeFlexibility", &self.node_type_flexibility)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.server_binding.is_some() {
            state.serialize_entry("serverBinding", &self.server_binding)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_message.is_some() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTemplateAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_template_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_template_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTemplateList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_template_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_template_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTemplateNodeTypeFlexibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cpus.is_some() {
            state.serialize_entry("cpus", &self.cpus)?;
        }
        if self.local_ssd.is_some() {
            state.serialize_entry("localSsd", &self.local_ssd)?;
        }
        if self.memory.is_some() {
            state.serialize_entry("memory", &self.memory)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTemplatesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_templates.is_empty() {
            state.serialize_entry("nodeTemplates", &self.node_templates)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_templates_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-templates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_templates_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cpu_platform.is_some() {
            state.serialize_entry("cpuPlatform", &self.cpu_platform)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.guest_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("guestCpus", &__With(&self.guest_cpus))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.local_ssd_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("localSsdGb", &__With(&self.local_ssd_gb))?;
        }
        if self.max_vms.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxVms", &__With(&self.max_vms))?;
        }
        if self.memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_types.is_empty() {
            state.serialize_entry("nodeTypes", &self.node_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "node-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::node_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-notification-endpoints")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NotificationEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.grpc_settings.is_some() {
            state.serialize_entry("grpcSettings", &self.grpc_settings)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-notification-endpoints")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NotificationEndpointGrpcSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.authority.is_some() {
            state.serialize_entry("authority", &self.authority)?;
        }
        if self.endpoint.is_some() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if self.payload_name.is_some() {
            state.serialize_entry("payloadName", &self.payload_name)?;
        }
        if self.resend_interval.is_some() {
            state.serialize_entry("resendInterval", &self.resend_interval)?;
        }
        if self.retry_duration_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("retryDurationSec", &__With(&self.retry_duration_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-notification-endpoints")]
#[doc(hidden)]
impl serde::ser::Serialize for super::NotificationEndpointList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-notification-endpoints")]
#[doc(hidden)]
impl serde::ser::Serialize for super::notification_endpoint_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-notification-endpoints")]
#[doc(hidden)]
impl serde::ser::Serialize for super::notification_endpoint_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.client_operation_id.is_some() {
            state.serialize_entry("clientOperationId", &self.client_operation_id)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.http_error_message.is_some() {
            state.serialize_entry("httpErrorMessage", &self.http_error_message)?;
        }
        if self.http_error_status_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("httpErrorStatusCode", &__With(&self.http_error_status_code))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.insert_time.is_some() {
            state.serialize_entry("insertTime", &self.insert_time)?;
        }
        if self.instances_bulk_insert_operation_metadata.is_some() {
            state.serialize_entry(
                "instancesBulkInsertOperationMetadata",
                &self.instances_bulk_insert_operation_metadata,
            )?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.operation_group_id.is_some() {
            state.serialize_entry("operationGroupId", &self.operation_group_id)?;
        }
        if self.operation_type.is_some() {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if self.progress.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("progress", &__With(&self.progress))?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self
            .set_common_instance_metadata_operation_metadata
            .is_some()
        {
            state.serialize_entry(
                "setCommonInstanceMetadataOperationMetadata",
                &self.set_common_instance_metadata_operation_metadata,
            )?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_message.is_some() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.target_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetId", &__With(&self.target_id))?;
        }
        if self.target_link.is_some() {
            state.serialize_entry("targetLink", &self.target_link)?;
        }
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::error::Errors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::error::errors::ErrorDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if self.help.is_some() {
            state.serialize_entry("help", &self.help)?;
        }
        if self.localized_message.is_some() {
            state.serialize_entry("localizedMessage", &self.localized_message)?;
        }
        if self.quota_info.is_some() {
            state.serialize_entry("quotaInfo", &self.quota_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::Warnings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::warnings::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::OperationAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::OperationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::OperationsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operations_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operations_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "organization-security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::OrganizationSecurityPoliciesListAssociationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.associations.is_empty() {
            state.serialize_entry("associations", &self.associations)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::OutlierDetection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.base_ejection_time.is_some() {
            state.serialize_entry("baseEjectionTime", &self.base_ejection_time)?;
        }
        if self.consecutive_errors.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("consecutiveErrors", &__With(&self.consecutive_errors))?;
        }
        if self.consecutive_gateway_failure.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "consecutiveGatewayFailure",
                &__With(&self.consecutive_gateway_failure),
            )?;
        }
        if self.enforcing_consecutive_errors.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "enforcingConsecutiveErrors",
                &__With(&self.enforcing_consecutive_errors),
            )?;
        }
        if self.enforcing_consecutive_gateway_failure.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "enforcingConsecutiveGatewayFailure",
                &__With(&self.enforcing_consecutive_gateway_failure),
            )?;
        }
        if self.enforcing_success_rate.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "enforcingSuccessRate",
                &__With(&self.enforcing_success_rate),
            )?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if self.max_ejection_percent.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxEjectionPercent", &__With(&self.max_ejection_percent))?;
        }
        if self.success_rate_minimum_hosts.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "successRateMinimumHosts",
                &__With(&self.success_rate_minimum_hosts),
            )?;
        }
        if self.success_rate_request_volume.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "successRateRequestVolume",
                &__With(&self.success_rate_request_volume),
            )?;
        }
        if self.success_rate_stdev_factor.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "successRateStdevFactor",
                &__With(&self.success_rate_stdev_factor),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketIntervals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.avg_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("avgMs", &__With(&self.avg_ms))?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.max_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxMs", &__With(&self.max_ms))?;
        }
        if self.min_ms.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minMs", &__With(&self.min_ms))?;
        }
        if self.num_intervals.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numIntervals", &__With(&self.num_intervals))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroring {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.collector_ilb.is_some() {
            state.serialize_entry("collectorIlb", &self.collector_ilb)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.mirrored_resources.is_some() {
            state.serialize_entry("mirroredResources", &self.mirrored_resources)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirroring_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirroring_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ip_protocols.is_empty() {
            state.serialize_entry("IPProtocols", &self.ip_protocols)?;
        }
        if !self.cidr_ranges.is_empty() {
            state.serialize_entry("cidrRanges", &self.cidr_ranges)?;
        }
        if self.direction.is_some() {
            state.serialize_entry("direction", &self.direction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringForwardingRuleInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.canonical_url.is_some() {
            state.serialize_entry("canonicalUrl", &self.canonical_url)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirroring_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirroring_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringMirroredResourceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringMirroredResourceInfoInstanceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.canonical_url.is_some() {
            state.serialize_entry("canonicalUrl", &self.canonical_url)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringMirroredResourceInfoSubnetInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.canonical_url.is_some() {
            state.serialize_entry("canonicalUrl", &self.canonical_url)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringNetworkInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.canonical_url.is_some() {
            state.serialize_entry("canonicalUrl", &self.canonical_url)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PacketMirroringsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.packet_mirrorings.is_empty() {
            state.serialize_entry("packetMirrorings", &self.packet_mirrorings)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirrorings_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "packet-mirrorings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::packet_mirrorings_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PathMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.default_custom_error_response_policy.is_some() {
            state.serialize_entry(
                "defaultCustomErrorResponsePolicy",
                &self.default_custom_error_response_policy,
            )?;
        }
        if self.default_route_action.is_some() {
            state.serialize_entry("defaultRouteAction", &self.default_route_action)?;
        }
        if self.default_service.is_some() {
            state.serialize_entry("defaultService", &self.default_service)?;
        }
        if self.default_url_redirect.is_some() {
            state.serialize_entry("defaultUrlRedirect", &self.default_url_redirect)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.header_action.is_some() {
            state.serialize_entry("headerAction", &self.header_action)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.path_rules.is_empty() {
            state.serialize_entry("pathRules", &self.path_rules)?;
        }
        if !self.route_rules.is_empty() {
            state.serialize_entry("routeRules", &self.route_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PathRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_error_response_policy.is_some() {
            state.serialize_entry(
                "customErrorResponsePolicy",
                &self.custom_error_response_policy,
            )?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if self.route_action.is_some() {
            state.serialize_entry("routeAction", &self.route_action)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if self.url_redirect.is_some() {
            state.serialize_entry("urlRedirect", &self.url_redirect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PerInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.preserved_state.is_some() {
            state.serialize_entry("preservedState", &self.preserved_state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "firewall-policies",
    feature = "images",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Policy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audit_configs.is_empty() {
            state.serialize_entry("auditConfigs", &self.audit_configs)?;
        }
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.version.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreconfiguredWafSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.expression_sets.is_empty() {
            state.serialize_entry("expressionSets", &self.expression_sets)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreservedState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self.external_i_ps.is_empty() {
            state.serialize_entry("externalIPs", &self.external_i_ps)?;
        }
        if !self.internal_i_ps.is_empty() {
            state.serialize_entry("internalIPs", &self.internal_i_ps)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreservedStatePreservedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreservedStatePreservedNetworkIp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreservedStatePreservedNetworkIpIpAddress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.address.is_some() {
            state.serialize_entry("address", &self.address)?;
        }
        if self.literal.is_some() {
            state.serialize_entry("literal", &self.literal)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.activation_status.is_some() {
            state.serialize_entry("activationStatus", &self.activation_status)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.rollout_operation.is_some() {
            state.serialize_entry("rolloutOperation", &self.rollout_operation)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeatureList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::preview_feature_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::preview_feature_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeatureRolloutOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rollout_input.is_some() {
            state.serialize_entry("rolloutInput", &self.rollout_input)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeatureRolloutOperationRolloutInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.predefined_rollout_plan.is_some() {
            state.serialize_entry("predefinedRolloutPlan", &self.predefined_rollout_plan)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeatureStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.help_link.is_some() {
            state.serialize_entry("helpLink", &self.help_link)?;
        }
        if self.release_status.is_some() {
            state.serialize_entry("releaseStatus", &self.release_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "preview-features")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PreviewFeatureStatusReleaseStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.stage.is_some() {
            state.serialize_entry("stage", &self.stage)?;
        }
        if self.update_date.is_some() {
            state.serialize_entry("updateDate", &self.update_date)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Project {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_armor_tier.is_some() {
            state.serialize_entry("cloudArmorTier", &self.cloud_armor_tier)?;
        }
        if self.common_instance_metadata.is_some() {
            state.serialize_entry("commonInstanceMetadata", &self.common_instance_metadata)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.default_network_tier.is_some() {
            state.serialize_entry("defaultNetworkTier", &self.default_network_tier)?;
        }
        if self.default_service_account.is_some() {
            state.serialize_entry("defaultServiceAccount", &self.default_service_account)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.enabled_features.is_empty() {
            state.serialize_entry("enabledFeatures", &self.enabled_features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.quotas.is_empty() {
            state.serialize_entry("quotas", &self.quotas)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.usage_export_location.is_some() {
            state.serialize_entry("usageExportLocation", &self.usage_export_location)?;
        }
        if self.vm_dns_setting.is_some() {
            state.serialize_entry("vmDnsSetting", &self.vm_dns_setting)?;
        }
        if self.xpn_project_status.is_some() {
            state.serialize_entry("xpnProjectStatus", &self.xpn_project_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsDisableXpnResourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.xpn_resource.is_some() {
            state.serialize_entry("xpnResource", &self.xpn_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsEnableXpnResourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.xpn_resource.is_some() {
            state.serialize_entry("xpnResource", &self.xpn_resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsGetXpnResources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsListXpnHostsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.organization.is_some() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsSetCloudArmorTierRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cloud_armor_tier.is_some() {
            state.serialize_entry("cloudArmorTier", &self.cloud_armor_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ProjectsSetDefaultNetworkTierRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network_tier.is_some() {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicAdvertisedPrefix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.byoip_api_version.is_some() {
            state.serialize_entry("byoipApiVersion", &self.byoip_api_version)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.dns_verification_ip.is_some() {
            state.serialize_entry("dnsVerificationIp", &self.dns_verification_ip)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.pdp_scope.is_some() {
            state.serialize_entry("pdpScope", &self.pdp_scope)?;
        }
        if !self.public_delegated_prefixs.is_empty() {
            state.serialize_entry("publicDelegatedPrefixs", &self.public_delegated_prefixs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.shared_secret.is_some() {
            state.serialize_entry("sharedSecret", &self.shared_secret)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicAdvertisedPrefixList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_advertised_prefix_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_advertised_prefix_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicAdvertisedPrefixPublicDelegatedPrefix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_range.is_some() {
            state.serialize_entry("ipRange", &self.ip_range)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.project.is_some() {
            state.serialize_entry("project", &self.project)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-public-delegated-prefixes",
    feature = "public-delegated-prefixes",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicDelegatedPrefix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allocatable_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "allocatablePrefixLength",
                &__With(&self.allocatable_prefix_length),
            )?;
        }
        if self.byoip_api_version.is_some() {
            state.serialize_entry("byoipApiVersion", &self.byoip_api_version)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.is_live_migration.is_some() {
            state.serialize_entry("isLiveMigration", &self.is_live_migration)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parent_prefix.is_some() {
            state.serialize_entry("parentPrefix", &self.parent_prefix)?;
        }
        if !self.public_delegated_sub_prefixs.is_empty() {
            state.serialize_entry(
                "publicDelegatedSubPrefixs",
                &self.public_delegated_sub_prefixs,
            )?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicDelegatedPrefixAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefix_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefix_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-public-delegated-prefixes",
    feature = "public-delegated-prefixes",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicDelegatedPrefixList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-public-delegated-prefixes",
    feature = "public-delegated-prefixes",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefix_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-public-delegated-prefixes",
    feature = "public-delegated-prefixes",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefix_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "global-public-delegated-prefixes",
    feature = "public-delegated-prefixes",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicDelegatedPrefixPublicDelegatedSubPrefix {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allocatable_prefix_length.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "allocatablePrefixLength",
                &__With(&self.allocatable_prefix_length),
            )?;
        }
        if self.delegatee_project.is_some() {
            state.serialize_entry("delegateeProject", &self.delegatee_project)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.is_address.is_some() {
            state.serialize_entry("isAddress", &self.is_address)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::PublicDelegatedPrefixesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.public_delegated_prefixes.is_empty() {
            state.serialize_entry("publicDelegatedPrefixes", &self.public_delegated_prefixes)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefixes_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::public_delegated_prefixes_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "projects", feature = "regions",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Quota {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("limit", &__With(&self.limit))?;
        }
        if self.metric.is_some() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if self.owner.is_some() {
            state.serialize_entry("owner", &self.owner)?;
        }
        if self.usage.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("usage", &__With(&self.usage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::QuotaExceededInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.future_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("futureLimit", &__With(&self.future_limit))?;
        }
        if self.limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("limit", &__With(&self.limit))?;
        }
        if self.limit_name.is_some() {
            state.serialize_entry("limitName", &self.limit_name)?;
        }
        if self.metric_name.is_some() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if self.rollout_status.is_some() {
            state.serialize_entry("rolloutStatus", &self.rollout_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Reference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.reference_type.is_some() {
            state.serialize_entry("referenceType", &self.reference_type)?;
        }
        if self.referrer.is_some() {
            state.serialize_entry("referrer", &self.referrer)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Region {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.quota_status_warning.is_some() {
            state.serialize_entry("quotaStatusWarning", &self.quota_status_warning)?;
        }
        if !self.quotas.is_empty() {
            state.serialize_entry("quotas", &self.quotas)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.supports_pzs.is_some() {
            state.serialize_entry("supportsPzs", &self.supports_pzs)?;
        }
        if !self.zones.is_empty() {
            state.serialize_entry("zones", &self.zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region::QuotaStatusWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region::quota_status_warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "addresses")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionAddressesMoveRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.destination_address.is_some() {
            state.serialize_entry("destinationAddress", &self.destination_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionAutoscalerList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_autoscaler_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-autoscalers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_autoscaler_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionDiskTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_disk_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disk-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_disk_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionDisksAddResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionDisksRemoveResourcePoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionDisksResizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-disks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionDisksStartAsyncReplicationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.async_secondary_disk.is_some() {
            state.serialize_entry("asyncSecondaryDisk", &self.async_secondary_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_group_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_group_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagerDeleteInstanceConfigReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagerList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_group_manager_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_group_manager_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagerPatchInstanceConfigReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_instance_configs.is_empty() {
            state.serialize_entry("perInstanceConfigs", &self.per_instance_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagerUpdateInstanceConfigReq {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_instance_configs.is_empty() {
            state.serialize_entry("perInstanceConfigs", &self.per_instance_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersAbandonInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersApplyUpdatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.all_instances.is_some() {
            state.serialize_entry("allInstances", &self.all_instances)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.minimal_action.is_some() {
            state.serialize_entry("minimalAction", &self.minimal_action)?;
        }
        if self.most_disruptive_allowed_action.is_some() {
            state.serialize_entry(
                "mostDisruptiveAllowedAction",
                &self.most_disruptive_allowed_action,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersCreateInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersDeleteInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.skip_instances_on_validation_error.is_some() {
            state.serialize_entry(
                "skipInstancesOnValidationError",
                &self.skip_instances_on_validation_error,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersListErrorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersListInstanceConfigsResp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::region_instance_group_managers_list_instance_configs_resp::Warning
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::region_instance_group_managers_list_instance_configs_resp::warning::Data
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.managed_instances.is_empty() {
            state.serialize_entry("managedInstances", &self.managed_instances)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersRecreateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersResumeInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersSetTargetPoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.target_pools.is_empty() {
            state.serialize_entry("targetPools", &self.target_pools)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersSetTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_template.is_some() {
            state.serialize_entry("instanceTemplate", &self.instance_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersStartInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersStopInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.force_stop.is_some() {
            state.serialize_entry("forceStop", &self.force_stop)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupManagersSuspendInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.force_suspend.is_some() {
            state.serialize_entry("forceSuspend", &self.force_suspend)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupsListInstances {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_groups_list_instances::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_instance_groups_list_instances::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupsListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_state.is_some() {
            state.serialize_entry("instanceState", &self.instance_state)?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionInstanceGroupsSetNamedPortsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.named_ports.is_empty() {
            state.serialize_entry("namedPorts", &self.named_ports)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "regions")]
#[doc(hidden)]
impl serde::ser::Serialize for super::region_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionNetworkEndpointGroupsAttachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-network-endpoint-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionNetworkEndpointGroupsDetachEndpointsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network_endpoints.is_empty() {
            state.serialize_entry("networkEndpoints", &self.network_endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.firewall_policys.is_empty() {
            state.serialize_entry("firewallPolicys", &self.firewall_policys)?;
        }
        if !self.firewalls.is_empty() {
            state.serialize_entry("firewalls", &self.firewalls)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-network-firewall-policies")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.packet_mirroring_rules.is_empty() {
            state.serialize_entry("packetMirroringRules", &self.packet_mirroring_rules)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "forwarding-rules",
    feature = "interconnect-attachments",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-security-policies",
    feature = "target-vpn-gateways",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "network-attachments",
    feature = "node-templates",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "subnetworks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionSetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionTargetHttpsProxiesSetSslCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RegionUrlMapsValidateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::RequestMirrorPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backend_service.is_some() {
            state.serialize_entry("backendService", &self.backend_service)?;
        }
        if self.mirror_percent.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("mirrorPercent", &__With(&self.mirror_percent))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Reservation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.advanced_deployment_control.is_some() {
            state.serialize_entry(
                "advancedDeploymentControl",
                &self.advanced_deployment_control,
            )?;
        }
        if self.aggregate_reservation.is_some() {
            state.serialize_entry("aggregateReservation", &self.aggregate_reservation)?;
        }
        if self.commitment.is_some() {
            state.serialize_entry("commitment", &self.commitment)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.delete_after_duration.is_some() {
            state.serialize_entry("deleteAfterDuration", &self.delete_after_duration)?;
        }
        if self.delete_at_time.is_some() {
            state.serialize_entry("deleteAtTime", &self.delete_at_time)?;
        }
        if self.deployment_type.is_some() {
            state.serialize_entry("deploymentType", &self.deployment_type)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enable_emergent_maintenance.is_some() {
            state.serialize_entry(
                "enableEmergentMaintenance",
                &self.enable_emergent_maintenance,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.linked_commitments.is_empty() {
            state.serialize_entry("linkedCommitments", &self.linked_commitments)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.protection_tier.is_some() {
            state.serialize_entry("protectionTier", &self.protection_tier)?;
        }
        if self.reservation_sharing_policy.is_some() {
            state.serialize_entry("reservationSharingPolicy", &self.reservation_sharing_policy)?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.scheduling_type.is_some() {
            state.serialize_entry("schedulingType", &self.scheduling_type)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.share_settings.is_some() {
            state.serialize_entry("shareSettings", &self.share_settings)?;
        }
        if self.specific_reservation.is_some() {
            state.serialize_entry("specificReservation", &self.specific_reservation)?;
        }
        if self.specific_reservation_required.is_some() {
            state.serialize_entry(
                "specificReservationRequired",
                &self.specific_reservation_required,
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-commitments", feature = "reservations",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationAdvancedDeploymentControl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reservation_operational_mode.is_some() {
            state.serialize_entry(
                "reservationOperationalMode",
                &self.reservation_operational_mode,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consume_reservation_type.is_some() {
            state.serialize_entry("consumeReservationType", &self.consume_reservation_type)?;
        }
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlock {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.health_info.is_some() {
            state.serialize_entry("healthInfo", &self.health_info)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.in_use_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("inUseCount", &__With(&self.in_use_count))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.physical_topology.is_some() {
            state.serialize_entry("physicalTopology", &self.physical_topology)?;
        }
        if self.reservation_maintenance.is_some() {
            state.serialize_entry("reservationMaintenance", &self.reservation_maintenance)?;
        }
        if self.reservation_sub_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "reservationSubBlockCount",
                &__With(&self.reservation_sub_block_count),
            )?;
        }
        if self.reservation_sub_block_in_use_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "reservationSubBlockInUseCount",
                &__With(&self.reservation_sub_block_in_use_count),
            )?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlockHealthInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.degraded_sub_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "degradedSubBlockCount",
                &__With(&self.degraded_sub_block_count),
            )?;
        }
        if self.health_status.is_some() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if self.healthy_sub_block_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "healthySubBlockCount",
                &__With(&self.healthy_sub_block_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlockPhysicalTopology {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.block.is_some() {
            state.serialize_entry("block", &self.block)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlockPhysicalTopologyInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("instanceId", &__With(&self.instance_id))?;
        }
        if self.physical_host_topology.is_some() {
            state.serialize_entry("physicalHostTopology", &self.physical_host_topology)?;
        }
        if self.project_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("projectId", &__With(&self.project_id))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlockPhysicalTopologyInstancePhysicalHostTopology {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.sub_block.is_some() {
            state.serialize_entry("subBlock", &self.sub_block)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlocksGetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationBlocksListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_blocks_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_blocks_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlock {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_topologies_info.is_some() {
            state.serialize_entry(
                "acceleratorTopologiesInfo",
                &self.accelerator_topologies_info,
            )?;
        }
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.health_info.is_some() {
            state.serialize_entry("healthInfo", &self.health_info)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.in_use_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("inUseCount", &__With(&self.in_use_count))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.physical_topology.is_some() {
            state.serialize_entry("physicalTopology", &self.physical_topology)?;
        }
        if self.reservation_sub_block_maintenance.is_some() {
            state.serialize_entry(
                "reservationSubBlockMaintenance",
                &self.reservation_sub_block_maintenance,
            )?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlockHealthInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.degraded_host_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("degradedHostCount", &__With(&self.degraded_host_count))?;
        }
        if self.degraded_infra_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("degradedInfraCount", &__With(&self.degraded_infra_count))?;
        }
        if self.health_status.is_some() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if self.healthy_host_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyHostCount", &__With(&self.healthy_host_count))?;
        }
        if self.healthy_infra_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("healthyInfraCount", &__With(&self.healthy_infra_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlockPhysicalTopology {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.block.is_some() {
            state.serialize_entry("block", &self.block)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.sub_block.is_some() {
            state.serialize_entry("subBlock", &self.sub_block)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlocksGetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlocksListResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_sub_blocks_list_response::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservation_sub_blocks_list_response::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlocksReportFaultyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disruption_schedule.is_some() {
            state.serialize_entry("disruptionSchedule", &self.disruption_schedule)?;
        }
        if self.failure_component.is_some() {
            state.serialize_entry("failureComponent", &self.failure_component)?;
        }
        if !self.fault_reasons.is_empty() {
            state.serialize_entry("faultReasons", &self.fault_reasons)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationSubBlocksReportFaultyRequestFaultReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.behavior.is_some() {
            state.serialize_entry("behavior", &self.behavior)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservation-blocks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationsBlocksPerformMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.maintenance_scope.is_some() {
            state.serialize_entry("maintenanceScope", &self.maintenance_scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationsPerformMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.maintenance_scope.is_some() {
            state.serialize_entry("maintenanceScope", &self.maintenance_scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationsResizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.specific_sku_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("specificSkuCount", &__With(&self.specific_sku_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reservations.is_empty() {
            state.serialize_entry("reservations", &self.reservations)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservations_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "reservations")]
#[doc(hidden)]
impl serde::ser::Serialize for super::reservations_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "region-commitments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceCommitment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_type.is_some() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if self.amount.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("amount", &__With(&self.amount))?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceGroupReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePoliciesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_consistency_group_policy.is_some() {
            state.serialize_entry(
                "diskConsistencyGroupPolicy",
                &self.disk_consistency_group_policy,
            )?;
        }
        if self.group_placement_policy.is_some() {
            state.serialize_entry("groupPlacementPolicy", &self.group_placement_policy)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance_schedule_policy.is_some() {
            state.serialize_entry("instanceSchedulePolicy", &self.instance_schedule_policy)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.snapshot_schedule_policy.is_some() {
            state.serialize_entry("snapshotSchedulePolicy", &self.snapshot_schedule_policy)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.workload_policy.is_some() {
            state.serialize_entry("workloadPolicy", &self.workload_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policy_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policy_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyDailyCycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.days_in_cycle.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("daysInCycle", &__With(&self.days_in_cycle))?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyDiskConsistencyGroupPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyGroupPlacementPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.availability_domain_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "availabilityDomainCount",
                &__With(&self.availability_domain_count),
            )?;
        }
        if self.collocation.is_some() {
            state.serialize_entry("collocation", &self.collocation)?;
        }
        if self.gpu_topology.is_some() {
            state.serialize_entry("gpuTopology", &self.gpu_topology)?;
        }
        if self.vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vmCount", &__With(&self.vm_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyHourlyCycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.hours_in_cycle.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hoursInCycle", &__With(&self.hours_in_cycle))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyInstanceSchedulePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.expiration_time.is_some() {
            state.serialize_entry("expirationTime", &self.expiration_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.time_zone.is_some() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.vm_start_schedule.is_some() {
            state.serialize_entry("vmStartSchedule", &self.vm_start_schedule)?;
        }
        if self.vm_stop_schedule.is_some() {
            state.serialize_entry("vmStopSchedule", &self.vm_stop_schedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyInstanceSchedulePolicySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.schedule.is_some() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::resource_policy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_schedule_policy.is_some() {
            state.serialize_entry("instanceSchedulePolicy", &self.instance_schedule_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_run_start_time.is_some() {
            state.serialize_entry("lastRunStartTime", &self.last_run_start_time)?;
        }
        if self.next_run_start_time.is_some() {
            state.serialize_entry("nextRunStartTime", &self.next_run_start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicySnapshotSchedulePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.retention_policy.is_some() {
            state.serialize_entry("retentionPolicy", &self.retention_policy)?;
        }
        if self.schedule.is_some() {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if self.snapshot_properties.is_some() {
            state.serialize_entry("snapshotProperties", &self.snapshot_properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_retention_days.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxRetentionDays", &__With(&self.max_retention_days))?;
        }
        if self.on_source_disk_delete.is_some() {
            state.serialize_entry("onSourceDiskDelete", &self.on_source_disk_delete)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicySnapshotSchedulePolicySchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.daily_schedule.is_some() {
            state.serialize_entry("dailySchedule", &self.daily_schedule)?;
        }
        if self.hourly_schedule.is_some() {
            state.serialize_entry("hourlySchedule", &self.hourly_schedule)?;
        }
        if self.weekly_schedule.is_some() {
            state.serialize_entry("weeklySchedule", &self.weekly_schedule)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicySnapshotSchedulePolicySnapshotProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.chain_name.is_some() {
            state.serialize_entry("chainName", &self.chain_name)?;
        }
        if self.guest_flush.is_some() {
            state.serialize_entry("guestFlush", &self.guest_flush)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.storage_locations.is_empty() {
            state.serialize_entry("storageLocations", &self.storage_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyWeeklyCycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.day_of_weeks.is_empty() {
            state.serialize_entry("dayOfWeeks", &self.day_of_weeks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyWeeklyCycleDayOfWeek {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.day.is_some() {
            state.serialize_entry("day", &self.day)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "resource-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourcePolicyWorkloadPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.accelerator_topology.is_some() {
            state.serialize_entry("acceleratorTopology", &self.accelerator_topology)?;
        }
        if self.max_topology_distance.is_some() {
            state.serialize_entry("maxTopologyDistance", &self.max_topology_distance)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.effective_instance_metadata.is_some() {
            state.serialize_entry(
                "effectiveInstanceMetadata",
                &self.effective_instance_metadata,
            )?;
        }
        if self.physical_host.is_some() {
            state.serialize_entry("physicalHost", &self.physical_host)?;
        }
        if self.physical_host_topology.is_some() {
            state.serialize_entry("physicalHostTopology", &self.physical_host_topology)?;
        }
        if self.reservation_consumption_info.is_some() {
            state.serialize_entry(
                "reservationConsumptionInfo",
                &self.reservation_consumption_info,
            )?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if self.upcoming_maintenance.is_some() {
            state.serialize_entry("upcomingMaintenance", &self.upcoming_maintenance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceStatusEffectiveInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.block_project_ssh_keys_metadata_value.is_some() {
            state.serialize_entry(
                "blockProjectSshKeysMetadataValue",
                &self.block_project_ssh_keys_metadata_value,
            )?;
        }
        if self.enable_guest_attributes_metadata_value.is_some() {
            state.serialize_entry(
                "enableGuestAttributesMetadataValue",
                &self.enable_guest_attributes_metadata_value,
            )?;
        }
        if self.enable_os_inventory_metadata_value.is_some() {
            state.serialize_entry(
                "enableOsInventoryMetadataValue",
                &self.enable_os_inventory_metadata_value,
            )?;
        }
        if self.enable_osconfig_metadata_value.is_some() {
            state.serialize_entry(
                "enableOsconfigMetadataValue",
                &self.enable_osconfig_metadata_value,
            )?;
        }
        if self.enable_oslogin_metadata_value.is_some() {
            state.serialize_entry(
                "enableOsloginMetadataValue",
                &self.enable_oslogin_metadata_value,
            )?;
        }
        if self.serial_port_enable_metadata_value.is_some() {
            state.serialize_entry(
                "serialPortEnableMetadataValue",
                &self.serial_port_enable_metadata_value,
            )?;
        }
        if self.serial_port_logging_enable_metadata_value.is_some() {
            state.serialize_entry(
                "serialPortLoggingEnableMetadataValue",
                &self.serial_port_logging_enable_metadata_value,
            )?;
        }
        if self.vm_dns_setting_metadata_value.is_some() {
            state.serialize_entry(
                "vmDnsSettingMetadataValue",
                &self.vm_dns_setting_metadata_value,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceStatusPhysicalHostTopology {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.block.is_some() {
            state.serialize_entry("block", &self.block)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.subblock.is_some() {
            state.serialize_entry("subblock", &self.subblock)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceStatusReservationConsumptionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consumed_reservation.is_some() {
            state.serialize_entry("consumedReservation", &self.consumed_reservation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceStatusScheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.availability_domain.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("availabilityDomain", &__With(&self.availability_domain))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "routers", feature = "routes",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Route {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.as_paths.is_empty() {
            state.serialize_entry("asPaths", &self.as_paths)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.dest_range.is_some() {
            state.serialize_entry("destRange", &self.dest_range)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.next_hop_gateway.is_some() {
            state.serialize_entry("nextHopGateway", &self.next_hop_gateway)?;
        }
        if self.next_hop_hub.is_some() {
            state.serialize_entry("nextHopHub", &self.next_hop_hub)?;
        }
        if self.next_hop_ilb.is_some() {
            state.serialize_entry("nextHopIlb", &self.next_hop_ilb)?;
        }
        if self.next_hop_instance.is_some() {
            state.serialize_entry("nextHopInstance", &self.next_hop_instance)?;
        }
        if self.next_hop_inter_region_cost.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "nextHopInterRegionCost",
                &__With(&self.next_hop_inter_region_cost),
            )?;
        }
        if self.next_hop_ip.is_some() {
            state.serialize_entry("nextHopIp", &self.next_hop_ip)?;
        }
        if self.next_hop_med.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("nextHopMed", &__With(&self.next_hop_med))?;
        }
        if self.next_hop_network.is_some() {
            state.serialize_entry("nextHopNetwork", &self.next_hop_network)?;
        }
        if self.next_hop_origin.is_some() {
            state.serialize_entry("nextHopOrigin", &self.next_hop_origin)?;
        }
        if self.next_hop_peering.is_some() {
            state.serialize_entry("nextHopPeering", &self.next_hop_peering)?;
        }
        if self.next_hop_vpn_tunnel.is_some() {
            state.serialize_entry("nextHopVpnTunnel", &self.next_hop_vpn_tunnel)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.route_status.is_some() {
            state.serialize_entry("routeStatus", &self.route_status)?;
        }
        if self.route_type.is_some() {
            state.serialize_entry("routeType", &self.route_type)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "routers", feature = "routes",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::route::Warnings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "routers", feature = "routes",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::route::warnings::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "routers", feature = "routes",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouteAsPath {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.as_lists.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("asLists", &__With(&self.as_lists))?;
        }
        if self.path_segment_type.is_some() {
            state.serialize_entry("pathSegmentType", &self.path_segment_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouteList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::route_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routes")]
#[doc(hidden)]
impl serde::ser::Serialize for super::route_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "routers", feature = "routes",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouteParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.terms.is_empty() {
            state.serialize_entry("terms", &self.terms)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutePolicyPolicyTerm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.actions.is_empty() {
            state.serialize_entry("actions", &self.actions)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Router {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bgp.is_some() {
            state.serialize_entry("bgp", &self.bgp)?;
        }
        if !self.bgp_peers.is_empty() {
            state.serialize_entry("bgpPeers", &self.bgp_peers)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.encrypted_interconnect_router.is_some() {
            state.serialize_entry(
                "encryptedInterconnectRouter",
                &self.encrypted_interconnect_router,
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.interfaces.is_empty() {
            state.serialize_entry("interfaces", &self.interfaces)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.md_5_authentication_keys.is_empty() {
            state.serialize_entry("md5AuthenticationKeys", &self.md_5_authentication_keys)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.nats.is_empty() {
            state.serialize_entry("nats", &self.nats)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterAdvertisedIpRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::router_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::router_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterBgp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.advertise_mode.is_some() {
            state.serialize_entry("advertiseMode", &self.advertise_mode)?;
        }
        if !self.advertised_groups.is_empty() {
            state.serialize_entry("advertisedGroups", &self.advertised_groups)?;
        }
        if !self.advertised_ip_ranges.is_empty() {
            state.serialize_entry("advertisedIpRanges", &self.advertised_ip_ranges)?;
        }
        if self.asn.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("asn", &__With(&self.asn))?;
        }
        if self.identifier_range.is_some() {
            state.serialize_entry("identifierRange", &self.identifier_range)?;
        }
        if self.keepalive_interval.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("keepaliveInterval", &__With(&self.keepalive_interval))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterBgpPeer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.advertise_mode.is_some() {
            state.serialize_entry("advertiseMode", &self.advertise_mode)?;
        }
        if !self.advertised_groups.is_empty() {
            state.serialize_entry("advertisedGroups", &self.advertised_groups)?;
        }
        if !self.advertised_ip_ranges.is_empty() {
            state.serialize_entry("advertisedIpRanges", &self.advertised_ip_ranges)?;
        }
        if self.advertised_route_priority.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "advertisedRoutePriority",
                &__With(&self.advertised_route_priority),
            )?;
        }
        if self.bfd.is_some() {
            state.serialize_entry("bfd", &self.bfd)?;
        }
        if !self.custom_learned_ip_ranges.is_empty() {
            state.serialize_entry("customLearnedIpRanges", &self.custom_learned_ip_ranges)?;
        }
        if self.custom_learned_route_priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "customLearnedRoutePriority",
                &__With(&self.custom_learned_route_priority),
            )?;
        }
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.enable_ipv_4.is_some() {
            state.serialize_entry("enableIpv4", &self.enable_ipv_4)?;
        }
        if self.enable_ipv_6.is_some() {
            state.serialize_entry("enableIpv6", &self.enable_ipv_6)?;
        }
        if !self.export_policies.is_empty() {
            state.serialize_entry("exportPolicies", &self.export_policies)?;
        }
        if !self.import_policies.is_empty() {
            state.serialize_entry("importPolicies", &self.import_policies)?;
        }
        if self.interface_name.is_some() {
            state.serialize_entry("interfaceName", &self.interface_name)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_4_nexthop_address.is_some() {
            state.serialize_entry("ipv4NexthopAddress", &self.ipv_4_nexthop_address)?;
        }
        if self.ipv_6_nexthop_address.is_some() {
            state.serialize_entry("ipv6NexthopAddress", &self.ipv_6_nexthop_address)?;
        }
        if self.management_type.is_some() {
            state.serialize_entry("managementType", &self.management_type)?;
        }
        if self.md_5_authentication_key_name.is_some() {
            state.serialize_entry(
                "md5AuthenticationKeyName",
                &self.md_5_authentication_key_name,
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.peer_asn.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("peerAsn", &__With(&self.peer_asn))?;
        }
        if self.peer_ip_address.is_some() {
            state.serialize_entry("peerIpAddress", &self.peer_ip_address)?;
        }
        if self.peer_ipv_4_nexthop_address.is_some() {
            state.serialize_entry("peerIpv4NexthopAddress", &self.peer_ipv_4_nexthop_address)?;
        }
        if self.peer_ipv_6_nexthop_address.is_some() {
            state.serialize_entry("peerIpv6NexthopAddress", &self.peer_ipv_6_nexthop_address)?;
        }
        if self.router_appliance_instance.is_some() {
            state.serialize_entry("routerApplianceInstance", &self.router_appliance_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterBgpPeerBfd {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_receive_interval.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minReceiveInterval", &__With(&self.min_receive_interval))?;
        }
        if self.min_transmit_interval.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minTransmitInterval", &__With(&self.min_transmit_interval))?;
        }
        if self.multiplier.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("multiplier", &__With(&self.multiplier))?;
        }
        if self.session_initialization_mode.is_some() {
            state.serialize_entry(
                "sessionInitializationMode",
                &self.session_initialization_mode,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterBgpPeerCustomLearnedIpRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.range.is_some() {
            state.serialize_entry("range", &self.range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_range.is_some() {
            state.serialize_entry("ipRange", &self.ip_range)?;
        }
        if self.ip_version.is_some() {
            state.serialize_entry("ipVersion", &self.ip_version)?;
        }
        if self.linked_interconnect_attachment.is_some() {
            state.serialize_entry(
                "linkedInterconnectAttachment",
                &self.linked_interconnect_attachment,
            )?;
        }
        if self.linked_vpn_tunnel.is_some() {
            state.serialize_entry("linkedVpnTunnel", &self.linked_vpn_tunnel)?;
        }
        if self.management_type.is_some() {
            state.serialize_entry("managementType", &self.management_type)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.private_ip_address.is_some() {
            state.serialize_entry("privateIpAddress", &self.private_ip_address)?;
        }
        if self.redundant_interface.is_some() {
            state.serialize_entry("redundantInterface", &self.redundant_interface)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::router_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::router_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterMd5AuthenticationKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_network_tier.is_some() {
            state.serialize_entry("autoNetworkTier", &self.auto_network_tier)?;
        }
        if !self.drain_nat_ips.is_empty() {
            state.serialize_entry("drainNatIps", &self.drain_nat_ips)?;
        }
        if self.enable_dynamic_port_allocation.is_some() {
            state.serialize_entry(
                "enableDynamicPortAllocation",
                &self.enable_dynamic_port_allocation,
            )?;
        }
        if self.enable_endpoint_independent_mapping.is_some() {
            state.serialize_entry(
                "enableEndpointIndependentMapping",
                &self.enable_endpoint_independent_mapping,
            )?;
        }
        if !self.endpoint_types.is_empty() {
            state.serialize_entry("endpointTypes", &self.endpoint_types)?;
        }
        if self.icmp_idle_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("icmpIdleTimeoutSec", &__With(&self.icmp_idle_timeout_sec))?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.max_ports_per_vm.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxPortsPerVm", &__With(&self.max_ports_per_vm))?;
        }
        if self.min_ports_per_vm.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minPortsPerVm", &__With(&self.min_ports_per_vm))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.nat_64_subnetworks.is_empty() {
            state.serialize_entry("nat64Subnetworks", &self.nat_64_subnetworks)?;
        }
        if self.nat_ip_allocate_option.is_some() {
            state.serialize_entry("natIpAllocateOption", &self.nat_ip_allocate_option)?;
        }
        if !self.nat_ips.is_empty() {
            state.serialize_entry("natIps", &self.nat_ips)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.source_subnetwork_ip_ranges_to_nat.is_some() {
            state.serialize_entry(
                "sourceSubnetworkIpRangesToNat",
                &self.source_subnetwork_ip_ranges_to_nat,
            )?;
        }
        if self.source_subnetwork_ip_ranges_to_nat_64.is_some() {
            state.serialize_entry(
                "sourceSubnetworkIpRangesToNat64",
                &self.source_subnetwork_ip_ranges_to_nat_64,
            )?;
        }
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if self.tcp_established_idle_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "tcpEstablishedIdleTimeoutSec",
                &__With(&self.tcp_established_idle_timeout_sec),
            )?;
        }
        if self.tcp_time_wait_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "tcpTimeWaitTimeoutSec",
                &__With(&self.tcp_time_wait_timeout_sec),
            )?;
        }
        if self.tcp_transitory_idle_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "tcpTransitoryIdleTimeoutSec",
                &__With(&self.tcp_transitory_idle_timeout_sec),
            )?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.udp_idle_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("udpIdleTimeoutSec", &__With(&self.udp_idle_timeout_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNatLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNatRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.action.is_some() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.rule_number.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ruleNumber", &__With(&self.rule_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNatRuleAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_nat_active_ips.is_empty() {
            state.serialize_entry("sourceNatActiveIps", &self.source_nat_active_ips)?;
        }
        if !self.source_nat_active_ranges.is_empty() {
            state.serialize_entry("sourceNatActiveRanges", &self.source_nat_active_ranges)?;
        }
        if !self.source_nat_drain_ips.is_empty() {
            state.serialize_entry("sourceNatDrainIps", &self.source_nat_drain_ips)?;
        }
        if !self.source_nat_drain_ranges.is_empty() {
            state.serialize_entry("sourceNatDrainRanges", &self.source_nat_drain_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNatSubnetworkToNat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.secondary_ip_range_names.is_empty() {
            state.serialize_entry("secondaryIpRangeNames", &self.secondary_ip_range_names)?;
        }
        if !self.source_ip_ranges_to_nat.is_empty() {
            state.serialize_entry("sourceIpRangesToNat", &self.source_ip_ranges_to_nat)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterNatSubnetworkToNat64 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.best_routes.is_empty() {
            state.serialize_entry("bestRoutes", &self.best_routes)?;
        }
        if !self.best_routes_for_router.is_empty() {
            state.serialize_entry("bestRoutesForRouter", &self.best_routes_for_router)?;
        }
        if !self.bgp_peer_status.is_empty() {
            state.serialize_entry("bgpPeerStatus", &self.bgp_peer_status)?;
        }
        if !self.nat_status.is_empty() {
            state.serialize_entry("natStatus", &self.nat_status)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterStatusBgpPeerStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.advertised_routes.is_empty() {
            state.serialize_entry("advertisedRoutes", &self.advertised_routes)?;
        }
        if self.bfd_status.is_some() {
            state.serialize_entry("bfdStatus", &self.bfd_status)?;
        }
        if self.enable_ipv_4.is_some() {
            state.serialize_entry("enableIpv4", &self.enable_ipv_4)?;
        }
        if self.enable_ipv_6.is_some() {
            state.serialize_entry("enableIpv6", &self.enable_ipv_6)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_4_nexthop_address.is_some() {
            state.serialize_entry("ipv4NexthopAddress", &self.ipv_4_nexthop_address)?;
        }
        if self.ipv_6_nexthop_address.is_some() {
            state.serialize_entry("ipv6NexthopAddress", &self.ipv_6_nexthop_address)?;
        }
        if self.linked_vpn_tunnel.is_some() {
            state.serialize_entry("linkedVpnTunnel", &self.linked_vpn_tunnel)?;
        }
        if self.md_5_auth_enabled.is_some() {
            state.serialize_entry("md5AuthEnabled", &self.md_5_auth_enabled)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.num_learned_routes.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numLearnedRoutes", &__With(&self.num_learned_routes))?;
        }
        if self.peer_ip_address.is_some() {
            state.serialize_entry("peerIpAddress", &self.peer_ip_address)?;
        }
        if self.peer_ipv_4_nexthop_address.is_some() {
            state.serialize_entry("peerIpv4NexthopAddress", &self.peer_ipv_4_nexthop_address)?;
        }
        if self.peer_ipv_6_nexthop_address.is_some() {
            state.serialize_entry("peerIpv6NexthopAddress", &self.peer_ipv_6_nexthop_address)?;
        }
        if self.router_appliance_instance.is_some() {
            state.serialize_entry("routerApplianceInstance", &self.router_appliance_instance)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_reason.is_some() {
            state.serialize_entry("statusReason", &self.status_reason)?;
        }
        if self.uptime.is_some() {
            state.serialize_entry("uptime", &self.uptime)?;
        }
        if self.uptime_seconds.is_some() {
            state.serialize_entry("uptimeSeconds", &self.uptime_seconds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterStatusNatStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.auto_allocated_nat_ips.is_empty() {
            state.serialize_entry("autoAllocatedNatIps", &self.auto_allocated_nat_ips)?;
        }
        if !self.drain_auto_allocated_nat_ips.is_empty() {
            state.serialize_entry(
                "drainAutoAllocatedNatIps",
                &self.drain_auto_allocated_nat_ips,
            )?;
        }
        if !self.drain_user_allocated_nat_ips.is_empty() {
            state.serialize_entry(
                "drainUserAllocatedNatIps",
                &self.drain_user_allocated_nat_ips,
            )?;
        }
        if self.min_extra_nat_ips_needed.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "minExtraNatIpsNeeded",
                &__With(&self.min_extra_nat_ips_needed),
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.num_vm_endpoints_with_nat_mappings.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numVmEndpointsWithNatMappings",
                &__With(&self.num_vm_endpoints_with_nat_mappings),
            )?;
        }
        if !self.rule_status.is_empty() {
            state.serialize_entry("ruleStatus", &self.rule_status)?;
        }
        if !self.user_allocated_nat_ip_resources.is_empty() {
            state.serialize_entry(
                "userAllocatedNatIpResources",
                &self.user_allocated_nat_ip_resources,
            )?;
        }
        if !self.user_allocated_nat_ips.is_empty() {
            state.serialize_entry("userAllocatedNatIps", &self.user_allocated_nat_ips)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterStatusNatStatusNatRuleStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.active_nat_ips.is_empty() {
            state.serialize_entry("activeNatIps", &self.active_nat_ips)?;
        }
        if !self.drain_nat_ips.is_empty() {
            state.serialize_entry("drainNatIps", &self.drain_nat_ips)?;
        }
        if self.min_extra_ips_needed.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minExtraIpsNeeded", &__With(&self.min_extra_ips_needed))?;
        }
        if self.num_vm_endpoints_with_nat_mappings.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numVmEndpointsWithNatMappings",
                &__With(&self.num_vm_endpoints_with_nat_mappings),
            )?;
        }
        if self.rule_number.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ruleNumber", &__With(&self.rule_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RouterStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutersGetRoutePolicyResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutersListBgpRoutes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.result.is_empty() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_list_bgp_routes::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_list_bgp_routes::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutersListRoutePolicies {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.result.is_empty() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_list_route_policies::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_list_route_policies::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutersPreviewResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::RoutersScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.routers.is_empty() {
            state.serialize_entry("routers", &self.routers)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::routers_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SSLHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SavedAttachedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if self.boot.is_some() {
            state.serialize_entry("boot", &self.boot)?;
        }
        if self.device_name.is_some() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.disk_type.is_some() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.index.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("index", &__With(&self.index))?;
        }
        if self.interface.is_some() {
            state.serialize_entry("interface", &self.interface)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.storage_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("storageBytes", &__With(&self.storage_bytes))?;
        }
        if self.storage_bytes_status.is_some() {
            state.serialize_entry("storageBytesStatus", &self.storage_bytes_status)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SavedDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.storage_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("storageBytes", &__With(&self.storage_bytes))?;
        }
        if self.storage_bytes_status.is_some() {
            state.serialize_entry("storageBytesStatus", &self.storage_bytes_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "autoscalers", feature = "region-autoscalers",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ScalingScheduleStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_start_time.is_some() {
            state.serialize_entry("lastStartTime", &self.last_start_time)?;
        }
        if self.next_start_time.is_some() {
            state.serialize_entry("nextStartTime", &self.next_start_time)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Scheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.automatic_restart.is_some() {
            state.serialize_entry("automaticRestart", &self.automatic_restart)?;
        }
        if self.availability_domain.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("availabilityDomain", &__With(&self.availability_domain))?;
        }
        if self.host_error_timeout_seconds.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "hostErrorTimeoutSeconds",
                &__With(&self.host_error_timeout_seconds),
            )?;
        }
        if self.instance_termination_action.is_some() {
            state.serialize_entry(
                "instanceTerminationAction",
                &self.instance_termination_action,
            )?;
        }
        if self.local_ssd_recovery_timeout.is_some() {
            state.serialize_entry("localSsdRecoveryTimeout", &self.local_ssd_recovery_timeout)?;
        }
        if self.location_hint.is_some() {
            state.serialize_entry("locationHint", &self.location_hint)?;
        }
        if self.max_run_duration.is_some() {
            state.serialize_entry("maxRunDuration", &self.max_run_duration)?;
        }
        if self.min_node_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if self.on_host_maintenance.is_some() {
            state.serialize_entry("onHostMaintenance", &self.on_host_maintenance)?;
        }
        if self.on_instance_stop_action.is_some() {
            state.serialize_entry("onInstanceStopAction", &self.on_instance_stop_action)?;
        }
        if self.preemptible.is_some() {
            state.serialize_entry("preemptible", &self.preemptible)?;
        }
        if self.provisioning_model.is_some() {
            state.serialize_entry("provisioningModel", &self.provisioning_model)?;
        }
        if self.skip_guest_os_shutdown.is_some() {
            state.serialize_entry("skipGuestOsShutdown", &self.skip_guest_os_shutdown)?;
        }
        if self.termination_time.is_some() {
            state.serialize_entry("terminationTime", &self.termination_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SchedulingNodeAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.operator.is_some() {
            state.serialize_entry("operator", &self.operator)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SchedulingOnInstanceStopAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.discard_local_ssd.is_some() {
            state.serialize_entry("discardLocalSsd", &self.discard_local_ssd)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Screenshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.contents.is_some() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPoliciesAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policies_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policies_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPoliciesListPreconfiguredExpressionSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.preconfigured_expression_sets.is_some() {
            state.serialize_entry(
                "preconfiguredExpressionSets",
                &self.preconfigured_expression_sets,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPoliciesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.security_policies.is_empty() {
            state.serialize_entry("securityPolicies", &self.security_policies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "security-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPoliciesWafConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.waf_rules.is_some() {
            state.serialize_entry("wafRules", &self.waf_rules)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.adaptive_protection_config.is_some() {
            state.serialize_entry("adaptiveProtectionConfig", &self.adaptive_protection_config)?;
        }
        if self.advanced_options_config.is_some() {
            state.serialize_entry("advancedOptionsConfig", &self.advanced_options_config)?;
        }
        if !self.associations.is_empty() {
            state.serialize_entry("associations", &self.associations)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.ddos_protection_config.is_some() {
            state.serialize_entry("ddosProtectionConfig", &self.ddos_protection_config)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parent.is_some() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.recaptcha_options_config.is_some() {
            state.serialize_entry("recaptchaOptionsConfig", &self.recaptcha_options_config)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.rules.is_empty() {
            state.serialize_entry("rules", &self.rules)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.user_defined_fields.is_empty() {
            state.serialize_entry("userDefinedFields", &self.user_defined_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyAdaptiveProtectionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.layer_7_ddos_defense_config.is_some() {
            state.serialize_entry("layer7DdosDefenseConfig", &self.layer_7_ddos_defense_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.rule_visibility.is_some() {
            state.serialize_entry("ruleVisibility", &self.rule_visibility)?;
        }
        if !self.threshold_configs.is_empty() {
            state.serialize_entry("thresholdConfigs", &self.threshold_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_deploy_confidence_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "autoDeployConfidenceThreshold",
                &__With(&self.auto_deploy_confidence_threshold),
            )?;
        }
        if self.auto_deploy_expiration_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "autoDeployExpirationSec",
                &__With(&self.auto_deploy_expiration_sec),
            )?;
        }
        if self.auto_deploy_impacted_baseline_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "autoDeployImpactedBaselineThreshold",
                &__With(&self.auto_deploy_impacted_baseline_threshold),
            )?;
        }
        if self.auto_deploy_load_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "autoDeployLoadThreshold",
                &__With(&self.auto_deploy_load_threshold),
            )?;
        }
        if self.detection_absolute_qps.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "detectionAbsoluteQps",
                &__With(&self.detection_absolute_qps),
            )?;
        }
        if self.detection_load_threshold.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "detectionLoadThreshold",
                &__With(&self.detection_load_threshold),
            )?;
        }
        if self.detection_relative_to_baseline_qps.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "detectionRelativeToBaselineQps",
                &__With(&self.detection_relative_to_baseline_qps),
            )?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.traffic_granularity_configs.is_empty() {
            state.serialize_entry(
                "trafficGranularityConfigs",
                &self.traffic_granularity_configs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfigTrafficGranularityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_each_unique_value.is_some() {
            state.serialize_entry("enableEachUniqueValue", &self.enable_each_unique_value)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyAdvancedOptionsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.json_custom_config.is_some() {
            state.serialize_entry("jsonCustomConfig", &self.json_custom_config)?;
        }
        if self.json_parsing.is_some() {
            state.serialize_entry("jsonParsing", &self.json_parsing)?;
        }
        if self.log_level.is_some() {
            state.serialize_entry("logLevel", &self.log_level)?;
        }
        if !self.user_ip_request_headers.is_empty() {
            state.serialize_entry("userIpRequestHeaders", &self.user_ip_request_headers)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content_types.is_empty() {
            state.serialize_entry("contentTypes", &self.content_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyAssociation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attachment_id.is_some() {
            state.serialize_entry("attachmentId", &self.attachment_id)?;
        }
        if self.display_name.is_some() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.excluded_folders.is_empty() {
            state.serialize_entry("excludedFolders", &self.excluded_folders)?;
        }
        if !self.excluded_projects.is_empty() {
            state.serialize_entry("excludedProjects", &self.excluded_projects)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.security_policy_id.is_some() {
            state.serialize_entry("securityPolicyId", &self.security_policy_id)?;
        }
        if self.short_name.is_some() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyDdosProtectionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ddos_protection.is_some() {
            state.serialize_entry("ddosProtection", &self.ddos_protection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::security_policy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRecaptchaOptionsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.redirect_site_key.is_some() {
            state.serialize_entry("redirectSiteKey", &self.redirect_site_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "region-backend-services",
    feature = "target-instances",
    feature = "target-pools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.action.is_some() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.header_action.is_some() {
            state.serialize_entry("headerAction", &self.header_action)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.network_match.is_some() {
            state.serialize_entry("networkMatch", &self.network_match)?;
        }
        if self.preconfigured_waf_config.is_some() {
            state.serialize_entry("preconfiguredWafConfig", &self.preconfigured_waf_config)?;
        }
        if self.preview.is_some() {
            state.serialize_entry("preview", &self.preview)?;
        }
        if self.priority.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if self.rate_limit_options.is_some() {
            state.serialize_entry("rateLimitOptions", &self.rate_limit_options)?;
        }
        if self.redirect_options.is_some() {
            state.serialize_entry("redirectOptions", &self.redirect_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleHttpHeaderAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_headers_to_adds.is_empty() {
            state.serialize_entry("requestHeadersToAdds", &self.request_headers_to_adds)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleHttpHeaderActionHttpHeaderOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.header_name.is_some() {
            state.serialize_entry("headerName", &self.header_name)?;
        }
        if self.header_value.is_some() {
            state.serialize_entry("headerValue", &self.header_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.expr.is_some() {
            state.serialize_entry("expr", &self.expr)?;
        }
        if self.expr_options.is_some() {
            state.serialize_entry("exprOptions", &self.expr_options)?;
        }
        if self.versioned_expr.is_some() {
            state.serialize_entry("versionedExpr", &self.versioned_expr)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleMatcherConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.src_ip_ranges.is_empty() {
            state.serialize_entry("srcIpRanges", &self.src_ip_ranges)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleMatcherExprOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recaptcha_options.is_some() {
            state.serialize_entry("recaptchaOptions", &self.recaptcha_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.action_token_site_keys.is_empty() {
            state.serialize_entry("actionTokenSiteKeys", &self.action_token_site_keys)?;
        }
        if !self.session_token_site_keys.is_empty() {
            state.serialize_entry("sessionTokenSiteKeys", &self.session_token_site_keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleNetworkMatcher {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dest_ip_ranges.is_empty() {
            state.serialize_entry("destIpRanges", &self.dest_ip_ranges)?;
        }
        if !self.dest_ports.is_empty() {
            state.serialize_entry("destPorts", &self.dest_ports)?;
        }
        if !self.ip_protocols.is_empty() {
            state.serialize_entry("ipProtocols", &self.ip_protocols)?;
        }
        if !self.src_asns.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("srcAsns", &__With(&self.src_asns))?;
        }
        if !self.src_ip_ranges.is_empty() {
            state.serialize_entry("srcIpRanges", &self.src_ip_ranges)?;
        }
        if !self.src_ports.is_empty() {
            state.serialize_entry("srcPorts", &self.src_ports)?;
        }
        if !self.src_region_codes.is_empty() {
            state.serialize_entry("srcRegionCodes", &self.src_region_codes)?;
        }
        if !self.user_defined_fields.is_empty() {
            state.serialize_entry("userDefinedFields", &self.user_defined_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRulePreconfiguredWafConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.exclusions.is_empty() {
            state.serialize_entry("exclusions", &self.exclusions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRulePreconfiguredWafConfigExclusion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_cookies_to_exclude.is_empty() {
            state.serialize_entry("requestCookiesToExclude", &self.request_cookies_to_exclude)?;
        }
        if !self.request_headers_to_exclude.is_empty() {
            state.serialize_entry("requestHeadersToExclude", &self.request_headers_to_exclude)?;
        }
        if !self.request_query_params_to_exclude.is_empty() {
            state.serialize_entry(
                "requestQueryParamsToExclude",
                &self.request_query_params_to_exclude,
            )?;
        }
        if !self.request_uris_to_exclude.is_empty() {
            state.serialize_entry("requestUrisToExclude", &self.request_uris_to_exclude)?;
        }
        if !self.target_rule_ids.is_empty() {
            state.serialize_entry("targetRuleIds", &self.target_rule_ids)?;
        }
        if self.target_rule_set.is_some() {
            state.serialize_entry("targetRuleSet", &self.target_rule_set)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.op.is_some() {
            state.serialize_entry("op", &self.op)?;
        }
        if self.val.is_some() {
            state.serialize_entry("val", &self.val)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleRateLimitOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ban_duration_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("banDurationSec", &__With(&self.ban_duration_sec))?;
        }
        if self.ban_threshold.is_some() {
            state.serialize_entry("banThreshold", &self.ban_threshold)?;
        }
        if self.conform_action.is_some() {
            state.serialize_entry("conformAction", &self.conform_action)?;
        }
        if self.enforce_on_key.is_some() {
            state.serialize_entry("enforceOnKey", &self.enforce_on_key)?;
        }
        if !self.enforce_on_key_configs.is_empty() {
            state.serialize_entry("enforceOnKeyConfigs", &self.enforce_on_key_configs)?;
        }
        if self.enforce_on_key_name.is_some() {
            state.serialize_entry("enforceOnKeyName", &self.enforce_on_key_name)?;
        }
        if self.exceed_action.is_some() {
            state.serialize_entry("exceedAction", &self.exceed_action)?;
        }
        if self.exceed_redirect_options.is_some() {
            state.serialize_entry("exceedRedirectOptions", &self.exceed_redirect_options)?;
        }
        if self.rate_limit_threshold.is_some() {
            state.serialize_entry("rateLimitThreshold", &self.rate_limit_threshold)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enforce_on_key_name.is_some() {
            state.serialize_entry("enforceOnKeyName", &self.enforce_on_key_name)?;
        }
        if self.enforce_on_key_type.is_some() {
            state.serialize_entry("enforceOnKeyType", &self.enforce_on_key_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleRateLimitOptionsThreshold {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if self.interval_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("intervalSec", &__With(&self.interval_sec))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyRuleRedirectOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "region-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPolicyUserDefinedField {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.base.is_some() {
            state.serialize_entry("base", &self.base)?;
        }
        if self.mask.is_some() {
            state.serialize_entry("mask", &self.mask)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.offset.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if self.size.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SecuritySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aws_v_4_authentication.is_some() {
            state.serialize_entry("awsV4Authentication", &self.aws_v_4_authentication)?;
        }
        if self.client_tls_policy.is_some() {
            state.serialize_entry("clientTlsPolicy", &self.client_tls_policy)?;
        }
        if !self.subject_alt_names.is_empty() {
            state.serialize_entry("subjectAltNames", &self.subject_alt_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SerialPortOutput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.contents.is_some() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("next", &__With(&self.next))?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.start.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("start", &__With(&self.start))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "node-groups", feature = "node-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServerBinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.email.is_some() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connected_endpoints.is_empty() {
            state.serialize_entry("connectedEndpoints", &self.connected_endpoints)?;
        }
        if self.connection_preference.is_some() {
            state.serialize_entry("connectionPreference", &self.connection_preference)?;
        }
        if !self.consumer_accept_lists.is_empty() {
            state.serialize_entry("consumerAcceptLists", &self.consumer_accept_lists)?;
        }
        if !self.consumer_reject_lists.is_empty() {
            state.serialize_entry("consumerRejectLists", &self.consumer_reject_lists)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.domain_names.is_empty() {
            state.serialize_entry("domainNames", &self.domain_names)?;
        }
        if self.enable_proxy_protocol.is_some() {
            state.serialize_entry("enableProxyProtocol", &self.enable_proxy_protocol)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.nat_subnets.is_empty() {
            state.serialize_entry("natSubnets", &self.nat_subnets)?;
        }
        if self.producer_forwarding_rule.is_some() {
            state.serialize_entry("producerForwardingRule", &self.producer_forwarding_rule)?;
        }
        if self.propagated_connection_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "propagatedConnectionLimit",
                &__With(&self.propagated_connection_limit),
            )?;
        }
        if self.psc_service_attachment_id.is_some() {
            state.serialize_entry("pscServiceAttachmentId", &self.psc_service_attachment_id)?;
        }
        if self.reconcile_connections.is_some() {
            state.serialize_entry("reconcileConnections", &self.reconcile_connections)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.target_service.is_some() {
            state.serialize_entry("targetService", &self.target_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachmentAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachment_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachment_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachmentConnectedEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.consumer_network.is_some() {
            state.serialize_entry("consumerNetwork", &self.consumer_network)?;
        }
        if self.endpoint.is_some() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.nat_ips.is_empty() {
            state.serialize_entry("natIps", &self.nat_ips)?;
        }
        if self.propagated_connection_count.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "propagatedConnectionCount",
                &__With(&self.propagated_connection_count),
            )?;
        }
        if self.psc_connection_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pscConnectionId", &__With(&self.psc_connection_id))?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachmentConsumerProjectLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.connection_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("connectionLimit", &__With(&self.connection_limit))?;
        }
        if self.network_url.is_some() {
            state.serialize_entry("networkUrl", &self.network_url)?;
        }
        if self.project_id_or_num.is_some() {
            state.serialize_entry("projectIdOrNum", &self.project_id_or_num)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachmentList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachment_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachment_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceAttachmentsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_attachments.is_empty() {
            state.serialize_entry("serviceAttachments", &self.service_attachments)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachments_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "service-attachments")]
#[doc(hidden)]
impl serde::ser::Serialize for super::service_attachments_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SetCommonInstanceMetadataOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.client_operation_id.is_some() {
            state.serialize_entry("clientOperationId", &self.client_operation_id)?;
        }
        if !self.per_location_operations.is_empty() {
            state.serialize_entry("perLocationOperations", &self.per_location_operations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "node-groups",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShareSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_map.is_empty() {
            state.serialize_entry("projectMap", &self.project_map)?;
        }
        if self.share_type.is_some() {
            state.serialize_entry("shareType", &self.share_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "future-reservations",
    feature = "node-groups",
    feature = "region-commitments",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShareSettingsProjectConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.project_id.is_some() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_integrity_monitoring.is_some() {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if self.enable_secure_boot.is_some() {
            state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
        }
        if self.enable_vtpm.is_some() {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedInstanceIdentity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ecc_p_256_encryption_key.is_some() {
            state.serialize_entry("eccP256EncryptionKey", &self.ecc_p_256_encryption_key)?;
        }
        if self.ecc_p_256_signing_key.is_some() {
            state.serialize_entry("eccP256SigningKey", &self.ecc_p_256_signing_key)?;
        }
        if self.encryption_key.is_some() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.signing_key.is_some() {
            state.serialize_entry("signingKey", &self.signing_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedInstanceIdentityEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ek_cert.is_some() {
            state.serialize_entry("ekCert", &self.ek_cert)?;
        }
        if self.ek_pub.is_some() {
            state.serialize_entry("ekPub", &self.ek_pub)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedInstanceIntegrityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_auto_learn_policy.is_some() {
            state.serialize_entry("updateAutoLearnPolicy", &self.update_auto_learn_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-buckets", feature = "backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SignedUrlKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key_name.is_some() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if self.key_value.is_some() {
            state.serialize_entry("keyValue", &self.key_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks", feature = "snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Snapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.auto_created.is_some() {
            state.serialize_entry("autoCreated", &self.auto_created)?;
        }
        if self.chain_name.is_some() {
            state.serialize_entry("chainName", &self.chain_name)?;
        }
        if self.creation_size_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("creationSizeBytes", &__With(&self.creation_size_bytes))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.download_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("downloadBytes", &__With(&self.download_bytes))?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if self.guest_flush.is_some() {
            state.serialize_entry("guestFlush", &self.guest_flush)?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.license_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("licenseCodes", &__With(&self.license_codes))?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.location_hint.is_some() {
            state.serialize_entry("locationHint", &self.location_hint)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.snapshot_encryption_key.is_some() {
            state.serialize_entry("snapshotEncryptionKey", &self.snapshot_encryption_key)?;
        }
        if self.snapshot_type.is_some() {
            state.serialize_entry("snapshotType", &self.snapshot_type)?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.source_disk_encryption_key.is_some() {
            state.serialize_entry("sourceDiskEncryptionKey", &self.source_disk_encryption_key)?;
        }
        if self.source_disk_for_recovery_checkpoint.is_some() {
            state.serialize_entry(
                "sourceDiskForRecoveryCheckpoint",
                &self.source_disk_for_recovery_checkpoint,
            )?;
        }
        if self.source_disk_id.is_some() {
            state.serialize_entry("sourceDiskId", &self.source_disk_id)?;
        }
        if self.source_instant_snapshot.is_some() {
            state.serialize_entry("sourceInstantSnapshot", &self.source_instant_snapshot)?;
        }
        if self.source_instant_snapshot_encryption_key.is_some() {
            state.serialize_entry(
                "sourceInstantSnapshotEncryptionKey",
                &self.source_instant_snapshot_encryption_key,
            )?;
        }
        if self.source_instant_snapshot_id.is_some() {
            state.serialize_entry("sourceInstantSnapshotId", &self.source_instant_snapshot_id)?;
        }
        if self.source_snapshot_schedule_policy.is_some() {
            state.serialize_entry(
                "sourceSnapshotSchedulePolicy",
                &self.source_snapshot_schedule_policy,
            )?;
        }
        if self.source_snapshot_schedule_policy_id.is_some() {
            state.serialize_entry(
                "sourceSnapshotSchedulePolicyId",
                &self.source_snapshot_schedule_policy_id,
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.storage_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("storageBytes", &__With(&self.storage_bytes))?;
        }
        if self.storage_bytes_status.is_some() {
            state.serialize_entry("storageBytesStatus", &self.storage_bytes_status)?;
        }
        if !self.storage_locations.is_empty() {
            state.serialize_entry("storageLocations", &self.storage_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SnapshotList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::snapshot_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshots")]
#[doc(hidden)]
impl serde::ser::Serialize for super::snapshot_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "region-disks", feature = "snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SnapshotParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshot-settings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SnapshotSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.storage_location.is_some() {
            state.serialize_entry("storageLocation", &self.storage_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshot-settings")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SnapshotSettingsStorageLocationSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "snapshot-settings")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::SnapshotSettingsStorageLocationSettingsStorageLocationPreference
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SourceDiskEncryptionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disk_encryption_key.is_some() {
            state.serialize_entry("diskEncryptionKey", &self.disk_encryption_key)?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "instance-templates", feature = "region-instance-templates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SourceInstanceParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_configs.is_empty() {
            state.serialize_entry("diskConfigs", &self.disk_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SourceInstanceProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.can_ip_forward.is_some() {
            state.serialize_entry("canIpForward", &self.can_ip_forward)?;
        }
        if self.deletion_protection.is_some() {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self.guest_accelerators.is_empty() {
            state.serialize_entry("guestAccelerators", &self.guest_accelerators)?;
        }
        if self.key_revocation_action_type.is_some() {
            state.serialize_entry("keyRevocationActionType", &self.key_revocation_action_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.machine_type.is_some() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.min_cpu_platform.is_some() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.service_accounts.is_empty() {
            state.serialize_entry("serviceAccounts", &self.service_accounts)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.managed.is_some() {
            state.serialize_entry("managed", &self.managed)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.private_key.is_some() {
            state.serialize_entry("privateKey", &self.private_key)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_managed.is_some() {
            state.serialize_entry("selfManaged", &self.self_managed)?;
        }
        if !self.subject_alternative_names.is_empty() {
            state.serialize_entry("subjectAlternativeNames", &self.subject_alternative_names)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificateAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificate_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificate_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificateList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificate_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificate_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificateManagedSslCertificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domain_status.is_empty() {
            state.serialize_entry("domainStatus", &self.domain_status)?;
        }
        if !self.domains.is_empty() {
            state.serialize_entry("domains", &self.domains)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-certificates", feature = "ssl-certificates",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificateSelfManagedSslCertificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if self.private_key.is_some() {
            state.serialize_entry("privateKey", &self.private_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslCertificatesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificates_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-certificates")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_certificates_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPoliciesAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPoliciesList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPoliciesListAvailableFeaturesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPoliciesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_policies.is_empty() {
            state.serialize_entry("sslPolicies", &self.ssl_policies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "ssl-policies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if !self.custom_features.is_empty() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.enabled_features.is_empty() {
            state.serialize_entry("enabledFeatures", &self.enabled_features)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.min_tls_version.is_some() {
            state.serialize_entry("minTlsVersion", &self.min_tls_version)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.profile.is_some() {
            state.serialize_entry("profile", &self.profile)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policy::Warnings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-ssl-policies", feature = "ssl-policies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ssl_policy::warnings::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "target-https-proxies", feature = "target-ssl-proxies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::SslPolicyReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ssl_policy.is_some() {
            state.serialize_entry("sslPolicy", &self.ssl_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::StatefulPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.preserved_state.is_some() {
            state.serialize_entry("preservedState", &self.preserved_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::StatefulPolicyPreservedState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self.external_i_ps.is_empty() {
            state.serialize_entry("externalIPs", &self.external_i_ps)?;
        }
        if !self.internal_i_ps.is_empty() {
            state.serialize_entry("internalIPs", &self.internal_i_ps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::StatefulPolicyPreservedStateDiskDevice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::StatefulPolicyPreservedStateNetworkIp {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.auto_delete.is_some() {
            state.serialize_entry("autoDelete", &self.auto_delete)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnects",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Status {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("code", &__With(&self.code))?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.capacity_provisioning_type.is_some() {
            state.serialize_entry("capacityProvisioningType", &self.capacity_provisioning_type)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.performance_provisioning_type.is_some() {
            state.serialize_entry(
                "performanceProvisioningType",
                &self.performance_provisioning_type,
            )?;
        }
        if self.pool_provisioned_capacity_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "poolProvisionedCapacityGb",
                &__With(&self.pool_provisioned_capacity_gb),
            )?;
        }
        if self.pool_provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("poolProvisionedIops", &__With(&self.pool_provisioned_iops))?;
        }
        if self.pool_provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "poolProvisionedThroughput",
                &__With(&self.pool_provisioned_throughput),
            )?;
        }
        if self.resource_status.is_some() {
            state.serialize_entry("resourceStatus", &self.resource_status)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.storage_pool_type.is_some() {
            state.serialize_entry("storagePoolType", &self.storage_pool_type)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attached_instances.is_empty() {
            state.serialize_entry("attachedInstances", &self.attached_instances)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.disk.is_some() {
            state.serialize_entry("disk", &self.disk)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("provisionedIops", &__With(&self.provisioned_iops))?;
        }
        if self.provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "provisionedThroughput",
                &__With(&self.provisioned_throughput),
            )?;
        }
        if !self.resource_policies.is_empty() {
            state.serialize_entry("resourcePolicies", &self.resource_policies)?;
        }
        if self.size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.used_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("usedBytes", &__With(&self.used_bytes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolListDisks {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_list_disks::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_list_disks::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolResourceStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.disk_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if self.last_resize_timestamp.is_some() {
            state.serialize_entry("lastResizeTimestamp", &self.last_resize_timestamp)?;
        }
        if self.max_total_provisioned_disk_capacity_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxTotalProvisionedDiskCapacityGb",
                &__With(&self.max_total_provisioned_disk_capacity_gb),
            )?;
        }
        if self.pool_used_capacity_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "poolUsedCapacityBytes",
                &__With(&self.pool_used_capacity_bytes),
            )?;
        }
        if self.pool_used_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("poolUsedIops", &__With(&self.pool_used_iops))?;
        }
        if self.pool_used_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("poolUsedThroughput", &__With(&self.pool_used_throughput))?;
        }
        if self.pool_user_written_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "poolUserWrittenBytes",
                &__With(&self.pool_user_written_bytes),
            )?;
        }
        if self.total_provisioned_disk_capacity_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "totalProvisionedDiskCapacityGb",
                &__With(&self.total_provisioned_disk_capacity_gb),
            )?;
        }
        if self.total_provisioned_disk_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "totalProvisionedDiskIops",
                &__With(&self.total_provisioned_disk_iops),
            )?;
        }
        if self.total_provisioned_disk_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "totalProvisionedDiskThroughput",
                &__With(&self.total_provisioned_disk_throughput),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.max_pool_provisioned_capacity_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxPoolProvisionedCapacityGb",
                &__With(&self.max_pool_provisioned_capacity_gb),
            )?;
        }
        if self.max_pool_provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxPoolProvisionedIops",
                &__With(&self.max_pool_provisioned_iops),
            )?;
        }
        if self.max_pool_provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maxPoolProvisionedThroughput",
                &__With(&self.max_pool_provisioned_throughput),
            )?;
        }
        if self.min_pool_provisioned_capacity_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "minPoolProvisionedCapacityGb",
                &__With(&self.min_pool_provisioned_capacity_gb),
            )?;
        }
        if self.min_pool_provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "minPoolProvisionedIops",
                &__With(&self.min_pool_provisioned_iops),
            )?;
        }
        if self.min_pool_provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "minPoolProvisionedThroughput",
                &__With(&self.min_pool_provisioned_throughput),
            )?;
        }
        if self.min_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minSizeGb", &__With(&self.min_size_gb))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if !self.supported_disk_types.is_empty() {
            state.serialize_entry("supportedDiskTypes", &self.supported_disk_types)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.storage_pool_types.is_empty() {
            state.serialize_entry("storagePoolTypes", &self.storage_pool_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pool-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pool_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::StoragePoolsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pools_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "storage-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::storage_pools_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Subnetwork {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.enable_flow_logs.is_some() {
            state.serialize_entry("enableFlowLogs", &self.enable_flow_logs)?;
        }
        if self.external_ipv_6_prefix.is_some() {
            state.serialize_entry("externalIpv6Prefix", &self.external_ipv_6_prefix)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.gateway_address.is_some() {
            state.serialize_entry("gatewayAddress", &self.gateway_address)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.internal_ipv_6_prefix.is_some() {
            state.serialize_entry("internalIpv6Prefix", &self.internal_ipv_6_prefix)?;
        }
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.ip_collection.is_some() {
            state.serialize_entry("ipCollection", &self.ip_collection)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.ipv_6_cidr_range.is_some() {
            state.serialize_entry("ipv6CidrRange", &self.ipv_6_cidr_range)?;
        }
        if self.ipv_6_gce_endpoint.is_some() {
            state.serialize_entry("ipv6GceEndpoint", &self.ipv_6_gce_endpoint)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.log_config.is_some() {
            state.serialize_entry("logConfig", &self.log_config)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.params.is_some() {
            state.serialize_entry("params", &self.params)?;
        }
        if self.private_ip_google_access.is_some() {
            state.serialize_entry("privateIpGoogleAccess", &self.private_ip_google_access)?;
        }
        if self.private_ipv_6_google_access.is_some() {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv_6_google_access)?;
        }
        if self.purpose.is_some() {
            state.serialize_entry("purpose", &self.purpose)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.reserved_internal_range.is_some() {
            state.serialize_entry("reservedInternalRange", &self.reserved_internal_range)?;
        }
        if self.role.is_some() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.secondary_ip_ranges.is_empty() {
            state.serialize_entry("secondaryIpRanges", &self.secondary_ip_ranges)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.system_reserved_external_ipv_6_ranges.is_empty() {
            state.serialize_entry(
                "systemReservedExternalIpv6Ranges",
                &self.system_reserved_external_ipv_6_ranges,
            )?;
        }
        if !self.system_reserved_internal_ipv_6_ranges.is_empty() {
            state.serialize_entry(
                "systemReservedInternalIpv6Ranges",
                &self.system_reserved_internal_ipv_6_ranges,
            )?;
        }
        if self.utilization_details.is_some() {
            state.serialize_entry("utilizationDetails", &self.utilization_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetwork_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetwork_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetwork_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetwork_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.aggregation_interval.is_some() {
            state.serialize_entry("aggregationInterval", &self.aggregation_interval)?;
        }
        if self.enable.is_some() {
            state.serialize_entry("enable", &self.enable)?;
        }
        if self.filter_expr.is_some() {
            state.serialize_entry("filterExpr", &self.filter_expr)?;
        }
        if self.flow_sampling.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("flowSampling", &__With(&self.flow_sampling))?;
        }
        if self.metadata.is_some() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.metadata_fields.is_empty() {
            state.serialize_entry("metadataFields", &self.metadata_fields)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_manager_tags.is_empty() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkSecondaryRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.range_name.is_some() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if self.reserved_internal_range.is_some() {
            state.serialize_entry("reservedInternalRange", &self.reserved_internal_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkUtilizationDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.external_ipv_6_instance_utilization.is_some() {
            state.serialize_entry(
                "externalIpv6InstanceUtilization",
                &self.external_ipv_6_instance_utilization,
            )?;
        }
        if self.external_ipv_6_lb_utilization.is_some() {
            state.serialize_entry(
                "externalIpv6LbUtilization",
                &self.external_ipv_6_lb_utilization,
            )?;
        }
        if self.internal_ipv_6_utilization.is_some() {
            state.serialize_entry("internalIpv6Utilization", &self.internal_ipv_6_utilization)?;
        }
        if !self.ipv_4_utilizations.is_empty() {
            state.serialize_entry("ipv4Utilizations", &self.ipv_4_utilizations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkUtilizationDetailsIPV4Utilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.range_name.is_some() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if self.total_allocated_ip.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalAllocatedIp", &__With(&self.total_allocated_ip))?;
        }
        if self.total_free_ip.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("totalFreeIp", &__With(&self.total_free_ip))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworkUtilizationDetailsIPV6Utilization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.total_allocated_ip.is_some() {
            state.serialize_entry("totalAllocatedIp", &self.total_allocated_ip)?;
        }
        if self.total_free_ip.is_some() {
            state.serialize_entry("totalFreeIp", &self.total_free_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworksExpandIpCidrRangeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworksScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetworks_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetworks_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworksScopedWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.scope_name.is_some() {
            state.serialize_entry("scopeName", &self.scope_name)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetworks_scoped_warning::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::subnetworks_scoped_warning::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SubnetworksSetPrivateIpGoogleAccessRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.private_ip_google_access.is_some() {
            state.serialize_entry("privateIpGoogleAccess", &self.private_ip_google_access)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "backend-services", feature = "region-backend-services",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Subsetting {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "health-checks", feature = "region-health-checks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TCPHealthCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.port.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.port_name.is_some() {
            state.serialize_entry("portName", &self.port_name)?;
        }
        if self.port_specification.is_some() {
            state.serialize_entry("portSpecification", &self.port_specification)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if self.response.is_some() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instance-templates",
    feature = "instances",
    feature = "machine-images",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Tags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-grpc-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetGrpcProxy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.self_link_with_id.is_some() {
            state.serialize_entry("selfLinkWithId", &self.self_link_with_id)?;
        }
        if self.url_map.is_some() {
            state.serialize_entry("urlMap", &self.url_map)?;
        }
        if self.validate_for_proxyless.is_some() {
            state.serialize_entry("validateForProxyless", &self.validate_for_proxyless)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-grpc-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetGrpcProxyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-grpc-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_grpc_proxy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-grpc-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_grpc_proxy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-http-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpProxiesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_http_proxies.is_empty() {
            state.serialize_entry("targetHttpProxies", &self.target_http_proxies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-http-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_http_proxies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-http-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_http_proxies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-http-proxies",
    feature = "target-http-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpProxy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.http_keep_alive_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "httpKeepAliveTimeoutSec",
                &__With(&self.http_keep_alive_timeout_sec),
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.proxy_bind.is_some() {
            state.serialize_entry("proxyBind", &self.proxy_bind)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.url_map.is_some() {
            state.serialize_entry("urlMap", &self.url_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-http-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpProxyAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-http-proxies",
    feature = "target-http-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpProxyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-http-proxies",
    feature = "target-http-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_http_proxy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-http-proxies",
    feature = "target-http-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_http_proxy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxiesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_https_proxies.is_empty() {
            state.serialize_entry("targetHttpsProxies", &self.target_https_proxies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxiesSetCertificateMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_map.is_some() {
            state.serialize_entry("certificateMap", &self.certificate_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxiesSetQuicOverrideRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.quic_override.is_some() {
            state.serialize_entry("quicOverride", &self.quic_override)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxiesSetSslCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-https-proxies",
    feature = "target-https-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.authorization_policy.is_some() {
            state.serialize_entry("authorizationPolicy", &self.authorization_policy)?;
        }
        if self.certificate_map.is_some() {
            state.serialize_entry("certificateMap", &self.certificate_map)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.http_keep_alive_timeout_sec.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "httpKeepAliveTimeoutSec",
                &__With(&self.http_keep_alive_timeout_sec),
            )?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.proxy_bind.is_some() {
            state.serialize_entry("proxyBind", &self.proxy_bind)?;
        }
        if self.quic_override.is_some() {
            state.serialize_entry("quicOverride", &self.quic_override)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.server_tls_policy.is_some() {
            state.serialize_entry("serverTlsPolicy", &self.server_tls_policy)?;
        }
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if self.ssl_policy.is_some() {
            state.serialize_entry("sslPolicy", &self.ssl_policy)?;
        }
        if self.tls_early_data.is_some() {
            state.serialize_entry("tlsEarlyData", &self.tls_early_data)?;
        }
        if self.url_map.is_some() {
            state.serialize_entry("urlMap", &self.url_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxyAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxy_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-https-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxy_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-https-proxies",
    feature = "target-https-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetHttpsProxyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-https-proxies",
    feature = "target-https-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-https-proxies",
    feature = "target-https-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_https_proxy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetInstance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.nat_policy.is_some() {
            state.serialize_entry("natPolicy", &self.nat_policy)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetInstanceAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instance_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instance_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetInstanceList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instance_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instance_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetInstancesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_instances.is_empty() {
            state.serialize_entry("targetInstances", &self.target_instances)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instances_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-instances")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_instances_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_pool.is_some() {
            state.serialize_entry("backupPool", &self.backup_pool)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.failover_ratio.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("failoverRatio", &__With(&self.failover_ratio))?;
        }
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.security_policy.is_some() {
            state.serialize_entry("securityPolicy", &self.security_policy)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.session_affinity.is_some() {
            state.serialize_entry("sessionAffinity", &self.session_affinity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pool_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pool_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolInstanceHealth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.health_status.is_empty() {
            state.serialize_entry("healthStatus", &self.health_status)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pool_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pool_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolsAddHealthCheckRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolsAddInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolsRemoveHealthCheckRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.health_checks.is_empty() {
            state.serialize_entry("healthChecks", &self.health_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolsRemoveInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetPoolsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_pools.is_empty() {
            state.serialize_entry("targetPools", &self.target_pools)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pools_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-pools")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_pools_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "forwarding-rules",
    feature = "global-forwarding-rules",
    feature = "target-pools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxiesSetBackendServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxiesSetCertificateMapRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_map.is_some() {
            state.serialize_entry("certificateMap", &self.certificate_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxiesSetProxyHeaderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxiesSetSslCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_map.is_some() {
            state.serialize_entry("certificateMap", &self.certificate_map)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.ssl_certificates.is_empty() {
            state.serialize_entry("sslCertificates", &self.ssl_certificates)?;
        }
        if self.ssl_policy.is_some() {
            state.serialize_entry("sslPolicy", &self.ssl_policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetSslProxyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_ssl_proxy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-ssl-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_ssl_proxy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxiesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_tcp_proxies.is_empty() {
            state.serialize_entry("targetTcpProxies", &self.target_tcp_proxies)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxies_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxies_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxiesSetBackendServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxiesSetProxyHeaderRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-target-tcp-proxies", feature = "target-tcp-proxies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.proxy_bind.is_some() {
            state.serialize_entry("proxyBind", &self.proxy_bind)?;
        }
        if self.proxy_header.is_some() {
            state.serialize_entry("proxyHeader", &self.proxy_header)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxyAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxy_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-tcp-proxies")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxy_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-target-tcp-proxies", feature = "target-tcp-proxies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetTcpProxyList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-target-tcp-proxies", feature = "target-tcp-proxies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxy_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-target-tcp-proxies", feature = "target-tcp-proxies",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_tcp_proxy_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetVpnGateway {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.forwarding_rules.is_empty() {
            state.serialize_entry("forwardingRules", &self.forwarding_rules)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.tunnels.is_empty() {
            state.serialize_entry("tunnels", &self.tunnels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetVpnGatewayAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateway_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateway_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetVpnGatewayList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateway_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateway_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TargetVpnGatewaysScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_vpn_gateways.is_empty() {
            state.serialize_entry("targetVpnGateways", &self.target_vpn_gateways)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateways_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "target-vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::target_vpn_gateways_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestFailure {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.actual_output_url.is_some() {
            state.serialize_entry("actualOutputUrl", &self.actual_output_url)?;
        }
        if self.actual_redirect_response_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "actualRedirectResponseCode",
                &__With(&self.actual_redirect_response_code),
            )?;
        }
        if self.actual_service.is_some() {
            state.serialize_entry("actualService", &self.actual_service)?;
        }
        if self.expected_output_url.is_some() {
            state.serialize_entry("expectedOutputUrl", &self.expected_output_url)?;
        }
        if self.expected_redirect_response_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "expectedRedirectResponseCode",
                &__With(&self.expected_redirect_response_code),
            )?;
        }
        if self.expected_service.is_some() {
            state.serialize_entry("expectedService", &self.expected_service)?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "global-addresses",
    feature = "images",
    feature = "instance-groups",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "license-codes",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "packet-mirrorings",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instance-groups",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-instances",
    feature = "target-pools",
    feature = "vpn-gateways",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestPermissionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.permissions.is_empty() {
            state.serialize_entry("permissions", &self.permissions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "addresses",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "global-addresses",
    feature = "images",
    feature = "instance-groups",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-groups",
    feature = "license-codes",
    feature = "licenses",
    feature = "machine-images",
    feature = "network-attachments",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "node-groups",
    feature = "node-templates",
    feature = "packet-mirrorings",
    feature = "region-backend-services",
    feature = "region-disks",
    feature = "region-instance-groups",
    feature = "region-instant-snapshots",
    feature = "region-network-firewall-policies",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "service-attachments",
    feature = "snapshots",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-instances",
    feature = "target-pools",
    feature = "vpn-gateways",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestPermissionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.permissions.is_empty() {
            state.serialize_entry("permissions", &self.permissions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "service-attachments", feature = "subnetworks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Uint128 {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.high.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("high", &__With(&self.high))?;
        }
        if self.low.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("low", &__With(&self.low))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "instances",
    feature = "node-groups",
    feature = "region-commitments",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UpcomingMaintenance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.can_reschedule.is_some() {
            state.serialize_entry("canReschedule", &self.can_reschedule)?;
        }
        if self.latest_window_start_time.is_some() {
            state.serialize_entry("latestWindowStartTime", &self.latest_window_start_time)?;
        }
        if self.maintenance_on_shutdown.is_some() {
            state.serialize_entry("maintenanceOnShutdown", &self.maintenance_on_shutdown)?;
        }
        if !self.maintenance_reasons.is_empty() {
            state.serialize_entry("maintenanceReasons", &self.maintenance_reasons)?;
        }
        if self.maintenance_status.is_some() {
            state.serialize_entry("maintenanceStatus", &self.maintenance_status)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.window_end_time.is_some() {
            state.serialize_entry("windowEndTime", &self.window_end_time)?;
        }
        if self.window_start_time.is_some() {
            state.serialize_entry("windowStartTime", &self.window_start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMap {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.default_custom_error_response_policy.is_some() {
            state.serialize_entry(
                "defaultCustomErrorResponsePolicy",
                &self.default_custom_error_response_policy,
            )?;
        }
        if self.default_route_action.is_some() {
            state.serialize_entry("defaultRouteAction", &self.default_route_action)?;
        }
        if self.default_service.is_some() {
            state.serialize_entry("defaultService", &self.default_service)?;
        }
        if self.default_url_redirect.is_some() {
            state.serialize_entry("defaultUrlRedirect", &self.default_url_redirect)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fingerprint", &__With(&self.fingerprint))?;
        }
        if self.header_action.is_some() {
            state.serialize_entry("headerAction", &self.header_action)?;
        }
        if !self.host_rules.is_empty() {
            state.serialize_entry("hostRules", &self.host_rules)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.path_matchers.is_empty() {
            state.serialize_entry("pathMatchers", &self.path_matchers)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.tests.is_empty() {
            state.serialize_entry("tests", &self.tests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_map_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_map_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.url_map.is_some() {
            state.serialize_entry("urlMap", &self.url_map)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapTest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.expected_output_url.is_some() {
            state.serialize_entry("expectedOutputUrl", &self.expected_output_url)?;
        }
        if self.expected_redirect_response_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "expectedRedirectResponseCode",
                &__With(&self.expected_redirect_response_code),
            )?;
        }
        if !self.headers.is_empty() {
            state.serialize_entry("headers", &self.headers)?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if self.path.is_some() {
            state.serialize_entry("path", &self.path)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapTestHeader {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.load_errors.is_empty() {
            state.serialize_entry("loadErrors", &self.load_errors)?;
        }
        if self.load_succeeded.is_some() {
            state.serialize_entry("loadSucceeded", &self.load_succeeded)?;
        }
        if !self.test_failures.is_empty() {
            state.serialize_entry("testFailures", &self.test_failures)?;
        }
        if self.test_passed.is_some() {
            state.serialize_entry("testPassed", &self.test_passed)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapsAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_maps_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_maps_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.url_maps.is_empty() {
            state.serialize_entry("urlMaps", &self.url_maps)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_maps_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::url_maps_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "url-maps")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapsValidateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.load_balancing_schemes.is_empty() {
            state.serialize_entry("loadBalancingSchemes", &self.load_balancing_schemes)?;
        }
        if self.resource.is_some() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlMapsValidateResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::UrlRewrite {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.host_rewrite.is_some() {
            state.serialize_entry("hostRewrite", &self.host_rewrite)?;
        }
        if self.path_prefix_rewrite.is_some() {
            state.serialize_entry("pathPrefixRewrite", &self.path_prefix_rewrite)?;
        }
        if self.path_template_rewrite.is_some() {
            state.serialize_entry("pathTemplateRewrite", &self.path_template_rewrite)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UsableSubnetwork {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.external_ipv_6_prefix.is_some() {
            state.serialize_entry("externalIpv6Prefix", &self.external_ipv_6_prefix)?;
        }
        if self.internal_ipv_6_prefix.is_some() {
            state.serialize_entry("internalIpv6Prefix", &self.internal_ipv_6_prefix)?;
        }
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.ipv_6_access_type.is_some() {
            state.serialize_entry("ipv6AccessType", &self.ipv_6_access_type)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.purpose.is_some() {
            state.serialize_entry("purpose", &self.purpose)?;
        }
        if self.role.is_some() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.secondary_ip_ranges.is_empty() {
            state.serialize_entry("secondaryIpRanges", &self.secondary_ip_ranges)?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if self.subnetwork.is_some() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UsableSubnetworkSecondaryRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ip_cidr_range.is_some() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if self.range_name.is_some() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UsableSubnetworksAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.scoped_warnings.is_empty() {
            state.serialize_entry("scopedWarnings", &self.scoped_warnings)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::usable_subnetworks_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "subnetworks")]
#[doc(hidden)]
impl serde::ser::Serialize for super::usable_subnetworks_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::UsageExportLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bucket_name.is_some() {
            state.serialize_entry("bucketName", &self.bucket_name)?;
        }
        if self.report_name_prefix.is_some() {
            state.serialize_entry("reportNamePrefix", &self.report_name_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VmEndpointNatMappings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance_name.is_some() {
            state.serialize_entry("instanceName", &self.instance_name)?;
        }
        if !self.interface_nat_mappings.is_empty() {
            state.serialize_entry("interfaceNatMappings", &self.interface_nat_mappings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VmEndpointNatMappingsInterfaceNatMappings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.drain_nat_ip_port_ranges.is_empty() {
            state.serialize_entry("drainNatIpPortRanges", &self.drain_nat_ip_port_ranges)?;
        }
        if !self.nat_ip_port_ranges.is_empty() {
            state.serialize_entry("natIpPortRanges", &self.nat_ip_port_ranges)?;
        }
        if self.num_total_drain_nat_ports.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numTotalDrainNatPorts",
                &__With(&self.num_total_drain_nat_ports),
            )?;
        }
        if self.num_total_nat_ports.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numTotalNatPorts", &__With(&self.num_total_nat_ports))?;
        }
        if !self.rule_mappings.is_empty() {
            state.serialize_entry("ruleMappings", &self.rule_mappings)?;
        }
        if self.source_alias_ip_range.is_some() {
            state.serialize_entry("sourceAliasIpRange", &self.source_alias_ip_range)?;
        }
        if self.source_virtual_ip.is_some() {
            state.serialize_entry("sourceVirtualIp", &self.source_virtual_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.drain_nat_ip_port_ranges.is_empty() {
            state.serialize_entry("drainNatIpPortRanges", &self.drain_nat_ip_port_ranges)?;
        }
        if !self.nat_ip_port_ranges.is_empty() {
            state.serialize_entry("natIpPortRanges", &self.nat_ip_port_ranges)?;
        }
        if self.num_total_drain_nat_ports.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "numTotalDrainNatPorts",
                &__With(&self.num_total_drain_nat_ports),
            )?;
        }
        if self.num_total_nat_ports.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numTotalNatPorts", &__With(&self.num_total_nat_ports))?;
        }
        if self.rule_number.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ruleNumber", &__With(&self.rule_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VmEndpointNatMappingsList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.result.is_empty() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vm_endpoint_nat_mappings_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "routers")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vm_endpoint_nat_mappings_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGateway {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.gateway_ip_version.is_some() {
            state.serialize_entry("gatewayIpVersion", &self.gateway_ip_version)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.network.is_some() {
            state.serialize_entry("network", &self.network)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.stack_type.is_some() {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if !self.vpn_interfaces.is_empty() {
            state.serialize_entry("vpnInterfaces", &self.vpn_interfaces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateway_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateway_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateway_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateway_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpn_connections.is_empty() {
            state.serialize_entry("vpnConnections", &self.vpn_connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayStatusHighAvailabilityRequirementState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if self.unsatisfied_reason.is_some() {
            state.serialize_entry("unsatisfiedReason", &self.unsatisfied_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayStatusTunnel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.local_gateway_interface.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "localGatewayInterface",
                &__With(&self.local_gateway_interface),
            )?;
        }
        if self.peer_gateway_interface.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "peerGatewayInterface",
                &__With(&self.peer_gateway_interface),
            )?;
        }
        if self.tunnel_url.is_some() {
            state.serialize_entry("tunnelUrl", &self.tunnel_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayStatusVpnConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.peer_external_gateway.is_some() {
            state.serialize_entry("peerExternalGateway", &self.peer_external_gateway)?;
        }
        if self.peer_gcp_gateway.is_some() {
            state.serialize_entry("peerGcpGateway", &self.peer_gcp_gateway)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.tunnels.is_empty() {
            state.serialize_entry("tunnels", &self.tunnels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewayVpnGatewayInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.interconnect_attachment.is_some() {
            state.serialize_entry("interconnectAttachment", &self.interconnect_attachment)?;
        }
        if self.ip_address.is_some() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if self.ipv_6_address.is_some() {
            state.serialize_entry("ipv6Address", &self.ipv_6_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewaysGetStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnGatewaysScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpn_gateways.is_empty() {
            state.serialize_entry("vpnGateways", &self.vpn_gateways)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateways_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-gateways")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_gateways_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cipher_suite.is_some() {
            state.serialize_entry("cipherSuite", &self.cipher_suite)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.detailed_status.is_some() {
            state.serialize_entry("detailedStatus", &self.detailed_status)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.ike_version.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ikeVersion", &__With(&self.ike_version))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.local_traffic_selector.is_empty() {
            state.serialize_entry("localTrafficSelector", &self.local_traffic_selector)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.peer_external_gateway.is_some() {
            state.serialize_entry("peerExternalGateway", &self.peer_external_gateway)?;
        }
        if self.peer_external_gateway_interface.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "peerExternalGatewayInterface",
                &__With(&self.peer_external_gateway_interface),
            )?;
        }
        if self.peer_gcp_gateway.is_some() {
            state.serialize_entry("peerGcpGateway", &self.peer_gcp_gateway)?;
        }
        if self.peer_ip.is_some() {
            state.serialize_entry("peerIp", &self.peer_ip)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.remote_traffic_selector.is_empty() {
            state.serialize_entry("remoteTrafficSelector", &self.remote_traffic_selector)?;
        }
        if self.router.is_some() {
            state.serialize_entry("router", &self.router)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.shared_secret.is_some() {
            state.serialize_entry("sharedSecret", &self.shared_secret)?;
        }
        if self.shared_secret_hash.is_some() {
            state.serialize_entry("sharedSecretHash", &self.shared_secret_hash)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.target_vpn_gateway.is_some() {
            state.serialize_entry("targetVpnGateway", &self.target_vpn_gateway)?;
        }
        if self.vpn_gateway.is_some() {
            state.serialize_entry("vpnGateway", &self.vpn_gateway)?;
        }
        if self.vpn_gateway_interface.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vpnGatewayInterface", &__With(&self.vpn_gateway_interface))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnel_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnel_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelCipherSuite {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.phase1.is_some() {
            state.serialize_entry("phase1", &self.phase1)?;
        }
        if self.phase2.is_some() {
            state.serialize_entry("phase2", &self.phase2)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnel_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnel_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelPhase1Algorithms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dh.is_empty() {
            state.serialize_entry("dh", &self.dh)?;
        }
        if !self.encryption.is_empty() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self.integrity.is_empty() {
            state.serialize_entry("integrity", &self.integrity)?;
        }
        if !self.prf.is_empty() {
            state.serialize_entry("prf", &self.prf)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelPhase2Algorithms {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.encryption.is_empty() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self.integrity.is_empty() {
            state.serialize_entry("integrity", &self.integrity)?;
        }
        if !self.pfs.is_empty() {
            state.serialize_entry("pfs", &self.pfs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::VpnTunnelsScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpn_tunnels.is_empty() {
            state.serialize_entry("vpnTunnels", &self.vpn_tunnels)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnels_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "vpn-tunnels")]
#[doc(hidden)]
impl serde::ser::Serialize for super::vpn_tunnels_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WafExpressionSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aliases.is_empty() {
            state.serialize_entry("aliases", &self.aliases)?;
        }
        if !self.expressions.is_empty() {
            state.serialize_entry("expressions", &self.expressions)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "organization-security-policies",
    feature = "security-policies",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WafExpressionSetExpression {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.sensitivity.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sensitivity", &__With(&self.sensitivity))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-url-maps", feature = "url-maps",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::WeightedBackendService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backend_service.is_some() {
            state.serialize_entry("backendService", &self.backend_service)?;
        }
        if self.header_action.is_some() {
            state.serialize_entry("headerAction", &self.header_action)?;
        }
        if self.weight.is_some() {
            struct __With<'a>(&'a std::option::Option<u32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("weight", &__With(&self.weight))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Wire {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if self.label.is_some() {
            state.serialize_entry("label", &self.label)?;
        }
        if self.wire_properties.is_some() {
            state.serialize_entry("wireProperties", &self.wire_properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interconnect.is_some() {
            state.serialize_entry("interconnect", &self.interconnect)?;
        }
        if self.vlan_tag.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vlanTag", &__With(&self.vlan_tag))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_enabled.is_some() {
            state.serialize_entry("adminEnabled", &self.admin_enabled)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.reconciling.is_some() {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.topology.is_some() {
            state.serialize_entry("topology", &self.topology)?;
        }
        if self.wire_properties.is_some() {
            state.serialize_entry("wireProperties", &self.wire_properties)?;
        }
        if !self.wires.is_empty() {
            state.serialize_entry("wires", &self.wires)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroupEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.interconnects.is_empty() {
            state.serialize_entry("interconnects", &self.interconnects)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroupEndpointInterconnect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.interconnect.is_some() {
            state.serialize_entry("interconnect", &self.interconnect)?;
        }
        if !self.vlan_tags.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("vlanTags", &__With(&self.vlan_tags))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroupList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.etag.is_some() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::wire_group_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::wire_group_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroupTopology {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireGroupTopologyEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.city.is_some() {
            state.serialize_entry("city", &self.city)?;
        }
        if self.label.is_some() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "wire-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for super::WireProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bandwidth_allocation.is_some() {
            state.serialize_entry("bandwidthAllocation", &self.bandwidth_allocation)?;
        }
        if self.bandwidth_unmetered.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("bandwidthUnmetered", &__With(&self.bandwidth_unmetered))?;
        }
        if self.fault_response.is_some() {
            state.serialize_entry("faultResponse", &self.fault_response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::XpnHostList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::xpn_host_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::xpn_host_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "projects")]
#[doc(hidden)]
impl serde::ser::Serialize for super::XpnResourceId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-zones", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::Zone {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.available_cpu_platforms.is_empty() {
            state.serialize_entry("availableCpuPlatforms", &self.available_cpu_platforms)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.supports_pzs.is_some() {
            state.serialize_entry("supportsPzs", &self.supports_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-zones", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-zones", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "region-zones", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "disks", feature = "instant-snapshots",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "reservation-blocks", feature = "reservation-sub-blocks",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneSetNestedPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(
    feature = "disks",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "node-groups",
    feature = "reservations",
    feature = "storage-pools",
))]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneSetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
