// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AuditConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audit_log_configs.is_empty() {
            state.serialize_entry("auditLogConfigs", &self.audit_log_configs)?;
        }
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::AuditLogConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.exempted_members.is_empty() {
            state.serialize_entry("exemptedMembers", &self.exempted_members)?;
        }
        if self.log_type.is_some() {
            state.serialize_entry("logType", &self.log_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Binding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self.members.is_empty() {
            state.serialize_entry("members", &self.members)?;
        }
        if self.role.is_some() {
            state.serialize_entry("role", &self.role)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::BulkInsertOperationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.created_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("createdVmCount", &__With(&self.created_vm_count))?;
        }
        if self.deleted_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("deletedVmCount", &__With(&self.deleted_vm_count))?;
        }
        if self.failed_to_create_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "failedToCreateVmCount",
                &__With(&self.failed_to_create_vm_count),
            )?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.target_vm_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetVmCount", &__With(&self.target_vm_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::CustomerEncryptionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kms_key_name.is_some() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.kms_key_service_account.is_some() {
            state.serialize_entry("kmsKeyServiceAccount", &self.kms_key_service_account)?;
        }
        if self.raw_key.is_some() {
            state.serialize_entry("rawKey", &self.raw_key)?;
        }
        if self.rsa_encrypted_key.is_some() {
            state.serialize_entry("rsaEncryptedKey", &self.rsa_encrypted_key)?;
        }
        if self.sha256.is_some() {
            state.serialize_entry("sha256", &self.sha256)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeprecationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.obsolete.is_some() {
            state.serialize_entry("obsolete", &self.obsolete)?;
        }
        if self.replacement.is_some() {
            state.serialize_entry("replacement", &self.replacement)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ErrorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.domain.is_some() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self.metadatas.is_empty() {
            state.serialize_entry("metadatas", &self.metadatas)?;
        }
        if self.reason.is_some() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Expr {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.expression.is_some() {
            state.serialize_entry("expression", &self.expression)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.title.is_some() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::FileContentBuffer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.content.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if self.file_type.is_some() {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalSetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GlobalSetPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::GuestOsFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.r#type.is_some() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Help {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.links.is_empty() {
            state.serialize_entry("links", &self.links)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::HelpLink {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.url.is_some() {
            state.serialize_entry("url", &self.url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.archive_size_bytes.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("archiveSizeBytes", &__With(&self.archive_size_bytes))?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.enable_confidential_compute.is_some() {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if self.family.is_some() {
            state.serialize_entry("family", &self.family)?;
        }
        if !self.guest_os_features.is_empty() {
            state.serialize_entry("guestOsFeatures", &self.guest_os_features)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.image_encryption_key.is_some() {
            state.serialize_entry("imageEncryptionKey", &self.image_encryption_key)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.label_fingerprint.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("labelFingerprint", &__With(&self.label_fingerprint))?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.license_codes.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("licenseCodes", &__With(&self.license_codes))?;
        }
        if !self.licenses.is_empty() {
            state.serialize_entry("licenses", &self.licenses)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.raw_disk.is_some() {
            state.serialize_entry("rawDisk", &self.raw_disk)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.shielded_instance_initial_state.is_some() {
            state.serialize_entry(
                "shieldedInstanceInitialState",
                &self.shielded_instance_initial_state,
            )?;
        }
        if self.source_disk.is_some() {
            state.serialize_entry("sourceDisk", &self.source_disk)?;
        }
        if self.source_disk_encryption_key.is_some() {
            state.serialize_entry("sourceDiskEncryptionKey", &self.source_disk_encryption_key)?;
        }
        if self.source_disk_id.is_some() {
            state.serialize_entry("sourceDiskId", &self.source_disk_id)?;
        }
        if self.source_image.is_some() {
            state.serialize_entry("sourceImage", &self.source_image)?;
        }
        if self.source_image_encryption_key.is_some() {
            state.serialize_entry(
                "sourceImageEncryptionKey",
                &self.source_image_encryption_key,
            )?;
        }
        if self.source_image_id.is_some() {
            state.serialize_entry("sourceImageId", &self.source_image_id)?;
        }
        if self.source_snapshot.is_some() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if self.source_snapshot_encryption_key.is_some() {
            state.serialize_entry(
                "sourceSnapshotEncryptionKey",
                &self.source_snapshot_encryption_key,
            )?;
        }
        if self.source_snapshot_id.is_some() {
            state.serialize_entry("sourceSnapshotId", &self.source_snapshot_id)?;
        }
        if self.source_type.is_some() {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.storage_locations.is_empty() {
            state.serialize_entry("storageLocations", &self.storage_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::image::RawDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.container_type.is_some() {
            state.serialize_entry("containerType", &self.container_type)?;
        }
        if self.sha_1_checksum.is_some() {
            state.serialize_entry("sha1Checksum", &self.sha_1_checksum)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ImageList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::image_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::image_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InitialStateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dbs.is_empty() {
            state.serialize_entry("dbs", &self.dbs)?;
        }
        if !self.dbxs.is_empty() {
            state.serialize_entry("dbxs", &self.dbxs)?;
        }
        if !self.keks.is_empty() {
            state.serialize_entry("keks", &self.keks)?;
        }
        if self.pk.is_some() {
            state.serialize_entry("pk", &self.pk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::InstancesBulkInsertOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.per_location_status.is_empty() {
            state.serialize_entry("perLocationStatus", &self.per_location_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::LocalizedMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.locale.is_some() {
            state.serialize_entry("locale", &self.locale)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.guest_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("guestCpus", &__With(&self.guest_cpus))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.image_space_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("imageSpaceGb", &__With(&self.image_space_gb))?;
        }
        if self.is_shared_cpu.is_some() {
            state.serialize_entry("isSharedCpu", &self.is_shared_cpu)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.maximum_persistent_disks.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisks",
                &__With(&self.maximum_persistent_disks),
            )?;
        }
        if self.maximum_persistent_disks_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisksSizeGb",
                &__With(&self.maximum_persistent_disks_size_gb),
            )?;
        }
        if self.memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type::Accelerators {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.guest_accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "guestAcceleratorCount",
                &__With(&self.guest_accelerator_count),
            )?;
        }
        if self.guest_accelerator_type.is_some() {
            state.serialize_entry("guestAcceleratorType", &self.guest_accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_types.is_empty() {
            state.serialize_entry("machineTypes", &self.machine_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.client_operation_id.is_some() {
            state.serialize_entry("clientOperationId", &self.client_operation_id)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.http_error_message.is_some() {
            state.serialize_entry("httpErrorMessage", &self.http_error_message)?;
        }
        if self.http_error_status_code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("httpErrorStatusCode", &__With(&self.http_error_status_code))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.insert_time.is_some() {
            state.serialize_entry("insertTime", &self.insert_time)?;
        }
        if self.instances_bulk_insert_operation_metadata.is_some() {
            state.serialize_entry(
                "instancesBulkInsertOperationMetadata",
                &self.instances_bulk_insert_operation_metadata,
            )?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.operation_group_id.is_some() {
            state.serialize_entry("operationGroupId", &self.operation_group_id)?;
        }
        if self.operation_type.is_some() {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if self.progress.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("progress", &__With(&self.progress))?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self
            .set_common_instance_metadata_operation_metadata
            .is_some()
        {
            state.serialize_entry(
                "setCommonInstanceMetadataOperationMetadata",
                &self.set_common_instance_metadata_operation_metadata,
            )?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.status_message.is_some() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.target_id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("targetId", &__With(&self.target_id))?;
        }
        if self.target_link.is_some() {
            state.serialize_entry("targetLink", &self.target_link)?;
        }
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::error::Errors {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.error_details.is_empty() {
            state.serialize_entry("errorDetails", &self.error_details)?;
        }
        if self.location.is_some() {
            state.serialize_entry("location", &self.location)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::error::errors::ErrorDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error_info.is_some() {
            state.serialize_entry("errorInfo", &self.error_info)?;
        }
        if self.help.is_some() {
            state.serialize_entry("help", &self.help)?;
        }
        if self.localized_message.is_some() {
            state.serialize_entry("localizedMessage", &self.localized_message)?;
        }
        if self.quota_info.is_some() {
            state.serialize_entry("quotaInfo", &self.quota_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::Warnings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::operation::warnings::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Policy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audit_configs.is_empty() {
            state.serialize_entry("auditConfigs", &self.audit_configs)?;
        }
        if !self.bindings.is_empty() {
            state.serialize_entry("bindings", &self.bindings)?;
        }
        if self.etag.is_some() {
            struct __With<'a>(&'a std::option::Option<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<
                        std::option::Option<
                            serde_with::base64::Base64<serde_with::base64::UrlSafe>,
                        >,
                    >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("etag", &__With(&self.etag))?;
        }
        if self.version.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::QuotaExceededInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.future_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("futureLimit", &__With(&self.future_limit))?;
        }
        if self.limit.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("limit", &__With(&self.limit))?;
        }
        if self.limit_name.is_some() {
            state.serialize_entry("limitName", &self.limit_name)?;
        }
        if self.metric_name.is_some() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if self.rollout_status.is_some() {
            state.serialize_entry("rolloutStatus", &self.rollout_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::SetCommonInstanceMetadataOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.client_operation_id.is_some() {
            state.serialize_entry("clientOperationId", &self.client_operation_id)?;
        }
        if !self.per_location_operations.is_empty() {
            state.serialize_entry("perLocationOperations", &self.per_location_operations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize
    for super::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Status {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("code", &__With(&self.code))?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestPermissionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.permissions.is_empty() {
            state.serialize_entry("permissions", &self.permissions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl serde::ser::Serialize for super::TestPermissionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.permissions.is_empty() {
            state.serialize_entry("permissions", &self.permissions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Zone {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.available_cpu_platforms.is_empty() {
            state.serialize_entry("availableCpuPlatforms", &self.available_cpu_platforms)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.supports_pzs.is_some() {
            state.serialize_entry("supportsPzs", &self.supports_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
