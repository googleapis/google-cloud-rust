// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "accelerator-types",
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disk-types",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "image-family-views",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnect-locations",
    feature = "interconnect-remote-locations",
    feature = "interconnects",
    feature = "license-codes",
    feature = "licenses",
    feature = "machine-images",
    feature = "machine-types",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "network-profiles",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "node-types",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disk-types",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "region-zones",
    feature = "regions",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pool-types",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
    feature = "zones",
))]
use crate::Result;

/// Implements a [AcceleratorTypes](super::stub::AcceleratorTypes) decorator for logging and tracing.
#[cfg(feature = "accelerator-types")]
#[derive(Clone, Debug)]
pub struct AcceleratorTypes<T>
where
    T: super::stub::AcceleratorTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "accelerator-types")]
impl<T> AcceleratorTypes<T>
where
    T: super::stub::AcceleratorTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "accelerator-types")]
impl<T> super::stub::AcceleratorTypes for AcceleratorTypes<T>
where
    T: super::stub::AcceleratorTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::accelerator_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::accelerator_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::accelerator_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Addresses](super::stub::Addresses) decorator for logging and tracing.
#[cfg(feature = "addresses")]
#[derive(Clone, Debug)]
pub struct Addresses<T>
where
    T: super::stub::Addresses + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "addresses")]
impl<T> Addresses<T>
where
    T: super::stub::Addresses + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "addresses")]
impl<T> super::stub::Addresses for Addresses<T>
where
    T: super::stub::Addresses + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::addresses::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::addresses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::addresses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Address>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::addresses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::addresses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn r#move(
        &self,
        req: crate::model::addresses::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.r#move(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::addresses::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::addresses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Autoscalers](super::stub::Autoscalers) decorator for logging and tracing.
#[cfg(feature = "autoscalers")]
#[derive(Clone, Debug)]
pub struct Autoscalers<T>
where
    T: super::stub::Autoscalers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "autoscalers")]
impl<T> Autoscalers<T>
where
    T: super::stub::Autoscalers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "autoscalers")]
impl<T> super::stub::Autoscalers for Autoscalers<T>
where
    T: super::stub::Autoscalers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::autoscalers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalerAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::autoscalers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::autoscalers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Autoscaler>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::autoscalers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::autoscalers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::autoscalers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::autoscalers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [BackendBuckets](super::stub::BackendBuckets) decorator for logging and tracing.
#[cfg(feature = "backend-buckets")]
#[derive(Clone, Debug)]
pub struct BackendBuckets<T>
where
    T: super::stub::BackendBuckets + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "backend-buckets")]
impl<T> BackendBuckets<T>
where
    T: super::stub::BackendBuckets + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "backend-buckets")]
impl<T> super::stub::BackendBuckets for BackendBuckets<T>
where
    T: super::stub::BackendBuckets + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_signed_url_key(
        &self,
        req: crate::model::backend_buckets::AddSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_signed_url_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::backend_buckets::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_signed_url_key(
        &self,
        req: crate::model::backend_buckets::DeleteSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_signed_url_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::backend_buckets::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendBucket>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::backend_buckets::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::backend_buckets::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::backend_buckets::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendBucketList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::backend_buckets::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_edge_security_policy(
        &self,
        req: crate::model::backend_buckets::SetEdgeSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_edge_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::backend_buckets::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::backend_buckets::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::backend_buckets::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [BackendServices](super::stub::BackendServices) decorator for logging and tracing.
#[cfg(feature = "backend-services")]
#[derive(Clone, Debug)]
pub struct BackendServices<T>
where
    T: super::stub::BackendServices + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "backend-services")]
impl<T> BackendServices<T>
where
    T: super::stub::BackendServices + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "backend-services")]
impl<T> super::stub::BackendServices for BackendServices<T>
where
    T: super::stub::BackendServices + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_signed_url_key(
        &self,
        req: crate::model::backend_services::AddSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_signed_url_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::backend_services::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::backend_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_signed_url_key(
        &self,
        req: crate::model::backend_services::DeleteSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_signed_url_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::backend_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendService>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_effective_security_policies(
        &self,
        req: crate::model::backend_services::GetEffectiveSecurityPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner
            .get_effective_security_policies(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_health(
        &self,
        req: crate::model::backend_services::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceGroupHealth>> {
        self.inner.get_health(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::backend_services::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::backend_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::backend_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_usable(
        &self,
        req: crate::model::backend_services::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceListUsable>> {
        self.inner.list_usable(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::backend_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_edge_security_policy(
        &self,
        req: crate::model::backend_services::SetEdgeSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_edge_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::backend_services::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::backend_services::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::backend_services::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::backend_services::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [CrossSiteNetworks](super::stub::CrossSiteNetworks) decorator for logging and tracing.
#[cfg(feature = "cross-site-networks")]
#[derive(Clone, Debug)]
pub struct CrossSiteNetworks<T>
where
    T: super::stub::CrossSiteNetworks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "cross-site-networks")]
impl<T> CrossSiteNetworks<T>
where
    T: super::stub::CrossSiteNetworks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "cross-site-networks")]
impl<T> super::stub::CrossSiteNetworks for CrossSiteNetworks<T>
where
    T: super::stub::CrossSiteNetworks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::cross_site_networks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::cross_site_networks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CrossSiteNetwork>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::cross_site_networks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::cross_site_networks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CrossSiteNetworkList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::cross_site_networks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [DiskTypes](super::stub::DiskTypes) decorator for logging and tracing.
#[cfg(feature = "disk-types")]
#[derive(Clone, Debug)]
pub struct DiskTypes<T>
where
    T: super::stub::DiskTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "disk-types")]
impl<T> DiskTypes<T>
where
    T: super::stub::DiskTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "disk-types")]
impl<T> super::stub::DiskTypes for DiskTypes<T>
where
    T: super::stub::DiskTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::disk_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::disk_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::disk_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Disks](super::stub::Disks) decorator for logging and tracing.
#[cfg(feature = "disks")]
#[derive(Clone, Debug)]
pub struct Disks<T>
where
    T: super::stub::Disks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "disks")]
impl<T> Disks<T>
where
    T: super::stub::Disks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "disks")]
impl<T> super::stub::Disks for Disks<T>
where
    T: super::stub::Disks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_resource_policies(
        &self,
        req: crate::model::disks::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::disks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::disks::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn bulk_set_labels(
        &self,
        req: crate::model::disks::BulkSetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_snapshot(
        &self,
        req: crate::model::disks::CreateSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_snapshot(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::disks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::disks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Disk>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::disks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::disks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::disks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_resource_policies(
        &self,
        req: crate::model::disks::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::disks::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::disks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::disks::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_async_replication(
        &self,
        req: crate::model::disks::StartAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_async_replication(
        &self,
        req: crate::model::disks::StopAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_group_async_replication(
        &self,
        req: crate::model::disks::StopGroupAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_group_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::disks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::disks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ExternalVpnGateways](super::stub::ExternalVpnGateways) decorator for logging and tracing.
#[cfg(feature = "external-vpn-gateways")]
#[derive(Clone, Debug)]
pub struct ExternalVpnGateways<T>
where
    T: super::stub::ExternalVpnGateways + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "external-vpn-gateways")]
impl<T> ExternalVpnGateways<T>
where
    T: super::stub::ExternalVpnGateways + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "external-vpn-gateways")]
impl<T> super::stub::ExternalVpnGateways for ExternalVpnGateways<T>
where
    T: super::stub::ExternalVpnGateways + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::external_vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::external_vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExternalVpnGateway>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::external_vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::external_vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExternalVpnGatewayList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::external_vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::external_vpn_gateways::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FirewallPolicies](super::stub::FirewallPolicies) decorator for logging and tracing.
#[cfg(feature = "firewall-policies")]
#[derive(Clone, Debug)]
pub struct FirewallPolicies<T>
where
    T: super::stub::FirewallPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "firewall-policies")]
impl<T> FirewallPolicies<T>
where
    T: super::stub::FirewallPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "firewall-policies")]
impl<T> super::stub::FirewallPolicies for FirewallPolicies<T>
where
    T: super::stub::FirewallPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_association(
        &self,
        req: crate::model::firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn clone_rules(
        &self,
        req: crate::model::firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.clone_rules(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_association(
        &self,
        req: crate::model::firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        self.inner.get_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_associations(
        &self,
        req: crate::model::firewall_policies::ListAssociationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPoliciesListAssociationsResponse>>
    {
        self.inner.list_associations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn r#move(
        &self,
        req: crate::model::firewall_policies::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.r#move(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_association(
        &self,
        req: crate::model::firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Firewalls](super::stub::Firewalls) decorator for logging and tracing.
#[cfg(feature = "firewalls")]
#[derive(Clone, Debug)]
pub struct Firewalls<T>
where
    T: super::stub::Firewalls + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "firewalls")]
impl<T> Firewalls<T>
where
    T: super::stub::Firewalls + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "firewalls")]
impl<T> super::stub::Firewalls for Firewalls<T>
where
    T: super::stub::Firewalls + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::firewalls::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::firewalls::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Firewall>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::firewalls::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::firewalls::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::firewalls::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::firewalls::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ForwardingRules](super::stub::ForwardingRules) decorator for logging and tracing.
#[cfg(feature = "forwarding-rules")]
#[derive(Clone, Debug)]
pub struct ForwardingRules<T>
where
    T: super::stub::ForwardingRules + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "forwarding-rules")]
impl<T> ForwardingRules<T>
where
    T: super::stub::ForwardingRules + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "forwarding-rules")]
impl<T> super::stub::ForwardingRules for ForwardingRules<T>
where
    T: super::stub::ForwardingRules + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::forwarding_rules::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::forwarding_rules::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::forwarding_rules::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRule>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::forwarding_rules::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::forwarding_rules::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::forwarding_rules::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::forwarding_rules::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target(
        &self,
        req: crate::model::forwarding_rules::SetTargetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [FutureReservations](super::stub::FutureReservations) decorator for logging and tracing.
#[cfg(feature = "future-reservations")]
#[derive(Clone, Debug)]
pub struct FutureReservations<T>
where
    T: super::stub::FutureReservations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "future-reservations")]
impl<T> FutureReservations<T>
where
    T: super::stub::FutureReservations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "future-reservations")]
impl<T> super::stub::FutureReservations for FutureReservations<T>
where
    T: super::stub::FutureReservations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::future_reservations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservationsAggregatedListResponse>>
    {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel(
        &self,
        req: crate::model::future_reservations::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.cancel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::future_reservations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::future_reservations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::future_reservations::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::future_reservations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservationsListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::future_reservations::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GlobalAddresses](super::stub::GlobalAddresses) decorator for logging and tracing.
#[cfg(feature = "global-addresses")]
#[derive(Clone, Debug)]
pub struct GlobalAddresses<T>
where
    T: super::stub::GlobalAddresses + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-addresses")]
impl<T> GlobalAddresses<T>
where
    T: super::stub::GlobalAddresses + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-addresses")]
impl<T> super::stub::GlobalAddresses for GlobalAddresses<T>
where
    T: super::stub::GlobalAddresses + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_addresses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_addresses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Address>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::global_addresses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_addresses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn r#move(
        &self,
        req: crate::model::global_addresses::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.r#move(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::global_addresses::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::global_addresses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GlobalForwardingRules](super::stub::GlobalForwardingRules) decorator for logging and tracing.
#[cfg(feature = "global-forwarding-rules")]
#[derive(Clone, Debug)]
pub struct GlobalForwardingRules<T>
where
    T: super::stub::GlobalForwardingRules + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-forwarding-rules")]
impl<T> GlobalForwardingRules<T>
where
    T: super::stub::GlobalForwardingRules + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-forwarding-rules")]
impl<T> super::stub::GlobalForwardingRules for GlobalForwardingRules<T>
where
    T: super::stub::GlobalForwardingRules + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_forwarding_rules::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_forwarding_rules::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRule>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::global_forwarding_rules::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_forwarding_rules::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::global_forwarding_rules::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::global_forwarding_rules::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target(
        &self,
        req: crate::model::global_forwarding_rules::SetTargetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GlobalNetworkEndpointGroups](super::stub::GlobalNetworkEndpointGroups) decorator for logging and tracing.
#[cfg(feature = "global-network-endpoint-groups")]
#[derive(Clone, Debug)]
pub struct GlobalNetworkEndpointGroups<T>
where
    T: super::stub::GlobalNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-network-endpoint-groups")]
impl<T> GlobalNetworkEndpointGroups<T>
where
    T: super::stub::GlobalNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-network-endpoint-groups")]
impl<T> super::stub::GlobalNetworkEndpointGroups for GlobalNetworkEndpointGroups<T>
where
    T: super::stub::GlobalNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn attach_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.attach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn detach_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.detach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::global_network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        self.inner.list_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [GlobalOperations](super::stub::GlobalOperations) decorator for logging and tracing.
#[cfg(feature = "global-operations")]
#[derive(Clone, Debug)]
pub struct GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-operations")]
impl<T> GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-operations")]
impl<T> super::stub::GlobalOperations for GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::global_operations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::global_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [GlobalOrganizationOperations](super::stub::GlobalOrganizationOperations) decorator for logging and tracing.
#[cfg(feature = "global-organization-operations")]
#[derive(Clone, Debug)]
pub struct GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-organization-operations")]
impl<T> GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-organization-operations")]
impl<T> super::stub::GlobalOrganizationOperations for GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_organization_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_organization_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [GlobalPublicDelegatedPrefixes](super::stub::GlobalPublicDelegatedPrefixes) decorator for logging and tracing.
#[cfg(feature = "global-public-delegated-prefixes")]
#[derive(Clone, Debug)]
pub struct GlobalPublicDelegatedPrefixes<T>
where
    T: super::stub::GlobalPublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl<T> GlobalPublicDelegatedPrefixes<T>
where
    T: super::stub::GlobalPublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl<T> super::stub::GlobalPublicDelegatedPrefixes for GlobalPublicDelegatedPrefixes<T>
where
    T: super::stub::GlobalPublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_public_delegated_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_public_delegated_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefix>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::global_public_delegated_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_public_delegated_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::global_public_delegated_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [HealthChecks](super::stub::HealthChecks) decorator for logging and tracing.
#[cfg(feature = "health-checks")]
#[derive(Clone, Debug)]
pub struct HealthChecks<T>
where
    T: super::stub::HealthChecks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "health-checks")]
impl<T> HealthChecks<T>
where
    T: super::stub::HealthChecks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "health-checks")]
impl<T> super::stub::HealthChecks for HealthChecks<T>
where
    T: super::stub::HealthChecks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::health_checks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthChecksAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheck>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [HttpHealthChecks](super::stub::HttpHealthChecks) decorator for logging and tracing.
#[cfg(feature = "http-health-checks")]
#[derive(Clone, Debug)]
pub struct HttpHealthChecks<T>
where
    T: super::stub::HttpHealthChecks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "http-health-checks")]
impl<T> HttpHealthChecks<T>
where
    T: super::stub::HttpHealthChecks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "http-health-checks")]
impl<T> super::stub::HttpHealthChecks for HttpHealthChecks<T>
where
    T: super::stub::HttpHealthChecks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::http_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::http_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpHealthCheck>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::http_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::http_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpHealthCheckList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::http_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::http_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [HttpsHealthChecks](super::stub::HttpsHealthChecks) decorator for logging and tracing.
#[cfg(feature = "https-health-checks")]
#[derive(Clone, Debug)]
pub struct HttpsHealthChecks<T>
where
    T: super::stub::HttpsHealthChecks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "https-health-checks")]
impl<T> HttpsHealthChecks<T>
where
    T: super::stub::HttpsHealthChecks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "https-health-checks")]
impl<T> super::stub::HttpsHealthChecks for HttpsHealthChecks<T>
where
    T: super::stub::HttpsHealthChecks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::https_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::https_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpsHealthCheck>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::https_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::https_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpsHealthCheckList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::https_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::https_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ImageFamilyViews](super::stub::ImageFamilyViews) decorator for logging and tracing.
#[cfg(feature = "image-family-views")]
#[derive(Clone, Debug)]
pub struct ImageFamilyViews<T>
where
    T: super::stub::ImageFamilyViews + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "image-family-views")]
impl<T> ImageFamilyViews<T>
where
    T: super::stub::ImageFamilyViews + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "image-family-views")]
impl<T> super::stub::ImageFamilyViews for ImageFamilyViews<T>
where
    T: super::stub::ImageFamilyViews + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::image_family_views::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageFamilyView>> {
        self.inner.get(req, options).await
    }
}

/// Implements a [Images](super::stub::Images) decorator for logging and tracing.
#[cfg(feature = "images")]
#[derive(Clone, Debug)]
pub struct Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "images")]
impl<T> Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "images")]
impl<T> super::stub::Images for Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deprecate(
        &self,
        req: crate::model::images::DeprecateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.deprecate(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_from_family(
        &self,
        req: crate::model::images::GetFromFamilyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        self.inner.get_from_family(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::images::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstanceGroupManagerResizeRequests](super::stub::InstanceGroupManagerResizeRequests) decorator for logging and tracing.
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl<T> InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl<T> super::stub::InstanceGroupManagerResizeRequests for InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn cancel(
        &self,
        req: crate::model::instance_group_manager_resize_requests::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.cancel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_group_manager_resize_requests::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_group_manager_resize_requests::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequest>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_group_manager_resize_requests::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_group_manager_resize_requests::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequestsListResponse>>
    {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstanceGroupManagers](super::stub::InstanceGroupManagers) decorator for logging and tracing.
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-group-managers")]
impl<T> InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-group-managers")]
impl<T> super::stub::InstanceGroupManagers for InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn abandon_instances(
        &self,
        req: crate::model::instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.abandon_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instance_group_managers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn apply_updates_to_instances(
        &self,
        req: crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.apply_updates_to_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_instances(
        &self,
        req: crate::model::instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_instances(
        &self,
        req: crate::model::instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_errors(
        &self,
        req: crate::model::instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagersListErrorsResponse>>
    {
        self.inner.list_errors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_managed_instances(
        &self,
        req: crate::model::instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListManagedInstancesResponse>,
    > {
        self.inner.list_managed_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListPerInstanceConfigsResp>,
    > {
        self.inner.list_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recreate_instances(
        &self,
        req: crate::model::instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.recreate_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_instances(
        &self,
        req: crate::model::instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_instance_template(
        &self,
        req: crate::model::instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_instance_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target_pools(
        &self,
        req: crate::model::instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target_pools(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_instances(
        &self,
        req: crate::model::instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_instances(
        &self,
        req: crate::model::instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend_instances(
        &self,
        req: crate::model::instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstanceGroups](super::stub::InstanceGroups) decorator for logging and tracing.
#[cfg(feature = "instance-groups")]
#[derive(Clone, Debug)]
pub struct InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-groups")]
impl<T> InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-groups")]
impl<T> super::stub::InstanceGroups for InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_instances(
        &self,
        req: crate::model::instance_groups::AddInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instance_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_instances(
        &self,
        req: crate::model::instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupsListInstances>> {
        self.inner.list_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_instances(
        &self,
        req: crate::model::instance_groups::RemoveInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_named_ports(
        &self,
        req: crate::model::instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_named_ports(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstanceSettings](super::stub::InstanceSettings) decorator for logging and tracing.
#[cfg(feature = "instance-settings")]
#[derive(Clone, Debug)]
pub struct InstanceSettings<T>
where
    T: super::stub::InstanceSettings + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-settings")]
impl<T> InstanceSettings<T>
where
    T: super::stub::InstanceSettings + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-settings")]
impl<T> super::stub::InstanceSettings for InstanceSettings<T>
where
    T: super::stub::InstanceSettings + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_settings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceSettings>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::instance_settings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstanceTemplates](super::stub::InstanceTemplates) decorator for logging and tracing.
#[cfg(feature = "instance-templates")]
#[derive(Clone, Debug)]
pub struct InstanceTemplates<T>
where
    T: super::stub::InstanceTemplates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-templates")]
impl<T> InstanceTemplates<T>
where
    T: super::stub::InstanceTemplates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-templates")]
impl<T> super::stub::InstanceTemplates for InstanceTemplates<T>
where
    T: super::stub::InstanceTemplates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instance_templates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::instance_templates::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::instance_templates::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_templates::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Instances](super::stub::Instances) decorator for logging and tracing.
#[cfg(feature = "instances")]
#[derive(Clone, Debug)]
pub struct Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instances")]
impl<T> Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instances")]
impl<T> super::stub::Instances for Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_access_config(
        &self,
        req: crate::model::instances::AddAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_network_interface(
        &self,
        req: crate::model::instances::AddNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_resource_policies(
        &self,
        req: crate::model::instances::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn attach_disk(
        &self,
        req: crate::model::instances::AttachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.attach_disk(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_access_config(
        &self,
        req: crate::model::instances::DeleteAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_network_interface(
        &self,
        req: crate::model::instances::DeleteNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn detach_disk(
        &self,
        req: crate::model::instances::DetachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.detach_disk(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_effective_firewalls(
        &self,
        req: crate::model::instances::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesGetEffectiveFirewallsResponse>> {
        self.inner.get_effective_firewalls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_guest_attributes(
        &self,
        req: crate::model::instances::GetGuestAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GuestAttributes>> {
        self.inner.get_guest_attributes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::instances::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_screenshot(
        &self,
        req: crate::model::instances::GetScreenshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Screenshot>> {
        self.inner.get_screenshot(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_serial_port_output(
        &self,
        req: crate::model::instances::GetSerialPortOutputRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SerialPortOutput>> {
        self.inner.get_serial_port_output(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_shielded_instance_identity(
        &self,
        req: crate::model::instances::GetShieldedInstanceIdentityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ShieldedInstanceIdentity>> {
        self.inner
            .get_shielded_instance_identity(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_referrers(
        &self,
        req: crate::model::instances::ListReferrersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceListReferrers>> {
        self.inner.list_referrers(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::instances::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_resource_policies(
        &self,
        req: crate::model::instances::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn report_host_as_faulty(
        &self,
        req: crate::model::instances::ReportHostAsFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.report_host_as_faulty(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn reset(
        &self,
        req: crate::model::instances::ResetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume(
        &self,
        req: crate::model::instances::ResumeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn send_diagnostic_interrupt(
        &self,
        req: crate::model::instances::SendDiagnosticInterruptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.send_diagnostic_interrupt(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_deletion_protection(
        &self,
        req: crate::model::instances::SetDeletionProtectionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_deletion_protection(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_disk_auto_delete(
        &self,
        req: crate::model::instances::SetDiskAutoDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_disk_auto_delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::instances::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::instances::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_machine_resources(
        &self,
        req: crate::model::instances::SetMachineResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_machine_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_machine_type(
        &self,
        req: crate::model::instances::SetMachineTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_machine_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_metadata(
        &self,
        req: crate::model::instances::SetMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_metadata(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_min_cpu_platform(
        &self,
        req: crate::model::instances::SetMinCpuPlatformRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_min_cpu_platform(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_name(
        &self,
        req: crate::model::instances::SetNameRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_name(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_scheduling(
        &self,
        req: crate::model::instances::SetSchedulingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_scheduling(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_service_account(
        &self,
        req: crate::model::instances::SetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_service_account(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_shielded_instance_integrity_policy(
        &self,
        req: crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner
            .set_shielded_instance_integrity_policy(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn set_tags(
        &self,
        req: crate::model::instances::SetTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_tags(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn simulate_maintenance_event(
        &self,
        req: crate::model::instances::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.simulate_maintenance_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start(
        &self,
        req: crate::model::instances::StartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_with_encryption_key(
        &self,
        req: crate::model::instances::StartWithEncryptionKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_with_encryption_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop(
        &self,
        req: crate::model::instances::StopRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend(
        &self,
        req: crate::model::instances::SuspendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::instances::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_access_config(
        &self,
        req: crate::model::instances::UpdateAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_display_device(
        &self,
        req: crate::model::instances::UpdateDisplayDeviceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_display_device(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_network_interface(
        &self,
        req: crate::model::instances::UpdateNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_shielded_instance_config(
        &self,
        req: crate::model::instances::UpdateShieldedInstanceConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner
            .update_shielded_instance_config(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InstantSnapshots](super::stub::InstantSnapshots) decorator for logging and tracing.
#[cfg(feature = "instant-snapshots")]
#[derive(Clone, Debug)]
pub struct InstantSnapshots<T>
where
    T: super::stub::InstantSnapshots + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instant-snapshots")]
impl<T> InstantSnapshots<T>
where
    T: super::stub::InstantSnapshots + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instant-snapshots")]
impl<T> super::stub::InstantSnapshots for InstantSnapshots<T>
where
    T: super::stub::InstantSnapshots + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instant_snapshots::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instant_snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instant_snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshot>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::instant_snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instant_snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instant_snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::instant_snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::instant_snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instant_snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InterconnectAttachmentGroups](super::stub::InterconnectAttachmentGroups) decorator for logging and tracing.
#[cfg(feature = "interconnect-attachment-groups")]
#[derive(Clone, Debug)]
pub struct InterconnectAttachmentGroups<T>
where
    T: super::stub::InterconnectAttachmentGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnect-attachment-groups")]
impl<T> InterconnectAttachmentGroups<T>
where
    T: super::stub::InterconnectAttachmentGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
impl<T> super::stub::InterconnectAttachmentGroups for InterconnectAttachmentGroups<T>
where
    T: super::stub::InterconnectAttachmentGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::interconnect_attachment_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnect_attachment_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::interconnect_attachment_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operational_status(
        &self,
        req: crate::model::interconnect_attachment_groups::GetOperationalStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::InterconnectAttachmentGroupsGetOperationalStatusResponse,
        >,
    > {
        self.inner.get_operational_status(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::interconnect_attachment_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnect_attachment_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentGroupsListResponse>>
    {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::interconnect_attachment_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::interconnect_attachment_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::interconnect_attachment_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InterconnectAttachments](super::stub::InterconnectAttachments) decorator for logging and tracing.
#[cfg(feature = "interconnect-attachments")]
#[derive(Clone, Debug)]
pub struct InterconnectAttachments<T>
where
    T: super::stub::InterconnectAttachments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnect-attachments")]
impl<T> InterconnectAttachments<T>
where
    T: super::stub::InterconnectAttachments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnect-attachments")]
impl<T> super::stub::InterconnectAttachments for InterconnectAttachments<T>
where
    T: super::stub::InterconnectAttachments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::interconnect_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::interconnect_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnect_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachment>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::interconnect_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnect_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::interconnect_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::interconnect_attachments::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InterconnectGroups](super::stub::InterconnectGroups) decorator for logging and tracing.
#[cfg(feature = "interconnect-groups")]
#[derive(Clone, Debug)]
pub struct InterconnectGroups<T>
where
    T: super::stub::InterconnectGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnect-groups")]
impl<T> InterconnectGroups<T>
where
    T: super::stub::InterconnectGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnect-groups")]
impl<T> super::stub::InterconnectGroups for InterconnectGroups<T>
where
    T: super::stub::InterconnectGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_members(
        &self,
        req: crate::model::interconnect_groups::CreateMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_members(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::interconnect_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnect_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::interconnect_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operational_status(
        &self,
        req: crate::model::interconnect_groups::GetOperationalStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroupsGetOperationalStatusResponse>>
    {
        self.inner.get_operational_status(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::interconnect_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnect_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroupsListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::interconnect_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::interconnect_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::interconnect_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [InterconnectLocations](super::stub::InterconnectLocations) decorator for logging and tracing.
#[cfg(feature = "interconnect-locations")]
#[derive(Clone, Debug)]
pub struct InterconnectLocations<T>
where
    T: super::stub::InterconnectLocations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnect-locations")]
impl<T> InterconnectLocations<T>
where
    T: super::stub::InterconnectLocations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnect-locations")]
impl<T> super::stub::InterconnectLocations for InterconnectLocations<T>
where
    T: super::stub::InterconnectLocations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnect_locations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectLocation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnect_locations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectLocationList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [InterconnectRemoteLocations](super::stub::InterconnectRemoteLocations) decorator for logging and tracing.
#[cfg(feature = "interconnect-remote-locations")]
#[derive(Clone, Debug)]
pub struct InterconnectRemoteLocations<T>
where
    T: super::stub::InterconnectRemoteLocations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnect-remote-locations")]
impl<T> InterconnectRemoteLocations<T>
where
    T: super::stub::InterconnectRemoteLocations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnect-remote-locations")]
impl<T> super::stub::InterconnectRemoteLocations for InterconnectRemoteLocations<T>
where
    T: super::stub::InterconnectRemoteLocations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnect_remote_locations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectRemoteLocation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnect_remote_locations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectRemoteLocationList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Interconnects](super::stub::Interconnects) decorator for logging and tracing.
#[cfg(feature = "interconnects")]
#[derive(Clone, Debug)]
pub struct Interconnects<T>
where
    T: super::stub::Interconnects + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "interconnects")]
impl<T> Interconnects<T>
where
    T: super::stub::Interconnects + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "interconnects")]
impl<T> super::stub::Interconnects for Interconnects<T>
where
    T: super::stub::Interconnects + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::interconnects::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::interconnects::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Interconnect>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_diagnostics(
        &self,
        req: crate::model::interconnects::GetDiagnosticsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectsGetDiagnosticsResponse>> {
        self.inner.get_diagnostics(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_macsec_config(
        &self,
        req: crate::model::interconnects::GetMacsecConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectsGetMacsecConfigResponse>> {
        self.inner.get_macsec_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::interconnects::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::interconnects::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::interconnects::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::interconnects::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [LicenseCodes](super::stub::LicenseCodes) decorator for logging and tracing.
#[cfg(feature = "license-codes")]
#[derive(Clone, Debug)]
pub struct LicenseCodes<T>
where
    T: super::stub::LicenseCodes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "license-codes")]
impl<T> LicenseCodes<T>
where
    T: super::stub::LicenseCodes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "license-codes")]
impl<T> super::stub::LicenseCodes for LicenseCodes<T>
where
    T: super::stub::LicenseCodes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::license_codes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LicenseCode>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::license_codes::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
}

/// Implements a [Licenses](super::stub::Licenses) decorator for logging and tracing.
#[cfg(feature = "licenses")]
#[derive(Clone, Debug)]
pub struct Licenses<T>
where
    T: super::stub::Licenses + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "licenses")]
impl<T> Licenses<T>
where
    T: super::stub::Licenses + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "licenses")]
impl<T> super::stub::Licenses for Licenses<T>
where
    T: super::stub::Licenses + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::licenses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::licenses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::License>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::licenses::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::licenses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::licenses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LicensesListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::licenses::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::licenses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::licenses::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [MachineImages](super::stub::MachineImages) decorator for logging and tracing.
#[cfg(feature = "machine-images")]
#[derive(Clone, Debug)]
pub struct MachineImages<T>
where
    T: super::stub::MachineImages + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "machine-images")]
impl<T> MachineImages<T>
where
    T: super::stub::MachineImages + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "machine-images")]
impl<T> super::stub::MachineImages for MachineImages<T>
where
    T: super::stub::MachineImages + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::machine_images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::machine_images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineImage>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::machine_images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::machine_images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::machine_images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineImageList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::machine_images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::machine_images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::machine_images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [MachineTypes](super::stub::MachineTypes) decorator for logging and tracing.
#[cfg(feature = "machine-types")]
#[derive(Clone, Debug)]
pub struct MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "machine-types")]
impl<T> MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "machine-types")]
impl<T> super::stub::MachineTypes for MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::machine_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::machine_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::machine_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [NetworkAttachments](super::stub::NetworkAttachments) decorator for logging and tracing.
#[cfg(feature = "network-attachments")]
#[derive(Clone, Debug)]
pub struct NetworkAttachments<T>
where
    T: super::stub::NetworkAttachments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "network-attachments")]
impl<T> NetworkAttachments<T>
where
    T: super::stub::NetworkAttachments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "network-attachments")]
impl<T> super::stub::NetworkAttachments for NetworkAttachments<T>
where
    T: super::stub::NetworkAttachments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::network_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachmentAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::network_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::network_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachment>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::network_attachments::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::network_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::network_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachmentList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::network_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::network_attachments::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::network_attachments::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NetworkEdgeSecurityServices](super::stub::NetworkEdgeSecurityServices) decorator for logging and tracing.
#[cfg(feature = "network-edge-security-services")]
#[derive(Clone, Debug)]
pub struct NetworkEdgeSecurityServices<T>
where
    T: super::stub::NetworkEdgeSecurityServices + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "network-edge-security-services")]
impl<T> NetworkEdgeSecurityServices<T>
where
    T: super::stub::NetworkEdgeSecurityServices + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "network-edge-security-services")]
impl<T> super::stub::NetworkEdgeSecurityServices for NetworkEdgeSecurityServices<T>
where
    T: super::stub::NetworkEdgeSecurityServices + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::network_edge_security_services::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEdgeSecurityServiceAggregatedList>>
    {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::network_edge_security_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::network_edge_security_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEdgeSecurityService>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::network_edge_security_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::network_edge_security_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NetworkEndpointGroups](super::stub::NetworkEndpointGroups) decorator for logging and tracing.
#[cfg(feature = "network-endpoint-groups")]
#[derive(Clone, Debug)]
pub struct NetworkEndpointGroups<T>
where
    T: super::stub::NetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "network-endpoint-groups")]
impl<T> NetworkEndpointGroups<T>
where
    T: super::stub::NetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "network-endpoint-groups")]
impl<T> super::stub::NetworkEndpointGroups for NetworkEndpointGroups<T>
where
    T: super::stub::NetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::network_endpoint_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn attach_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.attach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn detach_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.detach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        self.inner.list_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::network_endpoint_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NetworkFirewallPolicies](super::stub::NetworkFirewallPolicies) decorator for logging and tracing.
#[cfg(feature = "network-firewall-policies")]
#[derive(Clone, Debug)]
pub struct NetworkFirewallPolicies<T>
where
    T: super::stub::NetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "network-firewall-policies")]
impl<T> NetworkFirewallPolicies<T>
where
    T: super::stub::NetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "network-firewall-policies")]
impl<T> super::stub::NetworkFirewallPolicies for NetworkFirewallPolicies<T>
where
    T: super::stub::NetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_association(
        &self,
        req: crate::model::network_firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::AddPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_packet_mirroring_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::network_firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::network_firewall_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkFirewallPolicyAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn clone_rules(
        &self,
        req: crate::model::network_firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.clone_rules(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::network_firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::network_firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_association(
        &self,
        req: crate::model::network_firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        self.inner.get_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::network_firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::GetPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        self.inner.get_packet_mirroring_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::network_firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::network_firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::network_firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::network_firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::PatchPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_packet_mirroring_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::network_firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_association(
        &self,
        req: crate::model::network_firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::RemovePacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_packet_mirroring_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::network_firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::network_firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::network_firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NetworkProfiles](super::stub::NetworkProfiles) decorator for logging and tracing.
#[cfg(feature = "network-profiles")]
#[derive(Clone, Debug)]
pub struct NetworkProfiles<T>
where
    T: super::stub::NetworkProfiles + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "network-profiles")]
impl<T> NetworkProfiles<T>
where
    T: super::stub::NetworkProfiles + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "network-profiles")]
impl<T> super::stub::NetworkProfiles for NetworkProfiles<T>
where
    T: super::stub::NetworkProfiles + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::network_profiles::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkProfile>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::network_profiles::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkProfilesListResponse>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Networks](super::stub::Networks) decorator for logging and tracing.
#[cfg(feature = "networks")]
#[derive(Clone, Debug)]
pub struct Networks<T>
where
    T: super::stub::Networks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "networks")]
impl<T> Networks<T>
where
    T: super::stub::Networks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "networks")]
impl<T> super::stub::Networks for Networks<T>
where
    T: super::stub::Networks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_peering(
        &self,
        req: crate::model::networks::AddPeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_peering(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::networks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::networks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Network>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_effective_firewalls(
        &self,
        req: crate::model::networks::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworksGetEffectiveFirewallsResponse>> {
        self.inner.get_effective_firewalls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::networks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::networks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_peering_routes(
        &self,
        req: crate::model::networks::ListPeeringRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExchangedPeeringRoutesList>> {
        self.inner.list_peering_routes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::networks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_peering(
        &self,
        req: crate::model::networks::RemovePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_peering(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn request_remove_peering(
        &self,
        req: crate::model::networks::RequestRemovePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.request_remove_peering(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn switch_to_custom_mode(
        &self,
        req: crate::model::networks::SwitchToCustomModeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.switch_to_custom_mode(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_peering(
        &self,
        req: crate::model::networks::UpdatePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_peering(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NodeGroups](super::stub::NodeGroups) decorator for logging and tracing.
#[cfg(feature = "node-groups")]
#[derive(Clone, Debug)]
pub struct NodeGroups<T>
where
    T: super::stub::NodeGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "node-groups")]
impl<T> NodeGroups<T>
where
    T: super::stub::NodeGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "node-groups")]
impl<T> super::stub::NodeGroups for NodeGroups<T>
where
    T: super::stub::NodeGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_nodes(
        &self,
        req: crate::model::node_groups::AddNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_nodes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::node_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::node_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_nodes(
        &self,
        req: crate::model::node_groups::DeleteNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_nodes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::node_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::node_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::node_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::node_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_nodes(
        &self,
        req: crate::model::node_groups::ListNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupsListNodes>> {
        self.inner.list_nodes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::node_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::node_groups::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::node_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_node_template(
        &self,
        req: crate::model::node_groups::SetNodeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_node_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn simulate_maintenance_event(
        &self,
        req: crate::model::node_groups::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.simulate_maintenance_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::node_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NodeTemplates](super::stub::NodeTemplates) decorator for logging and tracing.
#[cfg(feature = "node-templates")]
#[derive(Clone, Debug)]
pub struct NodeTemplates<T>
where
    T: super::stub::NodeTemplates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "node-templates")]
impl<T> NodeTemplates<T>
where
    T: super::stub::NodeTemplates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "node-templates")]
impl<T> super::stub::NodeTemplates for NodeTemplates<T>
where
    T: super::stub::NodeTemplates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::node_templates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplateAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::node_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::node_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::node_templates::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::node_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::node_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplateList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::node_templates::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::node_templates::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NodeTypes](super::stub::NodeTypes) decorator for logging and tracing.
#[cfg(feature = "node-types")]
#[derive(Clone, Debug)]
pub struct NodeTypes<T>
where
    T: super::stub::NodeTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "node-types")]
impl<T> NodeTypes<T>
where
    T: super::stub::NodeTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "node-types")]
impl<T> super::stub::NodeTypes for NodeTypes<T>
where
    T: super::stub::NodeTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::node_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::node_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::node_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [OrganizationSecurityPolicies](super::stub::OrganizationSecurityPolicies) decorator for logging and tracing.
#[cfg(feature = "organization-security-policies")]
#[derive(Clone, Debug)]
pub struct OrganizationSecurityPolicies<T>
where
    T: super::stub::OrganizationSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "organization-security-policies")]
impl<T> OrganizationSecurityPolicies<T>
where
    T: super::stub::OrganizationSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "organization-security-policies")]
impl<T> super::stub::OrganizationSecurityPolicies for OrganizationSecurityPolicies<T>
where
    T: super::stub::OrganizationSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_association(
        &self,
        req: crate::model::organization_security_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::organization_security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn copy_rules(
        &self,
        req: crate::model::organization_security_policies::CopyRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.copy_rules(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::organization_security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::organization_security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_association(
        &self,
        req: crate::model::organization_security_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyAssociation>> {
        self.inner.get_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::organization_security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::organization_security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::organization_security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_associations(
        &self,
        req: crate::model::organization_security_policies::ListAssociationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::OrganizationSecurityPoliciesListAssociationsResponse>,
    > {
        self.inner.list_associations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_preconfigured_expression_sets(
        &self,
        req: crate::model::organization_security_policies::ListPreconfiguredExpressionSetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SecurityPoliciesListPreconfiguredExpressionSetsResponse,
        >,
    > {
        self.inner
            .list_preconfigured_expression_sets(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn r#move(
        &self,
        req: crate::model::organization_security_policies::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.r#move(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::organization_security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::organization_security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_association(
        &self,
        req: crate::model::organization_security_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::organization_security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PacketMirrorings](super::stub::PacketMirrorings) decorator for logging and tracing.
#[cfg(feature = "packet-mirrorings")]
#[derive(Clone, Debug)]
pub struct PacketMirrorings<T>
where
    T: super::stub::PacketMirrorings + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "packet-mirrorings")]
impl<T> PacketMirrorings<T>
where
    T: super::stub::PacketMirrorings + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "packet-mirrorings")]
impl<T> super::stub::PacketMirrorings for PacketMirrorings<T>
where
    T: super::stub::PacketMirrorings + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::packet_mirrorings::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroringAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::packet_mirrorings::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::packet_mirrorings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroring>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::packet_mirrorings::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::packet_mirrorings::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroringList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::packet_mirrorings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::packet_mirrorings::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PreviewFeatures](super::stub::PreviewFeatures) decorator for logging and tracing.
#[cfg(feature = "preview-features")]
#[derive(Clone, Debug)]
pub struct PreviewFeatures<T>
where
    T: super::stub::PreviewFeatures + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "preview-features")]
impl<T> PreviewFeatures<T>
where
    T: super::stub::PreviewFeatures + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "preview-features")]
impl<T> super::stub::PreviewFeatures for PreviewFeatures<T>
where
    T: super::stub::PreviewFeatures + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::preview_features::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PreviewFeature>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::preview_features::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PreviewFeatureList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::preview_features::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Projects](super::stub::Projects) decorator for logging and tracing.
#[cfg(feature = "projects")]
#[derive(Clone, Debug)]
pub struct Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "projects")]
impl<T> Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "projects")]
impl<T> super::stub::Projects for Projects<T>
where
    T: super::stub::Projects + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn disable_xpn_host(
        &self,
        req: crate::model::projects::DisableXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.disable_xpn_host(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn disable_xpn_resource(
        &self,
        req: crate::model::projects::DisableXpnResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.disable_xpn_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn enable_xpn_host(
        &self,
        req: crate::model::projects::EnableXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.enable_xpn_host(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn enable_xpn_resource(
        &self,
        req: crate::model::projects::EnableXpnResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.enable_xpn_resource(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::projects::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Project>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_xpn_host(
        &self,
        req: crate::model::projects::GetXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Project>> {
        self.inner.get_xpn_host(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_xpn_resources(
        &self,
        req: crate::model::projects::GetXpnResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ProjectsGetXpnResources>> {
        self.inner.get_xpn_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_xpn_hosts(
        &self,
        req: crate::model::projects::ListXpnHostsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::XpnHostList>> {
        self.inner.list_xpn_hosts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn move_disk(
        &self,
        req: crate::model::projects::MoveDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.move_disk(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn move_instance(
        &self,
        req: crate::model::projects::MoveInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.move_instance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_cloud_armor_tier(
        &self,
        req: crate::model::projects::SetCloudArmorTierRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_cloud_armor_tier(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_common_instance_metadata(
        &self,
        req: crate::model::projects::SetCommonInstanceMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_common_instance_metadata(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_default_network_tier(
        &self,
        req: crate::model::projects::SetDefaultNetworkTierRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_default_network_tier(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_usage_export_bucket(
        &self,
        req: crate::model::projects::SetUsageExportBucketRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_usage_export_bucket(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PublicAdvertisedPrefixes](super::stub::PublicAdvertisedPrefixes) decorator for logging and tracing.
#[cfg(feature = "public-advertised-prefixes")]
#[derive(Clone, Debug)]
pub struct PublicAdvertisedPrefixes<T>
where
    T: super::stub::PublicAdvertisedPrefixes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "public-advertised-prefixes")]
impl<T> PublicAdvertisedPrefixes<T>
where
    T: super::stub::PublicAdvertisedPrefixes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "public-advertised-prefixes")]
impl<T> super::stub::PublicAdvertisedPrefixes for PublicAdvertisedPrefixes<T>
where
    T: super::stub::PublicAdvertisedPrefixes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn announce(
        &self,
        req: crate::model::public_advertised_prefixes::AnnounceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.announce(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::public_advertised_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::public_advertised_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicAdvertisedPrefix>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::public_advertised_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::public_advertised_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicAdvertisedPrefixList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::public_advertised_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn withdraw(
        &self,
        req: crate::model::public_advertised_prefixes::WithdrawRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.withdraw(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [PublicDelegatedPrefixes](super::stub::PublicDelegatedPrefixes) decorator for logging and tracing.
#[cfg(feature = "public-delegated-prefixes")]
#[derive(Clone, Debug)]
pub struct PublicDelegatedPrefixes<T>
where
    T: super::stub::PublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "public-delegated-prefixes")]
impl<T> PublicDelegatedPrefixes<T>
where
    T: super::stub::PublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "public-delegated-prefixes")]
impl<T> super::stub::PublicDelegatedPrefixes for PublicDelegatedPrefixes<T>
where
    T: super::stub::PublicDelegatedPrefixes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::public_delegated_prefixes::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn announce(
        &self,
        req: crate::model::public_delegated_prefixes::AnnounceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.announce(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::public_delegated_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::public_delegated_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefix>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::public_delegated_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::public_delegated_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::public_delegated_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn withdraw(
        &self,
        req: crate::model::public_delegated_prefixes::WithdrawRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.withdraw(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionAutoscalers](super::stub::RegionAutoscalers) decorator for logging and tracing.
#[cfg(feature = "region-autoscalers")]
#[derive(Clone, Debug)]
pub struct RegionAutoscalers<T>
where
    T: super::stub::RegionAutoscalers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-autoscalers")]
impl<T> RegionAutoscalers<T>
where
    T: super::stub::RegionAutoscalers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-autoscalers")]
impl<T> super::stub::RegionAutoscalers for RegionAutoscalers<T>
where
    T: super::stub::RegionAutoscalers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_autoscalers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_autoscalers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Autoscaler>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_autoscalers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_autoscalers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionAutoscalerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_autoscalers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_autoscalers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionBackendServices](super::stub::RegionBackendServices) decorator for logging and tracing.
#[cfg(feature = "region-backend-services")]
#[derive(Clone, Debug)]
pub struct RegionBackendServices<T>
where
    T: super::stub::RegionBackendServices + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-backend-services")]
impl<T> RegionBackendServices<T>
where
    T: super::stub::RegionBackendServices + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-backend-services")]
impl<T> super::stub::RegionBackendServices for RegionBackendServices<T>
where
    T: super::stub::RegionBackendServices + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_backend_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_backend_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendService>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_health(
        &self,
        req: crate::model::region_backend_services::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceGroupHealth>> {
        self.inner.get_health(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::region_backend_services::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_backend_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_backend_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_usable(
        &self,
        req: crate::model::region_backend_services::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceListUsable>> {
        self.inner.list_usable(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_backend_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::region_backend_services::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::region_backend_services::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_backend_services::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_backend_services::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionCommitments](super::stub::RegionCommitments) decorator for logging and tracing.
#[cfg(feature = "region-commitments")]
#[derive(Clone, Debug)]
pub struct RegionCommitments<T>
where
    T: super::stub::RegionCommitments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-commitments")]
impl<T> RegionCommitments<T>
where
    T: super::stub::RegionCommitments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-commitments")]
impl<T> super::stub::RegionCommitments for RegionCommitments<T>
where
    T: super::stub::RegionCommitments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::region_commitments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CommitmentAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_commitments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Commitment>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_commitments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_commitments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CommitmentList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_commitments::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionDiskTypes](super::stub::RegionDiskTypes) decorator for logging and tracing.
#[cfg(feature = "region-disk-types")]
#[derive(Clone, Debug)]
pub struct RegionDiskTypes<T>
where
    T: super::stub::RegionDiskTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-disk-types")]
impl<T> RegionDiskTypes<T>
where
    T: super::stub::RegionDiskTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-disk-types")]
impl<T> super::stub::RegionDiskTypes for RegionDiskTypes<T>
where
    T: super::stub::RegionDiskTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_disk_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_disk_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionDiskTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [RegionDisks](super::stub::RegionDisks) decorator for logging and tracing.
#[cfg(feature = "region-disks")]
#[derive(Clone, Debug)]
pub struct RegionDisks<T>
where
    T: super::stub::RegionDisks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-disks")]
impl<T> RegionDisks<T>
where
    T: super::stub::RegionDisks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-disks")]
impl<T> super::stub::RegionDisks for RegionDisks<T>
where
    T: super::stub::RegionDisks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_resource_policies(
        &self,
        req: crate::model::region_disks::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::region_disks::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_snapshot(
        &self,
        req: crate::model::region_disks::CreateSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_snapshot(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_disks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_disks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Disk>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::region_disks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_disks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_disks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_resource_policies(
        &self,
        req: crate::model::region_disks::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::region_disks::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::region_disks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::region_disks::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_async_replication(
        &self,
        req: crate::model::region_disks::StartAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_async_replication(
        &self,
        req: crate::model::region_disks::StopAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_group_async_replication(
        &self,
        req: crate::model::region_disks::StopGroupAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_group_async_replication(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_disks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_disks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionHealthCheckServices](super::stub::RegionHealthCheckServices) decorator for logging and tracing.
#[cfg(feature = "region-health-check-services")]
#[derive(Clone, Debug)]
pub struct RegionHealthCheckServices<T>
where
    T: super::stub::RegionHealthCheckServices + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-health-check-services")]
impl<T> RegionHealthCheckServices<T>
where
    T: super::stub::RegionHealthCheckServices + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-health-check-services")]
impl<T> super::stub::RegionHealthCheckServices for RegionHealthCheckServices<T>
where
    T: super::stub::RegionHealthCheckServices + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_health_check_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_health_check_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckService>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_health_check_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_health_check_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckServicesList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_health_check_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionHealthChecks](super::stub::RegionHealthChecks) decorator for logging and tracing.
#[cfg(feature = "region-health-checks")]
#[derive(Clone, Debug)]
pub struct RegionHealthChecks<T>
where
    T: super::stub::RegionHealthChecks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-health-checks")]
impl<T> RegionHealthChecks<T>
where
    T: super::stub::RegionHealthChecks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-health-checks")]
impl<T> super::stub::RegionHealthChecks for RegionHealthChecks<T>
where
    T: super::stub::RegionHealthChecks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheck>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionInstanceGroupManagers](super::stub::RegionInstanceGroupManagers) decorator for logging and tracing.
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-group-managers")]
impl<T> RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl<T> super::stub::RegionInstanceGroupManagers for RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn abandon_instances(
        &self,
        req: crate::model::region_instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.abandon_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn apply_updates_to_instances(
        &self,
        req: crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.apply_updates_to_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_instances(
        &self,
        req: crate::model::region_instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_instances(
        &self,
        req: crate::model::region_instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_errors(
        &self,
        req: crate::model::region_instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagersListErrorsResponse>>
    {
        self.inner.list_errors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_managed_instances(
        &self,
        req: crate::model::region_instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstancesResponse>,
    > {
        self.inner.list_managed_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstanceConfigsResp>,
    > {
        self.inner.list_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recreate_instances(
        &self,
        req: crate::model::region_instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.recreate_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::region_instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_instances(
        &self,
        req: crate::model::region_instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_instance_template(
        &self,
        req: crate::model::region_instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_instance_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target_pools(
        &self,
        req: crate::model::region_instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target_pools(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_instances(
        &self,
        req: crate::model::region_instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_instances(
        &self,
        req: crate::model::region_instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend_instances(
        &self,
        req: crate::model::region_instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionInstanceGroups](super::stub::RegionInstanceGroups) decorator for logging and tracing.
#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-groups")]
impl<T> RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-groups")]
impl<T> super::stub::RegionInstanceGroups for RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_instances(
        &self,
        req: crate::model::region_instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupsListInstances>> {
        self.inner.list_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_named_ports(
        &self,
        req: crate::model::region_instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_named_ports(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionInstanceTemplates](super::stub::RegionInstanceTemplates) decorator for logging and tracing.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Debug)]
pub struct RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-templates")]
impl<T> RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-templates")]
impl<T> super::stub::RegionInstanceTemplates for RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionInstances](super::stub::RegionInstances) decorator for logging and tracing.
#[cfg(feature = "region-instances")]
#[derive(Clone, Debug)]
pub struct RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instances")]
impl<T> RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instances")]
impl<T> super::stub::RegionInstances for RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::region_instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionInstantSnapshots](super::stub::RegionInstantSnapshots) decorator for logging and tracing.
#[cfg(feature = "region-instant-snapshots")]
#[derive(Clone, Debug)]
pub struct RegionInstantSnapshots<T>
where
    T: super::stub::RegionInstantSnapshots + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instant-snapshots")]
impl<T> RegionInstantSnapshots<T>
where
    T: super::stub::RegionInstantSnapshots + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instant-snapshots")]
impl<T> super::stub::RegionInstantSnapshots for RegionInstantSnapshots<T>
where
    T: super::stub::RegionInstantSnapshots + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_instant_snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instant_snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshot>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::region_instant_snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_instant_snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instant_snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::region_instant_snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::region_instant_snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instant_snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionNetworkEndpointGroups](super::stub::RegionNetworkEndpointGroups) decorator for logging and tracing.
#[cfg(feature = "region-network-endpoint-groups")]
#[derive(Clone, Debug)]
pub struct RegionNetworkEndpointGroups<T>
where
    T: super::stub::RegionNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-network-endpoint-groups")]
impl<T> RegionNetworkEndpointGroups<T>
where
    T: super::stub::RegionNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-network-endpoint-groups")]
impl<T> super::stub::RegionNetworkEndpointGroups for RegionNetworkEndpointGroups<T>
where
    T: super::stub::RegionNetworkEndpointGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn attach_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.attach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn detach_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.detach_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        self.inner.list_network_endpoints(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionNetworkFirewallPolicies](super::stub::RegionNetworkFirewallPolicies) decorator for logging and tracing.
#[cfg(feature = "region-network-firewall-policies")]
#[derive(Clone, Debug)]
pub struct RegionNetworkFirewallPolicies<T>
where
    T: super::stub::RegionNetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-network-firewall-policies")]
impl<T> RegionNetworkFirewallPolicies<T>
where
    T: super::stub::RegionNetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-network-firewall-policies")]
impl<T> super::stub::RegionNetworkFirewallPolicies for RegionNetworkFirewallPolicies<T>
where
    T: super::stub::RegionNetworkFirewallPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_association(
        &self,
        req: crate::model::region_network_firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::region_network_firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn clone_rules(
        &self,
        req: crate::model::region_network_firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.clone_rules(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_network_firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_network_firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_association(
        &self,
        req: crate::model::region_network_firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        self.inner.get_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_effective_firewalls(
        &self,
        req: crate::model::region_network_firewall_policies::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse,
        >,
    > {
        self.inner.get_effective_firewalls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::region_network_firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::region_network_firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_network_firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_network_firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_network_firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::region_network_firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_association(
        &self,
        req: crate::model::region_network_firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_association(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::region_network_firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::region_network_firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_network_firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionNotificationEndpoints](super::stub::RegionNotificationEndpoints) decorator for logging and tracing.
#[cfg(feature = "region-notification-endpoints")]
#[derive(Clone, Debug)]
pub struct RegionNotificationEndpoints<T>
where
    T: super::stub::RegionNotificationEndpoints + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-notification-endpoints")]
impl<T> RegionNotificationEndpoints<T>
where
    T: super::stub::RegionNotificationEndpoints + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-notification-endpoints")]
impl<T> super::stub::RegionNotificationEndpoints for RegionNotificationEndpoints<T>
where
    T: super::stub::RegionNotificationEndpoints + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_notification_endpoints::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_notification_endpoints::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationEndpoint>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_notification_endpoints::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_notification_endpoints::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationEndpointList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionOperations](super::stub::RegionOperations) decorator for logging and tracing.
#[cfg(feature = "region-operations")]
#[derive(Clone, Debug)]
pub struct RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-operations")]
impl<T> RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-operations")]
impl<T> super::stub::RegionOperations for RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::region_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [RegionSecurityPolicies](super::stub::RegionSecurityPolicies) decorator for logging and tracing.
#[cfg(feature = "region-security-policies")]
#[derive(Clone, Debug)]
pub struct RegionSecurityPolicies<T>
where
    T: super::stub::RegionSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-security-policies")]
impl<T> RegionSecurityPolicies<T>
where
    T: super::stub::RegionSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-security-policies")]
impl<T> super::stub::RegionSecurityPolicies for RegionSecurityPolicies<T>
where
    T: super::stub::RegionSecurityPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::region_security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::region_security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::region_security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::region_security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::region_security_policies::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionSslCertificates](super::stub::RegionSslCertificates) decorator for logging and tracing.
#[cfg(feature = "region-ssl-certificates")]
#[derive(Clone, Debug)]
pub struct RegionSslCertificates<T>
where
    T: super::stub::RegionSslCertificates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-ssl-certificates")]
impl<T> RegionSslCertificates<T>
where
    T: super::stub::RegionSslCertificates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-ssl-certificates")]
impl<T> super::stub::RegionSslCertificates for RegionSslCertificates<T>
where
    T: super::stub::RegionSslCertificates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_ssl_certificates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_ssl_certificates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_ssl_certificates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_ssl_certificates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionSslPolicies](super::stub::RegionSslPolicies) decorator for logging and tracing.
#[cfg(feature = "region-ssl-policies")]
#[derive(Clone, Debug)]
pub struct RegionSslPolicies<T>
where
    T: super::stub::RegionSslPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-ssl-policies")]
impl<T> RegionSslPolicies<T>
where
    T: super::stub::RegionSslPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-ssl-policies")]
impl<T> super::stub::RegionSslPolicies for RegionSslPolicies<T>
where
    T: super::stub::RegionSslPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_ssl_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_ssl_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_ssl_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_ssl_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_available_features(
        &self,
        req: crate::model::region_ssl_policies::ListAvailableFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesListAvailableFeaturesResponse>>
    {
        self.inner.list_available_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_ssl_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionTargetHttpProxies](super::stub::RegionTargetHttpProxies) decorator for logging and tracing.
#[cfg(feature = "region-target-http-proxies")]
#[derive(Clone, Debug)]
pub struct RegionTargetHttpProxies<T>
where
    T: super::stub::RegionTargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-target-http-proxies")]
impl<T> RegionTargetHttpProxies<T>
where
    T: super::stub::RegionTargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-target-http-proxies")]
impl<T> super::stub::RegionTargetHttpProxies for RegionTargetHttpProxies<T>
where
    T: super::stub::RegionTargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_target_http_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_target_http_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_target_http_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_target_http_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_url_map(
        &self,
        req: crate::model::region_target_http_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_url_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionTargetHttpsProxies](super::stub::RegionTargetHttpsProxies) decorator for logging and tracing.
#[cfg(feature = "region-target-https-proxies")]
#[derive(Clone, Debug)]
pub struct RegionTargetHttpsProxies<T>
where
    T: super::stub::RegionTargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-target-https-proxies")]
impl<T> RegionTargetHttpsProxies<T>
where
    T: super::stub::RegionTargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-target-https-proxies")]
impl<T> super::stub::RegionTargetHttpsProxies for RegionTargetHttpsProxies<T>
where
    T: super::stub::RegionTargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_target_https_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_target_https_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_target_https_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_target_https_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_target_https_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_ssl_certificates(
        &self,
        req: crate::model::region_target_https_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_ssl_certificates(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_url_map(
        &self,
        req: crate::model::region_target_https_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_url_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionTargetTcpProxies](super::stub::RegionTargetTcpProxies) decorator for logging and tracing.
#[cfg(feature = "region-target-tcp-proxies")]
#[derive(Clone, Debug)]
pub struct RegionTargetTcpProxies<T>
where
    T: super::stub::RegionTargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-target-tcp-proxies")]
impl<T> RegionTargetTcpProxies<T>
where
    T: super::stub::RegionTargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-target-tcp-proxies")]
impl<T> super::stub::RegionTargetTcpProxies for RegionTargetTcpProxies<T>
where
    T: super::stub::RegionTargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_target_tcp_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_target_tcp_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_target_tcp_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_target_tcp_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionUrlMaps](super::stub::RegionUrlMaps) decorator for logging and tracing.
#[cfg(feature = "region-url-maps")]
#[derive(Clone, Debug)]
pub struct RegionUrlMaps<T>
where
    T: super::stub::RegionUrlMaps + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-url-maps")]
impl<T> RegionUrlMaps<T>
where
    T: super::stub::RegionUrlMaps + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-url-maps")]
impl<T> super::stub::RegionUrlMaps for RegionUrlMaps<T>
where
    T: super::stub::RegionUrlMaps + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_url_maps::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_url_maps::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMap>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_url_maps::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_url_maps::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_url_maps::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::region_url_maps::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn validate(
        &self,
        req: crate::model::region_url_maps::ValidateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsValidateResponse>> {
        self.inner.validate(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [RegionZones](super::stub::RegionZones) decorator for logging and tracing.
#[cfg(feature = "region-zones")]
#[derive(Clone, Debug)]
pub struct RegionZones<T>
where
    T: super::stub::RegionZones + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-zones")]
impl<T> RegionZones<T>
where
    T: super::stub::RegionZones + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-zones")]
impl<T> super::stub::RegionZones for RegionZones<T>
where
    T: super::stub::RegionZones + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Regions](super::stub::Regions) decorator for logging and tracing.
#[cfg(feature = "regions")]
#[derive(Clone, Debug)]
pub struct Regions<T>
where
    T: super::stub::Regions + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "regions")]
impl<T> Regions<T>
where
    T: super::stub::Regions + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "regions")]
impl<T> super::stub::Regions for Regions<T>
where
    T: super::stub::Regions + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::regions::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Region>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::regions::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [ReservationBlocks](super::stub::ReservationBlocks) decorator for logging and tracing.
#[cfg(feature = "reservation-blocks")]
#[derive(Clone, Debug)]
pub struct ReservationBlocks<T>
where
    T: super::stub::ReservationBlocks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reservation-blocks")]
impl<T> ReservationBlocks<T>
where
    T: super::stub::ReservationBlocks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reservation-blocks")]
impl<T> super::stub::ReservationBlocks for ReservationBlocks<T>
where
    T: super::stub::ReservationBlocks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::reservation_blocks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationBlocksGetResponse>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::reservation_blocks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationBlocksListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::reservation_blocks::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ReservationSubBlocks](super::stub::ReservationSubBlocks) decorator for logging and tracing.
#[cfg(feature = "reservation-sub-blocks")]
#[derive(Clone, Debug)]
pub struct ReservationSubBlocks<T>
where
    T: super::stub::ReservationSubBlocks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reservation-sub-blocks")]
impl<T> ReservationSubBlocks<T>
where
    T: super::stub::ReservationSubBlocks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reservation-sub-blocks")]
impl<T> super::stub::ReservationSubBlocks for ReservationSubBlocks<T>
where
    T: super::stub::ReservationSubBlocks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::reservation_sub_blocks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationSubBlocksGetResponse>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::reservation_sub_blocks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationSubBlocksListResponse>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::reservation_sub_blocks::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn report_faulty(
        &self,
        req: crate::model::reservation_sub_blocks::ReportFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.report_faulty(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Reservations](super::stub::Reservations) decorator for logging and tracing.
#[cfg(feature = "reservations")]
#[derive(Clone, Debug)]
pub struct Reservations<T>
where
    T: super::stub::Reservations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "reservations")]
impl<T> Reservations<T>
where
    T: super::stub::Reservations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "reservations")]
impl<T> super::stub::Reservations for Reservations<T>
where
    T: super::stub::Reservations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::reservations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::reservations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::reservations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Reservation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::reservations::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::reservations::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::reservations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::reservations::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::reservations::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::reservations::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::reservations::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::reservations::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ResourcePolicies](super::stub::ResourcePolicies) decorator for logging and tracing.
#[cfg(feature = "resource-policies")]
#[derive(Clone, Debug)]
pub struct ResourcePolicies<T>
where
    T: super::stub::ResourcePolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "resource-policies")]
impl<T> ResourcePolicies<T>
where
    T: super::stub::ResourcePolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "resource-policies")]
impl<T> super::stub::ResourcePolicies for ResourcePolicies<T>
where
    T: super::stub::ResourcePolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::resource_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicyAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::resource_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::resource_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::resource_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::resource_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::resource_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::resource_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::resource_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::resource_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Routers](super::stub::Routers) decorator for logging and tracing.
#[cfg(feature = "routers")]
#[derive(Clone, Debug)]
pub struct Routers<T>
where
    T: super::stub::Routers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "routers")]
impl<T> Routers<T>
where
    T: super::stub::Routers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "routers")]
impl<T> super::stub::Routers for Routers<T>
where
    T: super::stub::Routers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::routers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::routers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_route_policy(
        &self,
        req: crate::model::routers::DeleteRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_route_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::routers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Router>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_nat_ip_info(
        &self,
        req: crate::model::routers::GetNatIpInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NatIpInfoResponse>> {
        self.inner.get_nat_ip_info(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_nat_mapping_info(
        &self,
        req: crate::model::routers::GetNatMappingInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VmEndpointNatMappingsList>> {
        self.inner.get_nat_mapping_info(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_route_policy(
        &self,
        req: crate::model::routers::GetRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersGetRoutePolicyResponse>> {
        self.inner.get_route_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_router_status(
        &self,
        req: crate::model::routers::GetRouterStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterStatusResponse>> {
        self.inner.get_router_status(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::routers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::routers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_bgp_routes(
        &self,
        req: crate::model::routers::ListBgpRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersListBgpRoutes>> {
        self.inner.list_bgp_routes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_route_policies(
        &self,
        req: crate::model::routers::ListRoutePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersListRoutePolicies>> {
        self.inner.list_route_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::routers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_route_policy(
        &self,
        req: crate::model::routers::PatchRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_route_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn preview(
        &self,
        req: crate::model::routers::PreviewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersPreviewResponse>> {
        self.inner.preview(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::routers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_route_policy(
        &self,
        req: crate::model::routers::UpdateRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_route_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Routes](super::stub::Routes) decorator for logging and tracing.
#[cfg(feature = "routes")]
#[derive(Clone, Debug)]
pub struct Routes<T>
where
    T: super::stub::Routes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "routes")]
impl<T> Routes<T>
where
    T: super::stub::Routes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "routes")]
impl<T> super::stub::Routes for Routes<T>
where
    T: super::stub::Routes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::routes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::routes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Route>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::routes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::routes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouteList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SecurityPolicies](super::stub::SecurityPolicies) decorator for logging and tracing.
#[cfg(feature = "security-policies")]
#[derive(Clone, Debug)]
pub struct SecurityPolicies<T>
where
    T: super::stub::SecurityPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "security-policies")]
impl<T> SecurityPolicies<T>
where
    T: super::stub::SecurityPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "security-policies")]
impl<T> super::stub::SecurityPolicies for SecurityPolicies<T>
where
    T: super::stub::SecurityPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_rule(
        &self,
        req: crate::model::security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::security_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPoliciesAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_rule(
        &self,
        req: crate::model::security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        self.inner.get_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_preconfigured_expression_sets(
        &self,
        req: crate::model::security_policies::ListPreconfiguredExpressionSetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SecurityPoliciesListPreconfiguredExpressionSetsResponse,
        >,
    > {
        self.inner
            .list_preconfigured_expression_sets(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_rule(
        &self,
        req: crate::model::security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_rule(
        &self,
        req: crate::model::security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_rule(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::security_policies::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ServiceAttachments](super::stub::ServiceAttachments) decorator for logging and tracing.
#[cfg(feature = "service-attachments")]
#[derive(Clone, Debug)]
pub struct ServiceAttachments<T>
where
    T: super::stub::ServiceAttachments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "service-attachments")]
impl<T> ServiceAttachments<T>
where
    T: super::stub::ServiceAttachments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "service-attachments")]
impl<T> super::stub::ServiceAttachments for ServiceAttachments<T>
where
    T: super::stub::ServiceAttachments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::service_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachmentAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::service_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::service_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachment>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::service_attachments::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::service_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::service_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachmentList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::service_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::service_attachments::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::service_attachments::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SnapshotSettings](super::stub::SnapshotSettings) decorator for logging and tracing.
#[cfg(feature = "snapshot-settings")]
#[derive(Clone, Debug)]
pub struct SnapshotSettings<T>
where
    T: super::stub::SnapshotSettings + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "snapshot-settings")]
impl<T> SnapshotSettings<T>
where
    T: super::stub::SnapshotSettings + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "snapshot-settings")]
impl<T> super::stub::SnapshotSettings for SnapshotSettings<T>
where
    T: super::stub::SnapshotSettings + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::snapshot_settings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SnapshotSettings>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::snapshot_settings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Snapshots](super::stub::Snapshots) decorator for logging and tracing.
#[cfg(feature = "snapshots")]
#[derive(Clone, Debug)]
pub struct Snapshots<T>
where
    T: super::stub::Snapshots + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "snapshots")]
impl<T> Snapshots<T>
where
    T: super::stub::Snapshots + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "snapshots")]
impl<T> super::stub::Snapshots for Snapshots<T>
where
    T: super::stub::Snapshots + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snapshot>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SnapshotList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SslCertificates](super::stub::SslCertificates) decorator for logging and tracing.
#[cfg(feature = "ssl-certificates")]
#[derive(Clone, Debug)]
pub struct SslCertificates<T>
where
    T: super::stub::SslCertificates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "ssl-certificates")]
impl<T> SslCertificates<T>
where
    T: super::stub::SslCertificates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "ssl-certificates")]
impl<T> super::stub::SslCertificates for SslCertificates<T>
where
    T: super::stub::SslCertificates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::ssl_certificates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::ssl_certificates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::ssl_certificates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::ssl_certificates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::ssl_certificates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SslPolicies](super::stub::SslPolicies) decorator for logging and tracing.
#[cfg(feature = "ssl-policies")]
#[derive(Clone, Debug)]
pub struct SslPolicies<T>
where
    T: super::stub::SslPolicies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "ssl-policies")]
impl<T> SslPolicies<T>
where
    T: super::stub::SslPolicies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "ssl-policies")]
impl<T> super::stub::SslPolicies for SslPolicies<T>
where
    T: super::stub::SslPolicies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::ssl_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::ssl_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::ssl_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPolicy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::ssl_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::ssl_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_available_features(
        &self,
        req: crate::model::ssl_policies::ListAvailableFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesListAvailableFeaturesResponse>>
    {
        self.inner.list_available_features(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::ssl_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [StoragePoolTypes](super::stub::StoragePoolTypes) decorator for logging and tracing.
#[cfg(feature = "storage-pool-types")]
#[derive(Clone, Debug)]
pub struct StoragePoolTypes<T>
where
    T: super::stub::StoragePoolTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "storage-pool-types")]
impl<T> StoragePoolTypes<T>
where
    T: super::stub::StoragePoolTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "storage-pool-types")]
impl<T> super::stub::StoragePoolTypes for StoragePoolTypes<T>
where
    T: super::stub::StoragePoolTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::storage_pool_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::storage_pool_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::storage_pool_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [StoragePools](super::stub::StoragePools) decorator for logging and tracing.
#[cfg(feature = "storage-pools")]
#[derive(Clone, Debug)]
pub struct StoragePools<T>
where
    T: super::stub::StoragePools + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "storage-pools")]
impl<T> StoragePools<T>
where
    T: super::stub::StoragePools + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "storage-pools")]
impl<T> super::stub::StoragePools for StoragePools<T>
where
    T: super::stub::StoragePools + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::storage_pools::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::storage_pools::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::storage_pools::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePool>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::storage_pools::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::storage_pools::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::storage_pools::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_disks(
        &self,
        req: crate::model::storage_pools::ListDisksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolListDisks>> {
        self.inner.list_disks(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::storage_pools::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::storage_pools::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::storage_pools::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Subnetworks](super::stub::Subnetworks) decorator for logging and tracing.
#[cfg(feature = "subnetworks")]
#[derive(Clone, Debug)]
pub struct Subnetworks<T>
where
    T: super::stub::Subnetworks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "subnetworks")]
impl<T> Subnetworks<T>
where
    T: super::stub::Subnetworks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "subnetworks")]
impl<T> super::stub::Subnetworks for Subnetworks<T>
where
    T: super::stub::Subnetworks + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::subnetworks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SubnetworkAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::subnetworks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn expand_ip_cidr_range(
        &self,
        req: crate::model::subnetworks::ExpandIpCidrRangeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.expand_ip_cidr_range(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::subnetworks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Subnetwork>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::subnetworks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::subnetworks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::subnetworks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SubnetworkList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_usable(
        &self,
        req: crate::model::subnetworks::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsableSubnetworksAggregatedList>> {
        self.inner.list_usable(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::subnetworks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::subnetworks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_private_ip_google_access(
        &self,
        req: crate::model::subnetworks::SetPrivateIpGoogleAccessRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_private_ip_google_access(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::subnetworks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetGrpcProxies](super::stub::TargetGrpcProxies) decorator for logging and tracing.
#[cfg(feature = "target-grpc-proxies")]
#[derive(Clone, Debug)]
pub struct TargetGrpcProxies<T>
where
    T: super::stub::TargetGrpcProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-grpc-proxies")]
impl<T> TargetGrpcProxies<T>
where
    T: super::stub::TargetGrpcProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-grpc-proxies")]
impl<T> super::stub::TargetGrpcProxies for TargetGrpcProxies<T>
where
    T: super::stub::TargetGrpcProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_grpc_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_grpc_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetGrpcProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_grpc_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_grpc_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetGrpcProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::target_grpc_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetHttpProxies](super::stub::TargetHttpProxies) decorator for logging and tracing.
#[cfg(feature = "target-http-proxies")]
#[derive(Clone, Debug)]
pub struct TargetHttpProxies<T>
where
    T: super::stub::TargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-http-proxies")]
impl<T> TargetHttpProxies<T>
where
    T: super::stub::TargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-http-proxies")]
impl<T> super::stub::TargetHttpProxies for TargetHttpProxies<T>
where
    T: super::stub::TargetHttpProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_http_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_http_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_http_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_http_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_http_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::target_http_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_url_map(
        &self,
        req: crate::model::target_http_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_url_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetHttpsProxies](super::stub::TargetHttpsProxies) decorator for logging and tracing.
#[cfg(feature = "target-https-proxies")]
#[derive(Clone, Debug)]
pub struct TargetHttpsProxies<T>
where
    T: super::stub::TargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-https-proxies")]
impl<T> TargetHttpsProxies<T>
where
    T: super::stub::TargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-https-proxies")]
impl<T> super::stub::TargetHttpsProxies for TargetHttpsProxies<T>
where
    T: super::stub::TargetHttpsProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_https_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_https_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_https_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_https_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_https_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::target_https_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_certificate_map(
        &self,
        req: crate::model::target_https_proxies::SetCertificateMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_certificate_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_quic_override(
        &self,
        req: crate::model::target_https_proxies::SetQuicOverrideRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_quic_override(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_ssl_certificates(
        &self,
        req: crate::model::target_https_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_ssl_certificates(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_ssl_policy(
        &self,
        req: crate::model::target_https_proxies::SetSslPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_ssl_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_url_map(
        &self,
        req: crate::model::target_https_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_url_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetInstances](super::stub::TargetInstances) decorator for logging and tracing.
#[cfg(feature = "target-instances")]
#[derive(Clone, Debug)]
pub struct TargetInstances<T>
where
    T: super::stub::TargetInstances + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-instances")]
impl<T> TargetInstances<T>
where
    T: super::stub::TargetInstances + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-instances")]
impl<T> super::stub::TargetInstances for TargetInstances<T>
where
    T: super::stub::TargetInstances + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstanceAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstance>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstanceList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::target_instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::target_instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetPools](super::stub::TargetPools) decorator for logging and tracing.
#[cfg(feature = "target-pools")]
#[derive(Clone, Debug)]
pub struct TargetPools<T>
where
    T: super::stub::TargetPools + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-pools")]
impl<T> TargetPools<T>
where
    T: super::stub::TargetPools + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-pools")]
impl<T> super::stub::TargetPools for TargetPools<T>
where
    T: super::stub::TargetPools + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_health_check(
        &self,
        req: crate::model::target_pools::AddHealthCheckRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_health_check(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_instance(
        &self,
        req: crate::model::target_pools::AddInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_instance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_pools::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_pools::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_pools::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPool>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_health(
        &self,
        req: crate::model::target_pools::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolInstanceHealth>> {
        self.inner.get_health(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_pools::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_pools::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_health_check(
        &self,
        req: crate::model::target_pools::RemoveHealthCheckRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_health_check(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_instance(
        &self,
        req: crate::model::target_pools::RemoveInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_instance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_backup(
        &self,
        req: crate::model::target_pools::SetBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_backup(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::target_pools::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::target_pools::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetSslProxies](super::stub::TargetSslProxies) decorator for logging and tracing.
#[cfg(feature = "target-ssl-proxies")]
#[derive(Clone, Debug)]
pub struct TargetSslProxies<T>
where
    T: super::stub::TargetSslProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-ssl-proxies")]
impl<T> TargetSslProxies<T>
where
    T: super::stub::TargetSslProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-ssl-proxies")]
impl<T> super::stub::TargetSslProxies for TargetSslProxies<T>
where
    T: super::stub::TargetSslProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_ssl_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_ssl_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSslProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_ssl_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_ssl_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSslProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_backend_service(
        &self,
        req: crate::model::target_ssl_proxies::SetBackendServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_backend_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_certificate_map(
        &self,
        req: crate::model::target_ssl_proxies::SetCertificateMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_certificate_map(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_proxy_header(
        &self,
        req: crate::model::target_ssl_proxies::SetProxyHeaderRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_proxy_header(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_ssl_certificates(
        &self,
        req: crate::model::target_ssl_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_ssl_certificates(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_ssl_policy(
        &self,
        req: crate::model::target_ssl_proxies::SetSslPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_ssl_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetTcpProxies](super::stub::TargetTcpProxies) decorator for logging and tracing.
#[cfg(feature = "target-tcp-proxies")]
#[derive(Clone, Debug)]
pub struct TargetTcpProxies<T>
where
    T: super::stub::TargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-tcp-proxies")]
impl<T> TargetTcpProxies<T>
where
    T: super::stub::TargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-tcp-proxies")]
impl<T> super::stub::TargetTcpProxies for TargetTcpProxies<T>
where
    T: super::stub::TargetTcpProxies + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_tcp_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_tcp_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_tcp_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxy>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_tcp_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_tcp_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_backend_service(
        &self,
        req: crate::model::target_tcp_proxies::SetBackendServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_backend_service(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_proxy_header(
        &self,
        req: crate::model::target_tcp_proxies::SetProxyHeaderRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_proxy_header(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TargetVpnGateways](super::stub::TargetVpnGateways) decorator for logging and tracing.
#[cfg(feature = "target-vpn-gateways")]
#[derive(Clone, Debug)]
pub struct TargetVpnGateways<T>
where
    T: super::stub::TargetVpnGateways + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "target-vpn-gateways")]
impl<T> TargetVpnGateways<T>
where
    T: super::stub::TargetVpnGateways + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "target-vpn-gateways")]
impl<T> super::stub::TargetVpnGateways for TargetVpnGateways<T>
where
    T: super::stub::TargetVpnGateways + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::target_vpn_gateways::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGatewayAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::target_vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::target_vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGateway>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::target_vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::target_vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGatewayList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::target_vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [UrlMaps](super::stub::UrlMaps) decorator for logging and tracing.
#[cfg(feature = "url-maps")]
#[derive(Clone, Debug)]
pub struct UrlMaps<T>
where
    T: super::stub::UrlMaps + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "url-maps")]
impl<T> UrlMaps<T>
where
    T: super::stub::UrlMaps + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "url-maps")]
impl<T> super::stub::UrlMaps for UrlMaps<T>
where
    T: super::stub::UrlMaps + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::url_maps::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::url_maps::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::url_maps::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMap>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::url_maps::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn invalidate_cache(
        &self,
        req: crate::model::url_maps::InvalidateCacheRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.invalidate_cache(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::url_maps::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::url_maps::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::url_maps::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn validate(
        &self,
        req: crate::model::url_maps::ValidateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsValidateResponse>> {
        self.inner.validate(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VpnGateways](super::stub::VpnGateways) decorator for logging and tracing.
#[cfg(feature = "vpn-gateways")]
#[derive(Clone, Debug)]
pub struct VpnGateways<T>
where
    T: super::stub::VpnGateways + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vpn-gateways")]
impl<T> VpnGateways<T>
where
    T: super::stub::VpnGateways + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vpn-gateways")]
impl<T> super::stub::VpnGateways for VpnGateways<T>
where
    T: super::stub::VpnGateways + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::vpn_gateways::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewayAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGateway>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_status(
        &self,
        req: crate::model::vpn_gateways::GetStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewaysGetStatusResponse>> {
        self.inner.get_status(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewayList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::vpn_gateways::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [VpnTunnels](super::stub::VpnTunnels) decorator for logging and tracing.
#[cfg(feature = "vpn-tunnels")]
#[derive(Clone, Debug)]
pub struct VpnTunnels<T>
where
    T: super::stub::VpnTunnels + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "vpn-tunnels")]
impl<T> VpnTunnels<T>
where
    T: super::stub::VpnTunnels + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "vpn-tunnels")]
impl<T> super::stub::VpnTunnels for VpnTunnels<T>
where
    T: super::stub::VpnTunnels + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::vpn_tunnels::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnelAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::vpn_tunnels::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::vpn_tunnels::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnel>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::vpn_tunnels::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::vpn_tunnels::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnelList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::vpn_tunnels::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [WireGroups](super::stub::WireGroups) decorator for logging and tracing.
#[cfg(feature = "wire-groups")]
#[derive(Clone, Debug)]
pub struct WireGroups<T>
where
    T: super::stub::WireGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "wire-groups")]
impl<T> WireGroups<T>
where
    T: super::stub::WireGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "wire-groups")]
impl<T> super::stub::WireGroups for WireGroups<T>
where
    T: super::stub::WireGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::wire_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::wire_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WireGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::wire_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::wire_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WireGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::wire_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ZoneOperations](super::stub::ZoneOperations) decorator for logging and tracing.
#[cfg(feature = "zone-operations")]
#[derive(Clone, Debug)]
pub struct ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "zone-operations")]
impl<T> ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "zone-operations")]
impl<T> super::stub::ZoneOperations for ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::zone_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::zone_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [Zones](super::stub::Zones) decorator for logging and tracing.
#[cfg(feature = "zones")]
#[derive(Clone, Debug)]
pub struct Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "zones")]
impl<T> Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "zones")]
impl<T> super::stub::Zones for Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        self.inner.list(req, options).await
    }
}
