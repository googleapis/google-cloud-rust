// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "machine-types",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
    feature = "zones",
))]
use crate::Result;

/// Implements a [GlobalOperations](super::stub::GlobalOperations) decorator for logging and tracing.
#[cfg(feature = "global-operations")]
#[derive(Clone, Debug)]
pub struct GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-operations")]
impl<T> GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-operations")]
impl<T> super::stub::GlobalOperations for GlobalOperations<T>
where
    T: super::stub::GlobalOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::global_operations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::global_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [GlobalOrganizationOperations](super::stub::GlobalOrganizationOperations) decorator for logging and tracing.
#[cfg(feature = "global-organization-operations")]
#[derive(Clone, Debug)]
pub struct GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "global-organization-operations")]
impl<T> GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "global-organization-operations")]
impl<T> super::stub::GlobalOrganizationOperations for GlobalOrganizationOperations<T>
where
    T: super::stub::GlobalOrganizationOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::global_organization_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::global_organization_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [Images](super::stub::Images) decorator for logging and tracing.
#[cfg(feature = "images")]
#[derive(Clone, Debug)]
pub struct Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "images")]
impl<T> Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "images")]
impl<T> super::stub::Images for Images<T>
where
    T: super::stub::Images + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deprecate(
        &self,
        req: crate::model::images::DeprecateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.deprecate(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_from_family(
        &self,
        req: crate::model::images::GetFromFamilyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        self.inner.get_from_family(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::images::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
}

/// Implements a [InstanceGroupManagerResizeRequests](super::stub::InstanceGroupManagerResizeRequests) decorator for logging and tracing.
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl<T> InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl<T> super::stub::InstanceGroupManagerResizeRequests for InstanceGroupManagerResizeRequests<T>
where
    T: super::stub::InstanceGroupManagerResizeRequests + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn cancel(
        &self,
        req: crate::model::instance_group_manager_resize_requests::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.cancel(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_group_manager_resize_requests::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_group_manager_resize_requests::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequest>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_group_manager_resize_requests::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_group_manager_resize_requests::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequestsListResponse>>
    {
        self.inner.list(req, options).await
    }
}

/// Implements a [InstanceGroupManagers](super::stub::InstanceGroupManagers) decorator for logging and tracing.
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-group-managers")]
impl<T> InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-group-managers")]
impl<T> super::stub::InstanceGroupManagers for InstanceGroupManagers<T>
where
    T: super::stub::InstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn abandon_instances(
        &self,
        req: crate::model::instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.abandon_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instance_group_managers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn apply_updates_to_instances(
        &self,
        req: crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.apply_updates_to_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_instances(
        &self,
        req: crate::model::instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_instances(
        &self,
        req: crate::model::instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_errors(
        &self,
        req: crate::model::instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagersListErrorsResponse>>
    {
        self.inner.list_errors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_managed_instances(
        &self,
        req: crate::model::instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListManagedInstancesResponse>,
    > {
        self.inner.list_managed_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListPerInstanceConfigsResp>,
    > {
        self.inner.list_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recreate_instances(
        &self,
        req: crate::model::instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.recreate_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_instances(
        &self,
        req: crate::model::instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_instance_template(
        &self,
        req: crate::model::instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_instance_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target_pools(
        &self,
        req: crate::model::instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target_pools(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_instances(
        &self,
        req: crate::model::instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_instances(
        &self,
        req: crate::model::instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend_instances(
        &self,
        req: crate::model::instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_per_instance_configs(req, options).await
    }
}

/// Implements a [InstanceGroups](super::stub::InstanceGroups) decorator for logging and tracing.
#[cfg(feature = "instance-groups")]
#[derive(Clone, Debug)]
pub struct InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instance-groups")]
impl<T> InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instance-groups")]
impl<T> super::stub::InstanceGroups for InstanceGroups<T>
where
    T: super::stub::InstanceGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_instances(
        &self,
        req: crate::model::instance_groups::AddInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instance_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instance_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instance_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_instances(
        &self,
        req: crate::model::instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupsListInstances>> {
        self.inner.list_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_instances(
        &self,
        req: crate::model::instance_groups::RemoveInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_named_ports(
        &self,
        req: crate::model::instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_named_ports(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
}

/// Implements a [Instances](super::stub::Instances) decorator for logging and tracing.
#[cfg(feature = "instances")]
#[derive(Clone, Debug)]
pub struct Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "instances")]
impl<T> Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "instances")]
impl<T> super::stub::Instances for Instances<T>
where
    T: super::stub::Instances + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn add_access_config(
        &self,
        req: crate::model::instances::AddAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_network_interface(
        &self,
        req: crate::model::instances::AddNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn add_resource_policies(
        &self,
        req: crate::model::instances::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.add_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn attach_disk(
        &self,
        req: crate::model::instances::AttachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.attach_disk(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_access_config(
        &self,
        req: crate::model::instances::DeleteAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_network_interface(
        &self,
        req: crate::model::instances::DeleteNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn detach_disk(
        &self,
        req: crate::model::instances::DetachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.detach_disk(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_effective_firewalls(
        &self,
        req: crate::model::instances::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesGetEffectiveFirewallsResponse>> {
        self.inner.get_effective_firewalls(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_guest_attributes(
        &self,
        req: crate::model::instances::GetGuestAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GuestAttributes>> {
        self.inner.get_guest_attributes(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: crate::model::instances::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_screenshot(
        &self,
        req: crate::model::instances::GetScreenshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Screenshot>> {
        self.inner.get_screenshot(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_serial_port_output(
        &self,
        req: crate::model::instances::GetSerialPortOutputRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SerialPortOutput>> {
        self.inner.get_serial_port_output(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_shielded_instance_identity(
        &self,
        req: crate::model::instances::GetShieldedInstanceIdentityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ShieldedInstanceIdentity>> {
        self.inner
            .get_shielded_instance_identity(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_referrers(
        &self,
        req: crate::model::instances::ListReferrersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceListReferrers>> {
        self.inner.list_referrers(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn perform_maintenance(
        &self,
        req: crate::model::instances::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.perform_maintenance(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn remove_resource_policies(
        &self,
        req: crate::model::instances::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.remove_resource_policies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn report_host_as_faulty(
        &self,
        req: crate::model::instances::ReportHostAsFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.report_host_as_faulty(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn reset(
        &self,
        req: crate::model::instances::ResetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.reset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume(
        &self,
        req: crate::model::instances::ResumeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn send_diagnostic_interrupt(
        &self,
        req: crate::model::instances::SendDiagnosticInterruptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.send_diagnostic_interrupt(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_deletion_protection(
        &self,
        req: crate::model::instances::SetDeletionProtectionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_deletion_protection(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_disk_auto_delete(
        &self,
        req: crate::model::instances::SetDiskAutoDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_disk_auto_delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: crate::model::instances::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_labels(
        &self,
        req: crate::model::instances::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_labels(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_machine_resources(
        &self,
        req: crate::model::instances::SetMachineResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_machine_resources(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_machine_type(
        &self,
        req: crate::model::instances::SetMachineTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_machine_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_metadata(
        &self,
        req: crate::model::instances::SetMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_metadata(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_min_cpu_platform(
        &self,
        req: crate::model::instances::SetMinCpuPlatformRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_min_cpu_platform(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_name(
        &self,
        req: crate::model::instances::SetNameRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_name(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_scheduling(
        &self,
        req: crate::model::instances::SetSchedulingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_scheduling(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_security_policy(
        &self,
        req: crate::model::instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_security_policy(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_service_account(
        &self,
        req: crate::model::instances::SetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_service_account(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_shielded_instance_integrity_policy(
        &self,
        req: crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner
            .set_shielded_instance_integrity_policy(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn set_tags(
        &self,
        req: crate::model::instances::SetTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_tags(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn simulate_maintenance_event(
        &self,
        req: crate::model::instances::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.simulate_maintenance_event(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start(
        &self,
        req: crate::model::instances::StartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_with_encryption_key(
        &self,
        req: crate::model::instances::StartWithEncryptionKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_with_encryption_key(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop(
        &self,
        req: crate::model::instances::StopRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend(
        &self,
        req: crate::model::instances::SuspendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update(
        &self,
        req: crate::model::instances::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_access_config(
        &self,
        req: crate::model::instances::UpdateAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_access_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_display_device(
        &self,
        req: crate::model::instances::UpdateDisplayDeviceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_display_device(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_network_interface(
        &self,
        req: crate::model::instances::UpdateNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_network_interface(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_shielded_instance_config(
        &self,
        req: crate::model::instances::UpdateShieldedInstanceConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner
            .update_shielded_instance_config(req, options)
            .await
    }
}

/// Implements a [MachineTypes](super::stub::MachineTypes) decorator for logging and tracing.
#[cfg(feature = "machine-types")]
#[derive(Clone, Debug)]
pub struct MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "machine-types")]
impl<T> MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "machine-types")]
impl<T> super::stub::MachineTypes for MachineTypes<T>
where
    T: super::stub::MachineTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn aggregated_list(
        &self,
        req: crate::model::machine_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeAggregatedList>> {
        self.inner.aggregated_list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::machine_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineType>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::machine_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [RegionInstanceGroupManagers](super::stub::RegionInstanceGroupManagers) decorator for logging and tracing.
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-group-managers")]
impl<T> RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl<T> super::stub::RegionInstanceGroupManagers for RegionInstanceGroupManagers<T>
where
    T: super::stub::RegionInstanceGroupManagers + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn abandon_instances(
        &self,
        req: crate::model::region_instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.abandon_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn apply_updates_to_instances(
        &self,
        req: crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.apply_updates_to_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_instances(
        &self,
        req: crate::model::region_instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.create_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_instances(
        &self,
        req: crate::model::region_instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagerList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_errors(
        &self,
        req: crate::model::region_instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagersListErrorsResponse>>
    {
        self.inner.list_errors(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_managed_instances(
        &self,
        req: crate::model::region_instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstancesResponse>,
    > {
        self.inner.list_managed_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstanceConfigsResp>,
    > {
        self.inner.list_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch(
        &self,
        req: crate::model::region_instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn patch_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.patch_per_instance_configs(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn recreate_instances(
        &self,
        req: crate::model::region_instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.recreate_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resize(
        &self,
        req: crate::model::region_instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resize(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn resume_instances(
        &self,
        req: crate::model::region_instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.resume_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_instance_template(
        &self,
        req: crate::model::region_instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_instance_template(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_target_pools(
        &self,
        req: crate::model::region_instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_target_pools(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn start_instances(
        &self,
        req: crate::model::region_instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.start_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn stop_instances(
        &self,
        req: crate::model::region_instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.stop_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suspend_instances(
        &self,
        req: crate::model::region_instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.suspend_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.update_per_instance_configs(req, options).await
    }
}

/// Implements a [RegionInstanceGroups](super::stub::RegionInstanceGroups) decorator for logging and tracing.
#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-groups")]
impl<T> RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-groups")]
impl<T> super::stub::RegionInstanceGroups for RegionInstanceGroups<T>
where
    T: super::stub::RegionInstanceGroups + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_instances(
        &self,
        req: crate::model::region_instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupsListInstances>> {
        self.inner.list_instances(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_named_ports(
        &self,
        req: crate::model::region_instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.set_named_ports(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
}

/// Implements a [RegionInstanceTemplates](super::stub::RegionInstanceTemplates) decorator for logging and tracing.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Debug)]
pub struct RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instance-templates")]
impl<T> RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instance-templates")]
impl<T> super::stub::RegionInstanceTemplates for RegionInstanceTemplates<T>
where
    T: super::stub::RegionInstanceTemplates + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn insert(
        &self,
        req: crate::model::region_instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.insert(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        self.inner.list(req, options).await
    }
}

/// Implements a [RegionInstances](super::stub::RegionInstances) decorator for logging and tracing.
#[cfg(feature = "region-instances")]
#[derive(Clone, Debug)]
pub struct RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-instances")]
impl<T> RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-instances")]
impl<T> super::stub::RegionInstances for RegionInstances<T>
where
    T: super::stub::RegionInstances + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn bulk_insert(
        &self,
        req: crate::model::region_instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.bulk_insert(req, options).await
    }
}

/// Implements a [RegionOperations](super::stub::RegionOperations) decorator for logging and tracing.
#[cfg(feature = "region-operations")]
#[derive(Clone, Debug)]
pub struct RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "region-operations")]
impl<T> RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "region-operations")]
impl<T> super::stub::RegionOperations for RegionOperations<T>
where
    T: super::stub::RegionOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::region_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::region_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::region_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [ZoneOperations](super::stub::ZoneOperations) decorator for logging and tracing.
#[cfg(feature = "zone-operations")]
#[derive(Clone, Debug)]
pub struct ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "zone-operations")]
impl<T> ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "zone-operations")]
impl<T> super::stub::ZoneOperations for ZoneOperations<T>
where
    T: super::stub::ZoneOperations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn delete(
        &self,
        req: crate::model::zone_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        self.inner.delete(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        self.inner.list(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn wait(
        &self,
        req: crate::model::zone_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        self.inner.wait(req, options).await
    }
}

/// Implements a [Zones](super::stub::Zones) decorator for logging and tracing.
#[cfg(feature = "zones")]
#[derive(Clone, Debug)]
pub struct Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "zones")]
impl<T> Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "zones")]
impl<T> super::stub::Zones for Zones<T>
where
    T: super::stub::Zones + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get(
        &self,
        req: crate::model::zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        self.inner.get(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list(
        &self,
        req: crate::model::zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        self.inner.list(req, options).await
    }
}
