// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::ListMigrationJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigrationJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListMigrationJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigrationJobsResponse");
        debug_struct.field("migration_jobs", &self.migration_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMigrationJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("migration_job_id", &self.migration_job_id);
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMigrationJobRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StartMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_validation", &self.skip_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StopMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResumeMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PromoteMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PromoteMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VerifyMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migration_job", &self.migration_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RestartMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestartMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_validation", &self.skip_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateSshScriptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateSshScriptRequest");
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("vm", &self.vm);
        debug_struct.field("vm_port", &self.vm_port);
        debug_struct.field("vm_config", &self.vm_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VmCreationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmCreationConfig");
        debug_struct.field("vm_machine_type", &self.vm_machine_type);
        debug_struct.field("vm_zone", &self.vm_zone);
        debug_struct.field("subnet", &self.subnet);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VmSelectionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmSelectionConfig");
        debug_struct.field("vm_zone", &self.vm_zone);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SshScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SshScript");
        debug_struct.field("script", &self.script);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GenerateTcpProxyScriptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateTcpProxyScriptRequest");
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("vm_machine_type", &self.vm_machine_type);
        debug_struct.field("vm_zone", &self.vm_zone);
        debug_struct.field("vm_subnet", &self.vm_subnet);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TcpProxyScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TcpProxyScript");
        debug_struct.field("script", &self.script);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionProfilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionProfilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesResponse");
        debug_struct.field("connection_profiles", &self.connection_profiles);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionProfileRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionProfileRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_profile_id", &self.connection_profile_id);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("skip_validation", &self.skip_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionProfileRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("skip_validation", &self.skip_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionProfileRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreatePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePrivateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("private_connection_id", &self.private_connection_id);
        debug_struct.field("private_connection", &self.private_connection);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("skip_validation", &self.skip_validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListPrivateConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListPrivateConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsResponse");
        debug_struct.field("private_connections", &self.private_connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeletePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePrivateConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetPrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPrivateConnectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConversionWorkspacesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversionWorkspacesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConversionWorkspacesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversionWorkspacesResponse");
        debug_struct.field("conversion_workspaces", &self.conversion_workspaces);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConversionWorkspaceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("conversion_workspace_id", &self.conversion_workspace_id);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConversionWorkspaceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CommitConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommitConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("commit_name", &self.commit_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RollbackConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApplyConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplyConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListMappingRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMappingRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListMappingRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMappingRulesResponse");
        debug_struct.field("mapping_rules", &self.mapping_rules);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMappingRuleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SeedConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeedConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("seed_from", &self.seed_from);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConvertConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConvertConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("convert_full_path", &self.convert_full_path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ImportMappingRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportMappingRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("rules_format", &self.rules_format);
        debug_struct.field("rules_files", &self.rules_files);
        debug_struct.field("auto_commit", &self.auto_commit);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::import_mapping_rules_request::RulesFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RulesFile");
        debug_struct.field("rules_source_filename", &self.rules_source_filename);
        debug_struct.field("rules_content", &self.rules_content);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DescribeDatabaseEntitiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeDatabaseEntitiesRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("tree", &self.tree);
        debug_struct.field("uncommitted", &self.uncommitted);
        debug_struct.field("commit_id", &self.commit_id);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DescribeDatabaseEntitiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeDatabaseEntitiesResponse");
        debug_struct.field("database_entities", &self.database_entities);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchBackgroundJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchBackgroundJobsRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field(
            "return_most_recent_per_job_type",
            &self.return_most_recent_per_job_type,
        );
        debug_struct.field("max_size", &self.max_size);
        debug_struct.field("completed_until_time", &self.completed_until_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SearchBackgroundJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchBackgroundJobsResponse");
        debug_struct.field("jobs", &self.jobs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DescribeConversionWorkspaceRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeConversionWorkspaceRevisionsRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("commit_id", &self.commit_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DescribeConversionWorkspaceRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeConversionWorkspaceRevisionsResponse");
        debug_struct.field("revisions", &self.revisions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMappingRuleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("mapping_rule_id", &self.mapping_rule_id);
        debug_struct.field("mapping_rule", &self.mapping_rule);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMappingRuleRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchStaticIpsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchStaticIpsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsResponse");
        debug_struct.field("static_ips", &self.static_ips);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfig");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("ca_certificate", &self.ca_certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MySqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MySqlConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PostgreSqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgreSqlConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);
        debug_struct.field("network_architecture", &self.network_architecture);
        debug_struct.field("connectivity", &self.connectivity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OracleConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("database_service", &self.database_service);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("connectivity", &self.connectivity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlConnectionProfile");
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);
        debug_struct.field("settings", &self.settings);
        debug_struct.field("private_ip", &self.private_ip);
        debug_struct.field("public_ip", &self.public_ip);
        debug_struct.field("additional_public_ip", &self.additional_public_ip);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AlloyDbConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AlloyDbConnectionProfile");
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("settings", &self.settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlAclEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlAclEntry");
        debug_struct.field("value", &self.value);
        debug_struct.field("label", &self.label);
        debug_struct.field("expiration", &self.expiration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SqlIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlIpConfig");
        debug_struct.field("enable_ipv4", &self.enable_ipv4);
        debug_struct.field("private_network", &self.private_network);
        debug_struct.field("allocated_ip_range", &self.allocated_ip_range);
        debug_struct.field("require_ssl", &self.require_ssl);
        debug_struct.field("authorized_networks", &self.authorized_networks);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudSqlSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlSettings");
        debug_struct.field("database_version", &self.database_version);
        debug_struct.field("user_labels", &self.user_labels);
        debug_struct.field("tier", &self.tier);
        debug_struct.field("storage_auto_resize_limit", &self.storage_auto_resize_limit);
        debug_struct.field("activation_policy", &self.activation_policy);
        debug_struct.field("ip_config", &self.ip_config);
        debug_struct.field("auto_storage_increase", &self.auto_storage_increase);
        debug_struct.field("database_flags", &self.database_flags);
        debug_struct.field("data_disk_type", &self.data_disk_type);
        debug_struct.field("data_disk_size_gb", &self.data_disk_size_gb);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("secondary_zone", &self.secondary_zone);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("root_password", &self.root_password);
        debug_struct.field("root_password_set", &self.root_password_set);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("cmek_key_name", &self.cmek_key_name);
        debug_struct.field("availability_type", &self.availability_type);
        debug_struct.field("edition", &self.edition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AlloyDbSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AlloyDbSettings");
        debug_struct.field("initial_user", &self.initial_user);
        debug_struct.field("vpc_network", &self.vpc_network);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("primary_instance_settings", &self.primary_instance_settings);
        debug_struct.field("encryption_config", &self.encryption_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::alloy_db_settings::UserPassword {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserPassword");
        debug_struct.field("user", &self.user);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::alloy_db_settings::PrimaryInstanceSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrimaryInstanceSettings");
        debug_struct.field("id", &self.id);
        debug_struct.field("machine_config", &self.machine_config);
        debug_struct.field("database_flags", &self.database_flags);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("private_ip", &self.private_ip);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::alloy_db_settings::primary_instance_settings::MachineConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineConfig");
        debug_struct.field("cpu_count", &self.cpu_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::alloy_db_settings::EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("kms_key_name", &self.kms_key_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StaticIpConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticIpConnectivity");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateServiceConnectConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateServiceConnectConnectivity");
        debug_struct.field("service_attachment", &self.service_attachment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReverseSshConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReverseSshConnectivity");
        debug_struct.field("vm_ip", &self.vm_ip);
        debug_struct.field("vm_port", &self.vm_port);
        debug_struct.field("vm", &self.vm);
        debug_struct.field("vpc", &self.vpc);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VpcPeeringConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcPeeringConnectivity");
        debug_struct.field("vpc", &self.vpc);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ForwardSshTunnelConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForwardSshTunnelConnectivity");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("username", &self.username);
        debug_struct.field("port", &self.port);
        debug_struct.field("authentication_method", &self.authentication_method);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StaticServiceIpConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticServiceIpConnectivity");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnectivity");
        debug_struct.field("private_connection", &self.private_connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseType");
        debug_struct.field("provider", &self.provider);
        debug_struct.field("engine", &self.engine);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MigrationJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("phase", &self.phase);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("dump_path", &self.dump_path);
        debug_struct.field("dump_flags", &self.dump_flags);
        debug_struct.field("source", &self.source);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("error", &self.error);
        debug_struct.field("source_database", &self.source_database);
        debug_struct.field("destination_database", &self.destination_database);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("cmek_key_name", &self.cmek_key_name);
        debug_struct.field("performance_config", &self.performance_config);
        debug_struct.field("connectivity", &self.connectivity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::migration_job::DumpFlag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DumpFlag");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::migration_job::DumpFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DumpFlags");
        debug_struct.field("dump_flags", &self.dump_flags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::migration_job::PerformanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PerformanceConfig");
        debug_struct.field("dump_parallel_level", &self.dump_parallel_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConversionWorkspaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversionWorkspaceInfo");
        debug_struct.field("name", &self.name);
        debug_struct.field("commit_id", &self.commit_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionProfile");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state", &self.state);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("error", &self.error);
        debug_struct.field("provider", &self.provider);
        debug_struct.field("connection_profile", &self.connection_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MigrationJobVerificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationJobVerificationError");
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("error_detail_message", &self.error_detail_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("connectivity", &self.connectivity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VpcPeeringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcPeeringConfig");
        debug_struct.field("vpc_name", &self.vpc_name);
        debug_struct.field("subnet", &self.subnet);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseEngineInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEngineInfo");
        debug_struct.field("engine", &self.engine);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConversionWorkspace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversionWorkspace");
        debug_struct.field("name", &self.name);
        debug_struct.field("source", &self.source);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("global_settings", &self.global_settings);
        debug_struct.field("has_uncommitted_changes", &self.has_uncommitted_changes);
        debug_struct.field("latest_commit_id", &self.latest_commit_id);
        debug_struct.field("latest_commit_time", &self.latest_commit_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackgroundJobLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackgroundJobLogEntry");
        debug_struct.field("id", &self.id);
        debug_struct.field("job_type", &self.job_type);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("finish_time", &self.finish_time);
        debug_struct.field("completion_state", &self.completion_state);
        debug_struct.field("completion_comment", &self.completion_comment);
        debug_struct.field("request_autocommit", &self.request_autocommit);
        debug_struct.field("job_details", &self.job_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::background_job_log_entry::SeedJobDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeedJobDetails");
        debug_struct.field("connection_profile", &self.connection_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::background_job_log_entry::ImportRulesJobDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportRulesJobDetails");
        debug_struct.field("files", &self.files);
        debug_struct.field("file_format", &self.file_format);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::background_job_log_entry::ConvertJobDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConvertJobDetails");
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::background_job_log_entry::ApplyJobDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplyJobDetails");
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MappingRuleFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MappingRuleFilter");
        debug_struct.field("parent_entity", &self.parent_entity);
        debug_struct.field("entity_name_prefix", &self.entity_name_prefix);
        debug_struct.field("entity_name_suffix", &self.entity_name_suffix);
        debug_struct.field("entity_name_contains", &self.entity_name_contains);
        debug_struct.field("entities", &self.entities);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MappingRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MappingRule");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("rule_scope", &self.rule_scope);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("rule_order", &self.rule_order);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("revision_create_time", &self.revision_create_time);
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SingleEntityRename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SingleEntityRename");
        debug_struct.field("new_name", &self.new_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MultiEntityRename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiEntityRename");
        debug_struct.field("new_name_pattern", &self.new_name_pattern);
        debug_struct.field(
            "source_name_transformation",
            &self.source_name_transformation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EntityMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMove");
        debug_struct.field("new_schema", &self.new_schema);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SingleColumnChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SingleColumnChange");
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("charset", &self.charset);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field(
            "fractional_seconds_precision",
            &self.fractional_seconds_precision,
        );
        debug_struct.field("array", &self.array);
        debug_struct.field("array_length", &self.array_length);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("auto_generated", &self.auto_generated);
        debug_struct.field("udt", &self.udt);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("set_values", &self.set_values);
        debug_struct.field("comment", &self.comment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MultiColumnDatatypeChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiColumnDatatypeChange");
        debug_struct.field("source_data_type_filter", &self.source_data_type_filter);
        debug_struct.field("new_data_type", &self.new_data_type);
        debug_struct.field("override_length", &self.override_length);
        debug_struct.field("override_scale", &self.override_scale);
        debug_struct.field("override_precision", &self.override_precision);
        debug_struct.field(
            "override_fractional_seconds_precision",
            &self.override_fractional_seconds_precision,
        );
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("source_filter", &self.source_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceTextFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceTextFilter");
        debug_struct.field("source_min_length_filter", &self.source_min_length_filter);
        debug_struct.field("source_max_length_filter", &self.source_max_length_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceNumericFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceNumericFilter");
        debug_struct.field("source_min_scale_filter", &self.source_min_scale_filter);
        debug_struct.field("source_max_scale_filter", &self.source_max_scale_filter);
        debug_struct.field(
            "source_min_precision_filter",
            &self.source_min_precision_filter,
        );
        debug_struct.field(
            "source_max_precision_filter",
            &self.source_max_precision_filter,
        );
        debug_struct.field("numeric_filter_option", &self.numeric_filter_option);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConditionalColumnSetValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConditionalColumnSetValue");
        debug_struct.field("value_transformation", &self.value_transformation);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("source_filter", &self.source_filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ValueTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueTransformation");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("action", &self.action);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConvertRowIdToColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConvertRowIdToColumn");
        debug_struct.field("only_if_no_primary_key", &self.only_if_no_primary_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetTablePrimaryKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetTablePrimaryKey");
        debug_struct.field("primary_key_columns", &self.primary_key_columns);
        debug_struct.field("primary_key", &self.primary_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SinglePackageChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SinglePackageChange");
        debug_struct.field("package_description", &self.package_description);
        debug_struct.field("package_body", &self.package_body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceSqlChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceSqlChange");
        debug_struct.field("sql_code", &self.sql_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FilterTableColumns {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FilterTableColumns");
        debug_struct.field("include_columns", &self.include_columns);
        debug_struct.field("exclude_columns", &self.exclude_columns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ValueListFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueListFilter");
        debug_struct.field("value_present_list", &self.value_present_list);
        debug_struct.field("values", &self.values);
        debug_struct.field("ignore_case", &self.ignore_case);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IntComparisonFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntComparisonFilter");
        debug_struct.field("value_comparison", &self.value_comparison);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DoubleComparisonFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleComparisonFilter");
        debug_struct.field("value_comparison", &self.value_comparison);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AssignSpecificValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssignSpecificValue");
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ApplyHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplyHash");
        debug_struct.field("hash_function", &self.hash_function);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RoundToScale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoundToScale");
        debug_struct.field("scale", &self.scale);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEntity");
        debug_struct.field("short_name", &self.short_name);
        debug_struct.field("parent_entity", &self.parent_entity);
        debug_struct.field("tree", &self.tree);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("mappings", &self.mappings);
        debug_struct.field("entity_ddl", &self.entity_ddl);
        debug_struct.field("issues", &self.issues);
        debug_struct.field("entity_body", &self.entity_body);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseInstanceEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseInstanceEntity");
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SchemaEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaEntity");
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TableEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableEntity");
        debug_struct.field("columns", &self.columns);
        debug_struct.field("constraints", &self.constraints);
        debug_struct.field("indices", &self.indices);
        debug_struct.field("triggers", &self.triggers);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("comment", &self.comment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ColumnEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColumnEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("charset", &self.charset);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field(
            "fractional_seconds_precision",
            &self.fractional_seconds_precision,
        );
        debug_struct.field("array", &self.array);
        debug_struct.field("array_length", &self.array_length);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("auto_generated", &self.auto_generated);
        debug_struct.field("udt", &self.udt);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("set_values", &self.set_values);
        debug_struct.field("comment", &self.comment);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        debug_struct.field("default_value", &self.default_value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConstraintEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConstraintEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("table_columns", &self.table_columns);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("reference_columns", &self.reference_columns);
        debug_struct.field("reference_table", &self.reference_table);
        debug_struct.field("table_name", &self.table_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IndexEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndexEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("table_columns", &self.table_columns);
        debug_struct.field("unique", &self.unique);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TriggerEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TriggerEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("triggering_events", &self.triggering_events);
        debug_struct.field("trigger_type", &self.trigger_type);
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ViewEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ViewEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("constraints", &self.constraints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SequenceEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SequenceEntity");
        debug_struct.field("increment", &self.increment);
        debug_struct.field("start_value", &self.start_value);
        debug_struct.field("max_value", &self.max_value);
        debug_struct.field("min_value", &self.min_value);
        debug_struct.field("cycle", &self.cycle);
        debug_struct.field("cache", &self.cache);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StoredProcedureEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StoredProcedureEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FunctionEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FunctionEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaterializedViewEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedViewEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SynonymEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SynonymEntity");
        debug_struct.field("source_entity", &self.source_entity);
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PackageEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PackageEntity");
        debug_struct.field("package_sql_code", &self.package_sql_code);
        debug_struct.field("package_body", &self.package_body);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UDTEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UDTEntity");
        debug_struct.field("udt_sql_code", &self.udt_sql_code);
        debug_struct.field("udt_body", &self.udt_body);
        debug_struct.field("custom_features", &self.custom_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EntityMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMapping");
        debug_struct.field("source_entity", &self.source_entity);
        debug_struct.field("draft_entity", &self.draft_entity);
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("draft_type", &self.draft_type);
        debug_struct.field("mapping_log", &self.mapping_log);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EntityMappingLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMappingLogEntry");
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("rule_revision_id", &self.rule_revision_id);
        debug_struct.field("mapping_comment", &self.mapping_comment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EntityDdl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityDdl");
        debug_struct.field("ddl_type", &self.ddl_type);
        debug_struct.field("entity", &self.entity);
        debug_struct.field("ddl", &self.ddl);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("issue_id", &self.issue_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EntityIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityIssue");
        debug_struct.field("id", &self.id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("message", &self.message);
        debug_struct.field("code", &self.code);
        debug_struct.field("ddl", &self.ddl);
        debug_struct.field("position", &self.position);
        debug_struct.field("entity_type", &self.entity_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::entity_issue::Position {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Position");
        debug_struct.field("line", &self.line);
        debug_struct.field("column", &self.column);
        debug_struct.field("offset", &self.offset);
        debug_struct.field("length", &self.length);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
