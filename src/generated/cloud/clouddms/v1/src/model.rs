// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Retrieves a list of all migration jobs in a given project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationJobsRequest {
    /// Required. The parent which owns this collection of migrationJobs.
    pub parent: std::string::String,

    /// The maximum number of migration jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 migration jobs will be
    /// returned. The maximum value is 1000; values above 1000 are coerced to
    /// 1000.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// migrationJobs.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to migrationJobs.list must match the call
    /// that provided the page token.
    pub page_token: std::string::String,

    /// A filter expression that filters migration jobs listed in the response.
    /// The expression must specify the field name, a comparison operator, and the
    /// value that you want to use for filtering. The value must be a string,
    /// a number, or a boolean. The comparison operator must be
    /// either =, !=, >, or <. For example, list migration jobs created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.**
    /// You can also filter nested fields. For example, you could specify
    /// **reverseSshConnectivity.vmIp = "1.2.3.4"** to select all migration
    /// jobs connecting through the specific SSH tunnel bastion.
    pub filter: std::string::String,

    /// Sort the results based on the migration job name.
    /// Valid values are: "name", "name asc", and "name desc".
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigrationJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigrationJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigrationJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigrationJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListMigrationJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigrationJobsResponse {
    /// The list of migration jobs objects.
    pub migration_jobs: std::vec::Vec<crate::model::MigrationJob>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_jobs][crate::model::ListMigrationJobsResponse::migration_jobs].
    pub fn set_migration_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationJob>,
    {
        use std::iter::Iterator;
        self.migration_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigrationJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationJobsResponse {
    type PageItem = crate::model::MigrationJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigrationJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigrationJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationJobs" => Ok(__FieldTag::__migration_jobs),
                            "migration_jobs" => Ok(__FieldTag::__migration_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigrationJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigrationJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_jobs => {
                            if !fields.insert(__FieldTag::__migration_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_jobs",
                                ));
                            }
                            result.migration_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MigrationJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigrationJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migration_jobs.is_empty() {
            state.serialize_entry("migrationJobs", &self.migration_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigrationJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigrationJobsResponse");
        debug_struct.field("migration_jobs", &self.migration_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMigrationJobRequest {
    /// Required. Name of the migration job resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMigrationJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to create a new Database Migration Service migration job
/// in the specified project and region.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMigrationJobRequest {
    /// Required. The parent which owns this collection of migration jobs.
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.
    pub migration_job_id: std::string::String,

    /// Required. Represents a [migration
    /// job](https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs)
    /// object.
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigrationJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migration_job_id][crate::model::CreateMigrationJobRequest::migration_job_id].
    pub fn set_migration_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job_id = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::CreateMigrationJobRequest::migration_job].
    pub fn set_migration_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migration_job][crate::model::CreateMigrationJobRequest::migration_job].
    pub fn set_or_clear_migration_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __migration_job_id,
            __migration_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "migrationJobId" => Ok(__FieldTag::__migration_job_id),
                            "migration_job_id" => Ok(__FieldTag::__migration_job_id),
                            "migrationJob" => Ok(__FieldTag::__migration_job),
                            "migration_job" => Ok(__FieldTag::__migration_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migration_job_id => {
                            if !fields.insert(__FieldTag::__migration_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job_id",
                                ));
                            }
                            result.migration_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migration_job => {
                            if !fields.insert(__FieldTag::__migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job",
                                ));
                            }
                            result.migration_job = map
                                .next_value::<std::option::Option<crate::model::MigrationJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.migration_job_id.is_empty() {
            state.serialize_entry("migrationJobId", &self.migration_job_id)?;
        }
        if self.migration_job.is_some() {
            state.serialize_entry("migrationJob", &self.migration_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMigrationJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("migration_job_id", &self.migration_job_id);
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMigrationJobRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The migration job parameters to update.
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigrationJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMigrationJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migration_job][crate::model::UpdateMigrationJobRequest::migration_job].
    pub fn set_migration_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migration_job][crate::model::UpdateMigrationJobRequest::migration_job].
    pub fn set_or_clear_migration_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __migration_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "migrationJob" => Ok(__FieldTag::__migration_job),
                            "migration_job" => Ok(__FieldTag::__migration_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__migration_job => {
                            if !fields.insert(__FieldTag::__migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job",
                                ));
                            }
                            result.migration_job = map
                                .next_value::<std::option::Option<crate::model::MigrationJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.migration_job.is_some() {
            state.serialize_entry("migrationJob", &self.migration_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMigrationJobRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMigrationJobRequest {
    /// Required. Name of the migration job resource to delete.
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// The destination CloudSQL connection profile is always deleted with the
    /// migration job. In case of force delete, the destination CloudSQL replica
    /// database is also deleted.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteMigrationJobRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'StartMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationJobRequest {
    /// Name of the migration job resource to start.
    pub name: std::string::String,

    /// Optional. Start the migration job without running prior configuration
    /// verification. Defaults to `false`.
    pub skip_validation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::StartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StartMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __skip_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "skipValidation" => Ok(__FieldTag::__skip_validation),
                            "skip_validation" => Ok(__FieldTag::__skip_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_validation => {
                            if !fields.insert(__FieldTag::__skip_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_validation",
                                ));
                            }
                            result.skip_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.skip_validation) {
            state.serialize_entry("skipValidation", &self.skip_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_validation", &self.skip_validation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'StopMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StopMigrationJobRequest {
    /// Name of the migration job resource to stop.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StopMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StopMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopMigrationJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ResumeMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeMigrationJobRequest {
    /// Name of the migration job resource to resume.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ResumeMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'PromoteMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PromoteMigrationJobRequest {
    /// Name of the migration job resource to promote.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PromoteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PromoteMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PromoteMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PromoteMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PromoteMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PromoteMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PromoteMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PromoteMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PromoteMigrationJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'VerifyMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyMigrationJobRequest {
    /// Name of the migration job resource to verify.
    pub name: std::string::String,

    /// Optional. Field mask is used to specify the changed fields to be verified.
    /// It will not update the migration job.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The changed migration job parameters to verify.
    /// It will not update the migration job.
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::VerifyMigrationJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::VerifyMigrationJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migration_job][crate::model::VerifyMigrationJobRequest::migration_job].
    pub fn set_migration_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migration_job][crate::model::VerifyMigrationJobRequest::migration_job].
    pub fn set_or_clear_migration_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigrationJob>,
    {
        self.migration_job = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VerifyMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VerifyMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __update_mask,
            __migration_job,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "migrationJob" => Ok(__FieldTag::__migration_job),
                            "migration_job" => Ok(__FieldTag::__migration_job),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__migration_job => {
                            if !fields.insert(__FieldTag::__migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job",
                                ));
                            }
                            result.migration_job = map
                                .next_value::<std::option::Option<crate::model::MigrationJob>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.migration_job.is_some() {
            state.serialize_entry("migrationJob", &self.migration_job)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerifyMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerifyMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migration_job", &self.migration_job);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'RestartMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RestartMigrationJobRequest {
    /// Name of the migration job resource to restart.
    pub name: std::string::String,

    /// Optional. Restart the migration job without running prior configuration
    /// verification. Defaults to `false`.
    pub skip_validation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::RestartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for RestartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RestartMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestartMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __skip_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestartMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "skipValidation" => Ok(__FieldTag::__skip_validation),
                            "skip_validation" => Ok(__FieldTag::__skip_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestartMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestartMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_validation => {
                            if !fields.insert(__FieldTag::__skip_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_validation",
                                ));
                            }
                            result.skip_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestartMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.skip_validation) {
            state.serialize_entry("skipValidation", &self.skip_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RestartMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RestartMigrationJobRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("skip_validation", &self.skip_validation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GenerateSshScript' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateSshScriptRequest {
    /// Name of the migration job resource to generate the SSH script.
    pub migration_job: std::string::String,

    /// Required. Bastion VM Instance name to use or to create.
    pub vm: std::string::String,

    /// The port that will be open on the bastion host.
    pub vm_port: i32,

    /// The VM configuration
    pub vm_config: std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateSshScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateSshScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::GenerateSshScriptRequest::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::GenerateSshScriptRequest::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config].
    ///
    /// Note that all the setters affecting `vm_config` are mutually
    /// exclusive.
    pub fn set_vm_config<
        T: std::convert::Into<
                std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = v.into();
        self
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmCreationConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v.into()),
        );
        self
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmSelectionConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_selection_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmSelectionConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmSelectionConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_selection_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmSelectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GenerateSshScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateSshScriptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateSshScriptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_job,
            __vm,
            __vm_creation_config,
            __vm_selection_config,
            __vm_port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateSshScriptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationJob" => Ok(__FieldTag::__migration_job),
                            "migration_job" => Ok(__FieldTag::__migration_job),
                            "vm" => Ok(__FieldTag::__vm),
                            "vmCreationConfig" => Ok(__FieldTag::__vm_creation_config),
                            "vm_creation_config" => Ok(__FieldTag::__vm_creation_config),
                            "vmSelectionConfig" => Ok(__FieldTag::__vm_selection_config),
                            "vm_selection_config" => Ok(__FieldTag::__vm_selection_config),
                            "vmPort" => Ok(__FieldTag::__vm_port),
                            "vm_port" => Ok(__FieldTag::__vm_port),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateSshScriptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateSshScriptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_job => {
                            if !fields.insert(__FieldTag::__migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job",
                                ));
                            }
                            result.migration_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm => {
                            if !fields.insert(__FieldTag::__vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm",
                                ));
                            }
                            result.vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_creation_config => {
                            if !fields.insert(__FieldTag::__vm_creation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_creation_config",
                                ));
                            }
                            if result.vm_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_config`, a oneof with full ID .google.cloud.clouddms.v1.GenerateSshScriptRequest.vm_creation_config, latest field was vmCreationConfig",
                                ));
                            }
                            result.vm_config = std::option::Option::Some(
                                crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VmCreationConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vm_selection_config => {
                            if !fields.insert(__FieldTag::__vm_selection_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_selection_config",
                                ));
                            }
                            if result.vm_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_config`, a oneof with full ID .google.cloud.clouddms.v1.GenerateSshScriptRequest.vm_selection_config, latest field was vmSelectionConfig",
                                ));
                            }
                            result.vm_config = std::option::Option::Some(
                                crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::VmSelectionConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vm_port => {
                            if !fields.insert(__FieldTag::__vm_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateSshScriptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migration_job.is_empty() {
            state.serialize_entry("migrationJob", &self.migration_job)?;
        }
        if !self.vm.is_empty() {
            state.serialize_entry("vm", &self.vm)?;
        }
        if let Some(value) = self.vm_creation_config() {
            state.serialize_entry("vmCreationConfig", value)?;
        }
        if let Some(value) = self.vm_selection_config() {
            state.serialize_entry("vmSelectionConfig", value)?;
        }
        if !wkt::internal::is_default(&self.vm_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vmPort", &__With(&self.vm_port))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateSshScriptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateSshScriptRequest");
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("vm", &self.vm);
        debug_struct.field("vm_port", &self.vm_port);
        debug_struct.field("vm_config", &self.vm_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GenerateSshScriptRequest].
pub mod generate_ssh_script_request {
    #[allow(unused_imports)]
    use super::*;

    /// The VM configuration
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmConfig {
        /// The VM creation configuration
        VmCreationConfig(std::boxed::Box<crate::model::VmCreationConfig>),
        /// The VM selection configuration
        VmSelectionConfig(std::boxed::Box<crate::model::VmSelectionConfig>),
    }
}

/// VM creation configuration message
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmCreationConfig {
    /// Required. VM instance machine type to create.
    pub vm_machine_type: std::string::String,

    /// The Google Cloud Platform zone to create the VM in.
    pub vm_zone: std::string::String,

    /// The subnet name the vm needs to be created in.
    pub subnet: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_machine_type][crate::model::VmCreationConfig::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::VmCreationConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VmCreationConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VmCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmCreationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmCreationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_machine_type,
            __vm_zone,
            __subnet,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmCreationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmMachineType" => Ok(__FieldTag::__vm_machine_type),
                            "vm_machine_type" => Ok(__FieldTag::__vm_machine_type),
                            "vmZone" => Ok(__FieldTag::__vm_zone),
                            "vm_zone" => Ok(__FieldTag::__vm_zone),
                            "subnet" => Ok(__FieldTag::__subnet),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmCreationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmCreationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_machine_type => {
                            if !fields.insert(__FieldTag::__vm_machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_machine_type",
                                ));
                            }
                            result.vm_machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_zone => {
                            if !fields.insert(__FieldTag::__vm_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_zone",
                                ));
                            }
                            result.vm_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet",
                                ));
                            }
                            result.subnet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmCreationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_machine_type.is_empty() {
            state.serialize_entry("vmMachineType", &self.vm_machine_type)?;
        }
        if !self.vm_zone.is_empty() {
            state.serialize_entry("vmZone", &self.vm_zone)?;
        }
        if !self.subnet.is_empty() {
            state.serialize_entry("subnet", &self.subnet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmCreationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmCreationConfig");
        debug_struct.field("vm_machine_type", &self.vm_machine_type);
        debug_struct.field("vm_zone", &self.vm_zone);
        debug_struct.field("subnet", &self.subnet);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VM selection configuration message
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmSelectionConfig {
    /// Required. The Google Cloud Platform zone the VM is located.
    pub vm_zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmSelectionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_zone][crate::model::VmSelectionConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }
}

impl wkt::message::Message for VmSelectionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmSelectionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmSelectionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmSelectionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmZone" => Ok(__FieldTag::__vm_zone),
                            "vm_zone" => Ok(__FieldTag::__vm_zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmSelectionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmSelectionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_zone => {
                            if !fields.insert(__FieldTag::__vm_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_zone",
                                ));
                            }
                            result.vm_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmSelectionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_zone.is_empty() {
            state.serialize_entry("vmZone", &self.vm_zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmSelectionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmSelectionConfig");
        debug_struct.field("vm_zone", &self.vm_zone);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'GenerateSshScript' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SshScript {
    /// The ssh configuration script.
    pub script: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SshScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::SshScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for SshScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SshScript"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SshScript {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __script,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SshScript")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "script" => Ok(__FieldTag::__script),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SshScript;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SshScript")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SshScript {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.script.is_empty() {
            state.serialize_entry("script", &self.script)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SshScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SshScript");
        debug_struct.field("script", &self.script);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GenerateTcpProxyScript' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateTcpProxyScriptRequest {
    /// Name of the migration job resource to generate the TCP Proxy script.
    pub migration_job: std::string::String,

    /// Required. The name of the Compute instance that will host the proxy.
    pub vm_name: std::string::String,

    /// Required. The type of the Compute instance that will host the proxy.
    pub vm_machine_type: std::string::String,

    /// Optional. The Google Cloud Platform zone to create the VM in. The fully
    /// qualified name of the zone must be specified, including the region name,
    /// for example "us-central1-b". If not specified, uses the "-b" zone of the
    /// destination Connection Profile's region.
    pub vm_zone: std::string::String,

    /// Required. The name of the subnet the Compute instance will use for private
    /// connectivity. Must be supplied in the form of
    /// projects/{project}/regions/{region}/subnetworks/{subnetwork}.
    /// Note: the region for the subnet must match the Compute instance region.
    pub vm_subnet: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateTcpProxyScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateTcpProxyScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::GenerateTcpProxyScriptRequest::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_machine_type][crate::model::GenerateTcpProxyScriptRequest::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::GenerateTcpProxyScriptRequest::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [vm_subnet][crate::model::GenerateTcpProxyScriptRequest::vm_subnet].
    pub fn set_vm_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_subnet = v.into();
        self
    }
}

impl wkt::message::Message for GenerateTcpProxyScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateTcpProxyScriptRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateTcpProxyScriptRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migration_job,
            __vm_name,
            __vm_machine_type,
            __vm_zone,
            __vm_subnet,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateTcpProxyScriptRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migrationJob" => Ok(__FieldTag::__migration_job),
                            "migration_job" => Ok(__FieldTag::__migration_job),
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "vmMachineType" => Ok(__FieldTag::__vm_machine_type),
                            "vm_machine_type" => Ok(__FieldTag::__vm_machine_type),
                            "vmZone" => Ok(__FieldTag::__vm_zone),
                            "vm_zone" => Ok(__FieldTag::__vm_zone),
                            "vmSubnet" => Ok(__FieldTag::__vm_subnet),
                            "vm_subnet" => Ok(__FieldTag::__vm_subnet),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateTcpProxyScriptRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateTcpProxyScriptRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migration_job => {
                            if !fields.insert(__FieldTag::__migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_job",
                                ));
                            }
                            result.migration_job = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_machine_type => {
                            if !fields.insert(__FieldTag::__vm_machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_machine_type",
                                ));
                            }
                            result.vm_machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_zone => {
                            if !fields.insert(__FieldTag::__vm_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_zone",
                                ));
                            }
                            result.vm_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_subnet => {
                            if !fields.insert(__FieldTag::__vm_subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_subnet",
                                ));
                            }
                            result.vm_subnet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateTcpProxyScriptRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migration_job.is_empty() {
            state.serialize_entry("migrationJob", &self.migration_job)?;
        }
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.vm_machine_type.is_empty() {
            state.serialize_entry("vmMachineType", &self.vm_machine_type)?;
        }
        if !self.vm_zone.is_empty() {
            state.serialize_entry("vmZone", &self.vm_zone)?;
        }
        if !self.vm_subnet.is_empty() {
            state.serialize_entry("vmSubnet", &self.vm_subnet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateTcpProxyScriptRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateTcpProxyScriptRequest");
        debug_struct.field("migration_job", &self.migration_job);
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("vm_machine_type", &self.vm_machine_type);
        debug_struct.field("vm_zone", &self.vm_zone);
        debug_struct.field("vm_subnet", &self.vm_subnet);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'GenerateTcpProxyScript' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TcpProxyScript {
    /// The TCP Proxy configuration script.
    pub script: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TcpProxyScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::TcpProxyScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for TcpProxyScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TcpProxyScript"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TcpProxyScript {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __script,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TcpProxyScript")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "script" => Ok(__FieldTag::__script),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TcpProxyScript;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TcpProxyScript")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__script => {
                            if !fields.insert(__FieldTag::__script) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script",
                                ));
                            }
                            result.script = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TcpProxyScript {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.script.is_empty() {
            state.serialize_entry("script", &self.script)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TcpProxyScript {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TcpProxyScript");
        debug_struct.field("script", &self.script);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListConnectionProfiles' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionProfilesRequest {
    /// Required. The parent which owns this collection of connection profiles.
    pub parent: std::string::String,

    /// The maximum number of connection profiles to return. The service may return
    /// fewer than this value. If unspecified, at most 50 connection profiles will
    /// be returned. The maximum value is 1000; values above 1000 are coerced
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListConnectionProfiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectionProfiles`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// A filter expression that filters connection profiles listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list connection profiles created this year by
    /// specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z**. You can
    /// also filter nested fields. For example, you could specify **mySql.username
    /// = %lt;my_username%gt;** to list all connection profiles configured to
    /// connect with a specific username.
    pub filter: std::string::String,

    /// A comma-separated list of fields to order results according to.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionProfilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListConnectionProfiles' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConnectionProfilesResponse {
    /// The response list of connection profiles.
    pub connection_profiles: std::vec::Vec<crate::model::ConnectionProfile>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_profiles][crate::model::ListConnectionProfilesResponse::connection_profiles].
    pub fn set_connection_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProfile>,
    {
        use std::iter::Iterator;
        self.connection_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionProfilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionProfilesResponse {
    type PageItem = crate::model::ConnectionProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connection_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConnectionProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connection_profiles,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConnectionProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connectionProfiles" => Ok(__FieldTag::__connection_profiles),
                            "connection_profiles" => Ok(__FieldTag::__connection_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConnectionProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConnectionProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connection_profiles => {
                            if !fields.insert(__FieldTag::__connection_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profiles",
                                ));
                            }
                            result.connection_profiles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConnectionProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connection_profiles.is_empty() {
            state.serialize_entry("connectionProfiles", &self.connection_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConnectionProfilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionProfilesResponse");
        debug_struct.field("connection_profiles", &self.connection_profiles);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetConnectionProfile' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConnectionProfileRequest {
    /// Required. Name of the connection profile resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionProfileRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateConnectionProfile' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConnectionProfileRequest {
    /// Required. The parent which owns this collection of connection profiles.
    pub parent: std::string::String,

    /// Required. The connection profile identifier.
    pub connection_profile_id: std::string::String,

    /// Required. The create request body including the connection profile data
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't create any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    pub validate_only: bool,

    /// Optional. Create the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    pub skip_validation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_profile_id][crate::model::CreateConnectionProfileRequest::connection_profile_id].
    pub fn set_connection_profile_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile_id = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __connection_profile_id,
            __connection_profile,
            __request_id,
            __validate_only,
            __skip_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "connectionProfileId" => Ok(__FieldTag::__connection_profile_id),
                            "connection_profile_id" => Ok(__FieldTag::__connection_profile_id),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "skipValidation" => Ok(__FieldTag::__skip_validation),
                            "skip_validation" => Ok(__FieldTag::__skip_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile_id => {
                            if !fields.insert(__FieldTag::__connection_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile_id",
                                ));
                            }
                            result.connection_profile_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            result.connection_profile = map
                                .next_value::<std::option::Option<crate::model::ConnectionProfile>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_validation => {
                            if !fields.insert(__FieldTag::__skip_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_validation",
                                ));
                            }
                            result.skip_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.connection_profile_id.is_empty() {
            state.serialize_entry("connectionProfileId", &self.connection_profile_id)?;
        }
        if self.connection_profile.is_some() {
            state.serialize_entry("connectionProfile", &self.connection_profile)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.skip_validation) {
            state.serialize_entry("skipValidation", &self.skip_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionProfileRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_profile_id", &self.connection_profile_id);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("skip_validation", &self.skip_validation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateConnectionProfile' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConnectionProfileRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connection profile parameters to update.
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't update any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    pub validate_only: bool,

    /// Optional. Update the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    pub skip_validation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_or_clear_connection_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConnectionProfile>,
    {
        self.connection_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::UpdateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __connection_profile,
            __request_id,
            __validate_only,
            __skip_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "skipValidation" => Ok(__FieldTag::__skip_validation),
                            "skip_validation" => Ok(__FieldTag::__skip_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            result.connection_profile = map
                                .next_value::<std::option::Option<crate::model::ConnectionProfile>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_validation => {
                            if !fields.insert(__FieldTag::__skip_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_validation",
                                ));
                            }
                            result.skip_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.connection_profile.is_some() {
            state.serialize_entry("connectionProfile", &self.connection_profile)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.skip_validation) {
            state.serialize_entry("skipValidation", &self.skip_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionProfileRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("connection_profile", &self.connection_profile);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("skip_validation", &self.skip_validation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteConnectionProfile' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConnectionProfileRequest {
    /// Required. Name of the connection profile resource to delete.
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// In case of force delete, the CloudSQL replica database is also deleted
    /// (only for CloudSQL connection profile).
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConnectionProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConnectionProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConnectionProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConnectionProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConnectionProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConnectionProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConnectionProfileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionProfileRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to create a new private connection in the specified project
/// and region.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The parent that owns the collection of PrivateConnections.
    pub parent: std::string::String,

    /// Required. The private connection identifier.
    pub private_connection_id: std::string::String,

    /// Required. The private connection resource to create.
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// Optional. If set to true, will skip validations.
    pub skip_validation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_or_clear_private_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateConnection>,
    {
        self.private_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreatePrivateConnectionRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreatePrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __private_connection_id,
            __private_connection,
            __request_id,
            __skip_validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "privateConnectionId" => Ok(__FieldTag::__private_connection_id),
                            "private_connection_id" => Ok(__FieldTag::__private_connection_id),
                            "privateConnection" => Ok(__FieldTag::__private_connection),
                            "private_connection" => Ok(__FieldTag::__private_connection),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "skipValidation" => Ok(__FieldTag::__skip_validation),
                            "skip_validation" => Ok(__FieldTag::__skip_validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_connection_id => {
                            if !fields.insert(__FieldTag::__private_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection_id",
                                ));
                            }
                            result.private_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_connection => {
                            if !fields.insert(__FieldTag::__private_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection",
                                ));
                            }
                            result.private_connection = map
                                .next_value::<std::option::Option<crate::model::PrivateConnection>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_validation => {
                            if !fields.insert(__FieldTag::__skip_validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_validation",
                                ));
                            }
                            result.skip_validation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatePrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.private_connection_id.is_empty() {
            state.serialize_entry("privateConnectionId", &self.private_connection_id)?;
        }
        if self.private_connection.is_some() {
            state.serialize_entry("privateConnection", &self.private_connection)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.skip_validation) {
            state.serialize_entry("skipValidation", &self.skip_validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatePrivateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("private_connection_id", &self.private_connection_id);
        debug_struct.field("private_connection", &self.private_connection);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("skip_validation", &self.skip_validation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to retrieve a list of private connections in a given project
/// and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The parent that owns the collection of private connections.
    pub parent: std::string::String,

    /// Maximum number of private connections to return.
    /// If unspecified, at most 50 private connections that are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// A filter expression that filters private connections listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list private connections created this year by
    /// specifying **createTime %gt; 2021-01-01T00:00:00.000000000Z**.
    pub filter: std::string::String,

    /// Order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPrivateConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPrivateConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPrivateConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPrivateConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPrivateConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPrivateConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListPrivateConnections' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// List of private connections.
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPrivateConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPrivateConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateConnections" => Ok(__FieldTag::__private_connections),
                            "private_connections" => Ok(__FieldTag::__private_connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPrivateConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPrivateConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_connections => {
                            if !fields.insert(__FieldTag::__private_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connections",
                                ));
                            }
                            result.private_connections =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PrivateConnection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListPrivateConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_connections.is_empty() {
            state.serialize_entry("privateConnections", &self.private_connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListPrivateConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListPrivateConnectionsResponse");
        debug_struct.field("private_connections", &self.private_connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to delete a private connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The name of the private connection to delete.
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeletePrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeletePrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeletePrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeletePrivateConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to get a private connection resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The name of the private connection to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetPrivateConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPrivateConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPrivateConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPrivateConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPrivateConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetPrivateConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetPrivateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetPrivateConnectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Retrieve a list of all conversion workspaces in a given project and location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversionWorkspacesRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    pub parent: std::string::String,

    /// The maximum number of conversion workspaces to return. The service may
    /// return fewer than this value. If unspecified, at most 50 sets are returned.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// conversionWorkspaces.list, used in the subsequent request to retrieve the
    /// next page of results. On first call this should be left blank. When
    /// paginating, all other parameters provided to conversionWorkspaces.list must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// A filter expression that filters conversion workspaces listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list conversion workspaces created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.** You can
    /// also filter nested fields. For example, you could specify
    /// **source.version = "12.c.1"** to select all conversion workspaces with
    /// source database version equal to 12.c.1.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversionWorkspacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversionWorkspacesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversionWorkspacesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversionWorkspacesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversionWorkspacesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversionWorkspacesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversionWorkspacesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversionWorkspacesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversionWorkspacesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConversionWorkspacesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConversionWorkspacesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversionWorkspacesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListConversionWorkspaces' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversionWorkspacesResponse {
    /// The list of conversion workspace objects.
    pub conversion_workspaces: std::vec::Vec<crate::model::ConversionWorkspace>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversionWorkspacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspaces][crate::model::ListConversionWorkspacesResponse::conversion_workspaces].
    pub fn set_conversion_workspaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.conversion_workspaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversionWorkspacesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConversionWorkspacesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversionWorkspacesResponse {
    type PageItem = crate::model::ConversionWorkspace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversion_workspaces
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversionWorkspacesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversion_workspaces,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversionWorkspacesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversionWorkspaces" => Ok(__FieldTag::__conversion_workspaces),
                            "conversion_workspaces" => Ok(__FieldTag::__conversion_workspaces),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversionWorkspacesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversionWorkspacesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversion_workspaces => {
                            if !fields.insert(__FieldTag::__conversion_workspaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspaces",
                                ));
                            }
                            result.conversion_workspaces = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversionWorkspace>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListConversionWorkspacesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversion_workspaces.is_empty() {
            state.serialize_entry("conversionWorkspaces", &self.conversion_workspaces)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListConversionWorkspacesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConversionWorkspacesResponse");
        debug_struct.field("conversion_workspaces", &self.conversion_workspaces);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to create a new Conversion Workspace
/// in the specified project and region.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversionWorkspaceRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    pub parent: std::string::String,

    /// Required. The ID of the conversion workspace to create.
    pub conversion_workspace_id: std::string::String,

    /// Required. Represents a conversion workspace object.
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversionWorkspaceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversion_workspace_id][crate::model::CreateConversionWorkspaceRequest::conversion_workspace_id].
    pub fn set_conversion_workspace_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace_id = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::CreateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        self.conversion_workspace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversion_workspace][crate::model::CreateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_or_clear_conversion_workspace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        self.conversion_workspace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversion_workspace_id,
            __conversion_workspace,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversionWorkspaceId" => Ok(__FieldTag::__conversion_workspace_id),
                            "conversion_workspace_id" => Ok(__FieldTag::__conversion_workspace_id),
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversion_workspace_id => {
                            if !fields.insert(__FieldTag::__conversion_workspace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace_id",
                                ));
                            }
                            result.conversion_workspace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map.next_value::<std::option::Option<crate::model::ConversionWorkspace>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.conversion_workspace_id.is_empty() {
            state.serialize_entry("conversionWorkspaceId", &self.conversion_workspace_id)?;
        }
        if self.conversion_workspace.is_some() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConversionWorkspaceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("conversion_workspace_id", &self.conversion_workspace_id);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConversionWorkspaceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The conversion workspace parameters to update.
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversionWorkspaceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConversionWorkspaceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::UpdateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        self.conversion_workspace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversion_workspace][crate::model::UpdateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_or_clear_conversion_workspace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        self.conversion_workspace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __conversion_workspace,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map.next_value::<std::option::Option<crate::model::ConversionWorkspace>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.conversion_workspace.is_some() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConversionWorkspaceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to delete.
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// Force delete the conversion workspace, even if there's a running migration
    /// that is using the workspace.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConversionWorkspaceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CommitConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to commit.
    pub name: std::string::String,

    /// Optional. Optional name of the commit.
    pub commit_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_name][crate::model::CommitConversionWorkspaceRequest::commit_name].
    pub fn set_commit_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_name = v.into();
        self
    }
}

impl wkt::message::Message for CommitConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CommitConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __commit_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "commitName" => Ok(__FieldTag::__commit_name),
                            "commit_name" => Ok(__FieldTag::__commit_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_name => {
                            if !fields.insert(__FieldTag::__commit_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_name",
                                ));
                            }
                            result.commit_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.commit_name.is_empty() {
            state.serialize_entry("commitName", &self.commit_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CommitConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommitConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("commit_name", &self.commit_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'RollbackConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to roll back to.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RollbackConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RollbackConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ApplyConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplyConversionWorkspaceRequest {
    /// Required. The name of the conversion workspace resource for which to apply
    /// the draft tree. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub name: std::string::String,

    /// Filter which entities to apply. Leaving this field empty will apply all of
    /// the entities. Supports Google AIP 160 based filtering.
    pub filter: std::string::String,

    /// Optional. Only validates the apply process, but doesn't change the
    /// destination database. Only works for PostgreSQL destination connection
    /// profile.
    pub dry_run: bool,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the apply.
    pub auto_commit: bool,

    /// Which destination to use when applying the conversion workspace.
    pub destination:
        std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ApplyConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::ApplyConversionWorkspaceRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ApplyConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// if it holds a `ConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// to hold a `ConnectionProfile`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ApplyConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplyConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __filter,
            __dry_run,
            __auto_commit,
            __connection_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApplyConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "filter" => Ok(__FieldTag::__filter),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            "autoCommit" => Ok(__FieldTag::__auto_commit),
                            "auto_commit" => Ok(__FieldTag::__auto_commit),
                            "connectionProfile" => Ok(__FieldTag::__connection_profile),
                            "connection_profile" => Ok(__FieldTag::__connection_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplyConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplyConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_commit => {
                            if !fields.insert(__FieldTag::__auto_commit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_commit",
                                ));
                            }
                            result.auto_commit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_profile => {
                            if !fields.insert(__FieldTag::__connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_profile",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.clouddms.v1.ApplyConversionWorkspaceRequest.connection_profile, latest field was connectionProfile",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplyConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.dry_run) {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if !wkt::internal::is_default(&self.auto_commit) {
            state.serialize_entry("autoCommit", &self.auto_commit)?;
        }
        if let Some(value) = self.connection_profile() {
            state.serialize_entry("connectionProfile", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApplyConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplyConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("dry_run", &self.dry_run);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApplyConversionWorkspaceRequest].
pub mod apply_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// Which destination to use when applying the conversion workspace.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        ConnectionProfile(std::string::String),
    }
}

/// Retrieve a list of all mapping rules in a given conversion workspace.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMappingRulesRequest {
    /// Required. Name of the conversion workspace resource whose mapping rules are
    /// listed in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub parent: std::string::String,

    /// The maximum number of rules to return. The service may return
    /// fewer than this value.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// mappingRules.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to mappingRules.list must match the call
    /// that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMappingRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMappingRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMappingRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMappingRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMappingRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMappingRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMappingRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMappingRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMappingRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListMappingRulesRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMappingRulesResponse {
    /// The list of conversion workspace mapping rules.
    pub mapping_rules: std::vec::Vec<crate::model::MappingRule>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMappingRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mapping_rules][crate::model::ListMappingRulesResponse::mapping_rules].
    pub fn set_mapping_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MappingRule>,
    {
        use std::iter::Iterator;
        self.mapping_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMappingRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMappingRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMappingRulesResponse {
    type PageItem = crate::model::MappingRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.mapping_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMappingRulesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mapping_rules,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMappingRulesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mappingRules" => Ok(__FieldTag::__mapping_rules),
                            "mapping_rules" => Ok(__FieldTag::__mapping_rules),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMappingRulesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMappingRulesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mapping_rules => {
                            if !fields.insert(__FieldTag::__mapping_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping_rules",
                                ));
                            }
                            result.mapping_rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MappingRule>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMappingRulesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mapping_rules.is_empty() {
            state.serialize_entry("mappingRules", &self.mapping_rules)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMappingRulesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMappingRulesResponse");
        debug_struct.field("mapping_rules", &self.mapping_rules);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetMappingRule' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMappingRuleRequest {
    /// Required. Name of the mapping rule resource to get.
    /// Example: conversionWorkspaces/123/mappingRules/rule123
    ///
    /// In order to retrieve a previous revision of the mapping rule, also provide
    /// the revision ID.
    /// Example:
    /// conversionWorkspace/123/mappingRules/rule123@c7cfa2a8c7cfa2a8c7cfa2a8c7cfa2a8
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMappingRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMappingRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMappingRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMappingRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMappingRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMappingRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMappingRuleRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'SeedConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SeedConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to seed with new database
    /// structure, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub name: std::string::String,

    /// Should the conversion workspace be committed automatically after the
    /// seed operation.
    pub auto_commit: bool,

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    pub seed_from: std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeedConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SeedConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::SeedConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from].
    ///
    /// Note that all the setters affecting `seed_from` are mutually
    /// exclusive.
    pub fn set_seed_from<
        T: std::convert::Into<
                std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = v.into();
        self
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `SourceConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `SourceConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_source_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v.into(),
            ),
        );
        self
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `DestinationConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn destination_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `DestinationConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_destination_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SeedConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SeedConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SeedConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __auto_commit,
            __source_connection_profile,
            __destination_connection_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SeedConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "autoCommit" => Ok(__FieldTag::__auto_commit),
                            "auto_commit" => Ok(__FieldTag::__auto_commit),
                            "sourceConnectionProfile" => {
                                Ok(__FieldTag::__source_connection_profile)
                            }
                            "source_connection_profile" => {
                                Ok(__FieldTag::__source_connection_profile)
                            }
                            "destinationConnectionProfile" => {
                                Ok(__FieldTag::__destination_connection_profile)
                            }
                            "destination_connection_profile" => {
                                Ok(__FieldTag::__destination_connection_profile)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SeedConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SeedConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_commit => {
                            if !fields.insert(__FieldTag::__auto_commit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_commit",
                                ));
                            }
                            result.auto_commit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_connection_profile => {
                            if !fields.insert(__FieldTag::__source_connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_connection_profile",
                                ));
                            }
                            if result.seed_from.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `seed_from`, a oneof with full ID .google.cloud.clouddms.v1.SeedConversionWorkspaceRequest.source_connection_profile, latest field was sourceConnectionProfile",
                                ));
                            }
                            result.seed_from = std::option::Option::Some(
                                crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__destination_connection_profile => {
                            if !fields.insert(__FieldTag::__destination_connection_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_connection_profile",
                                ));
                            }
                            if result.seed_from.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `seed_from`, a oneof with full ID .google.cloud.clouddms.v1.SeedConversionWorkspaceRequest.destination_connection_profile, latest field was destinationConnectionProfile",
                                ));
                            }
                            result.seed_from = std::option::Option::Some(
                                crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SeedConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.auto_commit) {
            state.serialize_entry("autoCommit", &self.auto_commit)?;
        }
        if let Some(value) = self.source_connection_profile() {
            state.serialize_entry("sourceConnectionProfile", value)?;
        }
        if let Some(value) = self.destination_connection_profile() {
            state.serialize_entry("destinationConnectionProfile", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SeedConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SeedConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("seed_from", &self.seed_from);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SeedConversionWorkspaceRequest].
pub mod seed_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SeedFrom {
        /// Optional. Fully qualified (Uri) name of the source connection profile.
        SourceConnectionProfile(std::string::String),
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        DestinationConnectionProfile(std::string::String),
    }
}

/// Request message for 'ConvertConversionWorkspace' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConvertConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to convert in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub name: std::string::String,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the conversion.
    pub auto_commit: bool,

    /// Optional. Filter the entities to convert. Leaving this field empty will
    /// convert all of the entities. Supports Google AIP-160 style filtering.
    pub filter: std::string::String,

    /// Optional. Automatically convert the full entity path for each entity
    /// specified by the filter. For example, if the filter specifies a table, that
    /// table schema (and database if there is one) will also be converted.
    pub convert_full_path: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConvertConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConvertConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ConvertConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ConvertConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [convert_full_path][crate::model::ConvertConversionWorkspaceRequest::convert_full_path].
    pub fn set_convert_full_path<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.convert_full_path = v.into();
        self
    }
}

impl wkt::message::Message for ConvertConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertConversionWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConvertConversionWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __auto_commit,
            __filter,
            __convert_full_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConvertConversionWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "autoCommit" => Ok(__FieldTag::__auto_commit),
                            "auto_commit" => Ok(__FieldTag::__auto_commit),
                            "filter" => Ok(__FieldTag::__filter),
                            "convertFullPath" => Ok(__FieldTag::__convert_full_path),
                            "convert_full_path" => Ok(__FieldTag::__convert_full_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConvertConversionWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConvertConversionWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_commit => {
                            if !fields.insert(__FieldTag::__auto_commit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_commit",
                                ));
                            }
                            result.auto_commit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__convert_full_path => {
                            if !fields.insert(__FieldTag::__convert_full_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for convert_full_path",
                                ));
                            }
                            result.convert_full_path = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConvertConversionWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.auto_commit) {
            state.serialize_entry("autoCommit", &self.auto_commit)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.convert_full_path) {
            state.serialize_entry("convertFullPath", &self.convert_full_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConvertConversionWorkspaceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConvertConversionWorkspaceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("auto_commit", &self.auto_commit);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("convert_full_path", &self.convert_full_path);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ImportMappingRules' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportMappingRulesRequest {
    /// Required. Name of the conversion workspace resource to import the rules to
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub parent: std::string::String,

    /// Required. The format of the rules content file.
    pub rules_format: crate::model::ImportRulesFileFormat,

    /// Required. One or more rules files.
    pub rules_files: std::vec::Vec<crate::model::import_mapping_rules_request::RulesFile>,

    /// Required. Should the conversion workspace be committed automatically after
    /// the import operation.
    pub auto_commit: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rules_format][crate::model::ImportMappingRulesRequest::rules_format].
    pub fn set_rules_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules_format = v.into();
        self
    }

    /// Sets the value of [rules_files][crate::model::ImportMappingRulesRequest::rules_files].
    pub fn set_rules_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::import_mapping_rules_request::RulesFile>,
    {
        use std::iter::Iterator;
        self.rules_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ImportMappingRulesRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }
}

impl wkt::message::Message for ImportMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportMappingRulesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __rules_format,
            __rules_files,
            __auto_commit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportMappingRulesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "rulesFormat" => Ok(__FieldTag::__rules_format),
                            "rules_format" => Ok(__FieldTag::__rules_format),
                            "rulesFiles" => Ok(__FieldTag::__rules_files),
                            "rules_files" => Ok(__FieldTag::__rules_files),
                            "autoCommit" => Ok(__FieldTag::__auto_commit),
                            "auto_commit" => Ok(__FieldTag::__auto_commit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportMappingRulesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportMappingRulesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rules_format => {
                            if !fields.insert(__FieldTag::__rules_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules_format",
                                ));
                            }
                            result.rules_format = map.next_value::<std::option::Option<crate::model::ImportRulesFileFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rules_files => {
                            if !fields.insert(__FieldTag::__rules_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rules_files",
                                ));
                            }
                            result.rules_files = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::import_mapping_rules_request::RulesFile,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_commit => {
                            if !fields.insert(__FieldTag::__auto_commit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_commit",
                                ));
                            }
                            result.auto_commit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportMappingRulesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.rules_format) {
            state.serialize_entry("rulesFormat", &self.rules_format)?;
        }
        if !self.rules_files.is_empty() {
            state.serialize_entry("rulesFiles", &self.rules_files)?;
        }
        if !wkt::internal::is_default(&self.auto_commit) {
            state.serialize_entry("autoCommit", &self.auto_commit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportMappingRulesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportMappingRulesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("rules_format", &self.rules_format);
        debug_struct.field("rules_files", &self.rules_files);
        debug_struct.field("auto_commit", &self.auto_commit);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportMappingRulesRequest].
pub mod import_mapping_rules_request {
    #[allow(unused_imports)]
    use super::*;

    /// Details of a single rules file.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RulesFile {
        /// Required. The filename of the rules that needs to be converted. The
        /// filename is used mainly so that future logs of the import rules job
        /// contain it, and can therefore be searched by it.
        pub rules_source_filename: std::string::String,

        /// Required. The text content of the rules that needs to be converted.
        pub rules_content: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RulesFile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rules_source_filename][crate::model::import_mapping_rules_request::RulesFile::rules_source_filename].
        pub fn set_rules_source_filename<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_source_filename = v.into();
            self
        }

        /// Sets the value of [rules_content][crate::model::import_mapping_rules_request::RulesFile::rules_content].
        pub fn set_rules_content<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_content = v.into();
            self
        }
    }

    impl wkt::message::Message for RulesFile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest.RulesFile"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RulesFile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rules_source_filename,
                __rules_content,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RulesFile")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rulesSourceFilename" => Ok(__FieldTag::__rules_source_filename),
                                "rules_source_filename" => Ok(__FieldTag::__rules_source_filename),
                                "rulesContent" => Ok(__FieldTag::__rules_content),
                                "rules_content" => Ok(__FieldTag::__rules_content),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RulesFile;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RulesFile")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rules_source_filename => {
                                if !fields.insert(__FieldTag::__rules_source_filename) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rules_source_filename",
                                    ));
                                }
                                result.rules_source_filename = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__rules_content => {
                                if !fields.insert(__FieldTag::__rules_content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rules_content",
                                    ));
                                }
                                result.rules_content = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RulesFile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rules_source_filename.is_empty() {
                state.serialize_entry("rulesSourceFilename", &self.rules_source_filename)?;
            }
            if !self.rules_content.is_empty() {
                state.serialize_entry("rulesContent", &self.rules_content)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RulesFile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RulesFile");
            debug_struct.field("rules_source_filename", &self.rules_source_filename);
            debug_struct.field("rules_content", &self.rules_content);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Request message for 'DescribeDatabaseEntities' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesRequest {
    /// Required. Name of the conversion workspace resource whose database entities
    /// are described. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub conversion_workspace: std::string::String,

    /// Optional. The maximum number of entities to return. The service may return
    /// fewer entities than the value specifies.
    pub page_size: i32,

    /// Optional. The nextPageToken value received in the previous call to
    /// conversionWorkspace.describeDatabaseEntities, used in the subsequent
    /// request to retrieve the next page of results. On first call this should be
    /// left blank. When paginating, all other parameters provided to
    /// conversionWorkspace.describeDatabaseEntities must match the call that
    /// provided the page token.
    pub page_token: std::string::String,

    /// Required. The tree to fetch.
    pub tree: crate::model::describe_database_entities_request::DBTreeType,

    /// Optional. Whether to retrieve the latest committed version of the entities
    /// or the latest version. This field is ignored if a specific commit_id is
    /// specified.
    pub uncommitted: bool,

    /// Optional. Request a specific commit ID. If not specified, the entities from
    /// the latest commit are returned.
    pub commit_id: std::string::String,

    /// Optional. Filter the returned entities based on AIP-160 standard.
    pub filter: std::string::String,

    /// Optional. Results view based on AIP-157
    pub view: crate::model::DatabaseEntityView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeDatabaseEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeDatabaseEntitiesRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::DescribeDatabaseEntitiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::DescribeDatabaseEntitiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DescribeDatabaseEntitiesRequest::tree].
    pub fn set_tree<
        T: std::convert::Into<crate::model::describe_database_entities_request::DBTreeType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [uncommitted][crate::model::DescribeDatabaseEntitiesRequest::uncommitted].
    pub fn set_uncommitted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.uncommitted = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeDatabaseEntitiesRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::DescribeDatabaseEntitiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [view][crate::model::DescribeDatabaseEntitiesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::DatabaseEntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DescribeDatabaseEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversion_workspace,
            __page_size,
            __page_token,
            __tree,
            __uncommitted,
            __commit_id,
            __filter,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DescribeDatabaseEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "tree" => Ok(__FieldTag::__tree),
                            "uncommitted" => Ok(__FieldTag::__uncommitted),
                            "commitId" => Ok(__FieldTag::__commit_id),
                            "commit_id" => Ok(__FieldTag::__commit_id),
                            "filter" => Ok(__FieldTag::__filter),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DescribeDatabaseEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DescribeDatabaseEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tree => {
                            if !fields.insert(__FieldTag::__tree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tree",
                                ));
                            }
                            result.tree = map
                                .next_value::<std::option::Option<
                                    crate::model::describe_database_entities_request::DBTreeType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uncommitted => {
                            if !fields.insert(__FieldTag::__uncommitted) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uncommitted",
                                ));
                            }
                            result.uncommitted = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_id => {
                            if !fields.insert(__FieldTag::__commit_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_id",
                                ));
                            }
                            result.commit_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::DatabaseEntityView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DescribeDatabaseEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversion_workspace.is_empty() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.tree) {
            state.serialize_entry("tree", &self.tree)?;
        }
        if !wkt::internal::is_default(&self.uncommitted) {
            state.serialize_entry("uncommitted", &self.uncommitted)?;
        }
        if !self.commit_id.is_empty() {
            state.serialize_entry("commitId", &self.commit_id)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DescribeDatabaseEntitiesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeDatabaseEntitiesRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("tree", &self.tree);
        debug_struct.field("uncommitted", &self.uncommitted);
        debug_struct.field("commit_id", &self.commit_id);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DescribeDatabaseEntitiesRequest].
pub mod describe_database_entities_request {
    #[allow(unused_imports)]
    use super::*;

    /// The type of a tree to return
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DBTreeType {
        /// Unspecified tree type.
        Unspecified,
        /// The source database tree.
        SourceTree,
        /// The draft database tree.
        DraftTree,
        /// The destination database tree.
        DestinationTree,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DBTreeType::value] or
        /// [DBTreeType::name].
        UnknownValue(db_tree_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod db_tree_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DBTreeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SourceTree => std::option::Option::Some(1),
                Self::DraftTree => std::option::Option::Some(2),
                Self::DestinationTree => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DB_TREE_TYPE_UNSPECIFIED"),
                Self::SourceTree => std::option::Option::Some("SOURCE_TREE"),
                Self::DraftTree => std::option::Option::Some("DRAFT_TREE"),
                Self::DestinationTree => std::option::Option::Some("DESTINATION_TREE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DBTreeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DBTreeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DBTreeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SourceTree,
                2 => Self::DraftTree,
                3 => Self::DestinationTree,
                _ => Self::UnknownValue(db_tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DBTreeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DB_TREE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE_TREE" => Self::SourceTree,
                "DRAFT_TREE" => Self::DraftTree,
                "DESTINATION_TREE" => Self::DestinationTree,
                _ => Self::UnknownValue(db_tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DBTreeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SourceTree => serializer.serialize_i32(1),
                Self::DraftTree => serializer.serialize_i32(2),
                Self::DestinationTree => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DBTreeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DBTreeType>::new(
                ".google.cloud.clouddms.v1.DescribeDatabaseEntitiesRequest.DBTreeType",
            ))
        }
    }
}

/// Response message for 'DescribeDatabaseEntities' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesResponse {
    /// The list of database entities for the conversion workspace.
    pub database_entities: std::vec::Vec<crate::model::DatabaseEntity>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeDatabaseEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_entities][crate::model::DescribeDatabaseEntitiesResponse::database_entities].
    pub fn set_database_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseEntity>,
    {
        use std::iter::Iterator;
        self.database_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::DescribeDatabaseEntitiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for DescribeDatabaseEntitiesResponse {
    type PageItem = crate::model::DatabaseEntity;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.database_entities
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DescribeDatabaseEntitiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database_entities,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DescribeDatabaseEntitiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databaseEntities" => Ok(__FieldTag::__database_entities),
                            "database_entities" => Ok(__FieldTag::__database_entities),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DescribeDatabaseEntitiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DescribeDatabaseEntitiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database_entities => {
                            if !fields.insert(__FieldTag::__database_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_entities",
                                ));
                            }
                            result.database_entities =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatabaseEntity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DescribeDatabaseEntitiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database_entities.is_empty() {
            state.serialize_entry("databaseEntities", &self.database_entities)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DescribeDatabaseEntitiesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeDatabaseEntitiesResponse");
        debug_struct.field("database_entities", &self.database_entities);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'SearchBackgroundJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchBackgroundJobsRequest {
    /// Required. Name of the conversion workspace resource whose jobs are listed,
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub conversion_workspace: std::string::String,

    /// Optional. Whether or not to return just the most recent job per job type,
    pub return_most_recent_per_job_type: bool,

    /// Optional. The maximum number of jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 100 jobs are
    /// returned. The maximum value is 100; values above 100 are coerced to
    /// 100.
    pub max_size: i32,

    /// Optional. If provided, only returns jobs that completed until (not
    /// including) the given timestamp.
    pub completed_until_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBackgroundJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::SearchBackgroundJobsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [return_most_recent_per_job_type][crate::model::SearchBackgroundJobsRequest::return_most_recent_per_job_type].
    pub fn set_return_most_recent_per_job_type<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.return_most_recent_per_job_type = v.into();
        self
    }

    /// Sets the value of [max_size][crate::model::SearchBackgroundJobsRequest::max_size].
    pub fn set_max_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_size = v.into();
        self
    }

    /// Sets the value of [completed_until_time][crate::model::SearchBackgroundJobsRequest::completed_until_time].
    pub fn set_completed_until_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completed_until_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completed_until_time][crate::model::SearchBackgroundJobsRequest::completed_until_time].
    pub fn set_or_clear_completed_until_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.completed_until_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchBackgroundJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversion_workspace,
            __return_most_recent_per_job_type,
            __max_size,
            __completed_until_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchBackgroundJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "returnMostRecentPerJobType" => {
                                Ok(__FieldTag::__return_most_recent_per_job_type)
                            }
                            "return_most_recent_per_job_type" => {
                                Ok(__FieldTag::__return_most_recent_per_job_type)
                            }
                            "maxSize" => Ok(__FieldTag::__max_size),
                            "max_size" => Ok(__FieldTag::__max_size),
                            "completedUntilTime" => Ok(__FieldTag::__completed_until_time),
                            "completed_until_time" => Ok(__FieldTag::__completed_until_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchBackgroundJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchBackgroundJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_most_recent_per_job_type => {
                            if !fields.insert(__FieldTag::__return_most_recent_per_job_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_most_recent_per_job_type",
                                ));
                            }
                            result.return_most_recent_per_job_type = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_size => {
                            if !fields.insert(__FieldTag::__max_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__completed_until_time => {
                            if !fields.insert(__FieldTag::__completed_until_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completed_until_time",
                                ));
                            }
                            result.completed_until_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchBackgroundJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversion_workspace.is_empty() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !wkt::internal::is_default(&self.return_most_recent_per_job_type) {
            state.serialize_entry(
                "returnMostRecentPerJobType",
                &self.return_most_recent_per_job_type,
            )?;
        }
        if !wkt::internal::is_default(&self.max_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSize", &__With(&self.max_size))?;
        }
        if self.completed_until_time.is_some() {
            state.serialize_entry("completedUntilTime", &self.completed_until_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchBackgroundJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchBackgroundJobsRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field(
            "return_most_recent_per_job_type",
            &self.return_most_recent_per_job_type,
        );
        debug_struct.field("max_size", &self.max_size);
        debug_struct.field("completed_until_time", &self.completed_until_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'SearchBackgroundJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchBackgroundJobsResponse {
    /// The list of conversion workspace mapping rules.
    pub jobs: std::vec::Vec<crate::model::BackgroundJobLogEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBackgroundJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::SearchBackgroundJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackgroundJobLogEntry>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchBackgroundJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchBackgroundJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchBackgroundJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchBackgroundJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BackgroundJobLogEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchBackgroundJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchBackgroundJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchBackgroundJobsResponse");
        debug_struct.field("jobs", &self.jobs);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DescribeConversionWorkspaceRevisions' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsRequest {
    /// Required. Name of the conversion workspace resource whose revisions are
    /// listed. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub conversion_workspace: std::string::String,

    /// Optional. Optional filter to request a specific commit ID.
    pub commit_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeConversionWorkspaceRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeConversionWorkspaceRevisionsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeConversionWorkspaceRevisionsRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DescribeConversionWorkspaceRevisionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversion_workspace,
            __commit_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for DescribeConversionWorkspaceRevisionsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "commitId" => Ok(__FieldTag::__commit_id),
                            "commit_id" => Ok(__FieldTag::__commit_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DescribeConversionWorkspaceRevisionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DescribeConversionWorkspaceRevisionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_id => {
                            if !fields.insert(__FieldTag::__commit_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_id",
                                ));
                            }
                            result.commit_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DescribeConversionWorkspaceRevisionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversion_workspace.is_empty() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !self.commit_id.is_empty() {
            state.serialize_entry("commitId", &self.commit_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DescribeConversionWorkspaceRevisionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeConversionWorkspaceRevisionsRequest");
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("commit_id", &self.commit_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'DescribeConversionWorkspaceRevisions' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsResponse {
    /// The list of conversion workspace revisions.
    pub revisions: std::vec::Vec<crate::model::ConversionWorkspace>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeConversionWorkspaceRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revisions][crate::model::DescribeConversionWorkspaceRevisionsResponse::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DescribeConversionWorkspaceRevisionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __revisions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for DescribeConversionWorkspaceRevisionsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "revisions" => Ok(__FieldTag::__revisions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DescribeConversionWorkspaceRevisionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DescribeConversionWorkspaceRevisionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__revisions => {
                            if !fields.insert(__FieldTag::__revisions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revisions",
                                ));
                            }
                            result.revisions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversionWorkspace>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DescribeConversionWorkspaceRevisionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.revisions.is_empty() {
            state.serialize_entry("revisions", &self.revisions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DescribeConversionWorkspaceRevisionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DescribeConversionWorkspaceRevisionsResponse");
        debug_struct.field("revisions", &self.revisions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateMappingRule' command.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMappingRuleRequest {
    /// Required. The parent which owns this collection of mapping rules.
    pub parent: std::string::String,

    /// Required. The ID of the rule to create.
    pub mapping_rule_id: std::string::String,

    /// Required. Represents a [mapping rule]
    /// (<https://cloud.google.com/database-migration/reference/rest/v1/projects.locations.mappingRules>)
    /// object.
    pub mapping_rule: std::option::Option<crate::model::MappingRule>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMappingRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [mapping_rule_id][crate::model::CreateMappingRuleRequest::mapping_rule_id].
    pub fn set_mapping_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_rule_id = v.into();
        self
    }

    /// Sets the value of [mapping_rule][crate::model::CreateMappingRuleRequest::mapping_rule].
    pub fn set_mapping_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MappingRule>,
    {
        self.mapping_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mapping_rule][crate::model::CreateMappingRuleRequest::mapping_rule].
    pub fn set_or_clear_mapping_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MappingRule>,
    {
        self.mapping_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMappingRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMappingRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __mapping_rule_id,
            __mapping_rule,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMappingRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "mappingRuleId" => Ok(__FieldTag::__mapping_rule_id),
                            "mapping_rule_id" => Ok(__FieldTag::__mapping_rule_id),
                            "mappingRule" => Ok(__FieldTag::__mapping_rule),
                            "mapping_rule" => Ok(__FieldTag::__mapping_rule),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMappingRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMappingRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mapping_rule_id => {
                            if !fields.insert(__FieldTag::__mapping_rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping_rule_id",
                                ));
                            }
                            result.mapping_rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mapping_rule => {
                            if !fields.insert(__FieldTag::__mapping_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping_rule",
                                ));
                            }
                            result.mapping_rule =
                                map.next_value::<std::option::Option<crate::model::MappingRule>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMappingRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.mapping_rule_id.is_empty() {
            state.serialize_entry("mappingRuleId", &self.mapping_rule_id)?;
        }
        if self.mapping_rule.is_some() {
            state.serialize_entry("mappingRule", &self.mapping_rule)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMappingRuleRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("mapping_rule_id", &self.mapping_rule_id);
        debug_struct.field("mapping_rule", &self.mapping_rule);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteMappingRule' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMappingRuleRequest {
    /// Required. Name of the mapping rule resource to delete.
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMappingRuleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMappingRuleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMappingRuleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMappingRuleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMappingRuleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMappingRuleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteMappingRuleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMappingRuleRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'FetchStaticIps' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStaticIpsRequest {
    /// Required. The resource name for the location for which static IPs should be
    /// returned. Must be in the format `projects/*/locations/*`.
    pub name: std::string::String,

    /// Maximum number of IPs to return.
    pub page_size: i32,

    /// A page token, received from a previous `FetchStaticIps` call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchStaticIpsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStaticIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStaticIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStaticIpsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStaticIpsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStaticIpsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStaticIpsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStaticIpsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStaticIpsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for a 'FetchStaticIps' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStaticIpsResponse {
    /// List of static IPs.
    pub static_ips: std::vec::Vec<std::string::String>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [static_ips][crate::model::FetchStaticIpsResponse::static_ips].
    pub fn set_static_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.static_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchStaticIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStaticIpsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __static_ips,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStaticIpsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "staticIps" => Ok(__FieldTag::__static_ips),
                            "static_ips" => Ok(__FieldTag::__static_ips),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStaticIpsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStaticIpsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__static_ips => {
                            if !fields.insert(__FieldTag::__static_ips) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ips",
                                ));
                            }
                            result.static_ips = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStaticIpsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.static_ips.is_empty() {
            state.serialize_entry("staticIps", &self.static_ips)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStaticIpsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStaticIpsResponse");
        debug_struct.field("static_ips", &self.static_ips);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SSL configuration information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SslConfig {
    /// Output only. The ssl config type according to 'client_key',
    /// 'client_certificate' and 'ca_certificate'.
    pub r#type: crate::model::ssl_config::SslType,

    /// Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key
    /// associated with the Client Certificate. If this field is used then the
    /// 'client_certificate' field is mandatory.
    pub client_key: std::string::String,

    /// Input only. The x509 PEM-encoded certificate that will be used by the
    /// replica to authenticate against the source database server.If this field is
    /// used then the 'client_key' field is mandatory.
    pub client_certificate: std::string::String,

    /// Required. Input only. The x509 PEM-encoded certificate of the CA that
    /// signed the source database server's certificate. The replica will use this
    /// certificate to verify it's connecting to the right host.
    pub ca_certificate: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SslConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::ssl_config::SslType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::SslConfig::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::SslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SslConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SslConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __client_key,
            __client_certificate,
            __ca_certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SslConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "caCertificate" => Ok(__FieldTag::__ca_certificate),
                            "ca_certificate" => Ok(__FieldTag::__ca_certificate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SslConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SslConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::ssl_config::SslType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate => {
                            if !fields.insert(__FieldTag::__ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate",
                                ));
                            }
                            result.ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SslConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.ca_certificate.is_empty() {
            state.serialize_entry("caCertificate", &self.ca_certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SslConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SslConfig");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("ca_certificate", &self.ca_certificate);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies The kind of ssl configuration used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslType {
        /// Unspecified.
        Unspecified,
        /// Only 'ca_certificate' specified.
        ServerOnly,
        /// Both server ('ca_certificate'), and client ('client_key',
        /// 'client_certificate') specified.
        ServerClient,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslType::value] or
        /// [SslType::name].
        UnknownValue(ssl_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServerOnly => std::option::Option::Some(1),
                Self::ServerClient => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_TYPE_UNSPECIFIED"),
                Self::ServerOnly => std::option::Option::Some("SERVER_ONLY"),
                Self::ServerClient => std::option::Option::Some("SERVER_CLIENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServerOnly,
                2 => Self::ServerClient,
                _ => Self::UnknownValue(ssl_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVER_ONLY" => Self::ServerOnly,
                "SERVER_CLIENT" => Self::ServerClient,
                _ => Self::UnknownValue(ssl_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServerOnly => serializer.serialize_i32(1),
                Self::ServerClient => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslType>::new(
                ".google.cloud.clouddms.v1.SslConfig.SslType",
            ))
        }
    }
}

/// Specifies connection parameters required specifically for MySQL databases.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MySqlConnectionProfile {
    /// Required. The IP or hostname of the source MySQL database.
    pub host: std::string::String,

    /// Required. The network port of the source MySQL database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    pub cloud_sql_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::MySqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::MySqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::MySqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::MySqlConnectionProfile::ssl].
    pub fn set_ssl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl][crate::model::MySqlConnectionProfile::ssl].
    pub fn set_or_clear_ssl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::MySqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }
}

impl wkt::message::Message for MySqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MySqlConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MySqlConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host,
            __port,
            __username,
            __password,
            __password_set,
            __ssl,
            __cloud_sql_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MySqlConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "host" => Ok(__FieldTag::__host),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "passwordSet" => Ok(__FieldTag::__password_set),
                            "password_set" => Ok(__FieldTag::__password_set),
                            "ssl" => Ok(__FieldTag::__ssl),
                            "cloudSqlId" => Ok(__FieldTag::__cloud_sql_id),
                            "cloud_sql_id" => Ok(__FieldTag::__cloud_sql_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MySqlConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MySqlConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password_set => {
                            if !fields.insert(__FieldTag::__password_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_set",
                                ));
                            }
                            result.password_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl => {
                            if !fields.insert(__FieldTag::__ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl",
                                ));
                            }
                            result.ssl =
                                map.next_value::<std::option::Option<crate::model::SslConfig>>()?;
                        }
                        __FieldTag::__cloud_sql_id => {
                            if !fields.insert(__FieldTag::__cloud_sql_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_id",
                                ));
                            }
                            result.cloud_sql_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MySqlConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !wkt::internal::is_default(&self.password_set) {
            state.serialize_entry("passwordSet", &self.password_set)?;
        }
        if self.ssl.is_some() {
            state.serialize_entry("ssl", &self.ssl)?;
        }
        if !self.cloud_sql_id.is_empty() {
            state.serialize_entry("cloudSqlId", &self.cloud_sql_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MySqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MySqlConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies connection parameters required specifically for PostgreSQL
/// databases.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostgreSqlConnectionProfile {
    /// Required. The IP or hostname of the source PostgreSQL database.
    pub host: std::string::String,

    /// Required. The network port of the source PostgreSQL database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    pub cloud_sql_id: std::string::String,

    /// Output only. If the source is a Cloud SQL database, this field indicates
    /// the network architecture it's associated with.
    pub network_architecture: crate::model::NetworkArchitecture,

    /// Connectivity options used to establish a connection to the database server.
    pub connectivity:
        std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgreSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::PostgreSqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::PostgreSqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::PostgreSqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::PostgreSqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::PostgreSqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::PostgreSqlConnectionProfile::ssl].
    pub fn set_ssl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl][crate::model::PostgreSqlConnectionProfile::ssl].
    pub fn set_or_clear_ssl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::PostgreSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [network_architecture][crate::model::PostgreSqlConnectionProfile::network_architecture].
    pub fn set_network_architecture<T: std::convert::Into<crate::model::NetworkArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_architecture = v.into();
        self
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<
                std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `PrivateServiceConnectConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_service_connect_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>
    {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `PrivateServiceConnectConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_service_connect_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for PostgreSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PostgreSqlConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostgreSqlConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host,
            __port,
            __username,
            __password,
            __password_set,
            __ssl,
            __cloud_sql_id,
            __network_architecture,
            __static_ip_connectivity,
            __private_service_connect_connectivity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostgreSqlConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "host" => Ok(__FieldTag::__host),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "passwordSet" => Ok(__FieldTag::__password_set),
                            "password_set" => Ok(__FieldTag::__password_set),
                            "ssl" => Ok(__FieldTag::__ssl),
                            "cloudSqlId" => Ok(__FieldTag::__cloud_sql_id),
                            "cloud_sql_id" => Ok(__FieldTag::__cloud_sql_id),
                            "networkArchitecture" => Ok(__FieldTag::__network_architecture),
                            "network_architecture" => Ok(__FieldTag::__network_architecture),
                            "staticIpConnectivity" => Ok(__FieldTag::__static_ip_connectivity),
                            "static_ip_connectivity" => Ok(__FieldTag::__static_ip_connectivity),
                            "privateServiceConnectConnectivity" => {
                                Ok(__FieldTag::__private_service_connect_connectivity)
                            }
                            "private_service_connect_connectivity" => {
                                Ok(__FieldTag::__private_service_connect_connectivity)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostgreSqlConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostgreSqlConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password_set => {
                            if !fields.insert(__FieldTag::__password_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_set",
                                ));
                            }
                            result.password_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl => {
                            if !fields.insert(__FieldTag::__ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl",
                                ));
                            }
                            result.ssl =
                                map.next_value::<std::option::Option<crate::model::SslConfig>>()?;
                        }
                        __FieldTag::__cloud_sql_id => {
                            if !fields.insert(__FieldTag::__cloud_sql_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_id",
                                ));
                            }
                            result.cloud_sql_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_architecture => {
                            if !fields.insert(__FieldTag::__network_architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_architecture",
                                ));
                            }
                            result.network_architecture = map.next_value::<std::option::Option<crate::model::NetworkArchitecture>>()?.unwrap_or_default();
                        }
                        __FieldTag::__static_ip_connectivity => {
                            if !fields.insert(__FieldTag::__static_ip_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ip_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.PostgreSqlConnectionProfile.static_ip_connectivity, latest field was staticIpConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StaticIpConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__private_service_connect_connectivity => {
                            if !fields.insert(__FieldTag::__private_service_connect_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_service_connect_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.PostgreSqlConnectionProfile.private_service_connect_connectivity, latest field was privateServiceConnectConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostgreSqlConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !wkt::internal::is_default(&self.password_set) {
            state.serialize_entry("passwordSet", &self.password_set)?;
        }
        if self.ssl.is_some() {
            state.serialize_entry("ssl", &self.ssl)?;
        }
        if !self.cloud_sql_id.is_empty() {
            state.serialize_entry("cloudSqlId", &self.cloud_sql_id)?;
        }
        if !wkt::internal::is_default(&self.network_architecture) {
            state.serialize_entry("networkArchitecture", &self.network_architecture)?;
        }
        if let Some(value) = self.static_ip_connectivity() {
            state.serialize_entry("staticIpConnectivity", value)?;
        }
        if let Some(value) = self.private_service_connect_connectivity() {
            state.serialize_entry("privateServiceConnectConnectivity", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostgreSqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostgreSqlConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);
        debug_struct.field("network_architecture", &self.network_architecture);
        debug_struct.field("connectivity", &self.connectivity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PostgreSqlConnectionProfile].
pub mod postgre_sql_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
        /// Private service connect connectivity.
        PrivateServiceConnectConnectivity(
            std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>,
        ),
    }
}

/// Specifies connection parameters required specifically for Oracle
/// databases.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OracleConnectionProfile {
    /// Required. The IP or hostname of the source Oracle database.
    pub host: std::string::String,

    /// Required. The network port of the source Oracle database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    pub password: std::string::String,

    /// Output only. Indicates whether a new password is included in the request.
    pub password_set: bool,

    /// Required. Database service for the Oracle connection.
    pub database_service: std::string::String,

    /// SSL configuration for the connection to the source Oracle database.
    ///
    /// * Only `SERVER_ONLY` configuration is supported for Oracle SSL.
    /// * SSL is supported for Oracle versions 12 and above.
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// Connectivity options used to establish a connection to the database server.
    pub connectivity: std::option::Option<crate::model::oracle_connection_profile::Connectivity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::OracleConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::OracleConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [database_service][crate::model::OracleConnectionProfile::database_service].
    pub fn set_database_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_service = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::OracleConnectionProfile::ssl].
    pub fn set_ssl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ssl][crate::model::OracleConnectionProfile::ssl].
    pub fn set_or_clear_ssl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SslConfig>,
    {
        self.ssl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<
                std::option::Option<crate::model::oracle_connection_profile::Connectivity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `StaticServiceIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_service_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticServiceIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `StaticServiceIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_service_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `ForwardSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forward_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `ForwardSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_forward_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `PrivateConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `PrivateConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OracleConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OracleConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OracleConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __host,
            __port,
            __username,
            __password,
            __password_set,
            __database_service,
            __ssl,
            __static_service_ip_connectivity,
            __forward_ssh_connectivity,
            __private_connectivity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OracleConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "host" => Ok(__FieldTag::__host),
                            "port" => Ok(__FieldTag::__port),
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "passwordSet" => Ok(__FieldTag::__password_set),
                            "password_set" => Ok(__FieldTag::__password_set),
                            "databaseService" => Ok(__FieldTag::__database_service),
                            "database_service" => Ok(__FieldTag::__database_service),
                            "ssl" => Ok(__FieldTag::__ssl),
                            "staticServiceIpConnectivity" => {
                                Ok(__FieldTag::__static_service_ip_connectivity)
                            }
                            "static_service_ip_connectivity" => {
                                Ok(__FieldTag::__static_service_ip_connectivity)
                            }
                            "forwardSshConnectivity" => Ok(__FieldTag::__forward_ssh_connectivity),
                            "forward_ssh_connectivity" => {
                                Ok(__FieldTag::__forward_ssh_connectivity)
                            }
                            "privateConnectivity" => Ok(__FieldTag::__private_connectivity),
                            "private_connectivity" => Ok(__FieldTag::__private_connectivity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OracleConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OracleConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password_set => {
                            if !fields.insert(__FieldTag::__password_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password_set",
                                ));
                            }
                            result.password_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_service => {
                            if !fields.insert(__FieldTag::__database_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_service",
                                ));
                            }
                            result.database_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssl => {
                            if !fields.insert(__FieldTag::__ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssl",
                                ));
                            }
                            result.ssl =
                                map.next_value::<std::option::Option<crate::model::SslConfig>>()?;
                        }
                        __FieldTag::__static_service_ip_connectivity => {
                            if !fields.insert(__FieldTag::__static_service_ip_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_service_ip_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.OracleConnectionProfile.static_service_ip_connectivity, latest field was staticServiceIpConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__forward_ssh_connectivity => {
                            if !fields.insert(__FieldTag::__forward_ssh_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forward_ssh_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.OracleConnectionProfile.forward_ssh_connectivity, latest field was forwardSshConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__private_connectivity => {
                            if !fields.insert(__FieldTag::__private_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.OracleConnectionProfile.private_connectivity, latest field was privateConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::PrivateConnectivity>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OracleConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !wkt::internal::is_default(&self.password_set) {
            state.serialize_entry("passwordSet", &self.password_set)?;
        }
        if !self.database_service.is_empty() {
            state.serialize_entry("databaseService", &self.database_service)?;
        }
        if self.ssl.is_some() {
            state.serialize_entry("ssl", &self.ssl)?;
        }
        if let Some(value) = self.static_service_ip_connectivity() {
            state.serialize_entry("staticServiceIpConnectivity", value)?;
        }
        if let Some(value) = self.forward_ssh_connectivity() {
            state.serialize_entry("forwardSshConnectivity", value)?;
        }
        if let Some(value) = self.private_connectivity() {
            state.serialize_entry("privateConnectivity", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OracleConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OracleConnectionProfile");
        debug_struct.field("host", &self.host);
        debug_struct.field("port", &self.port);
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("password_set", &self.password_set);
        debug_struct.field("database_service", &self.database_service);
        debug_struct.field("ssl", &self.ssl);
        debug_struct.field("connectivity", &self.connectivity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OracleConnectionProfile].
pub mod oracle_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static Service IP connectivity.
        StaticServiceIpConnectivity(std::boxed::Box<crate::model::StaticServiceIpConnectivity>),
        /// Forward SSH tunnel connectivity.
        ForwardSshConnectivity(std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>),
        /// Private connectivity.
        PrivateConnectivity(std::boxed::Box<crate::model::PrivateConnectivity>),
    }
}

/// Specifies required connection parameters, and, optionally, the parameters
/// required to create a Cloud SQL destination database instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlConnectionProfile {
    /// Output only. The Cloud SQL instance ID that this connection profile is
    /// associated with.
    pub cloud_sql_id: std::string::String,

    /// Immutable. Metadata used to create the destination Cloud SQL database.
    pub settings: std::option::Option<crate::model::CloudSqlSettings>,

    /// Output only. The Cloud SQL database instance's private IP.
    pub private_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's public IP.
    pub public_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's additional (outgoing) public
    /// IP. Used when the Cloud SQL database availability type is REGIONAL (i.e.
    /// multiple zones / highly available).
    pub additional_public_ip: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_sql_id][crate::model::CloudSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::CloudSqlConnectionProfile::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudSqlSettings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::CloudSqlConnectionProfile::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudSqlSettings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ip][crate::model::CloudSqlConnectionProfile::private_ip].
    pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_ip = v.into();
        self
    }

    /// Sets the value of [public_ip][crate::model::CloudSqlConnectionProfile::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [additional_public_ip][crate::model::CloudSqlConnectionProfile::additional_public_ip].
    pub fn set_additional_public_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_public_ip = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_sql_id,
            __settings,
            __private_ip,
            __public_ip,
            __additional_public_ip,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudSqlId" => Ok(__FieldTag::__cloud_sql_id),
                            "cloud_sql_id" => Ok(__FieldTag::__cloud_sql_id),
                            "settings" => Ok(__FieldTag::__settings),
                            "privateIp" => Ok(__FieldTag::__private_ip),
                            "private_ip" => Ok(__FieldTag::__private_ip),
                            "publicIp" => Ok(__FieldTag::__public_ip),
                            "public_ip" => Ok(__FieldTag::__public_ip),
                            "additionalPublicIp" => Ok(__FieldTag::__additional_public_ip),
                            "additional_public_ip" => Ok(__FieldTag::__additional_public_ip),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_sql_id => {
                            if !fields.insert(__FieldTag::__cloud_sql_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_sql_id",
                                ));
                            }
                            result.cloud_sql_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings = map
                                .next_value::<std::option::Option<crate::model::CloudSqlSettings>>(
                                )?;
                        }
                        __FieldTag::__private_ip => {
                            if !fields.insert(__FieldTag::__private_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_ip",
                                ));
                            }
                            result.private_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip => {
                            if !fields.insert(__FieldTag::__public_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip",
                                ));
                            }
                            result.public_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_public_ip => {
                            if !fields.insert(__FieldTag::__additional_public_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_public_ip",
                                ));
                            }
                            result.additional_public_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cloud_sql_id.is_empty() {
            state.serialize_entry("cloudSqlId", &self.cloud_sql_id)?;
        }
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if !self.private_ip.is_empty() {
            state.serialize_entry("privateIp", &self.private_ip)?;
        }
        if !self.public_ip.is_empty() {
            state.serialize_entry("publicIp", &self.public_ip)?;
        }
        if !self.additional_public_ip.is_empty() {
            state.serialize_entry("additionalPublicIp", &self.additional_public_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSqlConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlConnectionProfile");
        debug_struct.field("cloud_sql_id", &self.cloud_sql_id);
        debug_struct.field("settings", &self.settings);
        debug_struct.field("private_ip", &self.private_ip);
        debug_struct.field("public_ip", &self.public_ip);
        debug_struct.field("additional_public_ip", &self.additional_public_ip);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Specifies required connection parameters, and the parameters
/// required to create an AlloyDB destination cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AlloyDbConnectionProfile {
    /// Required. The AlloyDB cluster ID that this connection profile is associated
    /// with.
    pub cluster_id: std::string::String,

    /// Immutable. Metadata used to create the destination AlloyDB cluster.
    pub settings: std::option::Option<crate::model::AlloyDbSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlloyDbConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_id][crate::model::AlloyDbConnectionProfile::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::AlloyDbConnectionProfile::settings].
    pub fn set_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AlloyDbSettings>,
    {
        self.settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [settings][crate::model::AlloyDbConnectionProfile::settings].
    pub fn set_or_clear_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AlloyDbSettings>,
    {
        self.settings = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AlloyDbConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AlloyDbConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_id,
            __settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlloyDbConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "settings" => Ok(__FieldTag::__settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AlloyDbConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlloyDbConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__settings => {
                            if !fields.insert(__FieldTag::__settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for settings",
                                ));
                            }
                            result.settings = map
                                .next_value::<std::option::Option<crate::model::AlloyDbSettings>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AlloyDbConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.settings.is_some() {
            state.serialize_entry("settings", &self.settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AlloyDbConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AlloyDbConnectionProfile");
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("settings", &self.settings);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An entry for an Access Control list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlAclEntry {
    /// The allowlisted value for the access control list.
    pub value: std::string::String,

    /// A label to identify this entry.
    pub label: std::string::String,

    /// The access control entry entry expiration.
    pub expiration: std::option::Option<crate::model::sql_acl_entry::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlAclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlAclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [label][crate::model::SqlAclEntry::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::sql_acl_entry::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::sql_acl_entry::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::sql_acl_entry::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for SqlAclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlAclEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlAclEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __expire_time,
            __ttl,
            __label,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlAclEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "label" => Ok(__FieldTag::__label),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlAclEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlAclEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.clouddms.v1.SqlAclEntry.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::sql_acl_entry::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.clouddms.v1.SqlAclEntry.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::sql_acl_entry::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__label => {
                            if !fields.insert(__FieldTag::__label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label",
                                ));
                            }
                            result.label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlAclEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if !self.label.is_empty() {
            state.serialize_entry("label", &self.label)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlAclEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlAclEntry");
        debug_struct.field("value", &self.value);
        debug_struct.field("label", &self.label);
        debug_struct.field("expiration", &self.expiration);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SqlAclEntry].
pub mod sql_acl_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The access control entry entry expiration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// The time when this access control entry expires in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example:
        /// `2012-11-15T16:19:00.094Z`.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The time-to-leave of this access control entry.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// IP Management configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SqlIpConfig {
    /// Whether the instance should be assigned an IPv4 address or not.
    pub enable_ipv4: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    pub private_network: std::string::String,

    /// Optional. The name of the allocated IP address range for the private IP
    /// Cloud SQL instance. This name refers to an already allocated IP range
    /// address. If set, the instance IP address will be created in the allocated
    /// range. Note that this IP address range can't be modified after the instance
    /// is created. If you change the VPC when configuring connectivity settings
    /// for the migration job, this field is not relevant.
    pub allocated_ip_range: std::string::String,

    /// Whether SSL connections over IP should be enforced or not.
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. See
    /// <https://en.wikipedia.org/wiki/CIDR_notation#CIDR_notation>, also known as
    /// 'slash' notation (e.g. `192.168.100.0/24`).
    pub authorized_networks: std::vec::Vec<crate::model::SqlAclEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlIpConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_ipv4][crate::model::SqlIpConfig::enable_ipv4].
    pub fn set_enable_ipv4<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_ipv4 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_ipv4][crate::model::SqlIpConfig::enable_ipv4].
    pub fn set_or_clear_enable_ipv4<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_ipv4 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_network][crate::model::SqlIpConfig::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::SqlIpConfig::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::SqlIpConfig::require_ssl].
    pub fn set_require_ssl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_ssl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [require_ssl][crate::model::SqlIpConfig::require_ssl].
    pub fn set_or_clear_require_ssl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.require_ssl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorized_networks][crate::model::SqlIpConfig::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlAclEntry>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlIpConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlIpConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SqlIpConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_ipv4,
            __private_network,
            __allocated_ip_range,
            __require_ssl,
            __authorized_networks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SqlIpConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableIpv4" => Ok(__FieldTag::__enable_ipv4),
                            "enable_ipv4" => Ok(__FieldTag::__enable_ipv4),
                            "privateNetwork" => Ok(__FieldTag::__private_network),
                            "private_network" => Ok(__FieldTag::__private_network),
                            "allocatedIpRange" => Ok(__FieldTag::__allocated_ip_range),
                            "allocated_ip_range" => Ok(__FieldTag::__allocated_ip_range),
                            "requireSsl" => Ok(__FieldTag::__require_ssl),
                            "require_ssl" => Ok(__FieldTag::__require_ssl),
                            "authorizedNetworks" => Ok(__FieldTag::__authorized_networks),
                            "authorized_networks" => Ok(__FieldTag::__authorized_networks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SqlIpConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SqlIpConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_ipv4 => {
                            if !fields.insert(__FieldTag::__enable_ipv4) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_ipv4",
                                ));
                            }
                            result.enable_ipv4 =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__private_network => {
                            if !fields.insert(__FieldTag::__private_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_network",
                                ));
                            }
                            result.private_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allocated_ip_range => {
                            if !fields.insert(__FieldTag::__allocated_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocated_ip_range",
                                ));
                            }
                            result.allocated_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__require_ssl => {
                            if !fields.insert(__FieldTag::__require_ssl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_ssl",
                                ));
                            }
                            result.require_ssl =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__authorized_networks => {
                            if !fields.insert(__FieldTag::__authorized_networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_networks",
                                ));
                            }
                            result.authorized_networks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SqlAclEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SqlIpConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_ipv4.is_some() {
            state.serialize_entry("enableIpv4", &self.enable_ipv4)?;
        }
        if !self.private_network.is_empty() {
            state.serialize_entry("privateNetwork", &self.private_network)?;
        }
        if !self.allocated_ip_range.is_empty() {
            state.serialize_entry("allocatedIpRange", &self.allocated_ip_range)?;
        }
        if self.require_ssl.is_some() {
            state.serialize_entry("requireSsl", &self.require_ssl)?;
        }
        if !self.authorized_networks.is_empty() {
            state.serialize_entry("authorizedNetworks", &self.authorized_networks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SqlIpConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SqlIpConfig");
        debug_struct.field("enable_ipv4", &self.enable_ipv4);
        debug_struct.field("private_network", &self.private_network);
        debug_struct.field("allocated_ip_range", &self.allocated_ip_range);
        debug_struct.field("require_ssl", &self.require_ssl);
        debug_struct.field("authorized_networks", &self.authorized_networks);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Settings for creating a Cloud SQL database instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudSqlSettings {
    /// The database engine type and version.
    pub database_version: crate::model::cloud_sql_settings::SqlDatabaseVersion,

    /// The resource labels for a Cloud SQL instance to use to annotate any related
    /// underlying resources such as Compute Engine VMs.
    /// An object containing a list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "18kg", "count": "3" }`.
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The tier (or machine type) for this instance, for example:
    /// `db-n1-standard-1` (MySQL instances) or
    /// `db-custom-1-3840` (PostgreSQL instances).
    /// For more information, see
    /// [Cloud SQL Instance
    /// Settings](https://cloud.google.com/sql/docs/mysql/instance-settings).
    pub tier: std::string::String,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is 'RUNNABLE'. Valid values:
    ///
    /// 'ALWAYS': The instance is on, and remains so even in
    /// the absence of connection requests.
    ///
    /// `NEVER`: The instance is off; it is not activated, even if a
    /// connection request arrives.
    pub activation_policy: crate::model::cloud_sql_settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled.
    pub ip_config: std::option::Option<crate::model::SqlIpConfig>,

    /// [default: ON] If you enable this setting, Cloud SQL checks your available
    /// storage every 30 seconds. If the available storage falls below a threshold
    /// size, Cloud SQL automatically adds additional storage capacity. If the
    /// available storage repeatedly falls below the threshold size, Cloud SQL
    /// continues to add storage until it reaches the maximum of 30 TB.
    pub auto_storage_increase: std::option::Option<wkt::BoolValue>,

    /// The database flags passed to the Cloud SQL instance at startup.
    /// An object containing a list of "key": value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The type of storage: `PD_SSD` (default) or `PD_HDD`.
    pub data_disk_type: crate::model::cloud_sql_settings::SqlDataDiskType,

    /// The storage capacity available to the database, in GB.
    /// The minimum (and default) size is 10GB.
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// The Google Cloud Platform zone where your Cloud SQL database instance is
    /// located.
    pub zone: std::string::String,

    /// Optional. The Google Cloud Platform zone where the failover Cloud SQL
    /// database instance is located. Used when the Cloud SQL database availability
    /// type is REGIONAL (i.e. multiple zones / highly available).
    pub secondary_zone: std::string::String,

    /// The Database Migration Service source connection profile ID,
    /// in the format:
    /// `projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID`
    pub source_id: std::string::String,

    /// Input only. Initial root password.
    pub root_password: std::string::String,

    /// Output only. Indicates If this connection profile root password is stored.
    pub root_password_set: bool,

    /// The Cloud SQL default instance level collation.
    pub collation: std::string::String,

    /// The KMS key name used for the csql instance.
    pub cmek_key_name: std::string::String,

    /// Optional. Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data availability.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    pub availability_type: crate::model::cloud_sql_settings::SqlAvailabilityType,

    /// Optional. The edition of the given Cloud SQL instance.
    pub edition: crate::model::cloud_sql_settings::Edition,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::CloudSqlSettings::database_version].
    pub fn set_database_version<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDatabaseVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::CloudSqlSettings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tier][crate::model::CloudSqlSettings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::CloudSqlSettings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.storage_auto_resize_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_auto_resize_limit][crate::model::CloudSqlSettings::storage_auto_resize_limit].
    pub fn set_or_clear_storage_auto_resize_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.storage_auto_resize_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [activation_policy][crate::model::CloudSqlSettings::activation_policy].
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_config][crate::model::CloudSqlSettings::ip_config].
    pub fn set_ip_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SqlIpConfig>,
    {
        self.ip_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_config][crate::model::CloudSqlSettings::ip_config].
    pub fn set_or_clear_ip_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SqlIpConfig>,
    {
        self.ip_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_storage_increase][crate::model::CloudSqlSettings::auto_storage_increase].
    pub fn set_auto_storage_increase<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.auto_storage_increase = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_storage_increase][crate::model::CloudSqlSettings::auto_storage_increase].
    pub fn set_or_clear_auto_storage_increase<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.auto_storage_increase = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_flags][crate::model::CloudSqlSettings::database_flags].
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::CloudSqlSettings::data_disk_type].
    pub fn set_data_disk_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDataDiskType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::CloudSqlSettings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_disk_size_gb][crate::model::CloudSqlSettings::data_disk_size_gb].
    pub fn set_or_clear_data_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.data_disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::CloudSqlSettings::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::CloudSqlSettings::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CloudSqlSettings::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [root_password][crate::model::CloudSqlSettings::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [root_password_set][crate::model::CloudSqlSettings::root_password_set].
    pub fn set_root_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.root_password_set = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::CloudSqlSettings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::CloudSqlSettings::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::CloudSqlSettings::availability_type].
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlAvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::CloudSqlSettings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::cloud_sql_settings::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudSqlSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database_version,
            __user_labels,
            __tier,
            __storage_auto_resize_limit,
            __activation_policy,
            __ip_config,
            __auto_storage_increase,
            __database_flags,
            __data_disk_type,
            __data_disk_size_gb,
            __zone,
            __secondary_zone,
            __source_id,
            __root_password,
            __root_password_set,
            __collation,
            __cmek_key_name,
            __availability_type,
            __edition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudSqlSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "databaseVersion" => Ok(__FieldTag::__database_version),
                            "database_version" => Ok(__FieldTag::__database_version),
                            "userLabels" => Ok(__FieldTag::__user_labels),
                            "user_labels" => Ok(__FieldTag::__user_labels),
                            "tier" => Ok(__FieldTag::__tier),
                            "storageAutoResizeLimit" => Ok(__FieldTag::__storage_auto_resize_limit),
                            "storage_auto_resize_limit" => {
                                Ok(__FieldTag::__storage_auto_resize_limit)
                            }
                            "activationPolicy" => Ok(__FieldTag::__activation_policy),
                            "activation_policy" => Ok(__FieldTag::__activation_policy),
                            "ipConfig" => Ok(__FieldTag::__ip_config),
                            "ip_config" => Ok(__FieldTag::__ip_config),
                            "autoStorageIncrease" => Ok(__FieldTag::__auto_storage_increase),
                            "auto_storage_increase" => Ok(__FieldTag::__auto_storage_increase),
                            "databaseFlags" => Ok(__FieldTag::__database_flags),
                            "database_flags" => Ok(__FieldTag::__database_flags),
                            "dataDiskType" => Ok(__FieldTag::__data_disk_type),
                            "data_disk_type" => Ok(__FieldTag::__data_disk_type),
                            "dataDiskSizeGb" => Ok(__FieldTag::__data_disk_size_gb),
                            "data_disk_size_gb" => Ok(__FieldTag::__data_disk_size_gb),
                            "zone" => Ok(__FieldTag::__zone),
                            "secondaryZone" => Ok(__FieldTag::__secondary_zone),
                            "secondary_zone" => Ok(__FieldTag::__secondary_zone),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "rootPassword" => Ok(__FieldTag::__root_password),
                            "root_password" => Ok(__FieldTag::__root_password),
                            "rootPasswordSet" => Ok(__FieldTag::__root_password_set),
                            "root_password_set" => Ok(__FieldTag::__root_password_set),
                            "collation" => Ok(__FieldTag::__collation),
                            "cmekKeyName" => Ok(__FieldTag::__cmek_key_name),
                            "cmek_key_name" => Ok(__FieldTag::__cmek_key_name),
                            "availabilityType" => Ok(__FieldTag::__availability_type),
                            "availability_type" => Ok(__FieldTag::__availability_type),
                            "edition" => Ok(__FieldTag::__edition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudSqlSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudSqlSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database_version => {
                            if !fields.insert(__FieldTag::__database_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_version",
                                ));
                            }
                            result.database_version = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_settings::SqlDatabaseVersion,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_labels => {
                            if !fields.insert(__FieldTag::__user_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_labels",
                                ));
                            }
                            result.user_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_auto_resize_limit => {
                            if !fields.insert(__FieldTag::__storage_auto_resize_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_auto_resize_limit",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_auto_resize_limit = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__activation_policy => {
                            if !fields.insert(__FieldTag::__activation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for activation_policy",
                                ));
                            }
                            result.activation_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_settings::SqlActivationPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_config => {
                            if !fields.insert(__FieldTag::__ip_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_config",
                                ));
                            }
                            result.ip_config =
                                map.next_value::<std::option::Option<crate::model::SqlIpConfig>>()?;
                        }
                        __FieldTag::__auto_storage_increase => {
                            if !fields.insert(__FieldTag::__auto_storage_increase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_storage_increase",
                                ));
                            }
                            result.auto_storage_increase =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__database_flags => {
                            if !fields.insert(__FieldTag::__database_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_flags",
                                ));
                            }
                            result.database_flags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_disk_type => {
                            if !fields.insert(__FieldTag::__data_disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disk_type",
                                ));
                            }
                            result.data_disk_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_settings::SqlDataDiskType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_disk_size_gb => {
                            if !fields.insert(__FieldTag::__data_disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_disk_size_gb = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_zone => {
                            if !fields.insert(__FieldTag::__secondary_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_zone",
                                ));
                            }
                            result.secondary_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_password => {
                            if !fields.insert(__FieldTag::__root_password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_password",
                                ));
                            }
                            result.root_password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_password_set => {
                            if !fields.insert(__FieldTag::__root_password_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_password_set",
                                ));
                            }
                            result.root_password_set = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmek_key_name => {
                            if !fields.insert(__FieldTag::__cmek_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmek_key_name",
                                ));
                            }
                            result.cmek_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__availability_type => {
                            if !fields.insert(__FieldTag::__availability_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability_type",
                                ));
                            }
                            result.availability_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_sql_settings::SqlAvailabilityType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__edition => {
                            if !fields.insert(__FieldTag::__edition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for edition",
                                ));
                            }
                            result.edition = map.next_value::<std::option::Option<crate::model::cloud_sql_settings::Edition>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudSqlSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.database_version) {
            state.serialize_entry("databaseVersion", &self.database_version)?;
        }
        if !self.user_labels.is_empty() {
            state.serialize_entry("userLabels", &self.user_labels)?;
        }
        if !self.tier.is_empty() {
            state.serialize_entry("tier", &self.tier)?;
        }
        if self.storage_auto_resize_limit.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "storageAutoResizeLimit",
                &__With(&self.storage_auto_resize_limit),
            )?;
        }
        if !wkt::internal::is_default(&self.activation_policy) {
            state.serialize_entry("activationPolicy", &self.activation_policy)?;
        }
        if self.ip_config.is_some() {
            state.serialize_entry("ipConfig", &self.ip_config)?;
        }
        if self.auto_storage_increase.is_some() {
            state.serialize_entry("autoStorageIncrease", &self.auto_storage_increase)?;
        }
        if !self.database_flags.is_empty() {
            state.serialize_entry("databaseFlags", &self.database_flags)?;
        }
        if !wkt::internal::is_default(&self.data_disk_type) {
            state.serialize_entry("dataDiskType", &self.data_disk_type)?;
        }
        if self.data_disk_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("dataDiskSizeGb", &__With(&self.data_disk_size_gb))?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.secondary_zone.is_empty() {
            state.serialize_entry("secondaryZone", &self.secondary_zone)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if !self.root_password.is_empty() {
            state.serialize_entry("rootPassword", &self.root_password)?;
        }
        if !wkt::internal::is_default(&self.root_password_set) {
            state.serialize_entry("rootPasswordSet", &self.root_password_set)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !self.cmek_key_name.is_empty() {
            state.serialize_entry("cmekKeyName", &self.cmek_key_name)?;
        }
        if !wkt::internal::is_default(&self.availability_type) {
            state.serialize_entry("availabilityType", &self.availability_type)?;
        }
        if !wkt::internal::is_default(&self.edition) {
            state.serialize_entry("edition", &self.edition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudSqlSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudSqlSettings");
        debug_struct.field("database_version", &self.database_version);
        debug_struct.field("user_labels", &self.user_labels);
        debug_struct.field("tier", &self.tier);
        debug_struct.field("storage_auto_resize_limit", &self.storage_auto_resize_limit);
        debug_struct.field("activation_policy", &self.activation_policy);
        debug_struct.field("ip_config", &self.ip_config);
        debug_struct.field("auto_storage_increase", &self.auto_storage_increase);
        debug_struct.field("database_flags", &self.database_flags);
        debug_struct.field("data_disk_type", &self.data_disk_type);
        debug_struct.field("data_disk_size_gb", &self.data_disk_size_gb);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("secondary_zone", &self.secondary_zone);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("root_password", &self.root_password);
        debug_struct.field("root_password_set", &self.root_password_set);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("cmek_key_name", &self.cmek_key_name);
        debug_struct.field("availability_type", &self.availability_type);
        debug_struct.field("edition", &self.edition);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudSqlSettings].
pub mod cloud_sql_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when the instance should be activated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlActivationPolicy {
        /// unspecified policy.
        Unspecified,
        /// The instance is always up and running.
        Always,
        /// The instance should never spin up.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlActivationPolicy::value] or
        /// [SqlActivationPolicy::name].
        UnknownValue(sql_activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlActivationPolicy>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlActivationPolicy",
            ))
        }
    }

    /// The storage options for Cloud SQL databases.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlDataDiskType {
        /// Unspecified.
        Unspecified,
        /// SSD disk.
        PdSsd,
        /// HDD disk.
        PdHdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlDataDiskType::value] or
        /// [SqlDataDiskType::name].
        UnknownValue(sql_data_disk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_data_disk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlDataDiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PdSsd => std::option::Option::Some(1),
                Self::PdHdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
                Self::PdSsd => std::option::Option::Some("PD_SSD"),
                Self::PdHdd => std::option::Option::Some("PD_HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlDataDiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlDataDiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlDataDiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PdSsd,
                2 => Self::PdHdd,
                _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlDataDiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PD_SSD" => Self::PdSsd,
                "PD_HDD" => Self::PdHdd,
                _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlDataDiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PdSsd => serializer.serialize_i32(1),
                Self::PdHdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlDataDiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDataDiskType>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlDataDiskType",
            ))
        }
    }

    /// The database engine type and version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlDatabaseVersion {
        /// Unspecified version.
        Unspecified,
        /// MySQL 5.6.
        Mysql56,
        /// MySQL 5.7.
        Mysql57,
        /// PostgreSQL 9.6.
        Postgres96,
        /// PostgreSQL 11.
        Postgres11,
        /// PostgreSQL 10.
        Postgres10,
        /// MySQL 8.0.
        Mysql80,
        /// PostgreSQL 12.
        Postgres12,
        /// PostgreSQL 13.
        Postgres13,
        /// PostgreSQL 14.
        Postgres14,
        /// PostgreSQL 15.
        Postgres15,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlDatabaseVersion::value] or
        /// [SqlDatabaseVersion::name].
        UnknownValue(sql_database_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_database_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlDatabaseVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Mysql56 => std::option::Option::Some(1),
                Self::Mysql57 => std::option::Option::Some(2),
                Self::Postgres96 => std::option::Option::Some(3),
                Self::Postgres11 => std::option::Option::Some(4),
                Self::Postgres10 => std::option::Option::Some(5),
                Self::Mysql80 => std::option::Option::Some(6),
                Self::Postgres12 => std::option::Option::Some(7),
                Self::Postgres13 => std::option::Option::Some(8),
                Self::Postgres14 => std::option::Option::Some(17),
                Self::Postgres15 => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_DATABASE_VERSION_UNSPECIFIED"),
                Self::Mysql56 => std::option::Option::Some("MYSQL_5_6"),
                Self::Mysql57 => std::option::Option::Some("MYSQL_5_7"),
                Self::Postgres96 => std::option::Option::Some("POSTGRES_9_6"),
                Self::Postgres11 => std::option::Option::Some("POSTGRES_11"),
                Self::Postgres10 => std::option::Option::Some("POSTGRES_10"),
                Self::Mysql80 => std::option::Option::Some("MYSQL_8_0"),
                Self::Postgres12 => std::option::Option::Some("POSTGRES_12"),
                Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
                Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
                Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlDatabaseVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlDatabaseVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlDatabaseVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Mysql56,
                2 => Self::Mysql57,
                3 => Self::Postgres96,
                4 => Self::Postgres11,
                5 => Self::Postgres10,
                6 => Self::Mysql80,
                7 => Self::Postgres12,
                8 => Self::Postgres13,
                17 => Self::Postgres14,
                18 => Self::Postgres15,
                _ => Self::UnknownValue(sql_database_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlDatabaseVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
                "MYSQL_5_6" => Self::Mysql56,
                "MYSQL_5_7" => Self::Mysql57,
                "POSTGRES_9_6" => Self::Postgres96,
                "POSTGRES_11" => Self::Postgres11,
                "POSTGRES_10" => Self::Postgres10,
                "MYSQL_8_0" => Self::Mysql80,
                "POSTGRES_12" => Self::Postgres12,
                "POSTGRES_13" => Self::Postgres13,
                "POSTGRES_14" => Self::Postgres14,
                "POSTGRES_15" => Self::Postgres15,
                _ => Self::UnknownValue(sql_database_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlDatabaseVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Mysql56 => serializer.serialize_i32(1),
                Self::Mysql57 => serializer.serialize_i32(2),
                Self::Postgres96 => serializer.serialize_i32(3),
                Self::Postgres11 => serializer.serialize_i32(4),
                Self::Postgres10 => serializer.serialize_i32(5),
                Self::Mysql80 => serializer.serialize_i32(6),
                Self::Postgres12 => serializer.serialize_i32(7),
                Self::Postgres13 => serializer.serialize_i32(8),
                Self::Postgres14 => serializer.serialize_i32(17),
                Self::Postgres15 => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlDatabaseVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDatabaseVersion>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlDatabaseVersion",
            ))
        }
    }

    /// The availability type of the given Cloud SQL instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlAvailabilityType {
        /// This is an unknown Availability type.
        Unspecified,
        /// Zonal availablility instance.
        Zonal,
        /// Regional availability instance.
        Regional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlAvailabilityType::value] or
        /// [SqlAvailabilityType::name].
        UnknownValue(sql_availability_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_availability_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlAvailabilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Zonal => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_AVAILABILITY_TYPE_UNSPECIFIED"),
                Self::Zonal => std::option::Option::Some("ZONAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlAvailabilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlAvailabilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlAvailabilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Zonal,
                2 => Self::Regional,
                _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlAvailabilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ZONAL" => Self::Zonal,
                "REGIONAL" => Self::Regional,
                _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlAvailabilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Zonal => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlAvailabilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlAvailabilityType>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlAvailabilityType",
            ))
        }
    }

    /// The edition of the given Cloud SQL instance.
    /// Can be ENTERPRISE or ENTERPRISE_PLUS.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified,
        /// The instance is an enterprise edition.
        Enterprise,
        /// The instance is an enterprise plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.Edition",
            ))
        }
    }
}

/// Settings for creating an AlloyDB cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AlloyDbSettings {
    /// Required. Input only. Initial user to setup during cluster creation.
    /// Required.
    pub initial_user: std::option::Option<crate::model::alloy_db_settings::UserPassword>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: "projects/{project_number}/global/networks/{network_id}". This is
    /// required to create a cluster.
    pub vpc_network: std::string::String,

    /// Labels for the AlloyDB cluster created by DMS. An object containing a list
    /// of 'key', 'value' pairs.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub primary_instance_settings:
        std::option::Option<crate::model::alloy_db_settings::PrimaryInstanceSettings>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    pub encryption_config: std::option::Option<crate::model::alloy_db_settings::EncryptionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlloyDbSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_user][crate::model::AlloyDbSettings::initial_user].
    pub fn set_initial_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::UserPassword>,
    {
        self.initial_user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_user][crate::model::AlloyDbSettings::initial_user].
    pub fn set_or_clear_initial_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::UserPassword>,
    {
        self.initial_user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vpc_network][crate::model::AlloyDbSettings::vpc_network].
    pub fn set_vpc_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_network = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AlloyDbSettings::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [primary_instance_settings][crate::model::AlloyDbSettings::primary_instance_settings].
    pub fn set_primary_instance_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::PrimaryInstanceSettings>,
    {
        self.primary_instance_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_instance_settings][crate::model::AlloyDbSettings::primary_instance_settings].
    pub fn set_or_clear_primary_instance_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::PrimaryInstanceSettings>,
    {
        self.primary_instance_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::AlloyDbSettings::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::AlloyDbSettings::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::alloy_db_settings::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AlloyDbSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AlloyDbSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initial_user,
            __vpc_network,
            __labels,
            __primary_instance_settings,
            __encryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AlloyDbSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initialUser" => Ok(__FieldTag::__initial_user),
                            "initial_user" => Ok(__FieldTag::__initial_user),
                            "vpcNetwork" => Ok(__FieldTag::__vpc_network),
                            "vpc_network" => Ok(__FieldTag::__vpc_network),
                            "labels" => Ok(__FieldTag::__labels),
                            "primaryInstanceSettings" => {
                                Ok(__FieldTag::__primary_instance_settings)
                            }
                            "primary_instance_settings" => {
                                Ok(__FieldTag::__primary_instance_settings)
                            }
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AlloyDbSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AlloyDbSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initial_user => {
                            if !fields.insert(__FieldTag::__initial_user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_user",
                                ));
                            }
                            result.initial_user = map.next_value::<std::option::Option<
                                crate::model::alloy_db_settings::UserPassword,
                            >>()?;
                        }
                        __FieldTag::__vpc_network => {
                            if !fields.insert(__FieldTag::__vpc_network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_network",
                                ));
                            }
                            result.vpc_network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_instance_settings => {
                            if !fields.insert(__FieldTag::__primary_instance_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_instance_settings",
                                ));
                            }
                            result.primary_instance_settings = map
                                .next_value::<std::option::Option<
                                    crate::model::alloy_db_settings::PrimaryInstanceSettings,
                                >>()?;
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map.next_value::<std::option::Option<
                                crate::model::alloy_db_settings::EncryptionConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AlloyDbSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.initial_user.is_some() {
            state.serialize_entry("initialUser", &self.initial_user)?;
        }
        if !self.vpc_network.is_empty() {
            state.serialize_entry("vpcNetwork", &self.vpc_network)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.primary_instance_settings.is_some() {
            state.serialize_entry("primaryInstanceSettings", &self.primary_instance_settings)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AlloyDbSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AlloyDbSettings");
        debug_struct.field("initial_user", &self.initial_user);
        debug_struct.field("vpc_network", &self.vpc_network);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("primary_instance_settings", &self.primary_instance_settings);
        debug_struct.field("encryption_config", &self.encryption_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AlloyDbSettings].
pub mod alloy_db_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The username/password for a database user. Used for specifying initial
    /// users at cluster creation time.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserPassword {
        /// The database username.
        pub user: std::string::String,

        /// The initial password for the user.
        pub password: std::string::String,

        /// Output only. Indicates if the initial_user.password field has been set.
        pub password_set: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserPassword {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user][crate::model::alloy_db_settings::UserPassword::user].
        pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.user = v.into();
            self
        }

        /// Sets the value of [password][crate::model::alloy_db_settings::UserPassword::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [password_set][crate::model::alloy_db_settings::UserPassword::password_set].
        pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.password_set = v.into();
            self
        }
    }

    impl wkt::message::Message for UserPassword {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.UserPassword"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserPassword {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __user,
                __password,
                __password_set,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserPassword")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "user" => Ok(__FieldTag::__user),
                                "password" => Ok(__FieldTag::__password),
                                "passwordSet" => Ok(__FieldTag::__password_set),
                                "password_set" => Ok(__FieldTag::__password_set),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserPassword;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserPassword")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__user => {
                                if !fields.insert(__FieldTag::__user) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for user",
                                    ));
                                }
                                result.user = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password_set => {
                                if !fields.insert(__FieldTag::__password_set) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password_set",
                                    ));
                                }
                                result.password_set = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UserPassword {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.user.is_empty() {
                state.serialize_entry("user", &self.user)?;
            }
            if !self.password.is_empty() {
                state.serialize_entry("password", &self.password)?;
            }
            if !wkt::internal::is_default(&self.password_set) {
                state.serialize_entry("passwordSet", &self.password_set)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UserPassword {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UserPassword");
            debug_struct.field("user", &self.user);
            debug_struct.field("password", &self.password);
            debug_struct.field("password_set", &self.password_set);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Settings for the cluster's primary instance
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrimaryInstanceSettings {
        /// Required. The ID of the AlloyDB primary instance. The ID must satisfy the
        /// regex expression "[a-z0-9-]+".
        pub id: std::string::String,

        /// Configuration for the machines that host the underlying
        /// database engine.
        pub machine_config: std::option::Option<
            crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
        >,

        /// Database flags to pass to AlloyDB when DMS is creating the AlloyDB
        /// cluster and instances. See the AlloyDB documentation for how these can be
        /// used.
        pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

        /// Labels for the AlloyDB primary instance created by DMS. An object
        /// containing a list of 'key', 'value' pairs.
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// Output only. The private IP address for the Instance.
        /// This is the connection endpoint for an end-user application.
        pub private_ip: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrimaryInstanceSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::alloy_db_settings::PrimaryInstanceSettings::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [machine_config][crate::model::alloy_db_settings::PrimaryInstanceSettings::machine_config].
        pub fn set_machine_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
                >,
        {
            self.machine_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [machine_config][crate::model::alloy_db_settings::PrimaryInstanceSettings::machine_config].
        pub fn set_or_clear_machine_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
                >,
        {
            self.machine_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [database_flags][crate::model::alloy_db_settings::PrimaryInstanceSettings::database_flags].
        pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [labels][crate::model::alloy_db_settings::PrimaryInstanceSettings::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [private_ip][crate::model::alloy_db_settings::PrimaryInstanceSettings::private_ip].
        pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.private_ip = v.into();
            self
        }
    }

    impl wkt::message::Message for PrimaryInstanceSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrimaryInstanceSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __machine_config,
                __database_flags,
                __labels,
                __private_ip,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrimaryInstanceSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "machineConfig" => Ok(__FieldTag::__machine_config),
                                "machine_config" => Ok(__FieldTag::__machine_config),
                                "databaseFlags" => Ok(__FieldTag::__database_flags),
                                "database_flags" => Ok(__FieldTag::__database_flags),
                                "labels" => Ok(__FieldTag::__labels),
                                "privateIp" => Ok(__FieldTag::__private_ip),
                                "private_ip" => Ok(__FieldTag::__private_ip),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrimaryInstanceSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrimaryInstanceSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__machine_config => {
                                if !fields.insert(__FieldTag::__machine_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_config",
                                    ));
                                }
                                result.machine_config = map.next_value::<std::option::Option<crate::model::alloy_db_settings::primary_instance_settings::MachineConfig>>()?
                                    ;
                            }
                            __FieldTag::__database_flags => {
                                if !fields.insert(__FieldTag::__database_flags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for database_flags",
                                    ));
                                }
                                result.database_flags = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__private_ip => {
                                if !fields.insert(__FieldTag::__private_ip) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for private_ip",
                                    ));
                                }
                                result.private_ip = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrimaryInstanceSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if self.machine_config.is_some() {
                state.serialize_entry("machineConfig", &self.machine_config)?;
            }
            if !self.database_flags.is_empty() {
                state.serialize_entry("databaseFlags", &self.database_flags)?;
            }
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.private_ip.is_empty() {
                state.serialize_entry("privateIp", &self.private_ip)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PrimaryInstanceSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PrimaryInstanceSettings");
            debug_struct.field("id", &self.id);
            debug_struct.field("machine_config", &self.machine_config);
            debug_struct.field("database_flags", &self.database_flags);
            debug_struct.field("labels", &self.labels);
            debug_struct.field("private_ip", &self.private_ip);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PrimaryInstanceSettings].
    pub mod primary_instance_settings {
        #[allow(unused_imports)]
        use super::*;

        /// MachineConfig describes the configuration of a machine.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MachineConfig {
            /// The number of CPU's in the VM instance.
            pub cpu_count: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MachineConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cpu_count][crate::model::alloy_db_settings::primary_instance_settings::MachineConfig::cpu_count].
            pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_count = v.into();
                self
            }
        }

        impl wkt::message::Message for MachineConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings.MachineConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MachineConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __cpu_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MachineConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "cpuCount" => Ok(__FieldTag::__cpu_count),
                                    "cpu_count" => Ok(__FieldTag::__cpu_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MachineConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MachineConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__cpu_count => {
                                    if !fields.insert(__FieldTag::__cpu_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for cpu_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.cpu_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MachineConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.cpu_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for MachineConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("MachineConfig");
                debug_struct.field("cpu_count", &self.cpu_count);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// EncryptionConfig describes the encryption config of a cluster that is
    /// encrypted with a CMEK (customer-managed encryption key).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The fully-qualified resource name of the KMS key.
        /// Each Cloud KMS key is regionalized and has the following format:
        /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        pub kms_key_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::alloy_db_settings::EncryptionConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.EncryptionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EncryptionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                                "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EncryptionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EncryptionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key_name => {
                                if !fields.insert(__FieldTag::__kms_key_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_name",
                                    ));
                                }
                                result.kms_key_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EncryptionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key_name.is_empty() {
                state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for EncryptionConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("EncryptionConfig");
            debug_struct.field("kms_key_name", &self.kms_key_name);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The source database will allow incoming connections from the public IP of the
/// destination database. You can retrieve the public IP of the Cloud SQL
/// instance from the Cloud SQL console or using Cloud SQL APIs. No additional
/// configuration is required.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticIpConnectivity {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticIpConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticIpConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticIpConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticIpConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticIpConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticIpConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StaticIpConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticIpConnectivity");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// [Private Service Connect
/// connectivity](https://cloud.google.com/vpc/docs/private-service-connect#service-attachments)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateServiceConnectConnectivity {
    /// Required. A service attachment that exposes a database, and has the
    /// following format:
    /// projects/{project}/regions/{region}/serviceAttachments/{service_attachment_name}
    pub service_attachment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateServiceConnectConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PrivateServiceConnectConnectivity::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }
}

impl wkt::message::Message for PrivateServiceConnectConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateServiceConnectConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateServiceConnectConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_attachment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateServiceConnectConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAttachment" => Ok(__FieldTag::__service_attachment),
                            "service_attachment" => Ok(__FieldTag::__service_attachment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateServiceConnectConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateServiceConnectConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_attachment => {
                            if !fields.insert(__FieldTag::__service_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_attachment",
                                ));
                            }
                            result.service_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateServiceConnectConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_attachment.is_empty() {
            state.serialize_entry("serviceAttachment", &self.service_attachment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateServiceConnectConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateServiceConnectConnectivity");
        debug_struct.field("service_attachment", &self.service_attachment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The details needed to configure a reverse SSH tunnel between the source and
/// destination databases. These details will be used when calling the
/// generateSshScript method (see
/// <https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs/generateSshScript>)
/// to produce the script that will help set up the reverse SSH tunnel, and to
/// set up the VPC peering between the Cloud SQL private network and the VPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReverseSshConnectivity {
    /// Required. The IP of the virtual machine (Compute Engine) used as the
    /// bastion server for the SSH tunnel.
    pub vm_ip: std::string::String,

    /// Required. The forwarding port of the virtual machine (Compute Engine) used
    /// as the bastion server for the SSH tunnel.
    pub vm_port: i32,

    /// The name of the virtual machine (Compute Engine) used as the bastion server
    /// for the SSH tunnel.
    pub vm: std::string::String,

    /// The name of the VPC to peer with the Cloud SQL private network.
    pub vpc: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReverseSshConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_ip][crate::model::ReverseSshConnectivity::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::ReverseSshConnectivity::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::ReverseSshConnectivity::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::ReverseSshConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for ReverseSshConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ReverseSshConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReverseSshConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_ip,
            __vm_port,
            __vm,
            __vpc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReverseSshConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmIp" => Ok(__FieldTag::__vm_ip),
                            "vm_ip" => Ok(__FieldTag::__vm_ip),
                            "vmPort" => Ok(__FieldTag::__vm_port),
                            "vm_port" => Ok(__FieldTag::__vm_port),
                            "vm" => Ok(__FieldTag::__vm),
                            "vpc" => Ok(__FieldTag::__vpc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReverseSshConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReverseSshConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_ip => {
                            if !fields.insert(__FieldTag::__vm_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_ip",
                                ));
                            }
                            result.vm_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_port => {
                            if !fields.insert(__FieldTag::__vm_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vm => {
                            if !fields.insert(__FieldTag::__vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm",
                                ));
                            }
                            result.vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc => {
                            if !fields.insert(__FieldTag::__vpc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc",
                                ));
                            }
                            result.vpc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReverseSshConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_ip.is_empty() {
            state.serialize_entry("vmIp", &self.vm_ip)?;
        }
        if !wkt::internal::is_default(&self.vm_port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vmPort", &__With(&self.vm_port))?;
        }
        if !self.vm.is_empty() {
            state.serialize_entry("vm", &self.vm)?;
        }
        if !self.vpc.is_empty() {
            state.serialize_entry("vpc", &self.vpc)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReverseSshConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReverseSshConnectivity");
        debug_struct.field("vm_ip", &self.vm_ip);
        debug_struct.field("vm_port", &self.vm_port);
        debug_struct.field("vm", &self.vm);
        debug_struct.field("vpc", &self.vpc);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The details of the VPC where the source database is located in Google Cloud.
/// We will use this information to set up the VPC peering connection between
/// Cloud SQL and this VPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcPeeringConnectivity {
    /// The name of the VPC network to peer with the Cloud SQL private network.
    pub vpc: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc][crate::model::VpcPeeringConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcPeeringConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcPeeringConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpc" => Ok(__FieldTag::__vpc),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcPeeringConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcPeeringConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc => {
                            if !fields.insert(__FieldTag::__vpc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc",
                                ));
                            }
                            result.vpc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcPeeringConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc.is_empty() {
            state.serialize_entry("vpc", &self.vpc)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcPeeringConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcPeeringConnectivity");
        debug_struct.field("vpc", &self.vpc);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Forward SSH Tunnel connectivity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ForwardSshTunnelConnectivity {
    /// Required. Hostname for the SSH tunnel.
    pub hostname: std::string::String,

    /// Required. Username for the SSH tunnel.
    pub username: std::string::String,

    /// Port for the SSH tunnel, default value is 22.
    pub port: i32,

    pub authentication_method:
        std::option::Option<crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardSshTunnelConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::ForwardSshTunnelConnectivity::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ForwardSshTunnelConnectivity::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [port][crate::model::ForwardSshTunnelConnectivity::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `PrivateKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `PrivateKey`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ForwardSshTunnelConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ForwardSshTunnelConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ForwardSshTunnelConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hostname,
            __username,
            __port,
            __password,
            __private_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ForwardSshTunnelConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hostname" => Ok(__FieldTag::__hostname),
                            "username" => Ok(__FieldTag::__username),
                            "port" => Ok(__FieldTag::__port),
                            "password" => Ok(__FieldTag::__password),
                            "privateKey" => Ok(__FieldTag::__private_key),
                            "private_key" => Ok(__FieldTag::__private_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ForwardSshTunnelConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ForwardSshTunnelConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.clouddms.v1.ForwardSshTunnelConnectivity.password, latest field was password",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__private_key => {
                            if !fields.insert(__FieldTag::__private_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_key",
                                ));
                            }
                            if result.authentication_method.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authentication_method`, a oneof with full ID .google.cloud.clouddms.v1.ForwardSshTunnelConnectivity.private_key, latest field was privateKey",
                                ));
                            }
                            result.authentication_method = std::option::Option::Some(
                                crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ForwardSshTunnelConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if let Some(value) = self.password() {
            state.serialize_entry("password", value)?;
        }
        if let Some(value) = self.private_key() {
            state.serialize_entry("privateKey", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ForwardSshTunnelConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ForwardSshTunnelConnectivity");
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("username", &self.username);
        debug_struct.field("port", &self.port);
        debug_struct.field("authentication_method", &self.authentication_method);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ForwardSshTunnelConnectivity].
pub mod forward_ssh_tunnel_connectivity {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Input only. SSH password.
        Password(std::string::String),
        /// Input only. SSH private key.
        PrivateKey(std::string::String),
    }
}

/// Static IP address connectivity configured on service project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StaticServiceIpConnectivity {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticServiceIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticServiceIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticServiceIpConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StaticServiceIpConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StaticServiceIpConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StaticServiceIpConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StaticServiceIpConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StaticServiceIpConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StaticServiceIpConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StaticServiceIpConnectivity");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Private Connectivity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateConnectivity {
    /// Required. The resource name (URI) of the private connection.
    pub private_connection: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::PrivateConnectivity::private_connection].
    pub fn set_private_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnectivity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateConnectivity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateConnectivity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateConnection" => Ok(__FieldTag::__private_connection),
                            "private_connection" => Ok(__FieldTag::__private_connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateConnectivity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateConnectivity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_connection => {
                            if !fields.insert(__FieldTag::__private_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_connection",
                                ));
                            }
                            result.private_connection = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateConnectivity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.private_connection.is_empty() {
            state.serialize_entry("privateConnection", &self.private_connection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateConnectivity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnectivity");
        debug_struct.field("private_connection", &self.private_connection);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A message defining the database engine and provider.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseType {
    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The database engine.
    pub engine: crate::model::DatabaseEngine,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::DatabaseType::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::DatabaseType::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseType"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provider,
            __engine,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provider" => Ok(__FieldTag::__provider),
                            "engine" => Ok(__FieldTag::__engine),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provider => {
                            if !fields.insert(__FieldTag::__provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider",
                                ));
                            }
                            result.provider = map
                                .next_value::<std::option::Option<crate::model::DatabaseProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__engine => {
                            if !fields.insert(__FieldTag::__engine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for engine",
                                ));
                            }
                            result.engine = map
                                .next_value::<std::option::Option<crate::model::DatabaseEngine>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.provider) {
            state.serialize_entry("provider", &self.provider)?;
        }
        if !wkt::internal::is_default(&self.engine) {
            state.serialize_entry("engine", &self.engine)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseType");
        debug_struct.field("provider", &self.provider);
        debug_struct.field("engine", &self.engine);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a Database Migration Service migration job object.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationJob {
    /// The name (URI) of this migration job resource, in the form of:
    /// projects/{project}/locations/{location}/migrationJobs/{migrationJob}.
    pub name: std::string::String,

    /// Output only. The timestamp when the migration job resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the migration job resource was last
    /// updated. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for migration job to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The migration job display name.
    pub display_name: std::string::String,

    /// The current migration job state.
    pub state: crate::model::migration_job::State,

    /// Output only. The current migration job phase.
    pub phase: crate::model::migration_job::Phase,

    /// Required. The migration job type.
    pub r#type: crate::model::migration_job::Type,

    /// The path to the dump file in Google Cloud Storage,
    /// in the format: (gs://[BUCKET_NAME]/[OBJECT_NAME]).
    /// This field and the "dump_flags" field are mutually exclusive.
    pub dump_path: std::string::String,

    /// The initial dump flags.
    /// This field and the "dump_path" field are mutually exclusive.
    pub dump_flags: std::option::Option<crate::model::migration_job::DumpFlags>,

    /// Required. The resource name (URI) of the source connection profile.
    pub source: std::string::String,

    /// Required. The resource name (URI) of the destination connection profile.
    pub destination: std::string::String,

    /// Output only. The duration of the migration job (in seconds). A duration in
    /// seconds with up to nine fractional digits, terminated by 's'. Example:
    /// "3.5s".
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. The error details in case of state FAILED.
    pub error: std::option::Option<rpc::model::Status>,

    /// The database engine type and provider of the source.
    pub source_database: std::option::Option<crate::model::DatabaseType>,

    /// The database engine type and provider of the destination.
    pub destination_database: std::option::Option<crate::model::DatabaseType>,

    /// Output only. If the migration job is completed, the time when it was
    /// completed.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The conversion workspace used by the migration.
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspaceInfo>,

    /// This field can be used to select the entities to migrate as part of
    /// the migration job. It uses AIP-160 notation to select a subset of the
    /// entities configured on the associated conversion-workspace. This field
    /// should not be set on migration-jobs that are not associated with a
    /// conversion workspace.
    pub filter: std::string::String,

    /// The CMEK (customer-managed encryption key) fully qualified key name used
    /// for the migration job.
    /// This field supports all migration jobs types except for:
    ///
    /// * Mysql to Mysql (use the cmek field in the cloudsql connection profile
    ///   instead).
    /// * PostrgeSQL to PostgreSQL (use the cmek field in the cloudsql
    ///   connection profile instead).
    /// * PostgreSQL to AlloyDB (use the kms_key_name field in the alloydb
    ///   connection profile instead).
    ///   Each Cloud CMEK key has the following format:
    ///   projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    pub cmek_key_name: std::string::String,

    /// Optional. Data dump parallelism settings used by the migration.
    /// Currently applicable only for MySQL to Cloud SQL for MySQL migrations only.
    pub performance_config: std::option::Option<crate::model::migration_job::PerformanceConfig>,

    /// The connectivity method.
    pub connectivity: std::option::Option<crate::model::migration_job::Connectivity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigrationJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MigrationJob::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MigrationJob::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::MigrationJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::MigrationJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::MigrationJob::phase].
    pub fn set_phase<T: std::convert::Into<crate::model::migration_job::Phase>>(
        mut self,
        v: T,
    ) -> Self {
        self.phase = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::migration_job::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dump_path][crate::model::MigrationJob::dump_path].
    pub fn set_dump_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_path = v.into();
        self
    }

    /// Sets the value of [dump_flags][crate::model::MigrationJob::dump_flags].
    pub fn set_dump_flags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::migration_job::DumpFlags>,
    {
        self.dump_flags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dump_flags][crate::model::MigrationJob::dump_flags].
    pub fn set_or_clear_dump_flags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::migration_job::DumpFlags>,
    {
        self.dump_flags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::MigrationJob::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::MigrationJob::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::MigrationJob::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::MigrationJob::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::MigrationJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::MigrationJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_database][crate::model::MigrationJob::source_database].
    pub fn set_source_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseType>,
    {
        self.source_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_database][crate::model::MigrationJob::source_database].
    pub fn set_or_clear_source_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseType>,
    {
        self.source_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_database][crate::model::MigrationJob::destination_database].
    pub fn set_destination_database<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseType>,
    {
        self.destination_database = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination_database][crate::model::MigrationJob::destination_database].
    pub fn set_or_clear_destination_database<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseType>,
    {
        self.destination_database = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::MigrationJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::MigrationJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::MigrationJob::conversion_workspace].
    pub fn set_conversion_workspace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspaceInfo>,
    {
        self.conversion_workspace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversion_workspace][crate::model::MigrationJob::conversion_workspace].
    pub fn set_or_clear_conversion_workspace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversionWorkspaceInfo>,
    {
        self.conversion_workspace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::MigrationJob::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::MigrationJob::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [performance_config][crate::model::MigrationJob::performance_config].
    pub fn set_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::migration_job::PerformanceConfig>,
    {
        self.performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_config][crate::model::MigrationJob::performance_config].
    pub fn set_or_clear_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::migration_job::PerformanceConfig>,
    {
        self.performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `ReverseSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reverse_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReverseSshConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `ReverseSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_reverse_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ReverseSshConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `VpcPeeringConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_peering_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `VpcPeeringConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __state,
            __phase,
            __type,
            __dump_path,
            __dump_flags,
            __source,
            __destination,
            __reverse_ssh_connectivity,
            __vpc_peering_connectivity,
            __static_ip_connectivity,
            __duration,
            __error,
            __source_database,
            __destination_database,
            __end_time,
            __conversion_workspace,
            __filter,
            __cmek_key_name,
            __performance_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "phase" => Ok(__FieldTag::__phase),
                            "type" => Ok(__FieldTag::__type),
                            "dumpPath" => Ok(__FieldTag::__dump_path),
                            "dump_path" => Ok(__FieldTag::__dump_path),
                            "dumpFlags" => Ok(__FieldTag::__dump_flags),
                            "dump_flags" => Ok(__FieldTag::__dump_flags),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "reverseSshConnectivity" => Ok(__FieldTag::__reverse_ssh_connectivity),
                            "reverse_ssh_connectivity" => {
                                Ok(__FieldTag::__reverse_ssh_connectivity)
                            }
                            "vpcPeeringConnectivity" => Ok(__FieldTag::__vpc_peering_connectivity),
                            "vpc_peering_connectivity" => {
                                Ok(__FieldTag::__vpc_peering_connectivity)
                            }
                            "staticIpConnectivity" => Ok(__FieldTag::__static_ip_connectivity),
                            "static_ip_connectivity" => Ok(__FieldTag::__static_ip_connectivity),
                            "duration" => Ok(__FieldTag::__duration),
                            "error" => Ok(__FieldTag::__error),
                            "sourceDatabase" => Ok(__FieldTag::__source_database),
                            "source_database" => Ok(__FieldTag::__source_database),
                            "destinationDatabase" => Ok(__FieldTag::__destination_database),
                            "destination_database" => Ok(__FieldTag::__destination_database),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "conversionWorkspace" => Ok(__FieldTag::__conversion_workspace),
                            "conversion_workspace" => Ok(__FieldTag::__conversion_workspace),
                            "filter" => Ok(__FieldTag::__filter),
                            "cmekKeyName" => Ok(__FieldTag::__cmek_key_name),
                            "cmek_key_name" => Ok(__FieldTag::__cmek_key_name),
                            "performanceConfig" => Ok(__FieldTag::__performance_config),
                            "performance_config" => Ok(__FieldTag::__performance_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migration_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__phase => {
                            if !fields.insert(__FieldTag::__phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase",
                                ));
                            }
                            result.phase = map.next_value::<std::option::Option<crate::model::migration_job::Phase>>()?.unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::migration_job::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dump_path => {
                            if !fields.insert(__FieldTag::__dump_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dump_path",
                                ));
                            }
                            result.dump_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dump_flags => {
                            if !fields.insert(__FieldTag::__dump_flags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dump_flags",
                                ));
                            }
                            result.dump_flags = map.next_value::<std::option::Option<crate::model::migration_job::DumpFlags>>()?
                                ;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reverse_ssh_connectivity => {
                            if !fields.insert(__FieldTag::__reverse_ssh_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reverse_ssh_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.MigrationJob.reverse_ssh_connectivity, latest field was reverseSshConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::migration_job::Connectivity::ReverseSshConnectivity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReverseSshConnectivity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vpc_peering_connectivity => {
                            if !fields.insert(__FieldTag::__vpc_peering_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_peering_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.MigrationJob.vpc_peering_connectivity, latest field was vpcPeeringConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::migration_job::Connectivity::VpcPeeringConnectivity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpcPeeringConnectivity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__static_ip_connectivity => {
                            if !fields.insert(__FieldTag::__static_ip_connectivity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for static_ip_connectivity",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.MigrationJob.static_ip_connectivity, latest field was staticIpConnectivity",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::migration_job::Connectivity::StaticIpConnectivity(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StaticIpConnectivity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__source_database => {
                            if !fields.insert(__FieldTag::__source_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_database",
                                ));
                            }
                            result.source_database = map
                                .next_value::<std::option::Option<crate::model::DatabaseType>>()?;
                        }
                        __FieldTag::__destination_database => {
                            if !fields.insert(__FieldTag::__destination_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_database",
                                ));
                            }
                            result.destination_database = map
                                .next_value::<std::option::Option<crate::model::DatabaseType>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__conversion_workspace => {
                            if !fields.insert(__FieldTag::__conversion_workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversion_workspace",
                                ));
                            }
                            result.conversion_workspace = map.next_value::<std::option::Option<crate::model::ConversionWorkspaceInfo>>()?
                                ;
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cmek_key_name => {
                            if !fields.insert(__FieldTag::__cmek_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cmek_key_name",
                                ));
                            }
                            result.cmek_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__performance_config => {
                            if !fields.insert(__FieldTag::__performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_config",
                                ));
                            }
                            result.performance_config = map.next_value::<std::option::Option<
                                crate::model::migration_job::PerformanceConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.phase) {
            state.serialize_entry("phase", &self.phase)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.dump_path.is_empty() {
            state.serialize_entry("dumpPath", &self.dump_path)?;
        }
        if self.dump_flags.is_some() {
            state.serialize_entry("dumpFlags", &self.dump_flags)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.destination.is_empty() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if let Some(value) = self.reverse_ssh_connectivity() {
            state.serialize_entry("reverseSshConnectivity", value)?;
        }
        if let Some(value) = self.vpc_peering_connectivity() {
            state.serialize_entry("vpcPeeringConnectivity", value)?;
        }
        if let Some(value) = self.static_ip_connectivity() {
            state.serialize_entry("staticIpConnectivity", value)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.source_database.is_some() {
            state.serialize_entry("sourceDatabase", &self.source_database)?;
        }
        if self.destination_database.is_some() {
            state.serialize_entry("destinationDatabase", &self.destination_database)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.conversion_workspace.is_some() {
            state.serialize_entry("conversionWorkspace", &self.conversion_workspace)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.cmek_key_name.is_empty() {
            state.serialize_entry("cmekKeyName", &self.cmek_key_name)?;
        }
        if self.performance_config.is_some() {
            state.serialize_entry("performanceConfig", &self.performance_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("phase", &self.phase);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("dump_path", &self.dump_path);
        debug_struct.field("dump_flags", &self.dump_flags);
        debug_struct.field("source", &self.source);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("error", &self.error);
        debug_struct.field("source_database", &self.source_database);
        debug_struct.field("destination_database", &self.destination_database);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("conversion_workspace", &self.conversion_workspace);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("cmek_key_name", &self.cmek_key_name);
        debug_struct.field("performance_config", &self.performance_config);
        debug_struct.field("connectivity", &self.connectivity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationJob].
pub mod migration_job {
    #[allow(unused_imports)]
    use super::*;

    /// Dump flag definition.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DumpFlag {
        /// The name of the flag
        pub name: std::string::String,

        /// The value of the flag.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DumpFlag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::migration_job::DumpFlag::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::migration_job::DumpFlag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for DumpFlag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlag"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DumpFlag {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DumpFlag")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DumpFlag;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DumpFlag")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DumpFlag {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DumpFlag {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DumpFlag");
            debug_struct.field("name", &self.name);
            debug_struct.field("value", &self.value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Dump flags definition.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DumpFlags {
        /// The flags for the initial dump.
        pub dump_flags: std::vec::Vec<crate::model::migration_job::DumpFlag>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DumpFlags {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_flags][crate::model::migration_job::DumpFlags::dump_flags].
        pub fn set_dump_flags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migration_job::DumpFlag>,
        {
            use std::iter::Iterator;
            self.dump_flags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DumpFlags {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlags"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DumpFlags {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dump_flags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DumpFlags")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dumpFlags" => Ok(__FieldTag::__dump_flags),
                                "dump_flags" => Ok(__FieldTag::__dump_flags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DumpFlags;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DumpFlags")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dump_flags => {
                                if !fields.insert(__FieldTag::__dump_flags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dump_flags",
                                    ));
                                }
                                result.dump_flags = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::migration_job::DumpFlag>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DumpFlags {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dump_flags.is_empty() {
                state.serialize_entry("dumpFlags", &self.dump_flags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DumpFlags {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DumpFlags");
            debug_struct.field("dump_flags", &self.dump_flags);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Performance configuration definition.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PerformanceConfig {
        /// Initial dump parallelism level.
        pub dump_parallel_level: crate::model::migration_job::performance_config::DumpParallelLevel,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_parallel_level][crate::model::migration_job::PerformanceConfig::dump_parallel_level].
        pub fn set_dump_parallel_level<
            T: std::convert::Into<crate::model::migration_job::performance_config::DumpParallelLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dump_parallel_level = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.PerformanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PerformanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dump_parallel_level,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PerformanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dumpParallelLevel" => Ok(__FieldTag::__dump_parallel_level),
                                "dump_parallel_level" => Ok(__FieldTag::__dump_parallel_level),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PerformanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PerformanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dump_parallel_level => {
                                if !fields.insert(__FieldTag::__dump_parallel_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dump_parallel_level",
                                    ));
                                }
                                result.dump_parallel_level = map.next_value::<std::option::Option<crate::model::migration_job::performance_config::DumpParallelLevel>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PerformanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.dump_parallel_level) {
                state.serialize_entry("dumpParallelLevel", &self.dump_parallel_level)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PerformanceConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PerformanceConfig");
            debug_struct.field("dump_parallel_level", &self.dump_parallel_level);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PerformanceConfig].
    pub mod performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Describes the parallelism level during initial dump.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DumpParallelLevel {
            /// Unknown dump parallel level. Will be defaulted to OPTIMAL.
            Unspecified,
            /// Minimal parallel level.
            Min,
            /// Optimal parallel level.
            Optimal,
            /// Maximum parallel level.
            Max,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DumpParallelLevel::value] or
            /// [DumpParallelLevel::name].
            UnknownValue(dump_parallel_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod dump_parallel_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl DumpParallelLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Min => std::option::Option::Some(1),
                    Self::Optimal => std::option::Option::Some(2),
                    Self::Max => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("DUMP_PARALLEL_LEVEL_UNSPECIFIED")
                    }
                    Self::Min => std::option::Option::Some("MIN"),
                    Self::Optimal => std::option::Option::Some("OPTIMAL"),
                    Self::Max => std::option::Option::Some("MAX"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for DumpParallelLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for DumpParallelLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for DumpParallelLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Min,
                    2 => Self::Optimal,
                    3 => Self::Max,
                    _ => Self::UnknownValue(dump_parallel_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for DumpParallelLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DUMP_PARALLEL_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "MIN" => Self::Min,
                    "OPTIMAL" => Self::Optimal,
                    "MAX" => Self::Max,
                    _ => Self::UnknownValue(dump_parallel_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for DumpParallelLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Min => serializer.serialize_i32(1),
                    Self::Optimal => serializer.serialize_i32(2),
                    Self::Max => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for DumpParallelLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DumpParallelLevel>::new(
                    ".google.cloud.clouddms.v1.MigrationJob.PerformanceConfig.DumpParallelLevel",
                ))
            }
        }
    }

    /// The current migration job states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the migration job is unknown.
        Unspecified,
        /// The migration job is down for maintenance.
        Maintenance,
        /// The migration job is in draft mode and no resources are created.
        Draft,
        /// The migration job is being created.
        Creating,
        /// The migration job is created and not started.
        NotStarted,
        /// The migration job is running.
        Running,
        /// The migration job failed.
        Failed,
        /// The migration job has been completed.
        Completed,
        /// The migration job is being deleted.
        Deleting,
        /// The migration job is being stopped.
        Stopping,
        /// The migration job is currently stopped.
        Stopped,
        /// The migration job has been deleted.
        Deleted,
        /// The migration job is being updated.
        Updating,
        /// The migration job is starting.
        Starting,
        /// The migration job is restarting.
        Restarting,
        /// The migration job is resuming.
        Resuming,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Maintenance => std::option::Option::Some(1),
                Self::Draft => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::NotStarted => std::option::Option::Some(4),
                Self::Running => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Completed => std::option::Option::Some(7),
                Self::Deleting => std::option::Option::Some(8),
                Self::Stopping => std::option::Option::Some(9),
                Self::Stopped => std::option::Option::Some(10),
                Self::Deleted => std::option::Option::Some(11),
                Self::Updating => std::option::Option::Some(12),
                Self::Starting => std::option::Option::Some(13),
                Self::Restarting => std::option::Option::Some(14),
                Self::Resuming => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Restarting => std::option::Option::Some("RESTARTING"),
                Self::Resuming => std::option::Option::Some("RESUMING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Maintenance,
                2 => Self::Draft,
                3 => Self::Creating,
                4 => Self::NotStarted,
                5 => Self::Running,
                6 => Self::Failed,
                7 => Self::Completed,
                8 => Self::Deleting,
                9 => Self::Stopping,
                10 => Self::Stopped,
                11 => Self::Deleted,
                12 => Self::Updating,
                13 => Self::Starting,
                14 => Self::Restarting,
                15 => Self::Resuming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "MAINTENANCE" => Self::Maintenance,
                "DRAFT" => Self::Draft,
                "CREATING" => Self::Creating,
                "NOT_STARTED" => Self::NotStarted,
                "RUNNING" => Self::Running,
                "FAILED" => Self::Failed,
                "COMPLETED" => Self::Completed,
                "DELETING" => Self::Deleting,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                "STARTING" => Self::Starting,
                "RESTARTING" => Self::Restarting,
                "RESUMING" => Self::Resuming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Maintenance => serializer.serialize_i32(1),
                Self::Draft => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::NotStarted => serializer.serialize_i32(4),
                Self::Running => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Completed => serializer.serialize_i32(7),
                Self::Deleting => serializer.serialize_i32(8),
                Self::Stopping => serializer.serialize_i32(9),
                Self::Stopped => serializer.serialize_i32(10),
                Self::Deleted => serializer.serialize_i32(11),
                Self::Updating => serializer.serialize_i32(12),
                Self::Starting => serializer.serialize_i32(13),
                Self::Restarting => serializer.serialize_i32(14),
                Self::Resuming => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.MigrationJob.State",
            ))
        }
    }

    /// The current migration job phase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Phase {
        /// The phase of the migration job is unknown.
        Unspecified,
        /// The migration job is in the full dump phase.
        FullDump,
        /// The migration job is CDC phase.
        Cdc,
        /// The migration job is running the promote phase.
        PromoteInProgress,
        /// Only RDS flow - waiting for source writes to stop
        WaitingForSourceWritesToStop,
        /// Only RDS flow - the sources writes stopped, waiting for dump to begin
        PreparingTheDump,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Phase::value] or
        /// [Phase::name].
        UnknownValue(phase::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phase {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Phase {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FullDump => std::option::Option::Some(1),
                Self::Cdc => std::option::Option::Some(2),
                Self::PromoteInProgress => std::option::Option::Some(3),
                Self::WaitingForSourceWritesToStop => std::option::Option::Some(4),
                Self::PreparingTheDump => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PHASE_UNSPECIFIED"),
                Self::FullDump => std::option::Option::Some("FULL_DUMP"),
                Self::Cdc => std::option::Option::Some("CDC"),
                Self::PromoteInProgress => std::option::Option::Some("PROMOTE_IN_PROGRESS"),
                Self::WaitingForSourceWritesToStop => {
                    std::option::Option::Some("WAITING_FOR_SOURCE_WRITES_TO_STOP")
                }
                Self::PreparingTheDump => std::option::Option::Some("PREPARING_THE_DUMP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Phase {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Phase {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Phase {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FullDump,
                2 => Self::Cdc,
                3 => Self::PromoteInProgress,
                4 => Self::WaitingForSourceWritesToStop,
                5 => Self::PreparingTheDump,
                _ => Self::UnknownValue(phase::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Phase {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHASE_UNSPECIFIED" => Self::Unspecified,
                "FULL_DUMP" => Self::FullDump,
                "CDC" => Self::Cdc,
                "PROMOTE_IN_PROGRESS" => Self::PromoteInProgress,
                "WAITING_FOR_SOURCE_WRITES_TO_STOP" => Self::WaitingForSourceWritesToStop,
                "PREPARING_THE_DUMP" => Self::PreparingTheDump,
                _ => Self::UnknownValue(phase::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Phase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FullDump => serializer.serialize_i32(1),
                Self::Cdc => serializer.serialize_i32(2),
                Self::PromoteInProgress => serializer.serialize_i32(3),
                Self::WaitingForSourceWritesToStop => serializer.serialize_i32(4),
                Self::PreparingTheDump => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Phase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Phase>::new(
                ".google.cloud.clouddms.v1.MigrationJob.Phase",
            ))
        }
    }

    /// The type of migration job (one-time or continuous).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The type of the migration job is unknown.
        Unspecified,
        /// The migration job is a one time migration.
        OneTime,
        /// The migration job is a continuous migration.
        Continuous,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OneTime => std::option::Option::Some(1),
                Self::Continuous => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::OneTime => std::option::Option::Some("ONE_TIME"),
                Self::Continuous => std::option::Option::Some("CONTINUOUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OneTime,
                2 => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "ONE_TIME" => Self::OneTime,
                "CONTINUOUS" => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OneTime => serializer.serialize_i32(1),
                Self::Continuous => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.clouddms.v1.MigrationJob.Type",
            ))
        }
    }

    /// The connectivity method.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connectivity {
        /// The details needed to communicate to the source over Reverse SSH
        /// tunnel connectivity.
        ReverseSshConnectivity(std::boxed::Box<crate::model::ReverseSshConnectivity>),
        /// The details of the VPC network that the source database is located in.
        VpcPeeringConnectivity(std::boxed::Box<crate::model::VpcPeeringConnectivity>),
        /// static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
    }
}

/// A conversion workspace's version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversionWorkspaceInfo {
    /// The resource name (URI) of the conversion workspace.
    pub name: std::string::String,

    /// The commit ID of the conversion workspace.
    pub commit_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversionWorkspaceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspaceInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::ConversionWorkspaceInfo::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for ConversionWorkspaceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspaceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversionWorkspaceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __commit_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversionWorkspaceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "commitId" => Ok(__FieldTag::__commit_id),
                            "commit_id" => Ok(__FieldTag::__commit_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversionWorkspaceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversionWorkspaceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_id => {
                            if !fields.insert(__FieldTag::__commit_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_id",
                                ));
                            }
                            result.commit_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversionWorkspaceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.commit_id.is_empty() {
            state.serialize_entry("commitId", &self.commit_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversionWorkspaceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversionWorkspaceInfo");
        debug_struct.field("name", &self.name);
        debug_struct.field("commit_id", &self.commit_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A connection profile definition.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionProfile {
    /// The name of this connection profile resource in the form of
    /// projects/{project}/locations/{location}/connectionProfiles/{connectionProfile}.
    pub name: std::string::String,

    /// Output only. The timestamp when the resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the resource was last updated.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for connection profile to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    pub state: crate::model::connection_profile::State,

    /// The connection profile display name.
    pub display_name: std::string::String,

    /// Output only. The error details in case of state FAILED.
    pub error: std::option::Option<rpc::model::Status>,

    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The connection profile definition.
    pub connection_profile:
        std::option::Option<crate::model::connection_profile::ConnectionProfile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ConnectionProfile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::ConnectionProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectionProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ConnectionProfile::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ConnectionProfile::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provider][crate::model::ConnectionProfile::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile].
    ///
    /// Note that all the setters affecting `connection_profile` are mutually
    /// exclusive.
    pub fn set_connection_profile<
        T: std::convert::Into<
                std::option::Option<crate::model::connection_profile::ConnectionProfile>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Mysql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Mysql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Mysql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_mysql<
        T: std::convert::Into<std::boxed::Box<crate::model::MySqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Mysql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Postgresql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgreSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Postgresql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Postgresql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_postgresql<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgreSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Postgresql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Oracle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Oracle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Oracle`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_oracle<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Oracle(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Cloudsql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Cloudsql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_cloudsql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Alloydb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alloydb(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AlloyDbConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Alloydb(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Alloydb`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_alloydb<
        T: std::convert::Into<std::boxed::Box<crate::model::AlloyDbConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Alloydb(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConnectionProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __state,
            __display_name,
            __mysql,
            __postgresql,
            __oracle,
            __cloudsql,
            __alloydb,
            __error,
            __provider,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "mysql" => Ok(__FieldTag::__mysql),
                            "postgresql" => Ok(__FieldTag::__postgresql),
                            "oracle" => Ok(__FieldTag::__oracle),
                            "cloudsql" => Ok(__FieldTag::__cloudsql),
                            "alloydb" => Ok(__FieldTag::__alloydb),
                            "error" => Ok(__FieldTag::__error),
                            "provider" => Ok(__FieldTag::__provider),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::connection_profile::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mysql => {
                            if !fields.insert(__FieldTag::__mysql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mysql",
                                ));
                            }
                            if result.connection_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_profile`, a oneof with full ID .google.cloud.clouddms.v1.ConnectionProfile.mysql, latest field was mysql",
                                ));
                            }
                            result.connection_profile = std::option::Option::Some(
                                crate::model::connection_profile::ConnectionProfile::Mysql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MySqlConnectionProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__postgresql => {
                            if !fields.insert(__FieldTag::__postgresql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postgresql",
                                ));
                            }
                            if result.connection_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_profile`, a oneof with full ID .google.cloud.clouddms.v1.ConnectionProfile.postgresql, latest field was postgresql",
                                ));
                            }
                            result.connection_profile = std::option::Option::Some(
                                crate::model::connection_profile::ConnectionProfile::Postgresql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostgreSqlConnectionProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oracle => {
                            if !fields.insert(__FieldTag::__oracle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oracle",
                                ));
                            }
                            if result.connection_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_profile`, a oneof with full ID .google.cloud.clouddms.v1.ConnectionProfile.oracle, latest field was oracle",
                                ));
                            }
                            result.connection_profile = std::option::Option::Some(
                                crate::model::connection_profile::ConnectionProfile::Oracle(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::OracleConnectionProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cloudsql => {
                            if !fields.insert(__FieldTag::__cloudsql) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloudsql",
                                ));
                            }
                            if result.connection_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_profile`, a oneof with full ID .google.cloud.clouddms.v1.ConnectionProfile.cloudsql, latest field was cloudsql",
                                ));
                            }
                            result.connection_profile = std::option::Option::Some(
                                crate::model::connection_profile::ConnectionProfile::Cloudsql(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CloudSqlConnectionProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__alloydb => {
                            if !fields.insert(__FieldTag::__alloydb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alloydb",
                                ));
                            }
                            if result.connection_profile.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection_profile`, a oneof with full ID .google.cloud.clouddms.v1.ConnectionProfile.alloydb, latest field was alloydb",
                                ));
                            }
                            result.connection_profile = std::option::Option::Some(
                                crate::model::connection_profile::ConnectionProfile::Alloydb(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AlloyDbConnectionProfile>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__provider => {
                            if !fields.insert(__FieldTag::__provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider",
                                ));
                            }
                            result.provider = map
                                .next_value::<std::option::Option<crate::model::DatabaseProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.mysql() {
            state.serialize_entry("mysql", value)?;
        }
        if let Some(value) = self.postgresql() {
            state.serialize_entry("postgresql", value)?;
        }
        if let Some(value) = self.oracle() {
            state.serialize_entry("oracle", value)?;
        }
        if let Some(value) = self.cloudsql() {
            state.serialize_entry("cloudsql", value)?;
        }
        if let Some(value) = self.alloydb() {
            state.serialize_entry("alloydb", value)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.provider) {
            state.serialize_entry("provider", &self.provider)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectionProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionProfile");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("state", &self.state);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("error", &self.error);
        debug_struct.field("provider", &self.provider);
        debug_struct.field("connection_profile", &self.connection_profile);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConnectionProfile].
pub mod connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the connection profile is unknown.
        Unspecified,
        /// The connection profile is in draft mode and fully editable.
        Draft,
        /// The connection profile is being created.
        Creating,
        /// The connection profile is ready.
        Ready,
        /// The connection profile is being updated.
        Updating,
        /// The connection profile is being deleted.
        Deleting,
        /// The connection profile has been deleted.
        Deleted,
        /// The last action on the connection profile failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Creating,
                3 => Self::Ready,
                4 => Self::Updating,
                5 => Self::Deleting,
                6 => Self::Deleted,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.ConnectionProfile.State",
            ))
        }
    }

    /// The connection profile definition.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConnectionProfile {
        /// A MySQL database connection profile.
        Mysql(std::boxed::Box<crate::model::MySqlConnectionProfile>),
        /// A PostgreSQL database connection profile.
        Postgresql(std::boxed::Box<crate::model::PostgreSqlConnectionProfile>),
        /// An Oracle database connection profile.
        Oracle(std::boxed::Box<crate::model::OracleConnectionProfile>),
        /// A CloudSQL database connection profile.
        Cloudsql(std::boxed::Box<crate::model::CloudSqlConnectionProfile>),
        /// An AlloyDB cluster connection profile.
        Alloydb(std::boxed::Box<crate::model::AlloyDbConnectionProfile>),
    }
}

/// Error message of a verification Migration job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationJobVerificationError {
    /// Output only. An instance of ErrorCode specifying the error that occurred.
    pub error_code: crate::model::migration_job_verification_error::ErrorCode,

    /// Output only. A formatted message with further details about the error and a
    /// CTA.
    pub error_message: std::string::String,

    /// Output only. A specific detailed error message, if supplied by the engine.
    pub error_detail_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationJobVerificationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::MigrationJobVerificationError::error_code].
    pub fn set_error_code<
        T: std::convert::Into<crate::model::migration_job_verification_error::ErrorCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationJobVerificationError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [error_detail_message][crate::model::MigrationJobVerificationError::error_detail_message].
    pub fn set_error_detail_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_detail_message = v.into();
        self
    }
}

impl wkt::message::Message for MigrationJobVerificationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJobVerificationError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationJobVerificationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_code,
            __error_message,
            __error_detail_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationJobVerificationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorCode" => Ok(__FieldTag::__error_code),
                            "error_code" => Ok(__FieldTag::__error_code),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "errorDetailMessage" => Ok(__FieldTag::__error_detail_message),
                            "error_detail_message" => Ok(__FieldTag::__error_detail_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationJobVerificationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationJobVerificationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_code => {
                            if !fields.insert(__FieldTag::__error_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_code",
                                ));
                            }
                            result.error_code = map
                                .next_value::<std::option::Option<
                                    crate::model::migration_job_verification_error::ErrorCode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_detail_message => {
                            if !fields.insert(__FieldTag::__error_detail_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_detail_message",
                                ));
                            }
                            result.error_detail_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationJobVerificationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.error_code) {
            state.serialize_entry("errorCode", &self.error_code)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self.error_detail_message.is_empty() {
            state.serialize_entry("errorDetailMessage", &self.error_detail_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationJobVerificationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationJobVerificationError");
        debug_struct.field("error_code", &self.error_code);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("error_detail_message", &self.error_detail_message);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationJobVerificationError].
pub mod migration_job_verification_error {
    #[allow(unused_imports)]
    use super::*;

    /// A general error code describing the type of error that occurred.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// An unknown error occurred
        Unspecified,
        /// We failed to connect to one of the connection profile.
        ConnectionFailure,
        /// We failed to authenticate to one of the connection profile.
        AuthenticationFailure,
        /// One of the involved connection profiles has an invalid configuration.
        InvalidConnectionProfileConfig,
        /// The versions of the source and the destination are incompatible.
        VersionIncompatibility,
        /// The types of the source and the destination are incompatible.
        ConnectionProfileTypesIncompatibility,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses,
        /// Extensions installed are either not supported or having unsupported
        /// versions.
        UnsupportedExtensions,
        /// Unsupported migration type.
        UnsupportedMigrationType,
        /// Invalid RDS logical replication.
        InvalidRdsLogicalReplication,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode,
        /// The table definition is not support due to missing primary key or replica
        /// identity.
        UnsupportedTableDefinition,
        /// The definer is not supported.
        UnsupportedDefiner,
        /// Migration is already running at the time of restart request.
        CantRestartRunningMigration,
        /// The source already has a replication setup.
        SourceAlreadySetup,
        /// The source has tables with limited support.
        /// E.g. PostgreSQL tables without primary keys.
        TablesWithLimitedSupport,
        /// The source uses an unsupported locale.
        UnsupportedDatabaseLocale,
        /// The source uses an unsupported Foreign Data Wrapper configuration.
        UnsupportedDatabaseFdwConfig,
        /// There was an underlying RDBMS error.
        ErrorRdbms,
        /// The source DB size in Bytes exceeds a certain threshold. The migration
        /// might require an increase of quota, or might not be supported.
        SourceSizeExceedsThreshold,
        /// The destination DB contains existing databases that are conflicting with
        /// those in the source DB.
        ExistingConflictingDatabases,
        /// Insufficient privilege to enable the parallelism configuration.
        ParallelImportInsufficientPrivilege,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectionFailure => std::option::Option::Some(1),
                Self::AuthenticationFailure => std::option::Option::Some(2),
                Self::InvalidConnectionProfileConfig => std::option::Option::Some(3),
                Self::VersionIncompatibility => std::option::Option::Some(4),
                Self::ConnectionProfileTypesIncompatibility => std::option::Option::Some(5),
                Self::NoPglogicalInstalled => std::option::Option::Some(7),
                Self::PglogicalNodeAlreadyExists => std::option::Option::Some(8),
                Self::InvalidWalLevel => std::option::Option::Some(9),
                Self::InvalidSharedPreloadLibrary => std::option::Option::Some(10),
                Self::InsufficientMaxReplicationSlots => std::option::Option::Some(11),
                Self::InsufficientMaxWalSenders => std::option::Option::Some(12),
                Self::InsufficientMaxWorkerProcesses => std::option::Option::Some(13),
                Self::UnsupportedExtensions => std::option::Option::Some(14),
                Self::UnsupportedMigrationType => std::option::Option::Some(15),
                Self::InvalidRdsLogicalReplication => std::option::Option::Some(16),
                Self::UnsupportedGtidMode => std::option::Option::Some(17),
                Self::UnsupportedTableDefinition => std::option::Option::Some(18),
                Self::UnsupportedDefiner => std::option::Option::Some(19),
                Self::CantRestartRunningMigration => std::option::Option::Some(21),
                Self::SourceAlreadySetup => std::option::Option::Some(23),
                Self::TablesWithLimitedSupport => std::option::Option::Some(24),
                Self::UnsupportedDatabaseLocale => std::option::Option::Some(25),
                Self::UnsupportedDatabaseFdwConfig => std::option::Option::Some(26),
                Self::ErrorRdbms => std::option::Option::Some(27),
                Self::SourceSizeExceedsThreshold => std::option::Option::Some(28),
                Self::ExistingConflictingDatabases => std::option::Option::Some(29),
                Self::ParallelImportInsufficientPrivilege => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::ConnectionFailure => std::option::Option::Some("CONNECTION_FAILURE"),
                Self::AuthenticationFailure => std::option::Option::Some("AUTHENTICATION_FAILURE"),
                Self::InvalidConnectionProfileConfig => {
                    std::option::Option::Some("INVALID_CONNECTION_PROFILE_CONFIG")
                }
                Self::VersionIncompatibility => {
                    std::option::Option::Some("VERSION_INCOMPATIBILITY")
                }
                Self::ConnectionProfileTypesIncompatibility => {
                    std::option::Option::Some("CONNECTION_PROFILE_TYPES_INCOMPATIBILITY")
                }
                Self::NoPglogicalInstalled => std::option::Option::Some("NO_PGLOGICAL_INSTALLED"),
                Self::PglogicalNodeAlreadyExists => {
                    std::option::Option::Some("PGLOGICAL_NODE_ALREADY_EXISTS")
                }
                Self::InvalidWalLevel => std::option::Option::Some("INVALID_WAL_LEVEL"),
                Self::InvalidSharedPreloadLibrary => {
                    std::option::Option::Some("INVALID_SHARED_PRELOAD_LIBRARY")
                }
                Self::InsufficientMaxReplicationSlots => {
                    std::option::Option::Some("INSUFFICIENT_MAX_REPLICATION_SLOTS")
                }
                Self::InsufficientMaxWalSenders => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WAL_SENDERS")
                }
                Self::InsufficientMaxWorkerProcesses => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WORKER_PROCESSES")
                }
                Self::UnsupportedExtensions => std::option::Option::Some("UNSUPPORTED_EXTENSIONS"),
                Self::UnsupportedMigrationType => {
                    std::option::Option::Some("UNSUPPORTED_MIGRATION_TYPE")
                }
                Self::InvalidRdsLogicalReplication => {
                    std::option::Option::Some("INVALID_RDS_LOGICAL_REPLICATION")
                }
                Self::UnsupportedGtidMode => std::option::Option::Some("UNSUPPORTED_GTID_MODE"),
                Self::UnsupportedTableDefinition => {
                    std::option::Option::Some("UNSUPPORTED_TABLE_DEFINITION")
                }
                Self::UnsupportedDefiner => std::option::Option::Some("UNSUPPORTED_DEFINER"),
                Self::CantRestartRunningMigration => {
                    std::option::Option::Some("CANT_RESTART_RUNNING_MIGRATION")
                }
                Self::SourceAlreadySetup => std::option::Option::Some("SOURCE_ALREADY_SETUP"),
                Self::TablesWithLimitedSupport => {
                    std::option::Option::Some("TABLES_WITH_LIMITED_SUPPORT")
                }
                Self::UnsupportedDatabaseLocale => {
                    std::option::Option::Some("UNSUPPORTED_DATABASE_LOCALE")
                }
                Self::UnsupportedDatabaseFdwConfig => {
                    std::option::Option::Some("UNSUPPORTED_DATABASE_FDW_CONFIG")
                }
                Self::ErrorRdbms => std::option::Option::Some("ERROR_RDBMS"),
                Self::SourceSizeExceedsThreshold => {
                    std::option::Option::Some("SOURCE_SIZE_EXCEEDS_THRESHOLD")
                }
                Self::ExistingConflictingDatabases => {
                    std::option::Option::Some("EXISTING_CONFLICTING_DATABASES")
                }
                Self::ParallelImportInsufficientPrivilege => {
                    std::option::Option::Some("PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectionFailure,
                2 => Self::AuthenticationFailure,
                3 => Self::InvalidConnectionProfileConfig,
                4 => Self::VersionIncompatibility,
                5 => Self::ConnectionProfileTypesIncompatibility,
                7 => Self::NoPglogicalInstalled,
                8 => Self::PglogicalNodeAlreadyExists,
                9 => Self::InvalidWalLevel,
                10 => Self::InvalidSharedPreloadLibrary,
                11 => Self::InsufficientMaxReplicationSlots,
                12 => Self::InsufficientMaxWalSenders,
                13 => Self::InsufficientMaxWorkerProcesses,
                14 => Self::UnsupportedExtensions,
                15 => Self::UnsupportedMigrationType,
                16 => Self::InvalidRdsLogicalReplication,
                17 => Self::UnsupportedGtidMode,
                18 => Self::UnsupportedTableDefinition,
                19 => Self::UnsupportedDefiner,
                21 => Self::CantRestartRunningMigration,
                23 => Self::SourceAlreadySetup,
                24 => Self::TablesWithLimitedSupport,
                25 => Self::UnsupportedDatabaseLocale,
                26 => Self::UnsupportedDatabaseFdwConfig,
                27 => Self::ErrorRdbms,
                28 => Self::SourceSizeExceedsThreshold,
                29 => Self::ExistingConflictingDatabases,
                30 => Self::ParallelImportInsufficientPrivilege,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "CONNECTION_FAILURE" => Self::ConnectionFailure,
                "AUTHENTICATION_FAILURE" => Self::AuthenticationFailure,
                "INVALID_CONNECTION_PROFILE_CONFIG" => Self::InvalidConnectionProfileConfig,
                "VERSION_INCOMPATIBILITY" => Self::VersionIncompatibility,
                "CONNECTION_PROFILE_TYPES_INCOMPATIBILITY" => {
                    Self::ConnectionProfileTypesIncompatibility
                }
                "NO_PGLOGICAL_INSTALLED" => Self::NoPglogicalInstalled,
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Self::PglogicalNodeAlreadyExists,
                "INVALID_WAL_LEVEL" => Self::InvalidWalLevel,
                "INVALID_SHARED_PRELOAD_LIBRARY" => Self::InvalidSharedPreloadLibrary,
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => Self::InsufficientMaxReplicationSlots,
                "INSUFFICIENT_MAX_WAL_SENDERS" => Self::InsufficientMaxWalSenders,
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => Self::InsufficientMaxWorkerProcesses,
                "UNSUPPORTED_EXTENSIONS" => Self::UnsupportedExtensions,
                "UNSUPPORTED_MIGRATION_TYPE" => Self::UnsupportedMigrationType,
                "INVALID_RDS_LOGICAL_REPLICATION" => Self::InvalidRdsLogicalReplication,
                "UNSUPPORTED_GTID_MODE" => Self::UnsupportedGtidMode,
                "UNSUPPORTED_TABLE_DEFINITION" => Self::UnsupportedTableDefinition,
                "UNSUPPORTED_DEFINER" => Self::UnsupportedDefiner,
                "CANT_RESTART_RUNNING_MIGRATION" => Self::CantRestartRunningMigration,
                "SOURCE_ALREADY_SETUP" => Self::SourceAlreadySetup,
                "TABLES_WITH_LIMITED_SUPPORT" => Self::TablesWithLimitedSupport,
                "UNSUPPORTED_DATABASE_LOCALE" => Self::UnsupportedDatabaseLocale,
                "UNSUPPORTED_DATABASE_FDW_CONFIG" => Self::UnsupportedDatabaseFdwConfig,
                "ERROR_RDBMS" => Self::ErrorRdbms,
                "SOURCE_SIZE_EXCEEDS_THRESHOLD" => Self::SourceSizeExceedsThreshold,
                "EXISTING_CONFLICTING_DATABASES" => Self::ExistingConflictingDatabases,
                "PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Self::ParallelImportInsufficientPrivilege
                }
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectionFailure => serializer.serialize_i32(1),
                Self::AuthenticationFailure => serializer.serialize_i32(2),
                Self::InvalidConnectionProfileConfig => serializer.serialize_i32(3),
                Self::VersionIncompatibility => serializer.serialize_i32(4),
                Self::ConnectionProfileTypesIncompatibility => serializer.serialize_i32(5),
                Self::NoPglogicalInstalled => serializer.serialize_i32(7),
                Self::PglogicalNodeAlreadyExists => serializer.serialize_i32(8),
                Self::InvalidWalLevel => serializer.serialize_i32(9),
                Self::InvalidSharedPreloadLibrary => serializer.serialize_i32(10),
                Self::InsufficientMaxReplicationSlots => serializer.serialize_i32(11),
                Self::InsufficientMaxWalSenders => serializer.serialize_i32(12),
                Self::InsufficientMaxWorkerProcesses => serializer.serialize_i32(13),
                Self::UnsupportedExtensions => serializer.serialize_i32(14),
                Self::UnsupportedMigrationType => serializer.serialize_i32(15),
                Self::InvalidRdsLogicalReplication => serializer.serialize_i32(16),
                Self::UnsupportedGtidMode => serializer.serialize_i32(17),
                Self::UnsupportedTableDefinition => serializer.serialize_i32(18),
                Self::UnsupportedDefiner => serializer.serialize_i32(19),
                Self::CantRestartRunningMigration => serializer.serialize_i32(21),
                Self::SourceAlreadySetup => serializer.serialize_i32(23),
                Self::TablesWithLimitedSupport => serializer.serialize_i32(24),
                Self::UnsupportedDatabaseLocale => serializer.serialize_i32(25),
                Self::UnsupportedDatabaseFdwConfig => serializer.serialize_i32(26),
                Self::ErrorRdbms => serializer.serialize_i32(27),
                Self::SourceSizeExceedsThreshold => serializer.serialize_i32(28),
                Self::ExistingConflictingDatabases => serializer.serialize_i32(29),
                Self::ParallelImportInsufficientPrivilege => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.clouddms.v1.MigrationJobVerificationError.ErrorCode",
            ))
        }
    }
}

/// The PrivateConnection resource is used to establish private connectivity
/// with the customer's network.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateConnection {
    /// The name of the resource.
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the resource.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for private connections to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The private connection display name.
    pub display_name: std::string::String,

    /// Output only. The state of the private connection.
    pub state: crate::model::private_connection::State,

    /// Output only. The error details in case of state FAILED.
    pub error: std::option::Option<rpc::model::Status>,

    pub connectivity: std::option::Option<crate::model::private_connection::Connectivity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::PrivateConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::PrivateConnection::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PrivateConnection::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::PrivateConnection::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connectivity][crate::model::PrivateConnection::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::private_connection::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// if it holds a `VpcPeeringConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_peering_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConfig>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// to hold a `VpcPeeringConfig`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __display_name,
            __state,
            __error,
            __vpc_peering_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "vpcPeeringConfig" => Ok(__FieldTag::__vpc_peering_config),
                            "vpc_peering_config" => Ok(__FieldTag::__vpc_peering_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::private_connection::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__vpc_peering_config => {
                            if !fields.insert(__FieldTag::__vpc_peering_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_peering_config",
                                ));
                            }
                            if result.connectivity.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connectivity`, a oneof with full ID .google.cloud.clouddms.v1.PrivateConnection.vpc_peering_config, latest field was vpcPeeringConfig",
                                ));
                            }
                            result.connectivity = std::option::Option::Some(
                                crate::model::private_connection::Connectivity::VpcPeeringConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VpcPeeringConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if let Some(value) = self.vpc_peering_config() {
            state.serialize_entry("vpcPeeringConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateConnection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("connectivity", &self.connectivity);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PrivateConnection].
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Private Connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Unspecified,
        /// The private connection is in creation state - creating resources.
        Creating,
        /// The private connection has been created with all of its resources.
        Created,
        /// The private connection creation has failed.
        Failed,
        /// The private connection is being deleted.
        Deleting,
        /// Delete request has failed, resource is in invalid state.
        FailedToDelete,
        /// The private connection has been deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::FailedToDelete => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::FailedToDelete => std::option::Option::Some("FAILED_TO_DELETE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Failed,
                4 => Self::Deleting,
                5 => Self::FailedToDelete,
                6 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "FAILED_TO_DELETE" => Self::FailedToDelete,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::FailedToDelete => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.PrivateConnection.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connectivity {
        /// VPC peering configuration.
        VpcPeeringConfig(std::boxed::Box<crate::model::VpcPeeringConfig>),
    }
}

/// The VPC peering configuration is used to create VPC peering with the
/// consumer's VPC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpcPeeringConfig {
    /// Required. Fully qualified name of the VPC that Database Migration Service
    /// will peer to.
    pub vpc_name: std::string::String,

    /// Required. A free subnet for peering. (CIDR of /29)
    pub subnet: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_name][crate::model::VpcPeeringConfig::vpc_name].
    pub fn set_vpc_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_name = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VpcPeeringConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpcPeeringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpc_name,
            __subnet,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpcPeeringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpcName" => Ok(__FieldTag::__vpc_name),
                            "vpc_name" => Ok(__FieldTag::__vpc_name),
                            "subnet" => Ok(__FieldTag::__subnet),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpcPeeringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpcPeeringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpc_name => {
                            if !fields.insert(__FieldTag::__vpc_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_name",
                                ));
                            }
                            result.vpc_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet",
                                ));
                            }
                            result.subnet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpcPeeringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpc_name.is_empty() {
            state.serialize_entry("vpcName", &self.vpc_name)?;
        }
        if !self.subnet.is_empty() {
            state.serialize_entry("subnet", &self.subnet)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpcPeeringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpcPeeringConfig");
        debug_struct.field("vpc_name", &self.vpc_name);
        debug_struct.field("subnet", &self.subnet);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type and version of a source or destination database.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseEngineInfo {
    /// Required. Engine type.
    pub engine: crate::model::DatabaseEngine,

    /// Required. Engine named version, for example 12.c.1.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEngineInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engine][crate::model::DatabaseEngineInfo::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatabaseEngineInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseEngineInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEngineInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseEngineInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __engine,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseEngineInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "engine" => Ok(__FieldTag::__engine),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseEngineInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseEngineInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__engine => {
                            if !fields.insert(__FieldTag::__engine) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for engine",
                                ));
                            }
                            result.engine = map
                                .next_value::<std::option::Option<crate::model::DatabaseEngine>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseEngineInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.engine) {
            state.serialize_entry("engine", &self.engine)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseEngineInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEngineInfo");
        debug_struct.field("engine", &self.engine);
        debug_struct.field("version", &self.version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The main conversion workspace resource entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversionWorkspace {
    /// Full name of the workspace resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    pub name: std::string::String,

    /// Required. The source engine details.
    pub source: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Required. The destination engine details.
    pub destination: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Optional. A generic list of settings for the workspace.
    /// The settings are database pair dependant and can indicate default behavior
    /// for the mapping rules engine or turn on or off specific features.
    /// Such examples can be: convert_foreign_key_to_interleave=true,
    /// skip_triggers=false, ignore_non_table_synonyms=true
    pub global_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Whether the workspace has uncommitted changes (changes which
    /// were made after the workspace was committed).
    pub has_uncommitted_changes: bool,

    /// Output only. The latest commit ID.
    pub latest_commit_id: std::string::String,

    /// Output only. The timestamp when the workspace was committed.
    pub latest_commit_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The display name for the workspace.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversionWorkspace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspace::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ConversionWorkspace::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEngineInfo>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::ConversionWorkspace::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEngineInfo>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination][crate::model::ConversionWorkspace::destination].
    pub fn set_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEngineInfo>,
    {
        self.destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [destination][crate::model::ConversionWorkspace::destination].
    pub fn set_or_clear_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEngineInfo>,
    {
        self.destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [global_settings][crate::model::ConversionWorkspace::global_settings].
    pub fn set_global_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.global_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [has_uncommitted_changes][crate::model::ConversionWorkspace::has_uncommitted_changes].
    pub fn set_has_uncommitted_changes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_uncommitted_changes = v.into();
        self
    }

    /// Sets the value of [latest_commit_id][crate::model::ConversionWorkspace::latest_commit_id].
    pub fn set_latest_commit_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_commit_id = v.into();
        self
    }

    /// Sets the value of [latest_commit_time][crate::model::ConversionWorkspace::latest_commit_time].
    pub fn set_latest_commit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_commit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_commit_time][crate::model::ConversionWorkspace::latest_commit_time].
    pub fn set_or_clear_latest_commit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.latest_commit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::ConversionWorkspace::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversionWorkspace::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConversionWorkspace::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConversionWorkspace::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::ConversionWorkspace::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for ConversionWorkspace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversionWorkspace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source,
            __destination,
            __global_settings,
            __has_uncommitted_changes,
            __latest_commit_id,
            __latest_commit_time,
            __create_time,
            __update_time,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversionWorkspace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "source" => Ok(__FieldTag::__source),
                            "destination" => Ok(__FieldTag::__destination),
                            "globalSettings" => Ok(__FieldTag::__global_settings),
                            "global_settings" => Ok(__FieldTag::__global_settings),
                            "hasUncommittedChanges" => Ok(__FieldTag::__has_uncommitted_changes),
                            "has_uncommitted_changes" => Ok(__FieldTag::__has_uncommitted_changes),
                            "latestCommitId" => Ok(__FieldTag::__latest_commit_id),
                            "latest_commit_id" => Ok(__FieldTag::__latest_commit_id),
                            "latestCommitTime" => Ok(__FieldTag::__latest_commit_time),
                            "latest_commit_time" => Ok(__FieldTag::__latest_commit_time),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversionWorkspace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversionWorkspace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map.next_value::<std::option::Option<crate::model::DatabaseEngineInfo>>()?
                                ;
                        }
                        __FieldTag::__destination => {
                            if !fields.insert(__FieldTag::__destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination",
                                ));
                            }
                            result.destination = map.next_value::<std::option::Option<crate::model::DatabaseEngineInfo>>()?
                                ;
                        }
                        __FieldTag::__global_settings => {
                            if !fields.insert(__FieldTag::__global_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_settings",
                                ));
                            }
                            result.global_settings = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__has_uncommitted_changes => {
                            if !fields.insert(__FieldTag::__has_uncommitted_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for has_uncommitted_changes",
                                ));
                            }
                            result.has_uncommitted_changes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_commit_id => {
                            if !fields.insert(__FieldTag::__latest_commit_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_commit_id",
                                ));
                            }
                            result.latest_commit_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_commit_time => {
                            if !fields.insert(__FieldTag::__latest_commit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_commit_time",
                                ));
                            }
                            result.latest_commit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConversionWorkspace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.destination.is_some() {
            state.serialize_entry("destination", &self.destination)?;
        }
        if !self.global_settings.is_empty() {
            state.serialize_entry("globalSettings", &self.global_settings)?;
        }
        if !wkt::internal::is_default(&self.has_uncommitted_changes) {
            state.serialize_entry("hasUncommittedChanges", &self.has_uncommitted_changes)?;
        }
        if !self.latest_commit_id.is_empty() {
            state.serialize_entry("latestCommitId", &self.latest_commit_id)?;
        }
        if self.latest_commit_time.is_some() {
            state.serialize_entry("latestCommitTime", &self.latest_commit_time)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConversionWorkspace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConversionWorkspace");
        debug_struct.field("name", &self.name);
        debug_struct.field("source", &self.source);
        debug_struct.field("destination", &self.destination);
        debug_struct.field("global_settings", &self.global_settings);
        debug_struct.field("has_uncommitted_changes", &self.has_uncommitted_changes);
        debug_struct.field("latest_commit_id", &self.latest_commit_id);
        debug_struct.field("latest_commit_time", &self.latest_commit_time);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Execution log of a background job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackgroundJobLogEntry {
    /// The background job log entry ID.
    pub id: std::string::String,

    /// The type of job that was executed.
    pub job_type: crate::model::BackgroundJobType,

    /// The timestamp when the background job was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the background job was finished.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Job completion state, i.e. the final state after the job
    /// completed.
    pub completion_state: crate::model::background_job_log_entry::JobCompletionState,

    /// Output only. Job completion comment, such as how many entities were seeded,
    /// how many warnings were found during conversion, and similar information.
    pub completion_comment: std::string::String,

    /// Output only. Whether the client requested the conversion workspace to be
    /// committed after a successful completion of the job.
    pub request_autocommit: bool,

    pub job_details: std::option::Option<crate::model::background_job_log_entry::JobDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackgroundJobLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BackgroundJobLogEntry::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::BackgroundJobLogEntry::job_type].
    pub fn set_job_type<T: std::convert::Into<crate::model::BackgroundJobType>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackgroundJobLogEntry::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BackgroundJobLogEntry::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::BackgroundJobLogEntry::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::BackgroundJobLogEntry::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [completion_state][crate::model::BackgroundJobLogEntry::completion_state].
    pub fn set_completion_state<
        T: std::convert::Into<crate::model::background_job_log_entry::JobCompletionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }

    /// Sets the value of [completion_comment][crate::model::BackgroundJobLogEntry::completion_comment].
    pub fn set_completion_comment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_comment = v.into();
        self
    }

    /// Sets the value of [request_autocommit][crate::model::BackgroundJobLogEntry::request_autocommit].
    pub fn set_request_autocommit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.request_autocommit = v.into();
        self
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details].
    ///
    /// Note that all the setters affecting `job_details` are mutually
    /// exclusive.
    pub fn set_job_details<
        T: std::convert::Into<std::option::Option<crate::model::background_job_log_entry::JobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = v.into();
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `SeedJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn seed_job_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>
    {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `SeedJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_seed_job_details<
        T: std::convert::Into<std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ImportRulesJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_rules_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ImportRulesJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_import_rules_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ConvertJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn convert_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ConvertJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_convert_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ApplyJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn apply_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ApplyJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_apply_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackgroundJobLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackgroundJobLogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __job_type,
            __start_time,
            __finish_time,
            __completion_state,
            __completion_comment,
            __request_autocommit,
            __seed_job_details,
            __import_rules_job_details,
            __convert_job_details,
            __apply_job_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackgroundJobLogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "jobType" => Ok(__FieldTag::__job_type),
                            "job_type" => Ok(__FieldTag::__job_type),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            "completionState" => Ok(__FieldTag::__completion_state),
                            "completion_state" => Ok(__FieldTag::__completion_state),
                            "completionComment" => Ok(__FieldTag::__completion_comment),
                            "completion_comment" => Ok(__FieldTag::__completion_comment),
                            "requestAutocommit" => Ok(__FieldTag::__request_autocommit),
                            "request_autocommit" => Ok(__FieldTag::__request_autocommit),
                            "seedJobDetails" => Ok(__FieldTag::__seed_job_details),
                            "seed_job_details" => Ok(__FieldTag::__seed_job_details),
                            "importRulesJobDetails" => Ok(__FieldTag::__import_rules_job_details),
                            "import_rules_job_details" => {
                                Ok(__FieldTag::__import_rules_job_details)
                            }
                            "convertJobDetails" => Ok(__FieldTag::__convert_job_details),
                            "convert_job_details" => Ok(__FieldTag::__convert_job_details),
                            "applyJobDetails" => Ok(__FieldTag::__apply_job_details),
                            "apply_job_details" => Ok(__FieldTag::__apply_job_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackgroundJobLogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackgroundJobLogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_type => {
                            if !fields.insert(__FieldTag::__job_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_type",
                                ));
                            }
                            result.job_type = map
                                .next_value::<std::option::Option<crate::model::BackgroundJobType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__completion_state => {
                            if !fields.insert(__FieldTag::__completion_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_state",
                                ));
                            }
                            result.completion_state = map
                                .next_value::<std::option::Option<
                                    crate::model::background_job_log_entry::JobCompletionState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__completion_comment => {
                            if !fields.insert(__FieldTag::__completion_comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_comment",
                                ));
                            }
                            result.completion_comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_autocommit => {
                            if !fields.insert(__FieldTag::__request_autocommit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_autocommit",
                                ));
                            }
                            result.request_autocommit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__seed_job_details => {
                            if !fields.insert(__FieldTag::__seed_job_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for seed_job_details",
                                ));
                            }
                            if result.job_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_details`, a oneof with full ID .google.cloud.clouddms.v1.BackgroundJobLogEntry.seed_job_details, latest field was seedJobDetails",
                                ));
                            }
                            result.job_details = std::option::Option::Some(
                                crate::model::background_job_log_entry::JobDetails::SeedJobDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::background_job_log_entry::SeedJobDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__import_rules_job_details => {
                            if !fields.insert(__FieldTag::__import_rules_job_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_rules_job_details",
                                ));
                            }
                            if result.job_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_details`, a oneof with full ID .google.cloud.clouddms.v1.BackgroundJobLogEntry.import_rules_job_details, latest field was importRulesJobDetails",
                                ));
                            }
                            result.job_details = std::option::Option::Some(
                                crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__convert_job_details => {
                            if !fields.insert(__FieldTag::__convert_job_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for convert_job_details",
                                ));
                            }
                            if result.job_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_details`, a oneof with full ID .google.cloud.clouddms.v1.BackgroundJobLogEntry.convert_job_details, latest field was convertJobDetails",
                                ));
                            }
                            result.job_details = std::option::Option::Some(
                                crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__apply_job_details => {
                            if !fields.insert(__FieldTag::__apply_job_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apply_job_details",
                                ));
                            }
                            if result.job_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_details`, a oneof with full ID .google.cloud.clouddms.v1.BackgroundJobLogEntry.apply_job_details, latest field was applyJobDetails",
                                ));
                            }
                            result.job_details = std::option::Option::Some(
                                crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::background_job_log_entry::ApplyJobDetails,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackgroundJobLogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.job_type) {
            state.serialize_entry("jobType", &self.job_type)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !wkt::internal::is_default(&self.completion_state) {
            state.serialize_entry("completionState", &self.completion_state)?;
        }
        if !self.completion_comment.is_empty() {
            state.serialize_entry("completionComment", &self.completion_comment)?;
        }
        if !wkt::internal::is_default(&self.request_autocommit) {
            state.serialize_entry("requestAutocommit", &self.request_autocommit)?;
        }
        if let Some(value) = self.seed_job_details() {
            state.serialize_entry("seedJobDetails", value)?;
        }
        if let Some(value) = self.import_rules_job_details() {
            state.serialize_entry("importRulesJobDetails", value)?;
        }
        if let Some(value) = self.convert_job_details() {
            state.serialize_entry("convertJobDetails", value)?;
        }
        if let Some(value) = self.apply_job_details() {
            state.serialize_entry("applyJobDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackgroundJobLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackgroundJobLogEntry");
        debug_struct.field("id", &self.id);
        debug_struct.field("job_type", &self.job_type);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("finish_time", &self.finish_time);
        debug_struct.field("completion_state", &self.completion_state);
        debug_struct.field("completion_comment", &self.completion_comment);
        debug_struct.field("request_autocommit", &self.request_autocommit);
        debug_struct.field("job_details", &self.job_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BackgroundJobLogEntry].
pub mod background_job_log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Details regarding a Seed background job.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SeedJobDetails {
        /// Output only. The connection profile which was used for the seed job.
        pub connection_profile: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SeedJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::SeedJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }
    }

    impl wkt::message::Message for SeedJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.SeedJobDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SeedJobDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __connection_profile,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SeedJobDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "connectionProfile" => Ok(__FieldTag::__connection_profile),
                                "connection_profile" => Ok(__FieldTag::__connection_profile),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SeedJobDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SeedJobDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__connection_profile => {
                                if !fields.insert(__FieldTag::__connection_profile) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for connection_profile",
                                    ));
                                }
                                result.connection_profile = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SeedJobDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.connection_profile.is_empty() {
                state.serialize_entry("connectionProfile", &self.connection_profile)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SeedJobDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SeedJobDetails");
            debug_struct.field("connection_profile", &self.connection_profile);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details regarding an Import Rules background job.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ImportRulesJobDetails {
        /// Output only. File names used for the import rules job.
        pub files: std::vec::Vec<std::string::String>,

        /// Output only. The requested file format.
        pub file_format: crate::model::ImportRulesFileFormat,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportRulesJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [files][crate::model::background_job_log_entry::ImportRulesJobDetails::files].
        pub fn set_files<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.files = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [file_format][crate::model::background_job_log_entry::ImportRulesJobDetails::file_format].
        pub fn set_file_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
            mut self,
            v: T,
        ) -> Self {
            self.file_format = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportRulesJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ImportRulesJobDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ImportRulesJobDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __files,
                __file_format,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ImportRulesJobDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "files" => Ok(__FieldTag::__files),
                                "fileFormat" => Ok(__FieldTag::__file_format),
                                "file_format" => Ok(__FieldTag::__file_format),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ImportRulesJobDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ImportRulesJobDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__files => {
                                if !fields.insert(__FieldTag::__files) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for files",
                                    ));
                                }
                                result.files = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__file_format => {
                                if !fields.insert(__FieldTag::__file_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for file_format",
                                    ));
                                }
                                result.file_format = map.next_value::<std::option::Option<crate::model::ImportRulesFileFormat>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ImportRulesJobDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.files.is_empty() {
                state.serialize_entry("files", &self.files)?;
            }
            if !wkt::internal::is_default(&self.file_format) {
                state.serialize_entry("fileFormat", &self.file_format)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ImportRulesJobDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ImportRulesJobDetails");
            debug_struct.field("files", &self.files);
            debug_struct.field("file_format", &self.file_format);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details regarding a Convert background job.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConvertJobDetails {
        /// Output only. AIP-160 based filter used to specify the entities to convert
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConvertJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ConvertJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ConvertJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ConvertJobDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConvertJobDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConvertJobDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConvertJobDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConvertJobDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConvertJobDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConvertJobDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConvertJobDetails");
            debug_struct.field("filter", &self.filter);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Details regarding an Apply background job.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ApplyJobDetails {
        /// Output only. The connection profile which was used for the apply job.
        pub connection_profile: std::string::String,

        /// Output only. AIP-160 based filter used to specify the entities to apply
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ApplyJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::ApplyJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ApplyJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ApplyJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ApplyJobDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ApplyJobDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __connection_profile,
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ApplyJobDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "connectionProfile" => Ok(__FieldTag::__connection_profile),
                                "connection_profile" => Ok(__FieldTag::__connection_profile),
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ApplyJobDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ApplyJobDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__connection_profile => {
                                if !fields.insert(__FieldTag::__connection_profile) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for connection_profile",
                                    ));
                                }
                                result.connection_profile = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ApplyJobDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.connection_profile.is_empty() {
                state.serialize_entry("connectionProfile", &self.connection_profile)?;
            }
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ApplyJobDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ApplyJobDetails");
            debug_struct.field("connection_profile", &self.connection_profile);
            debug_struct.field("filter", &self.filter);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Final state after a job completes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobCompletionState {
        /// The status is not specified. This state is used when job is not yet
        /// finished.
        Unspecified,
        /// Success.
        Succeeded,
        /// Error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobCompletionState::value] or
        /// [JobCompletionState::name].
        UnknownValue(job_completion_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_completion_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobCompletionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_COMPLETION_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobCompletionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobCompletionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobCompletionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                _ => Self::UnknownValue(job_completion_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobCompletionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_COMPLETION_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(job_completion_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobCompletionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobCompletionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobCompletionState>::new(
                ".google.cloud.clouddms.v1.BackgroundJobLogEntry.JobCompletionState",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobDetails {
        /// Output only. Seed job details.
        SeedJobDetails(std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>),
        /// Output only. Import rules job details.
        ImportRulesJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
        ),
        /// Output only. Convert job details.
        ConvertJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
        ),
        /// Output only. Apply job details.
        ApplyJobDetails(std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>),
    }
}

/// A filter defining the entities that a mapping rule should be applied to.
/// When more than one field is specified, the rule is applied only to
/// entities which match all the fields.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MappingRuleFilter {
    /// Optional. The rule should be applied to entities whose parent entity
    /// (fully qualified name) matches the given value.
    /// For example, if the rule applies to a table entity, the expected value
    /// should be a schema (schema). If the rule applies to a column or index
    /// entity, the expected value can be either a schema (schema) or a table
    /// (schema.table)
    pub parent_entity: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// starts with the given prefix.
    pub entity_name_prefix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// ends with the given suffix.
    pub entity_name_suffix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// contains the given string.
    pub entity_name_contains: std::string::String,

    /// Optional. The rule should be applied to specific entities defined by their
    /// fully qualified names.
    pub entities: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MappingRuleFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_entity][crate::model::MappingRuleFilter::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [entity_name_prefix][crate::model::MappingRuleFilter::entity_name_prefix].
    pub fn set_entity_name_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_prefix = v.into();
        self
    }

    /// Sets the value of [entity_name_suffix][crate::model::MappingRuleFilter::entity_name_suffix].
    pub fn set_entity_name_suffix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_suffix = v.into();
        self
    }

    /// Sets the value of [entity_name_contains][crate::model::MappingRuleFilter::entity_name_contains].
    pub fn set_entity_name_contains<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_contains = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::MappingRuleFilter::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MappingRuleFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRuleFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MappingRuleFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent_entity,
            __entity_name_prefix,
            __entity_name_suffix,
            __entity_name_contains,
            __entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MappingRuleFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parentEntity" => Ok(__FieldTag::__parent_entity),
                            "parent_entity" => Ok(__FieldTag::__parent_entity),
                            "entityNamePrefix" => Ok(__FieldTag::__entity_name_prefix),
                            "entity_name_prefix" => Ok(__FieldTag::__entity_name_prefix),
                            "entityNameSuffix" => Ok(__FieldTag::__entity_name_suffix),
                            "entity_name_suffix" => Ok(__FieldTag::__entity_name_suffix),
                            "entityNameContains" => Ok(__FieldTag::__entity_name_contains),
                            "entity_name_contains" => Ok(__FieldTag::__entity_name_contains),
                            "entities" => Ok(__FieldTag::__entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MappingRuleFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MappingRuleFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent_entity => {
                            if !fields.insert(__FieldTag::__parent_entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_entity",
                                ));
                            }
                            result.parent_entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_name_prefix => {
                            if !fields.insert(__FieldTag::__entity_name_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_name_prefix",
                                ));
                            }
                            result.entity_name_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_name_suffix => {
                            if !fields.insert(__FieldTag::__entity_name_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_name_suffix",
                                ));
                            }
                            result.entity_name_suffix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_name_contains => {
                            if !fields.insert(__FieldTag::__entity_name_contains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_name_contains",
                                ));
                            }
                            result.entity_name_contains = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MappingRuleFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent_entity.is_empty() {
            state.serialize_entry("parentEntity", &self.parent_entity)?;
        }
        if !self.entity_name_prefix.is_empty() {
            state.serialize_entry("entityNamePrefix", &self.entity_name_prefix)?;
        }
        if !self.entity_name_suffix.is_empty() {
            state.serialize_entry("entityNameSuffix", &self.entity_name_suffix)?;
        }
        if !self.entity_name_contains.is_empty() {
            state.serialize_entry("entityNameContains", &self.entity_name_contains)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MappingRuleFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MappingRuleFilter");
        debug_struct.field("parent_entity", &self.parent_entity);
        debug_struct.field("entity_name_prefix", &self.entity_name_prefix);
        debug_struct.field("entity_name_suffix", &self.entity_name_suffix);
        debug_struct.field("entity_name_contains", &self.entity_name_contains);
        debug_struct.field("entities", &self.entities);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Definition of a transformation that is to be applied to a group of entities
/// in the source schema. Several such transformations can be applied to an
/// entity sequentially to define the corresponding entity in the target schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MappingRule {
    /// Full name of the mapping rule resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
    pub name: std::string::String,

    /// Optional. A human readable name
    pub display_name: std::string::String,

    /// Optional. The mapping rule state
    pub state: crate::model::mapping_rule::State,

    /// Required. The rule scope
    pub rule_scope: crate::model::DatabaseEntityType,

    /// Required. The rule filter
    pub filter: std::option::Option<crate::model::MappingRuleFilter>,

    /// Required. The order in which the rule is applied. Lower order rules are
    /// applied before higher value rules so they may end up being overridden.
    pub rule_order: i64,

    /// Output only. The revision ID of the mapping rule.
    /// A new revision is committed whenever the mapping rule is changed in any
    /// way. The format is an 8-character hexadecimal string.
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The rule specific details.
    pub details: std::option::Option<crate::model::mapping_rule::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MappingRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MappingRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MappingRule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MappingRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::mapping_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rule_scope][crate::model::MappingRule::rule_scope].
    pub fn set_rule_scope<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_scope = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MappingRule::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MappingRuleFilter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::MappingRule::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MappingRuleFilter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_order][crate::model::MappingRule::rule_order].
    pub fn set_rule_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rule_order = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::MappingRule::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::MappingRule::revision_create_time].
    pub fn set_revision_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revision_create_time][crate::model::MappingRule::revision_create_time].
    pub fn set_or_clear_revision_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.revision_create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::mapping_rule::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleEntityRename(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiEntityRename(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `EntityMove`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_move(&self) -> std::option::Option<&std::boxed::Box<crate::model::EntityMove>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::EntityMove(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `EntityMove`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_entity_move<T: std::convert::Into<std::boxed::Box<crate::model::EntityMove>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::mapping_rule::Details::EntityMove(v.into()));
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleColumnChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_column_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleColumnChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleColumnChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleColumnChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_column_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleColumnChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleColumnChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiColumnDataTypeChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_column_data_type_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiColumnDatatypeChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiColumnDataTypeChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_column_data_type_change<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiColumnDatatypeChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConditionalColumnSetValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn conditional_column_set_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConditionalColumnSetValue>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConditionalColumnSetValue`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_conditional_column_set_value<
        T: std::convert::Into<std::boxed::Box<crate::model::ConditionalColumnSetValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConvertRowidColumn`, `None` if the field is not set or
    /// holds a different branch.
    pub fn convert_rowid_column(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConvertRowIdToColumn>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConvertRowidColumn(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConvertRowidColumn`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_convert_rowid_column<
        T: std::convert::Into<std::boxed::Box<crate::model::ConvertRowIdToColumn>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConvertRowidColumn(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SetTablePrimaryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_table_primary_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SetTablePrimaryKey>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SetTablePrimaryKey`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_set_table_primary_key<
        T: std::convert::Into<std::boxed::Box<crate::model::SetTablePrimaryKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SinglePackageChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_package_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SinglePackageChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SinglePackageChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SinglePackageChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_package_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SinglePackageChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SinglePackageChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SourceSqlChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_sql_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceSqlChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SourceSqlChange(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SourceSqlChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_source_sql_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceSqlChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SourceSqlChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `FilterTableColumns`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_table_columns(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FilterTableColumns>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::FilterTableColumns(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `FilterTableColumns`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_filter_table_columns<
        T: std::convert::Into<std::boxed::Box<crate::model::FilterTableColumns>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::FilterTableColumns(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MappingRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MappingRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __rule_scope,
            __filter,
            __rule_order,
            __revision_id,
            __revision_create_time,
            __single_entity_rename,
            __multi_entity_rename,
            __entity_move,
            __single_column_change,
            __multi_column_data_type_change,
            __conditional_column_set_value,
            __convert_rowid_column,
            __set_table_primary_key,
            __single_package_change,
            __source_sql_change,
            __filter_table_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MappingRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "ruleScope" => Ok(__FieldTag::__rule_scope),
                            "rule_scope" => Ok(__FieldTag::__rule_scope),
                            "filter" => Ok(__FieldTag::__filter),
                            "ruleOrder" => Ok(__FieldTag::__rule_order),
                            "rule_order" => Ok(__FieldTag::__rule_order),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "revisionCreateTime" => Ok(__FieldTag::__revision_create_time),
                            "revision_create_time" => Ok(__FieldTag::__revision_create_time),
                            "singleEntityRename" => Ok(__FieldTag::__single_entity_rename),
                            "single_entity_rename" => Ok(__FieldTag::__single_entity_rename),
                            "multiEntityRename" => Ok(__FieldTag::__multi_entity_rename),
                            "multi_entity_rename" => Ok(__FieldTag::__multi_entity_rename),
                            "entityMove" => Ok(__FieldTag::__entity_move),
                            "entity_move" => Ok(__FieldTag::__entity_move),
                            "singleColumnChange" => Ok(__FieldTag::__single_column_change),
                            "single_column_change" => Ok(__FieldTag::__single_column_change),
                            "multiColumnDataTypeChange" => {
                                Ok(__FieldTag::__multi_column_data_type_change)
                            }
                            "multi_column_data_type_change" => {
                                Ok(__FieldTag::__multi_column_data_type_change)
                            }
                            "conditionalColumnSetValue" => {
                                Ok(__FieldTag::__conditional_column_set_value)
                            }
                            "conditional_column_set_value" => {
                                Ok(__FieldTag::__conditional_column_set_value)
                            }
                            "convertRowidColumn" => Ok(__FieldTag::__convert_rowid_column),
                            "convert_rowid_column" => Ok(__FieldTag::__convert_rowid_column),
                            "setTablePrimaryKey" => Ok(__FieldTag::__set_table_primary_key),
                            "set_table_primary_key" => Ok(__FieldTag::__set_table_primary_key),
                            "singlePackageChange" => Ok(__FieldTag::__single_package_change),
                            "single_package_change" => Ok(__FieldTag::__single_package_change),
                            "sourceSqlChange" => Ok(__FieldTag::__source_sql_change),
                            "source_sql_change" => Ok(__FieldTag::__source_sql_change),
                            "filterTableColumns" => Ok(__FieldTag::__filter_table_columns),
                            "filter_table_columns" => Ok(__FieldTag::__filter_table_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MappingRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MappingRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::mapping_rule::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rule_scope => {
                            if !fields.insert(__FieldTag::__rule_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_scope",
                                ));
                            }
                            result.rule_scope = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<crate::model::MappingRuleFilter>>(
                                )?;
                        }
                        __FieldTag::__rule_order => {
                            if !fields.insert(__FieldTag::__rule_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_order",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rule_order = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_create_time => {
                            if !fields.insert(__FieldTag::__revision_create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_create_time",
                                ));
                            }
                            result.revision_create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__single_entity_rename => {
                            if !fields.insert(__FieldTag::__single_entity_rename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_entity_rename",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.single_entity_rename, latest field was singleEntityRename",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::SingleEntityRename(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SingleEntityRename>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_entity_rename => {
                            if !fields.insert(__FieldTag::__multi_entity_rename) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_entity_rename",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.multi_entity_rename, latest field was multiEntityRename",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::MultiEntityRename(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MultiEntityRename>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__entity_move => {
                            if !fields.insert(__FieldTag::__entity_move) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_move",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.entity_move, latest field was entityMove",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::EntityMove(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EntityMove>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_column_change => {
                            if !fields.insert(__FieldTag::__single_column_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_column_change",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.single_column_change, latest field was singleColumnChange",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::SingleColumnChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SingleColumnChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_column_data_type_change => {
                            if !fields.insert(__FieldTag::__multi_column_data_type_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_column_data_type_change",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.multi_column_data_type_change, latest field was multiColumnDataTypeChange",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::MultiColumnDataTypeChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MultiColumnDatatypeChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__conditional_column_set_value => {
                            if !fields.insert(__FieldTag::__conditional_column_set_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditional_column_set_value",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.conditional_column_set_value, latest field was conditionalColumnSetValue",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::ConditionalColumnSetValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ConditionalColumnSetValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__convert_rowid_column => {
                            if !fields.insert(__FieldTag::__convert_rowid_column) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for convert_rowid_column",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.convert_rowid_column, latest field was convertRowidColumn",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::ConvertRowidColumn(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ConvertRowIdToColumn>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__set_table_primary_key => {
                            if !fields.insert(__FieldTag::__set_table_primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_table_primary_key",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.set_table_primary_key, latest field was setTablePrimaryKey",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::SetTablePrimaryKey(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SetTablePrimaryKey>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_package_change => {
                            if !fields.insert(__FieldTag::__single_package_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_package_change",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.single_package_change, latest field was singlePackageChange",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::SinglePackageChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SinglePackageChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__source_sql_change => {
                            if !fields.insert(__FieldTag::__source_sql_change) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_sql_change",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.source_sql_change, latest field was sourceSqlChange",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::SourceSqlChange(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SourceSqlChange>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__filter_table_columns => {
                            if !fields.insert(__FieldTag::__filter_table_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_table_columns",
                                ));
                            }
                            if result.details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `details`, a oneof with full ID .google.cloud.clouddms.v1.MappingRule.filter_table_columns, latest field was filterTableColumns",
                                ));
                            }
                            result.details = std::option::Option::Some(
                                crate::model::mapping_rule::Details::FilterTableColumns(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FilterTableColumns>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MappingRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.rule_scope) {
            state.serialize_entry("ruleScope", &self.rule_scope)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.rule_order) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ruleOrder", &__With(&self.rule_order))?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if self.revision_create_time.is_some() {
            state.serialize_entry("revisionCreateTime", &self.revision_create_time)?;
        }
        if let Some(value) = self.single_entity_rename() {
            state.serialize_entry("singleEntityRename", value)?;
        }
        if let Some(value) = self.multi_entity_rename() {
            state.serialize_entry("multiEntityRename", value)?;
        }
        if let Some(value) = self.entity_move() {
            state.serialize_entry("entityMove", value)?;
        }
        if let Some(value) = self.single_column_change() {
            state.serialize_entry("singleColumnChange", value)?;
        }
        if let Some(value) = self.multi_column_data_type_change() {
            state.serialize_entry("multiColumnDataTypeChange", value)?;
        }
        if let Some(value) = self.conditional_column_set_value() {
            state.serialize_entry("conditionalColumnSetValue", value)?;
        }
        if let Some(value) = self.convert_rowid_column() {
            state.serialize_entry("convertRowidColumn", value)?;
        }
        if let Some(value) = self.set_table_primary_key() {
            state.serialize_entry("setTablePrimaryKey", value)?;
        }
        if let Some(value) = self.single_package_change() {
            state.serialize_entry("singlePackageChange", value)?;
        }
        if let Some(value) = self.source_sql_change() {
            state.serialize_entry("sourceSqlChange", value)?;
        }
        if let Some(value) = self.filter_table_columns() {
            state.serialize_entry("filterTableColumns", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MappingRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MappingRule");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("rule_scope", &self.rule_scope);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("rule_order", &self.rule_order);
        debug_struct.field("revision_id", &self.revision_id);
        debug_struct.field("revision_create_time", &self.revision_create_time);
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MappingRule].
pub mod mapping_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The current mapping rule state such as enabled, disabled or deleted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the mapping rule is unknown.
        Unspecified,
        /// The rule is enabled.
        Enabled,
        /// The rule is disabled.
        Disabled,
        /// The rule is logically deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.MappingRule.State",
            ))
        }
    }

    /// The rule specific details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Details {
        /// Optional. Rule to specify how a single entity should be renamed.
        SingleEntityRename(std::boxed::Box<crate::model::SingleEntityRename>),
        /// Optional. Rule to specify how multiple entities should be renamed.
        MultiEntityRename(std::boxed::Box<crate::model::MultiEntityRename>),
        /// Optional. Rule to specify how multiple entities should be relocated into
        /// a different schema.
        EntityMove(std::boxed::Box<crate::model::EntityMove>),
        /// Optional. Rule to specify how a single column is converted.
        SingleColumnChange(std::boxed::Box<crate::model::SingleColumnChange>),
        /// Optional. Rule to specify how multiple columns should be converted to a
        /// different data type.
        MultiColumnDataTypeChange(std::boxed::Box<crate::model::MultiColumnDatatypeChange>),
        /// Optional. Rule to specify how the data contained in a column should be
        /// transformed (such as trimmed, rounded, etc) provided that the data meets
        /// certain criteria.
        ConditionalColumnSetValue(std::boxed::Box<crate::model::ConditionalColumnSetValue>),
        /// Optional. Rule to specify how multiple tables should be converted with an
        /// additional rowid column.
        ConvertRowidColumn(std::boxed::Box<crate::model::ConvertRowIdToColumn>),
        /// Optional. Rule to specify the primary key for a table
        SetTablePrimaryKey(std::boxed::Box<crate::model::SetTablePrimaryKey>),
        /// Optional. Rule to specify how a single package is converted.
        SinglePackageChange(std::boxed::Box<crate::model::SinglePackageChange>),
        /// Optional. Rule to change the sql code for an entity, for example,
        /// function, procedure.
        SourceSqlChange(std::boxed::Box<crate::model::SourceSqlChange>),
        /// Optional. Rule to specify the list of columns to include or exclude from
        /// a table.
        FilterTableColumns(std::boxed::Box<crate::model::FilterTableColumns>),
    }
}

/// Options to configure rule type SingleEntityRename.
/// The rule is used to rename an entity.
///
/// The rule filter field can refer to only one entity.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT,
/// Synonym
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SingleEntityRename {
    /// Required. The new name of the destination entity
    pub new_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name][crate::model::SingleEntityRename::new_name].
    pub fn set_new_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_name = v.into();
        self
    }
}

impl wkt::message::Message for SingleEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleEntityRename"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SingleEntityRename {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SingleEntityRename")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newName" => Ok(__FieldTag::__new_name),
                            "new_name" => Ok(__FieldTag::__new_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SingleEntityRename;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SingleEntityRename")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_name => {
                            if !fields.insert(__FieldTag::__new_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_name",
                                ));
                            }
                            result.new_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SingleEntityRename {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.new_name.is_empty() {
            state.serialize_entry("newName", &self.new_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SingleEntityRename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SingleEntityRename");
        debug_struct.field("new_name", &self.new_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type MultiEntityRename.
/// The rule is used to rename multiple entities.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MultiEntityRename {
    /// Optional. The pattern used to generate the new entity's name. This pattern
    /// must include the characters '{name}', which will be replaced with the name
    /// of the original entity. For example, the pattern 't_{name}' for an entity
    /// name jobs would be converted to 't_jobs'.
    ///
    /// If unspecified, the default value for this field is '{name}'
    pub new_name_pattern: std::string::String,

    /// Optional. Additional transformation that can be done on the source entity
    /// name before it is being used by the new_name_pattern, for example lower
    /// case. If no transformation is desired, use NO_TRANSFORMATION
    pub source_name_transformation: crate::model::EntityNameTransformation,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name_pattern][crate::model::MultiEntityRename::new_name_pattern].
    pub fn set_new_name_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_name_pattern = v.into();
        self
    }

    /// Sets the value of [source_name_transformation][crate::model::MultiEntityRename::source_name_transformation].
    pub fn set_source_name_transformation<
        T: std::convert::Into<crate::model::EntityNameTransformation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_name_transformation = v.into();
        self
    }
}

impl wkt::message::Message for MultiEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiEntityRename"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MultiEntityRename {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_name_pattern,
            __source_name_transformation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiEntityRename")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newNamePattern" => Ok(__FieldTag::__new_name_pattern),
                            "new_name_pattern" => Ok(__FieldTag::__new_name_pattern),
                            "sourceNameTransformation" => {
                                Ok(__FieldTag::__source_name_transformation)
                            }
                            "source_name_transformation" => {
                                Ok(__FieldTag::__source_name_transformation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MultiEntityRename;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiEntityRename")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_name_pattern => {
                            if !fields.insert(__FieldTag::__new_name_pattern) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_name_pattern",
                                ));
                            }
                            result.new_name_pattern = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_name_transformation => {
                            if !fields.insert(__FieldTag::__source_name_transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_name_transformation",
                                ));
                            }
                            result.source_name_transformation = map.next_value::<std::option::Option<crate::model::EntityNameTransformation>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MultiEntityRename {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.new_name_pattern.is_empty() {
            state.serialize_entry("newNamePattern", &self.new_name_pattern)?;
        }
        if !wkt::internal::is_default(&self.source_name_transformation) {
            state.serialize_entry("sourceNameTransformation", &self.source_name_transformation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MultiEntityRename {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiEntityRename");
        debug_struct.field("new_name_pattern", &self.new_name_pattern);
        debug_struct.field(
            "source_name_transformation",
            &self.source_name_transformation,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type EntityMove.
/// The rule is used to move an entity to a new schema.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table, Column, Constraint, Index, View,
/// Function, Stored Procedure, Materialized View, Sequence, UDT
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityMove {
    /// Required. The new schema
    pub new_schema: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMove {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_schema][crate::model::EntityMove::new_schema].
    pub fn set_new_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_schema = v.into();
        self
    }
}

impl wkt::message::Message for EntityMove {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMove"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityMove {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityMove")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newSchema" => Ok(__FieldTag::__new_schema),
                            "new_schema" => Ok(__FieldTag::__new_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityMove;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityMove")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_schema => {
                            if !fields.insert(__FieldTag::__new_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_schema",
                                ));
                            }
                            result.new_schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityMove {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.new_schema.is_empty() {
            state.serialize_entry("newSchema", &self.new_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityMove {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMove");
        debug_struct.field("new_schema", &self.new_schema);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type SingleColumnChange.
/// The rule is used to change the properties of a column.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Column.
///
/// When using this rule, if a field is not specified than the destination
/// column's configuration will be the same as the one in the source column..
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SingleColumnChange {
    /// Optional. Column data type name.
    pub data_type: std::string::String,

    /// Optional. Charset override - instead of table level charset.
    pub charset: std::string::String,

    /// Optional. Collation override - instead of table level collation.
    pub collation: std::string::String,

    /// Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    pub length: i64,

    /// Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    pub precision: i32,

    /// Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    pub scale: i32,

    /// Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2)
    ///
    /// - when relevant.
    pub fractional_seconds_precision: i32,

    /// Optional. Is the column of array type.
    pub array: bool,

    /// Optional. The length of the array, only relevant if the column type is an
    /// array.
    pub array_length: i32,

    /// Optional. Is the column nullable.
    pub nullable: bool,

    /// Optional. Is the column auto-generated/identity.
    pub auto_generated: bool,

    /// Optional. Is the column a UDT (User-defined Type).
    pub udt: bool,

    /// Optional. Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Optional. Specifies the list of values allowed in the column.
    pub set_values: std::vec::Vec<std::string::String>,

    /// Optional. Comment associated with the column.
    pub comment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleColumnChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_type][crate::model::SingleColumnChange::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::SingleColumnChange::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::SingleColumnChange::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::SingleColumnChange::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::SingleColumnChange::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::SingleColumnChange::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::SingleColumnChange::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::SingleColumnChange::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::SingleColumnChange::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::SingleColumnChange::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::SingleColumnChange::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::SingleColumnChange::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SingleColumnChange::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::SingleColumnChange::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_values][crate::model::SingleColumnChange::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [comment][crate::model::SingleColumnChange::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }
}

impl wkt::message::Message for SingleColumnChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleColumnChange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SingleColumnChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_type,
            __charset,
            __collation,
            __length,
            __precision,
            __scale,
            __fractional_seconds_precision,
            __array,
            __array_length,
            __nullable,
            __auto_generated,
            __udt,
            __custom_features,
            __set_values,
            __comment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SingleColumnChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "charset" => Ok(__FieldTag::__charset),
                            "collation" => Ok(__FieldTag::__collation),
                            "length" => Ok(__FieldTag::__length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "fractionalSecondsPrecision" => {
                                Ok(__FieldTag::__fractional_seconds_precision)
                            }
                            "fractional_seconds_precision" => {
                                Ok(__FieldTag::__fractional_seconds_precision)
                            }
                            "array" => Ok(__FieldTag::__array),
                            "arrayLength" => Ok(__FieldTag::__array_length),
                            "array_length" => Ok(__FieldTag::__array_length),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "autoGenerated" => Ok(__FieldTag::__auto_generated),
                            "auto_generated" => Ok(__FieldTag::__auto_generated),
                            "udt" => Ok(__FieldTag::__udt),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            "setValues" => Ok(__FieldTag::__set_values),
                            "set_values" => Ok(__FieldTag::__set_values),
                            "comment" => Ok(__FieldTag::__comment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SingleColumnChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SingleColumnChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__charset => {
                            if !fields.insert(__FieldTag::__charset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for charset",
                                ));
                            }
                            result.charset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__fractional_seconds_precision => {
                            if !fields.insert(__FieldTag::__fractional_seconds_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fractional_seconds_precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.fractional_seconds_precision =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__array => {
                            if !fields.insert(__FieldTag::__array) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array",
                                ));
                            }
                            result.array = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__array_length => {
                            if !fields.insert(__FieldTag::__array_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.array_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_generated => {
                            if !fields.insert(__FieldTag::__auto_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_generated",
                                ));
                            }
                            result.auto_generated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__udt => {
                            if !fields.insert(__FieldTag::__udt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for udt",
                                ));
                            }
                            result.udt = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__set_values => {
                            if !fields.insert(__FieldTag::__set_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_values",
                                ));
                            }
                            result.set_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__comment => {
                            if !fields.insert(__FieldTag::__comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment",
                                ));
                            }
                            result.comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SingleColumnChange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !self.charset.is_empty() {
            state.serialize_entry("charset", &self.charset)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !wkt::internal::is_default(&self.fractional_seconds_precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "fractionalSecondsPrecision",
                &__With(&self.fractional_seconds_precision),
            )?;
        }
        if !wkt::internal::is_default(&self.array) {
            state.serialize_entry("array", &self.array)?;
        }
        if !wkt::internal::is_default(&self.array_length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("arrayLength", &__With(&self.array_length))?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.auto_generated) {
            state.serialize_entry("autoGenerated", &self.auto_generated)?;
        }
        if !wkt::internal::is_default(&self.udt) {
            state.serialize_entry("udt", &self.udt)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self.set_values.is_empty() {
            state.serialize_entry("setValues", &self.set_values)?;
        }
        if !self.comment.is_empty() {
            state.serialize_entry("comment", &self.comment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SingleColumnChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SingleColumnChange");
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("charset", &self.charset);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field(
            "fractional_seconds_precision",
            &self.fractional_seconds_precision,
        );
        debug_struct.field("array", &self.array);
        debug_struct.field("array_length", &self.array_length);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("auto_generated", &self.auto_generated);
        debug_struct.field("udt", &self.udt);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("set_values", &self.set_values);
        debug_struct.field("comment", &self.comment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type MultiColumnDatatypeChange.
/// The rule is used to change the data type and associated properties of
/// multiple columns at once.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of:Column.
///
/// This rule requires additional filters to be specified beyond the basic rule
/// filter field, which is the source data type, but the rule supports additional
/// filtering capabilities such as the minimum and maximum field length. All
/// additional filters which are specified are required to be met in order for
/// the rule to be applied (logical AND between the fields).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MultiColumnDatatypeChange {
    /// Required. Filter on source data type.
    pub source_data_type_filter: std::string::String,

    /// Required. New data type.
    pub new_data_type: std::string::String,

    /// Optional. Column length - e.g. varchar (50) - if not specified and relevant
    /// uses the source column length.
    pub override_length: i64,

    /// Optional. Column scale - when relevant - if not specified and relevant
    /// uses the source column scale.
    pub override_scale: i32,

    /// Optional. Column precision - when relevant - if not specified and relevant
    /// uses the source column precision.
    pub override_precision: i32,

    /// Optional. Column fractional seconds precision - used only for timestamp
    /// based datatypes - if not specified and relevant uses the source column
    /// fractional seconds precision.
    pub override_fractional_seconds_precision: i32,

    /// Optional. Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Filter on source column parameters.
    pub source_filter:
        std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiColumnDatatypeChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_data_type_filter][crate::model::MultiColumnDatatypeChange::source_data_type_filter].
    pub fn set_source_data_type_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_data_type_filter = v.into();
        self
    }

    /// Sets the value of [new_data_type][crate::model::MultiColumnDatatypeChange::new_data_type].
    pub fn set_new_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_data_type = v.into();
        self
    }

    /// Sets the value of [override_length][crate::model::MultiColumnDatatypeChange::override_length].
    pub fn set_override_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.override_length = v.into();
        self
    }

    /// Sets the value of [override_scale][crate::model::MultiColumnDatatypeChange::override_scale].
    pub fn set_override_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_scale = v.into();
        self
    }

    /// Sets the value of [override_precision][crate::model::MultiColumnDatatypeChange::override_precision].
    pub fn set_override_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_precision = v.into();
        self
    }

    /// Sets the value of [override_fractional_seconds_precision][crate::model::MultiColumnDatatypeChange::override_fractional_seconds_precision].
    pub fn set_override_fractional_seconds_precision<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MultiColumnDatatypeChange::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::MultiColumnDatatypeChange::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter].
    ///
    /// Note that all the setters affecting `source_filter` are mutually
    /// exclusive.
    pub fn set_source_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MultiColumnDatatypeChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiColumnDatatypeChange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MultiColumnDatatypeChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_data_type_filter,
            __source_text_filter,
            __source_numeric_filter,
            __new_data_type,
            __override_length,
            __override_scale,
            __override_precision,
            __override_fractional_seconds_precision,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiColumnDatatypeChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceDataTypeFilter" => Ok(__FieldTag::__source_data_type_filter),
                            "source_data_type_filter" => Ok(__FieldTag::__source_data_type_filter),
                            "sourceTextFilter" => Ok(__FieldTag::__source_text_filter),
                            "source_text_filter" => Ok(__FieldTag::__source_text_filter),
                            "sourceNumericFilter" => Ok(__FieldTag::__source_numeric_filter),
                            "source_numeric_filter" => Ok(__FieldTag::__source_numeric_filter),
                            "newDataType" => Ok(__FieldTag::__new_data_type),
                            "new_data_type" => Ok(__FieldTag::__new_data_type),
                            "overrideLength" => Ok(__FieldTag::__override_length),
                            "override_length" => Ok(__FieldTag::__override_length),
                            "overrideScale" => Ok(__FieldTag::__override_scale),
                            "override_scale" => Ok(__FieldTag::__override_scale),
                            "overridePrecision" => Ok(__FieldTag::__override_precision),
                            "override_precision" => Ok(__FieldTag::__override_precision),
                            "overrideFractionalSecondsPrecision" => {
                                Ok(__FieldTag::__override_fractional_seconds_precision)
                            }
                            "override_fractional_seconds_precision" => {
                                Ok(__FieldTag::__override_fractional_seconds_precision)
                            }
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MultiColumnDatatypeChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiColumnDatatypeChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_data_type_filter => {
                            if !fields.insert(__FieldTag::__source_data_type_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_data_type_filter",
                                ));
                            }
                            result.source_data_type_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_text_filter => {
                            if !fields.insert(__FieldTag::__source_text_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_text_filter",
                                ));
                            }
                            if result.source_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_filter`, a oneof with full ID .google.cloud.clouddms.v1.MultiColumnDatatypeChange.source_text_filter, latest field was sourceTextFilter",
                                ));
                            }
                            result.source_filter = std::option::Option::Some(
                                crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SourceTextFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__source_numeric_filter => {
                            if !fields.insert(__FieldTag::__source_numeric_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_numeric_filter",
                                ));
                            }
                            if result.source_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_filter`, a oneof with full ID .google.cloud.clouddms.v1.MultiColumnDatatypeChange.source_numeric_filter, latest field was sourceNumericFilter",
                                ));
                            }
                            result.source_filter = std::option::Option::Some(
                                crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SourceNumericFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__new_data_type => {
                            if !fields.insert(__FieldTag::__new_data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_data_type",
                                ));
                            }
                            result.new_data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__override_length => {
                            if !fields.insert(__FieldTag::__override_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.override_length =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__override_scale => {
                            if !fields.insert(__FieldTag::__override_scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.override_scale =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__override_precision => {
                            if !fields.insert(__FieldTag::__override_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.override_precision =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__override_fractional_seconds_precision => {
                            if !fields.insert(__FieldTag::__override_fractional_seconds_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for override_fractional_seconds_precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.override_fractional_seconds_precision =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MultiColumnDatatypeChange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_data_type_filter.is_empty() {
            state.serialize_entry("sourceDataTypeFilter", &self.source_data_type_filter)?;
        }
        if let Some(value) = self.source_text_filter() {
            state.serialize_entry("sourceTextFilter", value)?;
        }
        if let Some(value) = self.source_numeric_filter() {
            state.serialize_entry("sourceNumericFilter", value)?;
        }
        if !self.new_data_type.is_empty() {
            state.serialize_entry("newDataType", &self.new_data_type)?;
        }
        if !wkt::internal::is_default(&self.override_length) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("overrideLength", &__With(&self.override_length))?;
        }
        if !wkt::internal::is_default(&self.override_scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("overrideScale", &__With(&self.override_scale))?;
        }
        if !wkt::internal::is_default(&self.override_precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("overridePrecision", &__With(&self.override_precision))?;
        }
        if !wkt::internal::is_default(&self.override_fractional_seconds_precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "overrideFractionalSecondsPrecision",
                &__With(&self.override_fractional_seconds_precision),
            )?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MultiColumnDatatypeChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MultiColumnDatatypeChange");
        debug_struct.field("source_data_type_filter", &self.source_data_type_filter);
        debug_struct.field("new_data_type", &self.new_data_type);
        debug_struct.field("override_length", &self.override_length);
        debug_struct.field("override_scale", &self.override_scale);
        debug_struct.field("override_precision", &self.override_precision);
        debug_struct.field(
            "override_fractional_seconds_precision",
            &self.override_fractional_seconds_precision,
        );
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("source_filter", &self.source_filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MultiColumnDatatypeChange].
pub mod multi_column_datatype_change {
    #[allow(unused_imports)]
    use super::*;

    /// Filter on source column parameters.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Filter for text-based data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Filter for fixed point number data types such as
        /// NUMERIC/NUMBER.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Filter for text-based data types like varchar.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceTextFilter {
    /// Optional. The filter will match columns with length greater than or equal
    /// to this number.
    pub source_min_length_filter: i64,

    /// Optional. The filter will match columns with length smaller than or equal
    /// to this number.
    pub source_max_length_filter: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceTextFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_length_filter][crate::model::SourceTextFilter::source_min_length_filter].
    pub fn set_source_min_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_min_length_filter = v.into();
        self
    }

    /// Sets the value of [source_max_length_filter][crate::model::SourceTextFilter::source_max_length_filter].
    pub fn set_source_max_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_max_length_filter = v.into();
        self
    }
}

impl wkt::message::Message for SourceTextFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceTextFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceTextFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_min_length_filter,
            __source_max_length_filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceTextFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceMinLengthFilter" => Ok(__FieldTag::__source_min_length_filter),
                            "source_min_length_filter" => {
                                Ok(__FieldTag::__source_min_length_filter)
                            }
                            "sourceMaxLengthFilter" => Ok(__FieldTag::__source_max_length_filter),
                            "source_max_length_filter" => {
                                Ok(__FieldTag::__source_max_length_filter)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceTextFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceTextFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_min_length_filter => {
                            if !fields.insert(__FieldTag::__source_min_length_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_min_length_filter",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_min_length_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_max_length_filter => {
                            if !fields.insert(__FieldTag::__source_max_length_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_max_length_filter",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_max_length_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceTextFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_min_length_filter) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMinLengthFilter",
                &__With(&self.source_min_length_filter),
            )?;
        }
        if !wkt::internal::is_default(&self.source_max_length_filter) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMaxLengthFilter",
                &__With(&self.source_max_length_filter),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceTextFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceTextFilter");
        debug_struct.field("source_min_length_filter", &self.source_min_length_filter);
        debug_struct.field("source_max_length_filter", &self.source_max_length_filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Filter for fixed point number data types such as NUMERIC/NUMBER
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceNumericFilter {
    /// Optional. The filter will match columns with scale greater than or equal to
    /// this number.
    pub source_min_scale_filter: i32,

    /// Optional. The filter will match columns with scale smaller than or equal to
    /// this number.
    pub source_max_scale_filter: i32,

    /// Optional. The filter will match columns with precision greater than or
    /// equal to this number.
    pub source_min_precision_filter: i32,

    /// Optional. The filter will match columns with precision smaller than or
    /// equal to this number.
    pub source_max_precision_filter: i32,

    /// Required. Enum to set the option defining the datatypes numeric filter has
    /// to be applied to
    pub numeric_filter_option: crate::model::NumericFilterOption,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceNumericFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_scale_filter][crate::model::SourceNumericFilter::source_min_scale_filter].
    pub fn set_source_min_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_max_scale_filter][crate::model::SourceNumericFilter::source_max_scale_filter].
    pub fn set_source_max_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_min_precision_filter][crate::model::SourceNumericFilter::source_min_precision_filter].
    pub fn set_source_min_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_precision_filter = v.into();
        self
    }

    /// Sets the value of [source_max_precision_filter][crate::model::SourceNumericFilter::source_max_precision_filter].
    pub fn set_source_max_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_precision_filter = v.into();
        self
    }

    /// Sets the value of [numeric_filter_option][crate::model::SourceNumericFilter::numeric_filter_option].
    pub fn set_numeric_filter_option<T: std::convert::Into<crate::model::NumericFilterOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.numeric_filter_option = v.into();
        self
    }
}

impl wkt::message::Message for SourceNumericFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceNumericFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceNumericFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_min_scale_filter,
            __source_max_scale_filter,
            __source_min_precision_filter,
            __source_max_precision_filter,
            __numeric_filter_option,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceNumericFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceMinScaleFilter" => Ok(__FieldTag::__source_min_scale_filter),
                            "source_min_scale_filter" => Ok(__FieldTag::__source_min_scale_filter),
                            "sourceMaxScaleFilter" => Ok(__FieldTag::__source_max_scale_filter),
                            "source_max_scale_filter" => Ok(__FieldTag::__source_max_scale_filter),
                            "sourceMinPrecisionFilter" => {
                                Ok(__FieldTag::__source_min_precision_filter)
                            }
                            "source_min_precision_filter" => {
                                Ok(__FieldTag::__source_min_precision_filter)
                            }
                            "sourceMaxPrecisionFilter" => {
                                Ok(__FieldTag::__source_max_precision_filter)
                            }
                            "source_max_precision_filter" => {
                                Ok(__FieldTag::__source_max_precision_filter)
                            }
                            "numericFilterOption" => Ok(__FieldTag::__numeric_filter_option),
                            "numeric_filter_option" => Ok(__FieldTag::__numeric_filter_option),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceNumericFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceNumericFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_min_scale_filter => {
                            if !fields.insert(__FieldTag::__source_min_scale_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_min_scale_filter",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_min_scale_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_max_scale_filter => {
                            if !fields.insert(__FieldTag::__source_max_scale_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_max_scale_filter",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_max_scale_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_min_precision_filter => {
                            if !fields.insert(__FieldTag::__source_min_precision_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_min_precision_filter",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_min_precision_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source_max_precision_filter => {
                            if !fields.insert(__FieldTag::__source_max_precision_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_max_precision_filter",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_max_precision_filter =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__numeric_filter_option => {
                            if !fields.insert(__FieldTag::__numeric_filter_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numeric_filter_option",
                                ));
                            }
                            result.numeric_filter_option = map.next_value::<std::option::Option<crate::model::NumericFilterOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceNumericFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_min_scale_filter) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMinScaleFilter",
                &__With(&self.source_min_scale_filter),
            )?;
        }
        if !wkt::internal::is_default(&self.source_max_scale_filter) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMaxScaleFilter",
                &__With(&self.source_max_scale_filter),
            )?;
        }
        if !wkt::internal::is_default(&self.source_min_precision_filter) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMinPrecisionFilter",
                &__With(&self.source_min_precision_filter),
            )?;
        }
        if !wkt::internal::is_default(&self.source_max_precision_filter) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sourceMaxPrecisionFilter",
                &__With(&self.source_max_precision_filter),
            )?;
        }
        if !wkt::internal::is_default(&self.numeric_filter_option) {
            state.serialize_entry("numericFilterOption", &self.numeric_filter_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceNumericFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceNumericFilter");
        debug_struct.field("source_min_scale_filter", &self.source_min_scale_filter);
        debug_struct.field("source_max_scale_filter", &self.source_max_scale_filter);
        debug_struct.field(
            "source_min_precision_filter",
            &self.source_min_precision_filter,
        );
        debug_struct.field(
            "source_max_precision_filter",
            &self.source_max_precision_filter,
        );
        debug_struct.field("numeric_filter_option", &self.numeric_filter_option);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type ConditionalColumnSetValue.
/// The rule is used to transform the data which is being replicated/migrated.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Column.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConditionalColumnSetValue {
    /// Required. Description of data transformation during migration.
    pub value_transformation: std::option::Option<crate::model::ValueTransformation>,

    /// Optional. Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    pub source_filter:
        std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConditionalColumnSetValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_transformation][crate::model::ConditionalColumnSetValue::value_transformation].
    pub fn set_value_transformation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ValueTransformation>,
    {
        self.value_transformation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value_transformation][crate::model::ConditionalColumnSetValue::value_transformation].
    pub fn set_or_clear_value_transformation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ValueTransformation>,
    {
        self.value_transformation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_features][crate::model::ConditionalColumnSetValue::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::ConditionalColumnSetValue::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter].
    ///
    /// Note that all the setters affecting `source_filter` are mutually
    /// exclusive.
    pub fn set_source_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConditionalColumnSetValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConditionalColumnSetValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConditionalColumnSetValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_text_filter,
            __source_numeric_filter,
            __value_transformation,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConditionalColumnSetValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceTextFilter" => Ok(__FieldTag::__source_text_filter),
                            "source_text_filter" => Ok(__FieldTag::__source_text_filter),
                            "sourceNumericFilter" => Ok(__FieldTag::__source_numeric_filter),
                            "source_numeric_filter" => Ok(__FieldTag::__source_numeric_filter),
                            "valueTransformation" => Ok(__FieldTag::__value_transformation),
                            "value_transformation" => Ok(__FieldTag::__value_transformation),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConditionalColumnSetValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConditionalColumnSetValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_text_filter => {
                            if !fields.insert(__FieldTag::__source_text_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_text_filter",
                                ));
                            }
                            if result.source_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_filter`, a oneof with full ID .google.cloud.clouddms.v1.ConditionalColumnSetValue.source_text_filter, latest field was sourceTextFilter",
                                ));
                            }
                            result.source_filter = std::option::Option::Some(
                                crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SourceTextFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__source_numeric_filter => {
                            if !fields.insert(__FieldTag::__source_numeric_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_numeric_filter",
                                ));
                            }
                            if result.source_filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_filter`, a oneof with full ID .google.cloud.clouddms.v1.ConditionalColumnSetValue.source_numeric_filter, latest field was sourceNumericFilter",
                                ));
                            }
                            result.source_filter = std::option::Option::Some(
                                crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SourceNumericFilter>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__value_transformation => {
                            if !fields.insert(__FieldTag::__value_transformation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_transformation",
                                ));
                            }
                            result.value_transformation = map.next_value::<std::option::Option<crate::model::ValueTransformation>>()?
                                ;
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConditionalColumnSetValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.source_text_filter() {
            state.serialize_entry("sourceTextFilter", value)?;
        }
        if let Some(value) = self.source_numeric_filter() {
            state.serialize_entry("sourceNumericFilter", value)?;
        }
        if self.value_transformation.is_some() {
            state.serialize_entry("valueTransformation", &self.value_transformation)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConditionalColumnSetValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConditionalColumnSetValue");
        debug_struct.field("value_transformation", &self.value_transformation);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("source_filter", &self.source_filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConditionalColumnSetValue].
pub mod conditional_column_set_value {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Optional filter on source column length. Used for text based
        /// data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Optional filter on source column precision and scale. Used for
        /// fixed point numbers such as NUMERIC/NUMBER data types.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Description of data transformation during migration as part of the
/// ConditionalColumnSetValue.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValueTransformation {
    pub filter: std::option::Option<crate::model::value_transformation::Filter>,

    pub action: std::option::Option<crate::model::value_transformation::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IsNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn is_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IsNull(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IsNull`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_is_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.filter =
            std::option::Option::Some(crate::model::value_transformation::Filter::IsNull(v.into()));
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `ValueList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValueListFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::ValueList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `ValueList`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_value_list<T: std::convert::Into<std::boxed::Box<crate::model::ValueListFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::ValueList(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IntComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IntComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IntComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_int_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::IntComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::IntComparison(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `DoubleComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DoubleComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::DoubleComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `DoubleComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_double_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::DoubleComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::DoubleComparison(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignNull(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignNull`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignNull(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignSpecificValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_specific_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AssignSpecificValue>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignSpecificValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignSpecificValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_specific_value<
        T: std::convert::Into<std::boxed::Box<crate::model::AssignSpecificValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignSpecificValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMinValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_min_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMinValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMinValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_min_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMinValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMaxValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_max_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMaxValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMaxValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_max_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMaxValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `RoundScale`, `None` if the field is not set or
    /// holds a different branch.
    pub fn round_scale(&self) -> std::option::Option<&std::boxed::Box<crate::model::RoundToScale>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::RoundScale(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `RoundScale`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_round_scale<T: std::convert::Into<std::boxed::Box<crate::model::RoundToScale>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::RoundScale(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `ApplyHash`, `None` if the field is not set or
    /// holds a different branch.
    pub fn apply_hash(&self) -> std::option::Option<&std::boxed::Box<crate::model::ApplyHash>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::ApplyHash(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `ApplyHash`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_apply_hash<T: std::convert::Into<std::boxed::Box<crate::model::ApplyHash>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::ApplyHash(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValueTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueTransformation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValueTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_null,
            __value_list,
            __int_comparison,
            __double_comparison,
            __assign_null,
            __assign_specific_value,
            __assign_min_value,
            __assign_max_value,
            __round_scale,
            __apply_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValueTransformation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "isNull" => Ok(__FieldTag::__is_null),
                            "is_null" => Ok(__FieldTag::__is_null),
                            "valueList" => Ok(__FieldTag::__value_list),
                            "value_list" => Ok(__FieldTag::__value_list),
                            "intComparison" => Ok(__FieldTag::__int_comparison),
                            "int_comparison" => Ok(__FieldTag::__int_comparison),
                            "doubleComparison" => Ok(__FieldTag::__double_comparison),
                            "double_comparison" => Ok(__FieldTag::__double_comparison),
                            "assignNull" => Ok(__FieldTag::__assign_null),
                            "assign_null" => Ok(__FieldTag::__assign_null),
                            "assignSpecificValue" => Ok(__FieldTag::__assign_specific_value),
                            "assign_specific_value" => Ok(__FieldTag::__assign_specific_value),
                            "assignMinValue" => Ok(__FieldTag::__assign_min_value),
                            "assign_min_value" => Ok(__FieldTag::__assign_min_value),
                            "assignMaxValue" => Ok(__FieldTag::__assign_max_value),
                            "assign_max_value" => Ok(__FieldTag::__assign_max_value),
                            "roundScale" => Ok(__FieldTag::__round_scale),
                            "round_scale" => Ok(__FieldTag::__round_scale),
                            "applyHash" => Ok(__FieldTag::__apply_hash),
                            "apply_hash" => Ok(__FieldTag::__apply_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValueTransformation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValueTransformation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_null => {
                            if !fields.insert(__FieldTag::__is_null) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_null",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.is_null, latest field was isNull",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::value_transformation::Filter::IsNull(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__value_list => {
                            if !fields.insert(__FieldTag::__value_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_list",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.value_list, latest field was valueList",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::value_transformation::Filter::ValueList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ValueListFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int_comparison => {
                            if !fields.insert(__FieldTag::__int_comparison) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_comparison",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.int_comparison, latest field was intComparison",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::value_transformation::Filter::IntComparison(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IntComparisonFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_comparison => {
                            if !fields.insert(__FieldTag::__double_comparison) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_comparison",
                                ));
                            }
                            if result.filter.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `filter`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.double_comparison, latest field was doubleComparison",
                                ));
                            }
                            result.filter = std::option::Option::Some(
                                crate::model::value_transformation::Filter::DoubleComparison(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DoubleComparisonFilter>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__assign_null => {
                            if !fields.insert(__FieldTag::__assign_null) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assign_null",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.assign_null, latest field was assignNull",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::AssignNull(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__assign_specific_value => {
                            if !fields.insert(__FieldTag::__assign_specific_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assign_specific_value",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.assign_specific_value, latest field was assignSpecificValue",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::AssignSpecificValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AssignSpecificValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__assign_min_value => {
                            if !fields.insert(__FieldTag::__assign_min_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assign_min_value",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.assign_min_value, latest field was assignMinValue",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::AssignMinValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__assign_max_value => {
                            if !fields.insert(__FieldTag::__assign_max_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assign_max_value",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.assign_max_value, latest field was assignMaxValue",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::AssignMaxValue(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__round_scale => {
                            if !fields.insert(__FieldTag::__round_scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for round_scale",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.round_scale, latest field was roundScale",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::RoundScale(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RoundToScale>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__apply_hash => {
                            if !fields.insert(__FieldTag::__apply_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apply_hash",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.clouddms.v1.ValueTransformation.apply_hash, latest field was applyHash",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::value_transformation::Action::ApplyHash(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ApplyHash>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValueTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.is_null() {
            state.serialize_entry("isNull", value)?;
        }
        if let Some(value) = self.value_list() {
            state.serialize_entry("valueList", value)?;
        }
        if let Some(value) = self.int_comparison() {
            state.serialize_entry("intComparison", value)?;
        }
        if let Some(value) = self.double_comparison() {
            state.serialize_entry("doubleComparison", value)?;
        }
        if let Some(value) = self.assign_null() {
            state.serialize_entry("assignNull", value)?;
        }
        if let Some(value) = self.assign_specific_value() {
            state.serialize_entry("assignSpecificValue", value)?;
        }
        if let Some(value) = self.assign_min_value() {
            state.serialize_entry("assignMinValue", value)?;
        }
        if let Some(value) = self.assign_max_value() {
            state.serialize_entry("assignMaxValue", value)?;
        }
        if let Some(value) = self.round_scale() {
            state.serialize_entry("roundScale", value)?;
        }
        if let Some(value) = self.apply_hash() {
            state.serialize_entry("applyHash", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValueTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueTransformation");
        debug_struct.field("filter", &self.filter);
        debug_struct.field("action", &self.action);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ValueTransformation].
pub mod value_transformation {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. Value is null
        IsNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Value is found in the specified list.
        ValueList(std::boxed::Box<crate::model::ValueListFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type integer.
        IntComparison(std::boxed::Box<crate::model::IntComparisonFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type double.
        DoubleComparison(std::boxed::Box<crate::model::DoubleComparisonFilter>),
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Optional. Set to null
        AssignNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to a specific value (value is converted to fit the target
        /// data type)
        AssignSpecificValue(std::boxed::Box<crate::model::AssignSpecificValue>),
        /// Optional. Set to min_value - if integer or numeric, will use
        /// int.minvalue, etc
        AssignMinValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to max_value - if integer or numeric, will use
        /// int.maxvalue, etc
        AssignMaxValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Allows the data to change scale
        RoundScale(std::boxed::Box<crate::model::RoundToScale>),
        /// Optional. Applies a hash function on the data
        ApplyHash(std::boxed::Box<crate::model::ApplyHash>),
    }
}

/// Options to configure rule type ConvertROWIDToColumn.
/// The rule is used to add column rowid to destination tables based on an Oracle
/// rowid function/property.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table.
///
/// This rule requires additional filter to be specified beyond the basic rule
/// filter field, which is whether or not to work on tables which already have a
/// primary key defined.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConvertRowIdToColumn {
    /// Required. Only work on tables without primary key defined
    pub only_if_no_primary_key: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConvertRowIdToColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [only_if_no_primary_key][crate::model::ConvertRowIdToColumn::only_if_no_primary_key].
    pub fn set_only_if_no_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.only_if_no_primary_key = v.into();
        self
    }
}

impl wkt::message::Message for ConvertRowIdToColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertRowIdToColumn"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConvertRowIdToColumn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __only_if_no_primary_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConvertRowIdToColumn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onlyIfNoPrimaryKey" => Ok(__FieldTag::__only_if_no_primary_key),
                            "only_if_no_primary_key" => Ok(__FieldTag::__only_if_no_primary_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConvertRowIdToColumn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConvertRowIdToColumn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__only_if_no_primary_key => {
                            if !fields.insert(__FieldTag::__only_if_no_primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for only_if_no_primary_key",
                                ));
                            }
                            result.only_if_no_primary_key = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConvertRowIdToColumn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.only_if_no_primary_key) {
            state.serialize_entry("onlyIfNoPrimaryKey", &self.only_if_no_primary_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConvertRowIdToColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConvertRowIdToColumn");
        debug_struct.field("only_if_no_primary_key", &self.only_if_no_primary_key);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type SetTablePrimaryKey.
/// The rule is used to specify the columns and name to configure/alter the
/// primary key of a table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Table.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetTablePrimaryKey {
    /// Required. List of column names for the primary key
    pub primary_key_columns: std::vec::Vec<std::string::String>,

    /// Optional. Name for the primary key
    pub primary_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetTablePrimaryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_key_columns][crate::model::SetTablePrimaryKey::primary_key_columns].
    pub fn set_primary_key_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.primary_key_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [primary_key][crate::model::SetTablePrimaryKey::primary_key].
    pub fn set_primary_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }
}

impl wkt::message::Message for SetTablePrimaryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SetTablePrimaryKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetTablePrimaryKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __primary_key_columns,
            __primary_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetTablePrimaryKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "primaryKeyColumns" => Ok(__FieldTag::__primary_key_columns),
                            "primary_key_columns" => Ok(__FieldTag::__primary_key_columns),
                            "primaryKey" => Ok(__FieldTag::__primary_key),
                            "primary_key" => Ok(__FieldTag::__primary_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetTablePrimaryKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetTablePrimaryKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__primary_key_columns => {
                            if !fields.insert(__FieldTag::__primary_key_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key_columns",
                                ));
                            }
                            result.primary_key_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__primary_key => {
                            if !fields.insert(__FieldTag::__primary_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_key",
                                ));
                            }
                            result.primary_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetTablePrimaryKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.primary_key_columns.is_empty() {
            state.serialize_entry("primaryKeyColumns", &self.primary_key_columns)?;
        }
        if !self.primary_key.is_empty() {
            state.serialize_entry("primaryKey", &self.primary_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetTablePrimaryKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetTablePrimaryKey");
        debug_struct.field("primary_key_columns", &self.primary_key_columns);
        debug_struct.field("primary_key", &self.primary_key);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type SinglePackageChange.
/// The rule is used to alter the sql code for a package entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Package
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SinglePackageChange {
    /// Optional. Sql code for package description
    pub package_description: std::string::String,

    /// Optional. Sql code for package body
    pub package_body: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SinglePackageChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_description][crate::model::SinglePackageChange::package_description].
    pub fn set_package_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_description = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::SinglePackageChange::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }
}

impl wkt::message::Message for SinglePackageChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SinglePackageChange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SinglePackageChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package_description,
            __package_body,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SinglePackageChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "packageDescription" => Ok(__FieldTag::__package_description),
                            "package_description" => Ok(__FieldTag::__package_description),
                            "packageBody" => Ok(__FieldTag::__package_body),
                            "package_body" => Ok(__FieldTag::__package_body),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SinglePackageChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SinglePackageChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package_description => {
                            if !fields.insert(__FieldTag::__package_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_description",
                                ));
                            }
                            result.package_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_body => {
                            if !fields.insert(__FieldTag::__package_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_body",
                                ));
                            }
                            result.package_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SinglePackageChange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.package_description.is_empty() {
            state.serialize_entry("packageDescription", &self.package_description)?;
        }
        if !self.package_body.is_empty() {
            state.serialize_entry("packageBody", &self.package_body)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SinglePackageChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SinglePackageChange");
        debug_struct.field("package_description", &self.package_description);
        debug_struct.field("package_body", &self.package_body);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type SourceSqlChange.
/// The rule is used to alter the sql code for database entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: StoredProcedure, Function, Trigger, View
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceSqlChange {
    /// Required. Sql code for source (stored procedure, function, trigger or view)
    pub sql_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceSqlChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::SourceSqlChange::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }
}

impl wkt::message::Message for SourceSqlChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceSqlChange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceSqlChange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceSqlChange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceSqlChange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceSqlChange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceSqlChange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceSqlChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceSqlChange");
        debug_struct.field("sql_code", &self.sql_code);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Options to configure rule type FilterTableColumns.
/// The rule is used to filter the list of columns to include or exclude from a
/// table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Table
///
/// Only one of the two lists can be specified for the rule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FilterTableColumns {
    /// Optional. List of columns to be included for a particular table.
    pub include_columns: std::vec::Vec<std::string::String>,

    /// Optional. List of columns to be excluded for a particular table.
    pub exclude_columns: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterTableColumns {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_columns][crate::model::FilterTableColumns::include_columns].
    pub fn set_include_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_columns][crate::model::FilterTableColumns::exclude_columns].
    pub fn set_exclude_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FilterTableColumns {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FilterTableColumns"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilterTableColumns {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_columns,
            __exclude_columns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterTableColumns")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeColumns" => Ok(__FieldTag::__include_columns),
                            "include_columns" => Ok(__FieldTag::__include_columns),
                            "excludeColumns" => Ok(__FieldTag::__exclude_columns),
                            "exclude_columns" => Ok(__FieldTag::__exclude_columns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilterTableColumns;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterTableColumns")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_columns => {
                            if !fields.insert(__FieldTag::__include_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_columns",
                                ));
                            }
                            result.include_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exclude_columns => {
                            if !fields.insert(__FieldTag::__exclude_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclude_columns",
                                ));
                            }
                            result.exclude_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FilterTableColumns {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.include_columns.is_empty() {
            state.serialize_entry("includeColumns", &self.include_columns)?;
        }
        if !self.exclude_columns.is_empty() {
            state.serialize_entry("excludeColumns", &self.exclude_columns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FilterTableColumns {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FilterTableColumns");
        debug_struct.field("include_columns", &self.include_columns);
        debug_struct.field("exclude_columns", &self.exclude_columns);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A list of values to filter by in ConditionalColumnSetValue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ValueListFilter {
    /// Required. Indicates whether the filter matches rows with values that are
    /// present in the list or those with values not present in it.
    pub value_present_list: crate::model::ValuePresentInList,

    /// Required. The list to be used to filter by
    pub values: std::vec::Vec<std::string::String>,

    /// Required. Whether to ignore case when filtering by values. Defaults to
    /// false
    pub ignore_case: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueListFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_present_list][crate::model::ValueListFilter::value_present_list].
    pub fn set_value_present_list<T: std::convert::Into<crate::model::ValuePresentInList>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_present_list = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ValueListFilter::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_case][crate::model::ValueListFilter::ignore_case].
    pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_case = v.into();
        self
    }
}

impl wkt::message::Message for ValueListFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueListFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValueListFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value_present_list,
            __values,
            __ignore_case,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValueListFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "valuePresentList" => Ok(__FieldTag::__value_present_list),
                            "value_present_list" => Ok(__FieldTag::__value_present_list),
                            "values" => Ok(__FieldTag::__values),
                            "ignoreCase" => Ok(__FieldTag::__ignore_case),
                            "ignore_case" => Ok(__FieldTag::__ignore_case),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValueListFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValueListFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value_present_list => {
                            if !fields.insert(__FieldTag::__value_present_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_present_list",
                                ));
                            }
                            result.value_present_list = map.next_value::<std::option::Option<crate::model::ValuePresentInList>>()?.unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ignore_case => {
                            if !fields.insert(__FieldTag::__ignore_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_case",
                                ));
                            }
                            result.ignore_case = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValueListFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.value_present_list) {
            state.serialize_entry("valuePresentList", &self.value_present_list)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !wkt::internal::is_default(&self.ignore_case) {
            state.serialize_entry("ignoreCase", &self.ignore_case)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ValueListFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueListFilter");
        debug_struct.field("value_present_list", &self.value_present_list);
        debug_struct.field("values", &self.values);
        debug_struct.field("ignore_case", &self.ignore_case);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Filter based on relation between source value and compare value of type
/// integer in ConditionalColumnSetValue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IntComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Integer compare value to be used
    pub value: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::IntComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::IntComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for IntComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IntComparisonFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntComparisonFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value_comparison,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntComparisonFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "valueComparison" => Ok(__FieldTag::__value_comparison),
                            "value_comparison" => Ok(__FieldTag::__value_comparison),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntComparisonFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntComparisonFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value_comparison => {
                            if !fields.insert(__FieldTag::__value_comparison) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_comparison",
                                ));
                            }
                            result.value_comparison = map
                                .next_value::<std::option::Option<crate::model::ValueComparison>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IntComparisonFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.value_comparison) {
            state.serialize_entry("valueComparison", &self.value_comparison)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IntComparisonFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntComparisonFilter");
        debug_struct.field("value_comparison", &self.value_comparison);
        debug_struct.field("value", &self.value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Filter based on relation between source
/// value and compare value of type double in ConditionalColumnSetValue
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DoubleComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Double compare value to be used
    pub value: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DoubleComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::DoubleComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DoubleComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DoubleComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DoubleComparisonFilter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DoubleComparisonFilter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value_comparison,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DoubleComparisonFilter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "valueComparison" => Ok(__FieldTag::__value_comparison),
                            "value_comparison" => Ok(__FieldTag::__value_comparison),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DoubleComparisonFilter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DoubleComparisonFilter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value_comparison => {
                            if !fields.insert(__FieldTag::__value_comparison) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_comparison",
                                ));
                            }
                            result.value_comparison = map
                                .next_value::<std::option::Option<crate::model::ValueComparison>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DoubleComparisonFilter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.value_comparison) {
            state.serialize_entry("valueComparison", &self.value_comparison)?;
        }
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DoubleComparisonFilter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleComparisonFilter");
        debug_struct.field("value_comparison", &self.value_comparison);
        debug_struct.field("value", &self.value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set to a specific value (value is converted to fit the target data type)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AssignSpecificValue {
    /// Required. Specific value to be assigned
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignSpecificValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AssignSpecificValue::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for AssignSpecificValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AssignSpecificValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssignSpecificValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssignSpecificValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssignSpecificValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssignSpecificValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AssignSpecificValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AssignSpecificValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AssignSpecificValue");
        debug_struct.field("value", &self.value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Apply a hash function on the value.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplyHash {
    pub hash_function: std::option::Option<crate::model::apply_hash::HashFunction>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyHash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_function][crate::model::ApplyHash::hash_function].
    ///
    /// Note that all the setters affecting `hash_function` are mutually
    /// exclusive.
    pub fn set_hash_function<
        T: std::convert::Into<std::option::Option<crate::model::apply_hash::HashFunction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = v.into();
        self
    }

    /// The value of [hash_function][crate::model::ApplyHash::hash_function]
    /// if it holds a `UuidFromBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uuid_from_bytes(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.hash_function.as_ref().and_then(|v| match v {
            crate::model::apply_hash::HashFunction::UuidFromBytes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hash_function][crate::model::ApplyHash::hash_function]
    /// to hold a `UuidFromBytes`.
    ///
    /// Note that all the setters affecting `hash_function` are
    /// mutually exclusive.
    pub fn set_uuid_from_bytes<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = std::option::Option::Some(
            crate::model::apply_hash::HashFunction::UuidFromBytes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ApplyHash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyHash"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplyHash {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uuid_from_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApplyHash")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uuidFromBytes" => Ok(__FieldTag::__uuid_from_bytes),
                            "uuid_from_bytes" => Ok(__FieldTag::__uuid_from_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplyHash;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplyHash")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uuid_from_bytes => {
                            if !fields.insert(__FieldTag::__uuid_from_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid_from_bytes",
                                ));
                            }
                            if result.hash_function.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `hash_function`, a oneof with full ID .google.cloud.clouddms.v1.ApplyHash.uuid_from_bytes, latest field was uuidFromBytes",
                                ));
                            }
                            result.hash_function = std::option::Option::Some(
                                crate::model::apply_hash::HashFunction::UuidFromBytes(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Empty>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplyHash {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.uuid_from_bytes() {
            state.serialize_entry("uuidFromBytes", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApplyHash {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplyHash");
        debug_struct.field("hash_function", &self.hash_function);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApplyHash].
pub mod apply_hash {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HashFunction {
        /// Optional. Generate UUID from the data's byte array
        UuidFromBytes(std::boxed::Box<wkt::Empty>),
    }
}

/// This allows the data to change scale, for example if the source is 2 digits
/// after the decimal point, specify round to scale value = 2. If for example the
/// value needs to be converted to an integer, use round to scale value = 0.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RoundToScale {
    /// Required. Scale value to be used
    pub scale: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoundToScale {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scale][crate::model::RoundToScale::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }
}

impl wkt::message::Message for RoundToScale {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RoundToScale"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RoundToScale {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scale,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RoundToScale")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scale" => Ok(__FieldTag::__scale),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RoundToScale;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RoundToScale")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RoundToScale {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RoundToScale {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoundToScale");
        debug_struct.field("scale", &self.scale);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The base entity type for all the database related entities.
/// The message contains the entity name, the name of its parent, the entity
/// type, and the specific details per entity type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseEntity {
    /// The short name (e.g. table name) of the entity.
    pub short_name: std::string::String,

    /// The full name of the parent entity (e.g. schema name).
    pub parent_entity: std::string::String,

    /// The type of tree the entity belongs to.
    pub tree: crate::model::database_entity::TreeType,

    /// The type of the database entity (table, view, index, ...).
    pub entity_type: crate::model::DatabaseEntityType,

    /// Details about entity mappings.
    /// For source tree entities, this holds the draft entities which were
    /// generated by the mapping rules.
    /// For draft tree entities, this holds the source entities which were
    /// converted to form the draft entity.
    /// Destination entities will have no mapping details.
    pub mappings: std::vec::Vec<crate::model::EntityMapping>,

    /// Details about the entity DDL script. Multiple DDL scripts are provided for
    /// child entities such as a table entity will have one DDL for the table with
    /// additional DDLs for each index, constraint and such.
    pub entity_ddl: std::vec::Vec<crate::model::EntityDdl>,

    /// Details about the various issues found for the entity.
    pub issues: std::vec::Vec<crate::model::EntityIssue>,

    /// The specific body for each entity type.
    pub entity_body: std::option::Option<crate::model::database_entity::EntityBody>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [short_name][crate::model::DatabaseEntity::short_name].
    pub fn set_short_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_name = v.into();
        self
    }

    /// Sets the value of [parent_entity][crate::model::DatabaseEntity::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DatabaseEntity::tree].
    pub fn set_tree<T: std::convert::Into<crate::model::database_entity::TreeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::DatabaseEntity::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [mappings][crate::model::DatabaseEntity::mappings].
    pub fn set_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMapping>,
    {
        use std::iter::Iterator;
        self.mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_ddl][crate::model::DatabaseEntity::entity_ddl].
    pub fn set_entity_ddl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityDdl>,
    {
        use std::iter::Iterator;
        self.entity_ddl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [issues][crate::model::DatabaseEntity::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityIssue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body].
    ///
    /// Note that all the setters affecting `entity_body` are mutually
    /// exclusive.
    pub fn set_entity_body<
        T: std::convert::Into<std::option::Option<crate::model::database_entity::EntityBody>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = v.into();
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Database`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseInstanceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Database(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Database`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseInstanceEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Database(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::SchemaEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Schema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::SchemaEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Schema(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::TableEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Table(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `View`, `None` if the field is not set or
    /// holds a different branch.
    pub fn view(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::View(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `View`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_view<T: std::convert::Into<std::boxed::Box<crate::model::ViewEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::View(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Sequence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sequence(&self) -> std::option::Option<&std::boxed::Box<crate::model::SequenceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Sequence(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Sequence`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_sequence<T: std::convert::Into<std::boxed::Box<crate::model::SequenceEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Sequence(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `StoredProcedure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stored_procedure(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StoredProcedureEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::StoredProcedure(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `StoredProcedure`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_stored_procedure<
        T: std::convert::Into<std::boxed::Box<crate::model::StoredProcedureEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::StoredProcedure(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabaseFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_function(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabaseFunction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabaseFunction`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_function<
        T: std::convert::Into<std::boxed::Box<crate::model::FunctionEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabaseFunction(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Synonym`, `None` if the field is not set or
    /// holds a different branch.
    pub fn synonym(&self) -> std::option::Option<&std::boxed::Box<crate::model::SynonymEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Synonym(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Synonym`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_synonym<T: std::convert::Into<std::boxed::Box<crate::model::SynonymEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Synonym(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabasePackage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_package(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PackageEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabasePackage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabasePackage`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_package<
        T: std::convert::Into<std::boxed::Box<crate::model::PackageEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabasePackage(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Udt`, `None` if the field is not set or
    /// holds a different branch.
    pub fn udt(&self) -> std::option::Option<&std::boxed::Box<crate::model::UDTEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Udt(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Udt`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_udt<T: std::convert::Into<std::boxed::Box<crate::model::UDTEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Udt(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `MaterializedView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn materialized_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaterializedViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::MaterializedView(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `MaterializedView`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_materialized_view<
        T: std::convert::Into<std::boxed::Box<crate::model::MaterializedViewEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::MaterializedView(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __short_name,
            __parent_entity,
            __tree,
            __entity_type,
            __mappings,
            __entity_ddl,
            __issues,
            __database,
            __schema,
            __table,
            __view,
            __sequence,
            __stored_procedure,
            __database_function,
            __synonym,
            __database_package,
            __udt,
            __materialized_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "shortName" => Ok(__FieldTag::__short_name),
                            "short_name" => Ok(__FieldTag::__short_name),
                            "parentEntity" => Ok(__FieldTag::__parent_entity),
                            "parent_entity" => Ok(__FieldTag::__parent_entity),
                            "tree" => Ok(__FieldTag::__tree),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "mappings" => Ok(__FieldTag::__mappings),
                            "entityDdl" => Ok(__FieldTag::__entity_ddl),
                            "entity_ddl" => Ok(__FieldTag::__entity_ddl),
                            "issues" => Ok(__FieldTag::__issues),
                            "database" => Ok(__FieldTag::__database),
                            "schema" => Ok(__FieldTag::__schema),
                            "table" => Ok(__FieldTag::__table),
                            "view" => Ok(__FieldTag::__view),
                            "sequence" => Ok(__FieldTag::__sequence),
                            "storedProcedure" => Ok(__FieldTag::__stored_procedure),
                            "stored_procedure" => Ok(__FieldTag::__stored_procedure),
                            "databaseFunction" => Ok(__FieldTag::__database_function),
                            "database_function" => Ok(__FieldTag::__database_function),
                            "synonym" => Ok(__FieldTag::__synonym),
                            "databasePackage" => Ok(__FieldTag::__database_package),
                            "database_package" => Ok(__FieldTag::__database_package),
                            "udt" => Ok(__FieldTag::__udt),
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__short_name => {
                            if !fields.insert(__FieldTag::__short_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for short_name",
                                ));
                            }
                            result.short_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_entity => {
                            if !fields.insert(__FieldTag::__parent_entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_entity",
                                ));
                            }
                            result.parent_entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tree => {
                            if !fields.insert(__FieldTag::__tree) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tree",
                                ));
                            }
                            result.tree = map.next_value::<std::option::Option<crate::model::database_entity::TreeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mappings => {
                            if !fields.insert(__FieldTag::__mappings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mappings",
                                ));
                            }
                            result.mappings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityMapping>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entity_ddl => {
                            if !fields.insert(__FieldTag::__entity_ddl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_ddl",
                                ));
                            }
                            result.entity_ddl = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityDdl>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityIssue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.database, latest field was database",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Database(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DatabaseInstanceEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.schema, latest field was schema",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Schema(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SchemaEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.table, latest field was table",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Table(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TableEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.view, latest field was view",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::View(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ViewEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__sequence => {
                            if !fields.insert(__FieldTag::__sequence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sequence",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.sequence, latest field was sequence",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Sequence(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SequenceEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__stored_procedure => {
                            if !fields.insert(__FieldTag::__stored_procedure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stored_procedure",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.stored_procedure, latest field was storedProcedure",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::StoredProcedure(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StoredProcedureEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__database_function => {
                            if !fields.insert(__FieldTag::__database_function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_function",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.database_function, latest field was databaseFunction",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::DatabaseFunction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FunctionEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__synonym => {
                            if !fields.insert(__FieldTag::__synonym) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synonym",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.synonym, latest field was synonym",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Synonym(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SynonymEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__database_package => {
                            if !fields.insert(__FieldTag::__database_package) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_package",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.database_package, latest field was databasePackage",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::DatabasePackage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PackageEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__udt => {
                            if !fields.insert(__FieldTag::__udt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for udt",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.udt, latest field was udt",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::Udt(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::UDTEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            if result.entity_body.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_body`, a oneof with full ID .google.cloud.clouddms.v1.DatabaseEntity.materialized_view, latest field was materializedView",
                                ));
                            }
                            result.entity_body = std::option::Option::Some(
                                crate::model::database_entity::EntityBody::MaterializedView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MaterializedViewEntity>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.short_name.is_empty() {
            state.serialize_entry("shortName", &self.short_name)?;
        }
        if !self.parent_entity.is_empty() {
            state.serialize_entry("parentEntity", &self.parent_entity)?;
        }
        if !wkt::internal::is_default(&self.tree) {
            state.serialize_entry("tree", &self.tree)?;
        }
        if !wkt::internal::is_default(&self.entity_type) {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.mappings.is_empty() {
            state.serialize_entry("mappings", &self.mappings)?;
        }
        if !self.entity_ddl.is_empty() {
            state.serialize_entry("entityDdl", &self.entity_ddl)?;
        }
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if let Some(value) = self.database() {
            state.serialize_entry("database", value)?;
        }
        if let Some(value) = self.schema() {
            state.serialize_entry("schema", value)?;
        }
        if let Some(value) = self.table() {
            state.serialize_entry("table", value)?;
        }
        if let Some(value) = self.view() {
            state.serialize_entry("view", value)?;
        }
        if let Some(value) = self.sequence() {
            state.serialize_entry("sequence", value)?;
        }
        if let Some(value) = self.stored_procedure() {
            state.serialize_entry("storedProcedure", value)?;
        }
        if let Some(value) = self.database_function() {
            state.serialize_entry("databaseFunction", value)?;
        }
        if let Some(value) = self.synonym() {
            state.serialize_entry("synonym", value)?;
        }
        if let Some(value) = self.database_package() {
            state.serialize_entry("databasePackage", value)?;
        }
        if let Some(value) = self.udt() {
            state.serialize_entry("udt", value)?;
        }
        if let Some(value) = self.materialized_view() {
            state.serialize_entry("materializedView", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEntity");
        debug_struct.field("short_name", &self.short_name);
        debug_struct.field("parent_entity", &self.parent_entity);
        debug_struct.field("tree", &self.tree);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("mappings", &self.mappings);
        debug_struct.field("entity_ddl", &self.entity_ddl);
        debug_struct.field("issues", &self.issues);
        debug_struct.field("entity_body", &self.entity_body);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DatabaseEntity].
pub mod database_entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of database entities tree.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TreeType {
        /// Tree type unspecified.
        Unspecified,
        /// Tree of entities loaded from a source database.
        Source,
        /// Tree of entities converted from the source tree using the mapping rules.
        Draft,
        /// Tree of entities observed on the destination database.
        Destination,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TreeType::value] or
        /// [TreeType::name].
        UnknownValue(tree_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tree_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TreeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Source => std::option::Option::Some(1),
                Self::Draft => std::option::Option::Some(2),
                Self::Destination => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TREE_TYPE_UNSPECIFIED"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Destination => std::option::Option::Some("DESTINATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TreeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TreeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TreeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Source,
                2 => Self::Draft,
                3 => Self::Destination,
                _ => Self::UnknownValue(tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TreeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TREE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE" => Self::Source,
                "DRAFT" => Self::Draft,
                "DESTINATION" => Self::Destination,
                _ => Self::UnknownValue(tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TreeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Source => serializer.serialize_i32(1),
                Self::Draft => serializer.serialize_i32(2),
                Self::Destination => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TreeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TreeType>::new(
                ".google.cloud.clouddms.v1.DatabaseEntity.TreeType",
            ))
        }
    }

    /// The specific body for each entity type.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityBody {
        /// Database.
        Database(std::boxed::Box<crate::model::DatabaseInstanceEntity>),
        /// Schema.
        Schema(std::boxed::Box<crate::model::SchemaEntity>),
        /// Table.
        Table(std::boxed::Box<crate::model::TableEntity>),
        /// View.
        View(std::boxed::Box<crate::model::ViewEntity>),
        /// Sequence.
        Sequence(std::boxed::Box<crate::model::SequenceEntity>),
        /// Stored procedure.
        StoredProcedure(std::boxed::Box<crate::model::StoredProcedureEntity>),
        /// Function.
        DatabaseFunction(std::boxed::Box<crate::model::FunctionEntity>),
        /// Synonym.
        Synonym(std::boxed::Box<crate::model::SynonymEntity>),
        /// Package.
        DatabasePackage(std::boxed::Box<crate::model::PackageEntity>),
        /// UDT.
        Udt(std::boxed::Box<crate::model::UDTEntity>),
        /// Materialized view.
        MaterializedView(std::boxed::Box<crate::model::MaterializedViewEntity>),
    }
}

/// DatabaseInstance acts as a parent entity to other database entities.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseInstanceEntity {
    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseInstanceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::DatabaseInstanceEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::DatabaseInstanceEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatabaseInstanceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseInstanceEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseInstanceEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseInstanceEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseInstanceEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseInstanceEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseInstanceEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseInstanceEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseInstanceEntity");
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Schema typically has no parent entity, but can have a parent entity
/// DatabaseInstance (for database engines which support it).  For some database
/// engines, the terms  schema and user can be used interchangeably when they
/// refer to a namespace or a collection of other database entities. Can store
/// additional information which is schema specific.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchemaEntity {
    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::SchemaEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::SchemaEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SchemaEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SchemaEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchemaEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchemaEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchemaEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchemaEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchemaEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchemaEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchemaEntity");
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Table's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TableEntity {
    /// Table columns.
    pub columns: std::vec::Vec<crate::model::ColumnEntity>,

    /// Table constraints.
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,

    /// Table indices.
    pub indices: std::vec::Vec<crate::model::IndexEntity>,

    /// Table triggers.
    pub triggers: std::vec::Vec<crate::model::TriggerEntity>,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Comment associated with the table.
    pub comment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::TableEntity::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnEntity>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraints][crate::model::TableEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [indices][crate::model::TableEntity::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexEntity>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [triggers][crate::model::TableEntity::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TriggerEntity>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_features][crate::model::TableEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::TableEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [comment][crate::model::TableEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }
}

impl wkt::message::Message for TableEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TableEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TableEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __columns,
            __constraints,
            __indices,
            __triggers,
            __custom_features,
            __comment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TableEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "columns" => Ok(__FieldTag::__columns),
                            "constraints" => Ok(__FieldTag::__constraints),
                            "indices" => Ok(__FieldTag::__indices),
                            "triggers" => Ok(__FieldTag::__triggers),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            "comment" => Ok(__FieldTag::__comment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TableEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TableEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ColumnEntity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__constraints => {
                            if !fields.insert(__FieldTag::__constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraints",
                                ));
                            }
                            result.constraints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConstraintEntity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__indices => {
                            if !fields.insert(__FieldTag::__indices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indices",
                                ));
                            }
                            result.indices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::IndexEntity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__triggers => {
                            if !fields.insert(__FieldTag::__triggers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggers",
                                ));
                            }
                            result.triggers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TriggerEntity>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__comment => {
                            if !fields.insert(__FieldTag::__comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment",
                                ));
                            }
                            result.comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TableEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self.constraints.is_empty() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if !self.indices.is_empty() {
            state.serialize_entry("indices", &self.indices)?;
        }
        if !self.triggers.is_empty() {
            state.serialize_entry("triggers", &self.triggers)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self.comment.is_empty() {
            state.serialize_entry("comment", &self.comment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TableEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TableEntity");
        debug_struct.field("columns", &self.columns);
        debug_struct.field("constraints", &self.constraints);
        debug_struct.field("indices", &self.indices);
        debug_struct.field("triggers", &self.triggers);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("comment", &self.comment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Column is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnEntity {
    /// Column name.
    pub name: std::string::String,

    /// Column data type.
    pub data_type: std::string::String,

    /// Charset override - instead of table level charset.
    pub charset: std::string::String,

    /// Collation override - instead of table level collation.
    pub collation: std::string::String,

    /// Column length - e.g. varchar (50).
    pub length: i64,

    /// Column precision - when relevant.
    pub precision: i32,

    /// Column scale - when relevant.
    pub scale: i32,

    /// Column fractional second precision - used for timestamp based datatypes.
    pub fractional_seconds_precision: i32,

    /// Is the column of array type.
    pub array: bool,

    /// If the column is array, of which length.
    pub array_length: i32,

    /// Is the column nullable.
    pub nullable: bool,

    /// Is the column auto-generated/identity.
    pub auto_generated: bool,

    /// Is the column a UDT.
    pub udt: bool,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Specifies the list of values allowed in the column.
    /// Only used for set data type.
    pub set_values: std::vec::Vec<std::string::String>,

    /// Comment associated with the column.
    pub comment: std::string::String,

    /// Column order in the table.
    pub ordinal_position: i32,

    /// Default value of the column.
    pub default_value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::ColumnEntity::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::ColumnEntity::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::ColumnEntity::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::ColumnEntity::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::ColumnEntity::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::ColumnEntity::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::ColumnEntity::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::ColumnEntity::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::ColumnEntity::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::ColumnEntity::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::ColumnEntity::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::ColumnEntity::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ColumnEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::ColumnEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_values][crate::model::ColumnEntity::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [comment][crate::model::ColumnEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnEntity::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnEntity::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }
}

impl wkt::message::Message for ColumnEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ColumnEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __data_type,
            __charset,
            __collation,
            __length,
            __precision,
            __scale,
            __fractional_seconds_precision,
            __array,
            __array_length,
            __nullable,
            __auto_generated,
            __udt,
            __custom_features,
            __set_values,
            __comment,
            __ordinal_position,
            __default_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dataType" => Ok(__FieldTag::__data_type),
                            "data_type" => Ok(__FieldTag::__data_type),
                            "charset" => Ok(__FieldTag::__charset),
                            "collation" => Ok(__FieldTag::__collation),
                            "length" => Ok(__FieldTag::__length),
                            "precision" => Ok(__FieldTag::__precision),
                            "scale" => Ok(__FieldTag::__scale),
                            "fractionalSecondsPrecision" => {
                                Ok(__FieldTag::__fractional_seconds_precision)
                            }
                            "fractional_seconds_precision" => {
                                Ok(__FieldTag::__fractional_seconds_precision)
                            }
                            "array" => Ok(__FieldTag::__array),
                            "arrayLength" => Ok(__FieldTag::__array_length),
                            "array_length" => Ok(__FieldTag::__array_length),
                            "nullable" => Ok(__FieldTag::__nullable),
                            "autoGenerated" => Ok(__FieldTag::__auto_generated),
                            "auto_generated" => Ok(__FieldTag::__auto_generated),
                            "udt" => Ok(__FieldTag::__udt),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            "setValues" => Ok(__FieldTag::__set_values),
                            "set_values" => Ok(__FieldTag::__set_values),
                            "comment" => Ok(__FieldTag::__comment),
                            "ordinalPosition" => Ok(__FieldTag::__ordinal_position),
                            "ordinal_position" => Ok(__FieldTag::__ordinal_position),
                            "defaultValue" => Ok(__FieldTag::__default_value),
                            "default_value" => Ok(__FieldTag::__default_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_type => {
                            if !fields.insert(__FieldTag::__data_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_type",
                                ));
                            }
                            result.data_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__charset => {
                            if !fields.insert(__FieldTag::__charset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for charset",
                                ));
                            }
                            result.charset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collation => {
                            if !fields.insert(__FieldTag::__collation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collation",
                                ));
                            }
                            result.collation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__length => {
                            if !fields.insert(__FieldTag::__length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for length",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__precision => {
                            if !fields.insert(__FieldTag::__precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precision = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale => {
                            if !fields.insert(__FieldTag::__scale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__fractional_seconds_precision => {
                            if !fields.insert(__FieldTag::__fractional_seconds_precision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fractional_seconds_precision",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.fractional_seconds_precision =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__array => {
                            if !fields.insert(__FieldTag::__array) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array",
                                ));
                            }
                            result.array = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__array_length => {
                            if !fields.insert(__FieldTag::__array_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.array_length = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__nullable => {
                            if !fields.insert(__FieldTag::__nullable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nullable",
                                ));
                            }
                            result.nullable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_generated => {
                            if !fields.insert(__FieldTag::__auto_generated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_generated",
                                ));
                            }
                            result.auto_generated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__udt => {
                            if !fields.insert(__FieldTag::__udt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for udt",
                                ));
                            }
                            result.udt = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__set_values => {
                            if !fields.insert(__FieldTag::__set_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_values",
                                ));
                            }
                            result.set_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__comment => {
                            if !fields.insert(__FieldTag::__comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for comment",
                                ));
                            }
                            result.comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ordinal_position => {
                            if !fields.insert(__FieldTag::__ordinal_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ordinal_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ordinal_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__default_value => {
                            if !fields.insert(__FieldTag::__default_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_value",
                                ));
                            }
                            result.default_value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.data_type.is_empty() {
            state.serialize_entry("dataType", &self.data_type)?;
        }
        if !self.charset.is_empty() {
            state.serialize_entry("charset", &self.charset)?;
        }
        if !self.collation.is_empty() {
            state.serialize_entry("collation", &self.collation)?;
        }
        if !wkt::internal::is_default(&self.length) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("length", &__With(&self.length))?;
        }
        if !wkt::internal::is_default(&self.precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("precision", &__With(&self.precision))?;
        }
        if !wkt::internal::is_default(&self.scale) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scale", &__With(&self.scale))?;
        }
        if !wkt::internal::is_default(&self.fractional_seconds_precision) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "fractionalSecondsPrecision",
                &__With(&self.fractional_seconds_precision),
            )?;
        }
        if !wkt::internal::is_default(&self.array) {
            state.serialize_entry("array", &self.array)?;
        }
        if !wkt::internal::is_default(&self.array_length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("arrayLength", &__With(&self.array_length))?;
        }
        if !wkt::internal::is_default(&self.nullable) {
            state.serialize_entry("nullable", &self.nullable)?;
        }
        if !wkt::internal::is_default(&self.auto_generated) {
            state.serialize_entry("autoGenerated", &self.auto_generated)?;
        }
        if !wkt::internal::is_default(&self.udt) {
            state.serialize_entry("udt", &self.udt)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self.set_values.is_empty() {
            state.serialize_entry("setValues", &self.set_values)?;
        }
        if !self.comment.is_empty() {
            state.serialize_entry("comment", &self.comment)?;
        }
        if !wkt::internal::is_default(&self.ordinal_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ordinalPosition", &__With(&self.ordinal_position))?;
        }
        if !self.default_value.is_empty() {
            state.serialize_entry("defaultValue", &self.default_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ColumnEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColumnEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("data_type", &self.data_type);
        debug_struct.field("charset", &self.charset);
        debug_struct.field("collation", &self.collation);
        debug_struct.field("length", &self.length);
        debug_struct.field("precision", &self.precision);
        debug_struct.field("scale", &self.scale);
        debug_struct.field(
            "fractional_seconds_precision",
            &self.fractional_seconds_precision,
        );
        debug_struct.field("array", &self.array);
        debug_struct.field("array_length", &self.array_length);
        debug_struct.field("nullable", &self.nullable);
        debug_struct.field("auto_generated", &self.auto_generated);
        debug_struct.field("udt", &self.udt);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("set_values", &self.set_values);
        debug_struct.field("comment", &self.comment);
        debug_struct.field("ordinal_position", &self.ordinal_position);
        debug_struct.field("default_value", &self.default_value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Constraint is not used as an independent entity, it is retrieved
/// as part of another entity such as Table or View.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConstraintEntity {
    /// The name of the table constraint.
    pub name: std::string::String,

    /// Type of constraint, for example unique, primary key, foreign key (currently
    /// only primary key is supported).
    pub r#type: std::string::String,

    /// Table columns used as part of the Constraint, for example primary key
    /// constraint should list the columns which constitutes the key.
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Reference columns which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full names
    /// of referenced columns by the foreign key.
    pub reference_columns: std::vec::Vec<std::string::String>,

    /// Reference table which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full name
    /// of the referenced table by the foreign key.
    pub reference_table: std::string::String,

    /// Table which is associated with the constraint. In case the constraint
    /// is defined on a table, this field is left empty as this information is
    /// stored in parent_name. However, if constraint is defined on a view, this
    /// field stores the table name on which the view is defined.
    pub table_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConstraintEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConstraintEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ConstraintEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::ConstraintEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_features][crate::model::ConstraintEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::ConstraintEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reference_columns][crate::model::ConstraintEntity::reference_columns].
    pub fn set_reference_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reference_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reference_table][crate::model::ConstraintEntity::reference_table].
    pub fn set_reference_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_table = v.into();
        self
    }

    /// Sets the value of [table_name][crate::model::ConstraintEntity::table_name].
    pub fn set_table_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_name = v.into();
        self
    }
}

impl wkt::message::Message for ConstraintEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConstraintEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConstraintEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __table_columns,
            __custom_features,
            __reference_columns,
            __reference_table,
            __table_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConstraintEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "tableColumns" => Ok(__FieldTag::__table_columns),
                            "table_columns" => Ok(__FieldTag::__table_columns),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            "referenceColumns" => Ok(__FieldTag::__reference_columns),
                            "reference_columns" => Ok(__FieldTag::__reference_columns),
                            "referenceTable" => Ok(__FieldTag::__reference_table),
                            "reference_table" => Ok(__FieldTag::__reference_table),
                            "tableName" => Ok(__FieldTag::__table_name),
                            "table_name" => Ok(__FieldTag::__table_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConstraintEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConstraintEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_columns => {
                            if !fields.insert(__FieldTag::__table_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_columns",
                                ));
                            }
                            result.table_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__reference_columns => {
                            if !fields.insert(__FieldTag::__reference_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_columns",
                                ));
                            }
                            result.reference_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reference_table => {
                            if !fields.insert(__FieldTag::__reference_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_table",
                                ));
                            }
                            result.reference_table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_name => {
                            if !fields.insert(__FieldTag::__table_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_name",
                                ));
                            }
                            result.table_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConstraintEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.table_columns.is_empty() {
            state.serialize_entry("tableColumns", &self.table_columns)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self.reference_columns.is_empty() {
            state.serialize_entry("referenceColumns", &self.reference_columns)?;
        }
        if !self.reference_table.is_empty() {
            state.serialize_entry("referenceTable", &self.reference_table)?;
        }
        if !self.table_name.is_empty() {
            state.serialize_entry("tableName", &self.table_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConstraintEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConstraintEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("table_columns", &self.table_columns);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("reference_columns", &self.reference_columns);
        debug_struct.field("reference_table", &self.reference_table);
        debug_struct.field("table_name", &self.table_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Index is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IndexEntity {
    /// The name of the index.
    pub name: std::string::String,

    /// Type of index, for example B-TREE.
    pub r#type: std::string::String,

    /// Table columns used as part of the Index, for example B-TREE index should
    /// list the columns which constitutes the index.
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Boolean value indicating whether the index is unique.
    pub unique: bool,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IndexEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::IndexEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::IndexEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unique][crate::model::IndexEntity::unique].
    pub fn set_unique<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::IndexEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::IndexEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IndexEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IndexEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IndexEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __table_columns,
            __unique,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IndexEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "tableColumns" => Ok(__FieldTag::__table_columns),
                            "table_columns" => Ok(__FieldTag::__table_columns),
                            "unique" => Ok(__FieldTag::__unique),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IndexEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IndexEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_columns => {
                            if !fields.insert(__FieldTag::__table_columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_columns",
                                ));
                            }
                            result.table_columns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__unique => {
                            if !fields.insert(__FieldTag::__unique) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unique",
                                ));
                            }
                            result.unique = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IndexEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.table_columns.is_empty() {
            state.serialize_entry("tableColumns", &self.table_columns)?;
        }
        if !wkt::internal::is_default(&self.unique) {
            state.serialize_entry("unique", &self.unique)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IndexEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IndexEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("table_columns", &self.table_columns);
        debug_struct.field("unique", &self.unique);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Trigger is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TriggerEntity {
    /// The name of the trigger.
    pub name: std::string::String,

    /// The DML, DDL, or database events that fire the trigger, for example
    /// INSERT, UPDATE.
    pub triggering_events: std::vec::Vec<std::string::String>,

    /// Indicates when the trigger fires, for example BEFORE STATEMENT, AFTER EACH
    /// ROW.
    pub trigger_type: std::string::String,

    /// The SQL code which creates the trigger.
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TriggerEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TriggerEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [triggering_events][crate::model::TriggerEntity::triggering_events].
    pub fn set_triggering_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.triggering_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trigger_type][crate::model::TriggerEntity::trigger_type].
    pub fn set_trigger_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_type = v.into();
        self
    }

    /// Sets the value of [sql_code][crate::model::TriggerEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::TriggerEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::TriggerEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TriggerEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TriggerEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TriggerEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __triggering_events,
            __trigger_type,
            __sql_code,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TriggerEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "triggeringEvents" => Ok(__FieldTag::__triggering_events),
                            "triggering_events" => Ok(__FieldTag::__triggering_events),
                            "triggerType" => Ok(__FieldTag::__trigger_type),
                            "trigger_type" => Ok(__FieldTag::__trigger_type),
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TriggerEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TriggerEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__triggering_events => {
                            if !fields.insert(__FieldTag::__triggering_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for triggering_events",
                                ));
                            }
                            result.triggering_events = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__trigger_type => {
                            if !fields.insert(__FieldTag::__trigger_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_type",
                                ));
                            }
                            result.trigger_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TriggerEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.triggering_events.is_empty() {
            state.serialize_entry("triggeringEvents", &self.triggering_events)?;
        }
        if !self.trigger_type.is_empty() {
            state.serialize_entry("triggerType", &self.trigger_type)?;
        }
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TriggerEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TriggerEntity");
        debug_struct.field("name", &self.name);
        debug_struct.field("triggering_events", &self.triggering_events);
        debug_struct.field("trigger_type", &self.trigger_type);
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// View's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ViewEntity {
    /// The SQL code which creates the view.
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    /// View constraints.
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::ViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ViewEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::ViewEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [constraints][crate::model::ViewEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ViewEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ViewEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_code,
            __custom_features,
            __constraints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ViewEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            "constraints" => Ok(__FieldTag::__constraints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ViewEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ViewEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__constraints => {
                            if !fields.insert(__FieldTag::__constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraints",
                                ));
                            }
                            result.constraints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConstraintEntity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ViewEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self.constraints.is_empty() {
            state.serialize_entry("constraints", &self.constraints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ViewEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ViewEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);
        debug_struct.field("constraints", &self.constraints);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Sequence's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SequenceEntity {
    /// Increment value for the sequence.
    pub increment: i64,

    /// Start number for the sequence represented as bytes to accommodate large.
    /// numbers
    pub start_value: ::bytes::Bytes,

    /// Maximum number for the sequence represented as bytes to accommodate large.
    /// numbers
    pub max_value: ::bytes::Bytes,

    /// Minimum number for the sequence represented as bytes to accommodate large.
    /// numbers
    pub min_value: ::bytes::Bytes,

    /// Indicates whether the sequence value should cycle through.
    pub cycle: bool,

    /// Indicates number of entries to cache / precreate.
    pub cache: i64,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SequenceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [increment][crate::model::SequenceEntity::increment].
    pub fn set_increment<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.increment = v.into();
        self
    }

    /// Sets the value of [start_value][crate::model::SequenceEntity::start_value].
    pub fn set_start_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.start_value = v.into();
        self
    }

    /// Sets the value of [max_value][crate::model::SequenceEntity::max_value].
    pub fn set_max_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.max_value = v.into();
        self
    }

    /// Sets the value of [min_value][crate::model::SequenceEntity::min_value].
    pub fn set_min_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.min_value = v.into();
        self
    }

    /// Sets the value of [cycle][crate::model::SequenceEntity::cycle].
    pub fn set_cycle<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cycle = v.into();
        self
    }

    /// Sets the value of [cache][crate::model::SequenceEntity::cache].
    pub fn set_cache<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cache = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SequenceEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::SequenceEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SequenceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SequenceEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SequenceEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __increment,
            __start_value,
            __max_value,
            __min_value,
            __cycle,
            __cache,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SequenceEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "increment" => Ok(__FieldTag::__increment),
                            "startValue" => Ok(__FieldTag::__start_value),
                            "start_value" => Ok(__FieldTag::__start_value),
                            "maxValue" => Ok(__FieldTag::__max_value),
                            "max_value" => Ok(__FieldTag::__max_value),
                            "minValue" => Ok(__FieldTag::__min_value),
                            "min_value" => Ok(__FieldTag::__min_value),
                            "cycle" => Ok(__FieldTag::__cycle),
                            "cache" => Ok(__FieldTag::__cache),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SequenceEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SequenceEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__increment => {
                            if !fields.insert(__FieldTag::__increment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for increment",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.increment = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_value => {
                            if !fields.insert(__FieldTag::__start_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.start_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_value => {
                            if !fields.insert(__FieldTag::__max_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_value => {
                            if !fields.insert(__FieldTag::__min_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cycle => {
                            if !fields.insert(__FieldTag::__cycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cycle",
                                ));
                            }
                            result.cycle = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cache => {
                            if !fields.insert(__FieldTag::__cache) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cache = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SequenceEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.increment) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("increment", &__With(&self.increment))?;
        }
        if !self.start_value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("startValue", &__With(&self.start_value))?;
        }
        if !self.max_value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxValue", &__With(&self.max_value))?;
        }
        if !self.min_value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minValue", &__With(&self.min_value))?;
        }
        if !wkt::internal::is_default(&self.cycle) {
            state.serialize_entry("cycle", &self.cycle)?;
        }
        if !wkt::internal::is_default(&self.cache) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cache", &__With(&self.cache))?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SequenceEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SequenceEntity");
        debug_struct.field("increment", &self.increment);
        debug_struct.field("start_value", &self.start_value);
        debug_struct.field("max_value", &self.max_value);
        debug_struct.field("min_value", &self.min_value);
        debug_struct.field("cycle", &self.cycle);
        debug_struct.field("cache", &self.cache);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Stored procedure's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StoredProcedureEntity {
    /// The SQL code which creates the stored procedure.
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredProcedureEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::StoredProcedureEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::StoredProcedureEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::StoredProcedureEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StoredProcedureEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StoredProcedureEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StoredProcedureEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_code,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StoredProcedureEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StoredProcedureEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StoredProcedureEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StoredProcedureEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StoredProcedureEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StoredProcedureEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Function's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FunctionEntity {
    /// The SQL code which creates the function.
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FunctionEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::FunctionEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::FunctionEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::FunctionEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for FunctionEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FunctionEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FunctionEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_code,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FunctionEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FunctionEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FunctionEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FunctionEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FunctionEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FunctionEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MaterializedView's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaterializedViewEntity {
    /// The SQL code which creates the view.
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaterializedViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::MaterializedViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MaterializedViewEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::MaterializedViewEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaterializedViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MaterializedViewEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaterializedViewEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sql_code,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedViewEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sqlCode" => Ok(__FieldTag::__sql_code),
                            "sql_code" => Ok(__FieldTag::__sql_code),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaterializedViewEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedViewEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sql_code => {
                            if !fields.insert(__FieldTag::__sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sql_code",
                                ));
                            }
                            result.sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaterializedViewEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sql_code.is_empty() {
            state.serialize_entry("sqlCode", &self.sql_code)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaterializedViewEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaterializedViewEntity");
        debug_struct.field("sql_code", &self.sql_code);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Synonym's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SynonymEntity {
    /// The name of the entity for which the synonym is being created (the source).
    pub source_entity: std::string::String,

    /// The type of the entity for which the synonym is being created
    /// (usually a table or a sequence).
    pub source_type: crate::model::DatabaseEntityType,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynonymEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::SynonymEntity::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::SynonymEntity::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SynonymEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::SynonymEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SynonymEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SynonymEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynonymEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_entity,
            __source_type,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynonymEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceEntity" => Ok(__FieldTag::__source_entity),
                            "source_entity" => Ok(__FieldTag::__source_entity),
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynonymEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynonymEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_entity => {
                            if !fields.insert(__FieldTag::__source_entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_entity",
                                ));
                            }
                            result.source_entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynonymEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_entity.is_empty() {
            state.serialize_entry("sourceEntity", &self.source_entity)?;
        }
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SynonymEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SynonymEntity");
        debug_struct.field("source_entity", &self.source_entity);
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Package's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PackageEntity {
    /// The SQL code which creates the package.
    pub package_sql_code: std::string::String,

    /// The SQL code which creates the package body. If the package specification
    /// has cursors or subprograms, then the package body is mandatory.
    pub package_body: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_sql_code][crate::model::PackageEntity::package_sql_code].
    pub fn set_package_sql_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_sql_code = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::PackageEntity::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::PackageEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::PackageEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PackageEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PackageEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PackageEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __package_sql_code,
            __package_body,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PackageEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "packageSqlCode" => Ok(__FieldTag::__package_sql_code),
                            "package_sql_code" => Ok(__FieldTag::__package_sql_code),
                            "packageBody" => Ok(__FieldTag::__package_body),
                            "package_body" => Ok(__FieldTag::__package_body),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PackageEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PackageEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__package_sql_code => {
                            if !fields.insert(__FieldTag::__package_sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_sql_code",
                                ));
                            }
                            result.package_sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__package_body => {
                            if !fields.insert(__FieldTag::__package_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for package_body",
                                ));
                            }
                            result.package_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PackageEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.package_sql_code.is_empty() {
            state.serialize_entry("packageSqlCode", &self.package_sql_code)?;
        }
        if !self.package_body.is_empty() {
            state.serialize_entry("packageBody", &self.package_body)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PackageEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PackageEntity");
        debug_struct.field("package_sql_code", &self.package_sql_code);
        debug_struct.field("package_body", &self.package_body);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UDT's parent is a schema.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UDTEntity {
    /// The SQL code which creates the udt.
    pub udt_sql_code: std::string::String,

    /// The SQL code which creates the udt body.
    pub udt_body: std::string::String,

    /// Custom engine specific features.
    pub custom_features: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UDTEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [udt_sql_code][crate::model::UDTEntity::udt_sql_code].
    pub fn set_udt_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_sql_code = v.into();
        self
    }

    /// Sets the value of [udt_body][crate::model::UDTEntity::udt_body].
    pub fn set_udt_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::UDTEntity::custom_features].
    pub fn set_custom_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_features][crate::model::UDTEntity::custom_features].
    pub fn set_or_clear_custom_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.custom_features = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UDTEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UDTEntity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UDTEntity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __udt_sql_code,
            __udt_body,
            __custom_features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UDTEntity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "udtSqlCode" => Ok(__FieldTag::__udt_sql_code),
                            "udt_sql_code" => Ok(__FieldTag::__udt_sql_code),
                            "udtBody" => Ok(__FieldTag::__udt_body),
                            "udt_body" => Ok(__FieldTag::__udt_body),
                            "customFeatures" => Ok(__FieldTag::__custom_features),
                            "custom_features" => Ok(__FieldTag::__custom_features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UDTEntity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UDTEntity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__udt_sql_code => {
                            if !fields.insert(__FieldTag::__udt_sql_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for udt_sql_code",
                                ));
                            }
                            result.udt_sql_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__udt_body => {
                            if !fields.insert(__FieldTag::__udt_body) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for udt_body",
                                ));
                            }
                            result.udt_body = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_features => {
                            if !fields.insert(__FieldTag::__custom_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_features",
                                ));
                            }
                            result.custom_features =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UDTEntity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.udt_sql_code.is_empty() {
            state.serialize_entry("udtSqlCode", &self.udt_sql_code)?;
        }
        if !self.udt_body.is_empty() {
            state.serialize_entry("udtBody", &self.udt_body)?;
        }
        if self.custom_features.is_some() {
            state.serialize_entry("customFeatures", &self.custom_features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UDTEntity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UDTEntity");
        debug_struct.field("udt_sql_code", &self.udt_sql_code);
        debug_struct.field("udt_body", &self.udt_body);
        debug_struct.field("custom_features", &self.custom_features);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of the mappings of a database entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityMapping {
    /// Source entity full name.
    /// The source entity can also be a column, index or constraint using the
    /// same naming notation schema.table.column.
    pub source_entity: std::string::String,

    /// Target entity full name.
    /// The draft entity can also include a column, index or constraint using the
    /// same naming notation schema.table.column.
    pub draft_entity: std::string::String,

    /// Type of source entity.
    pub source_type: crate::model::DatabaseEntityType,

    /// Type of draft entity.
    pub draft_type: crate::model::DatabaseEntityType,

    /// Entity mapping log entries.
    /// Multiple rules can be effective and contribute changes to a converted
    /// entity, such as a rule can handle the entity name, another rule can handle
    /// an entity type. In addition, rules which did not change the entity are also
    /// logged along with the reason preventing them to do so.
    pub mapping_log: std::vec::Vec<crate::model::EntityMappingLogEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::EntityMapping::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [draft_entity][crate::model::EntityMapping::draft_entity].
    pub fn set_draft_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.draft_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::EntityMapping::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [draft_type][crate::model::EntityMapping::draft_type].
    pub fn set_draft_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.draft_type = v.into();
        self
    }

    /// Sets the value of [mapping_log][crate::model::EntityMapping::mapping_log].
    pub fn set_mapping_log<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMappingLogEntry>,
    {
        use std::iter::Iterator;
        self.mapping_log = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMapping"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityMapping {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_entity,
            __draft_entity,
            __source_type,
            __draft_type,
            __mapping_log,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityMapping")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceEntity" => Ok(__FieldTag::__source_entity),
                            "source_entity" => Ok(__FieldTag::__source_entity),
                            "draftEntity" => Ok(__FieldTag::__draft_entity),
                            "draft_entity" => Ok(__FieldTag::__draft_entity),
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "draftType" => Ok(__FieldTag::__draft_type),
                            "draft_type" => Ok(__FieldTag::__draft_type),
                            "mappingLog" => Ok(__FieldTag::__mapping_log),
                            "mapping_log" => Ok(__FieldTag::__mapping_log),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityMapping;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityMapping")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_entity => {
                            if !fields.insert(__FieldTag::__source_entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_entity",
                                ));
                            }
                            result.source_entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__draft_entity => {
                            if !fields.insert(__FieldTag::__draft_entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for draft_entity",
                                ));
                            }
                            result.draft_entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__draft_type => {
                            if !fields.insert(__FieldTag::__draft_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for draft_type",
                                ));
                            }
                            result.draft_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mapping_log => {
                            if !fields.insert(__FieldTag::__mapping_log) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping_log",
                                ));
                            }
                            result.mapping_log = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EntityMappingLogEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityMapping {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source_entity.is_empty() {
            state.serialize_entry("sourceEntity", &self.source_entity)?;
        }
        if !self.draft_entity.is_empty() {
            state.serialize_entry("draftEntity", &self.draft_entity)?;
        }
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if !wkt::internal::is_default(&self.draft_type) {
            state.serialize_entry("draftType", &self.draft_type)?;
        }
        if !self.mapping_log.is_empty() {
            state.serialize_entry("mappingLog", &self.mapping_log)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityMapping {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMapping");
        debug_struct.field("source_entity", &self.source_entity);
        debug_struct.field("draft_entity", &self.draft_entity);
        debug_struct.field("source_type", &self.source_type);
        debug_struct.field("draft_type", &self.draft_type);
        debug_struct.field("mapping_log", &self.mapping_log);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A single record of a rule which was used for a mapping.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityMappingLogEntry {
    /// Which rule caused this log entry.
    pub rule_id: std::string::String,

    /// Rule revision ID.
    pub rule_revision_id: std::string::String,

    /// Comment.
    pub mapping_comment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMappingLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::EntityMappingLogEntry::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [rule_revision_id][crate::model::EntityMappingLogEntry::rule_revision_id].
    pub fn set_rule_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_revision_id = v.into();
        self
    }

    /// Sets the value of [mapping_comment][crate::model::EntityMappingLogEntry::mapping_comment].
    pub fn set_mapping_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_comment = v.into();
        self
    }
}

impl wkt::message::Message for EntityMappingLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMappingLogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityMappingLogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule_id,
            __rule_revision_id,
            __mapping_comment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityMappingLogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ruleId" => Ok(__FieldTag::__rule_id),
                            "rule_id" => Ok(__FieldTag::__rule_id),
                            "ruleRevisionId" => Ok(__FieldTag::__rule_revision_id),
                            "rule_revision_id" => Ok(__FieldTag::__rule_revision_id),
                            "mappingComment" => Ok(__FieldTag::__mapping_comment),
                            "mapping_comment" => Ok(__FieldTag::__mapping_comment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityMappingLogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityMappingLogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule_id => {
                            if !fields.insert(__FieldTag::__rule_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_id",
                                ));
                            }
                            result.rule_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rule_revision_id => {
                            if !fields.insert(__FieldTag::__rule_revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule_revision_id",
                                ));
                            }
                            result.rule_revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mapping_comment => {
                            if !fields.insert(__FieldTag::__mapping_comment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mapping_comment",
                                ));
                            }
                            result.mapping_comment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityMappingLogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rule_id.is_empty() {
            state.serialize_entry("ruleId", &self.rule_id)?;
        }
        if !self.rule_revision_id.is_empty() {
            state.serialize_entry("ruleRevisionId", &self.rule_revision_id)?;
        }
        if !self.mapping_comment.is_empty() {
            state.serialize_entry("mappingComment", &self.mapping_comment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityMappingLogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityMappingLogEntry");
        debug_struct.field("rule_id", &self.rule_id);
        debug_struct.field("rule_revision_id", &self.rule_revision_id);
        debug_struct.field("mapping_comment", &self.mapping_comment);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A single DDL statement for a specific entity
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityDdl {
    /// Type of DDL (Create, Alter).
    pub ddl_type: std::string::String,

    /// The name of the database entity the ddl refers to.
    pub entity: std::string::String,

    /// The actual ddl code.
    pub ddl: std::string::String,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,

    /// EntityIssues found for this ddl.
    pub issue_id: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityDdl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ddl_type][crate::model::EntityDdl::ddl_type].
    pub fn set_ddl_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl_type = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::EntityDdl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityDdl::ddl].
    pub fn set_ddl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityDdl::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [issue_id][crate::model::EntityDdl::issue_id].
    pub fn set_issue_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.issue_id = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityDdl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityDdl"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityDdl {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ddl_type,
            __entity,
            __ddl,
            __entity_type,
            __issue_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityDdl")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ddlType" => Ok(__FieldTag::__ddl_type),
                            "ddl_type" => Ok(__FieldTag::__ddl_type),
                            "entity" => Ok(__FieldTag::__entity),
                            "ddl" => Ok(__FieldTag::__ddl),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "issueId" => Ok(__FieldTag::__issue_id),
                            "issue_id" => Ok(__FieldTag::__issue_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityDdl;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityDdl")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ddl_type => {
                            if !fields.insert(__FieldTag::__ddl_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl_type",
                                ));
                            }
                            result.ddl_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ddl => {
                            if !fields.insert(__FieldTag::__ddl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl",
                                ));
                            }
                            result.ddl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__issue_id => {
                            if !fields.insert(__FieldTag::__issue_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_id",
                                ));
                            }
                            result.issue_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityDdl {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ddl_type.is_empty() {
            state.serialize_entry("ddlType", &self.ddl_type)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self.ddl.is_empty() {
            state.serialize_entry("ddl", &self.ddl)?;
        }
        if !wkt::internal::is_default(&self.entity_type) {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.issue_id.is_empty() {
            state.serialize_entry("issueId", &self.issue_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityDdl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityDdl");
        debug_struct.field("ddl_type", &self.ddl_type);
        debug_struct.field("entity", &self.entity);
        debug_struct.field("ddl", &self.ddl);
        debug_struct.field("entity_type", &self.entity_type);
        debug_struct.field("issue_id", &self.issue_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Issue related to the entity.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityIssue {
    /// Unique Issue ID.
    pub id: std::string::String,

    /// The type of the issue.
    pub r#type: crate::model::entity_issue::IssueType,

    /// Severity of the issue
    pub severity: crate::model::entity_issue::IssueSeverity,

    /// Issue detailed message
    pub message: std::string::String,

    /// Error/Warning code
    pub code: std::string::String,

    /// The ddl which caused the issue, if relevant.
    pub ddl: std::option::Option<std::string::String>,

    /// The position of the issue found, if relevant.
    pub position: std::option::Option<crate::model::entity_issue::Position>,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityIssue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EntityIssue::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityIssue::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_issue::IssueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::EntityIssue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::entity_issue::IssueSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [message][crate::model::EntityIssue::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [code][crate::model::EntityIssue::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityIssue::ddl].
    pub fn set_ddl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ddl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ddl][crate::model::EntityIssue::ddl].
    pub fn set_or_clear_ddl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ddl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [position][crate::model::EntityIssue::position].
    pub fn set_position<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::entity_issue::Position>,
    {
        self.position = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [position][crate::model::EntityIssue::position].
    pub fn set_or_clear_position<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::entity_issue::Position>,
    {
        self.position = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityIssue::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }
}

impl wkt::message::Message for EntityIssue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityIssue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __type,
            __severity,
            __message,
            __code,
            __ddl,
            __position,
            __entity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityIssue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "type" => Ok(__FieldTag::__type),
                            "severity" => Ok(__FieldTag::__severity),
                            "message" => Ok(__FieldTag::__message),
                            "code" => Ok(__FieldTag::__code),
                            "ddl" => Ok(__FieldTag::__ddl),
                            "position" => Ok(__FieldTag::__position),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityIssue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityIssue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::entity_issue::IssueType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::entity_issue::IssueSeverity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ddl => {
                            if !fields.insert(__FieldTag::__ddl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ddl",
                                ));
                            }
                            result.ddl =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__position => {
                            if !fields.insert(__FieldTag::__position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for position",
                                ));
                            }
                            result.position = map.next_value::<std::option::Option<crate::model::entity_issue::Position>>()?
                                ;
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type = map.next_value::<std::option::Option<crate::model::DatabaseEntityType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityIssue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.code.is_empty() {
            state.serialize_entry("code", &self.code)?;
        }
        if self.ddl.is_some() {
            state.serialize_entry("ddl", &self.ddl)?;
        }
        if self.position.is_some() {
            state.serialize_entry("position", &self.position)?;
        }
        if !wkt::internal::is_default(&self.entity_type) {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityIssue");
        debug_struct.field("id", &self.id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("message", &self.message);
        debug_struct.field("code", &self.code);
        debug_struct.field("ddl", &self.ddl);
        debug_struct.field("position", &self.position);
        debug_struct.field("entity_type", &self.entity_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EntityIssue].
pub mod entity_issue {
    #[allow(unused_imports)]
    use super::*;

    /// Issue position.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Position {
        /// Issue line number
        pub line: i32,

        /// Issue column number
        pub column: i32,

        /// Issue offset
        pub offset: i32,

        /// Issue length
        pub length: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Position {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line][crate::model::entity_issue::Position::line].
        pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line = v.into();
            self
        }

        /// Sets the value of [column][crate::model::entity_issue::Position::column].
        pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [offset][crate::model::entity_issue::Position::offset].
        pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset = v.into();
            self
        }

        /// Sets the value of [length][crate::model::entity_issue::Position::length].
        pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.length = v.into();
            self
        }
    }

    impl wkt::message::Message for Position {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue.Position"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Position {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __line,
                __column,
                __offset,
                __length,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Position")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "line" => Ok(__FieldTag::__line),
                                "column" => Ok(__FieldTag::__column),
                                "offset" => Ok(__FieldTag::__offset),
                                "length" => Ok(__FieldTag::__length),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Position;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Position")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__line => {
                                if !fields.insert(__FieldTag::__line) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for line",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__column => {
                                if !fields.insert(__FieldTag::__column) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.column = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__offset => {
                                if !fields.insert(__FieldTag::__offset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for offset",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__length => {
                                if !fields.insert(__FieldTag::__length) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for length",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.length = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Position {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.line) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("line", &__With(&self.line))?;
            }
            if !wkt::internal::is_default(&self.column) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("column", &__With(&self.column))?;
            }
            if !wkt::internal::is_default(&self.offset) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("offset", &__With(&self.offset))?;
            }
            if !wkt::internal::is_default(&self.length) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("length", &__With(&self.length))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Position {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Position");
            debug_struct.field("line", &self.line);
            debug_struct.field("column", &self.column);
            debug_struct.field("offset", &self.offset);
            debug_struct.field("length", &self.length);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Type of issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueType {
        /// Unspecified issue type.
        Unspecified,
        /// Issue originated from the DDL
        Ddl,
        /// Issue originated during the apply process
        Apply,
        /// Issue originated during the convert process
        Convert,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueType::value] or
        /// [IssueType::name].
        UnknownValue(issue_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ddl => std::option::Option::Some(1),
                Self::Apply => std::option::Option::Some(2),
                Self::Convert => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ISSUE_TYPE_UNSPECIFIED"),
                Self::Ddl => std::option::Option::Some("ISSUE_TYPE_DDL"),
                Self::Apply => std::option::Option::Some("ISSUE_TYPE_APPLY"),
                Self::Convert => std::option::Option::Some("ISSUE_TYPE_CONVERT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ddl,
                2 => Self::Apply,
                3 => Self::Convert,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ISSUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ISSUE_TYPE_DDL" => Self::Ddl,
                "ISSUE_TYPE_APPLY" => Self::Apply,
                "ISSUE_TYPE_CONVERT" => Self::Convert,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ddl => serializer.serialize_i32(1),
                Self::Apply => serializer.serialize_i32(2),
                Self::Convert => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueType>::new(
                ".google.cloud.clouddms.v1.EntityIssue.IssueType",
            ))
        }
    }

    /// Severity of issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueSeverity {
        /// Unspecified issue severity
        Unspecified,
        /// Info
        Info,
        /// Warning
        Warning,
        /// Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueSeverity::value] or
        /// [IssueSeverity::name].
        UnknownValue(issue_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ISSUE_SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("ISSUE_SEVERITY_INFO"),
                Self::Warning => std::option::Option::Some("ISSUE_SEVERITY_WARNING"),
                Self::Error => std::option::Option::Some("ISSUE_SEVERITY_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(issue_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ISSUE_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ISSUE_SEVERITY_INFO" => Self::Info,
                "ISSUE_SEVERITY_WARNING" => Self::Warning,
                "ISSUE_SEVERITY_ERROR" => Self::Error,
                _ => Self::UnknownValue(issue_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueSeverity>::new(
                ".google.cloud.clouddms.v1.EntityIssue.IssueSeverity",
            ))
        }
    }
}

/// AIP-157 Partial Response view for Database Entity.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEntityView {
    /// Unspecified view. Defaults to basic view.
    Unspecified,
    /// Default view. Does not return DDLs or Issues.
    Basic,
    /// Return full entity details including mappings, ddl and issues.
    Full,
    /// Top-most (Database, Schema) nodes which are returned contains summary
    /// details for their decendents such as the number of entities per type and
    /// issues rollups. When this view is used, only a single page of result is
    /// returned and the page_size property of the request is ignored. The
    /// returned page will only include the top-most node types.
    RootSummary,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEntityView::value] or
    /// [DatabaseEntityView::name].
    UnknownValue(database_entity_view::UnknownValue),
}

#[doc(hidden)]
pub mod database_entity_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEntityView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::RootSummary => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENTITY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("DATABASE_ENTITY_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("DATABASE_ENTITY_VIEW_FULL"),
            Self::RootSummary => std::option::Option::Some("DATABASE_ENTITY_VIEW_ROOT_SUMMARY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEntityView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEntityView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEntityView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::RootSummary,
            _ => Self::UnknownValue(database_entity_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEntityView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "DATABASE_ENTITY_VIEW_BASIC" => Self::Basic,
            "DATABASE_ENTITY_VIEW_FULL" => Self::Full,
            "DATABASE_ENTITY_VIEW_ROOT_SUMMARY" => Self::RootSummary,
            _ => Self::UnknownValue(database_entity_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEntityView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::RootSummary => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEntityView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEntityView>::new(
            ".google.cloud.clouddms.v1.DatabaseEntityView",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NetworkArchitecture {
    Unspecified,
    /// Instance is in Cloud SQL's old producer network architecture.
    OldCsqlProducer,
    /// Instance is in Cloud SQL's new producer network architecture.
    NewCsqlProducer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NetworkArchitecture::value] or
    /// [NetworkArchitecture::name].
    UnknownValue(network_architecture::UnknownValue),
}

#[doc(hidden)]
pub mod network_architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NetworkArchitecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::OldCsqlProducer => std::option::Option::Some(1),
            Self::NewCsqlProducer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NETWORK_ARCHITECTURE_UNSPECIFIED"),
            Self::OldCsqlProducer => {
                std::option::Option::Some("NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER")
            }
            Self::NewCsqlProducer => {
                std::option::Option::Some("NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NetworkArchitecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NetworkArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NetworkArchitecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::OldCsqlProducer,
            2 => Self::NewCsqlProducer,
            _ => Self::UnknownValue(network_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NetworkArchitecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NETWORK_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER" => Self::OldCsqlProducer,
            "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER" => Self::NewCsqlProducer,
            _ => Self::UnknownValue(network_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NetworkArchitecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::OldCsqlProducer => serializer.serialize_i32(1),
            Self::NewCsqlProducer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NetworkArchitecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkArchitecture>::new(
            ".google.cloud.clouddms.v1.NetworkArchitecture",
        ))
    }
}

/// The database engine types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEngine {
    /// The source database engine of the migration job is unknown.
    Unspecified,
    /// The source engine is MySQL.
    Mysql,
    /// The source engine is PostgreSQL.
    Postgresql,
    /// The source engine is Oracle.
    Oracle,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEngine::value] or
    /// [DatabaseEngine::name].
    UnknownValue(database_engine::UnknownValue),
}

#[doc(hidden)]
pub mod database_engine {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEngine {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Mysql => std::option::Option::Some(1),
            Self::Postgresql => std::option::Option::Some(2),
            Self::Oracle => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENGINE_UNSPECIFIED"),
            Self::Mysql => std::option::Option::Some("MYSQL"),
            Self::Postgresql => std::option::Option::Some("POSTGRESQL"),
            Self::Oracle => std::option::Option::Some("ORACLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEngine {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEngine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEngine {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Mysql,
            2 => Self::Postgresql,
            4 => Self::Oracle,
            _ => Self::UnknownValue(database_engine::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEngine {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENGINE_UNSPECIFIED" => Self::Unspecified,
            "MYSQL" => Self::Mysql,
            "POSTGRESQL" => Self::Postgresql,
            "ORACLE" => Self::Oracle,
            _ => Self::UnknownValue(database_engine::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEngine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Mysql => serializer.serialize_i32(1),
            Self::Postgresql => serializer.serialize_i32(2),
            Self::Oracle => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
            ".google.cloud.clouddms.v1.DatabaseEngine",
        ))
    }
}

/// The database providers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseProvider {
    /// The database provider is unknown.
    Unspecified,
    /// CloudSQL runs the database.
    Cloudsql,
    /// RDS runs the database.
    Rds,
    /// Amazon Aurora.
    Aurora,
    /// AlloyDB.
    Alloydb,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseProvider::value] or
    /// [DatabaseProvider::name].
    UnknownValue(database_provider::UnknownValue),
}

#[doc(hidden)]
pub mod database_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Cloudsql => std::option::Option::Some(1),
            Self::Rds => std::option::Option::Some(2),
            Self::Aurora => std::option::Option::Some(3),
            Self::Alloydb => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_PROVIDER_UNSPECIFIED"),
            Self::Cloudsql => std::option::Option::Some("CLOUDSQL"),
            Self::Rds => std::option::Option::Some("RDS"),
            Self::Aurora => std::option::Option::Some("AURORA"),
            Self::Alloydb => std::option::Option::Some("ALLOYDB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Cloudsql,
            2 => Self::Rds,
            3 => Self::Aurora,
            4 => Self::Alloydb,
            _ => Self::UnknownValue(database_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "CLOUDSQL" => Self::Cloudsql,
            "RDS" => Self::Rds,
            "AURORA" => Self::Aurora,
            "ALLOYDB" => Self::Alloydb,
            _ => Self::UnknownValue(database_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Cloudsql => serializer.serialize_i32(1),
            Self::Rds => serializer.serialize_i32(2),
            Self::Aurora => serializer.serialize_i32(3),
            Self::Alloydb => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseProvider>::new(
            ".google.cloud.clouddms.v1.DatabaseProvider",
        ))
    }
}

/// Enum used by ValueListFilter to indicate whether the source value is in the
/// supplied list
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ValuePresentInList {
    /// Value present in list unspecified
    Unspecified,
    /// If the source value is in the supplied list at value_list
    IfValueList,
    /// If the source value is not in the supplied list at value_list
    IfValueNotList,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ValuePresentInList::value] or
    /// [ValuePresentInList::name].
    UnknownValue(value_present_in_list::UnknownValue),
}

#[doc(hidden)]
pub mod value_present_in_list {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ValuePresentInList {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IfValueList => std::option::Option::Some(1),
            Self::IfValueNotList => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VALUE_PRESENT_IN_LIST_UNSPECIFIED"),
            Self::IfValueList => std::option::Option::Some("VALUE_PRESENT_IN_LIST_IF_VALUE_LIST"),
            Self::IfValueNotList => {
                std::option::Option::Some("VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ValuePresentInList {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ValuePresentInList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ValuePresentInList {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IfValueList,
            2 => Self::IfValueNotList,
            _ => Self::UnknownValue(value_present_in_list::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ValuePresentInList {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VALUE_PRESENT_IN_LIST_UNSPECIFIED" => Self::Unspecified,
            "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST" => Self::IfValueList,
            "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST" => Self::IfValueNotList,
            _ => Self::UnknownValue(value_present_in_list::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ValuePresentInList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IfValueList => serializer.serialize_i32(1),
            Self::IfValueNotList => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ValuePresentInList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValuePresentInList>::new(
            ".google.cloud.clouddms.v1.ValuePresentInList",
        ))
    }
}

/// The type of database entities supported,
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEntityType {
    /// Unspecified database entity type.
    Unspecified,
    /// Schema.
    Schema,
    /// Table.
    Table,
    /// Column.
    Column,
    /// Constraint.
    Constraint,
    /// Index.
    Index,
    /// Trigger.
    Trigger,
    /// View.
    View,
    /// Sequence.
    Sequence,
    /// Stored Procedure.
    StoredProcedure,
    /// Function.
    Function,
    /// Synonym.
    Synonym,
    /// Package.
    DatabasePackage,
    /// UDT.
    Udt,
    /// Materialized View.
    MaterializedView,
    /// Database.
    Database,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEntityType::value] or
    /// [DatabaseEntityType::name].
    UnknownValue(database_entity_type::UnknownValue),
}

#[doc(hidden)]
pub mod database_entity_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEntityType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Schema => std::option::Option::Some(1),
            Self::Table => std::option::Option::Some(2),
            Self::Column => std::option::Option::Some(3),
            Self::Constraint => std::option::Option::Some(4),
            Self::Index => std::option::Option::Some(5),
            Self::Trigger => std::option::Option::Some(6),
            Self::View => std::option::Option::Some(7),
            Self::Sequence => std::option::Option::Some(8),
            Self::StoredProcedure => std::option::Option::Some(9),
            Self::Function => std::option::Option::Some(10),
            Self::Synonym => std::option::Option::Some(11),
            Self::DatabasePackage => std::option::Option::Some(12),
            Self::Udt => std::option::Option::Some(13),
            Self::MaterializedView => std::option::Option::Some(14),
            Self::Database => std::option::Option::Some(15),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENTITY_TYPE_UNSPECIFIED"),
            Self::Schema => std::option::Option::Some("DATABASE_ENTITY_TYPE_SCHEMA"),
            Self::Table => std::option::Option::Some("DATABASE_ENTITY_TYPE_TABLE"),
            Self::Column => std::option::Option::Some("DATABASE_ENTITY_TYPE_COLUMN"),
            Self::Constraint => std::option::Option::Some("DATABASE_ENTITY_TYPE_CONSTRAINT"),
            Self::Index => std::option::Option::Some("DATABASE_ENTITY_TYPE_INDEX"),
            Self::Trigger => std::option::Option::Some("DATABASE_ENTITY_TYPE_TRIGGER"),
            Self::View => std::option::Option::Some("DATABASE_ENTITY_TYPE_VIEW"),
            Self::Sequence => std::option::Option::Some("DATABASE_ENTITY_TYPE_SEQUENCE"),
            Self::StoredProcedure => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_STORED_PROCEDURE")
            }
            Self::Function => std::option::Option::Some("DATABASE_ENTITY_TYPE_FUNCTION"),
            Self::Synonym => std::option::Option::Some("DATABASE_ENTITY_TYPE_SYNONYM"),
            Self::DatabasePackage => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_DATABASE_PACKAGE")
            }
            Self::Udt => std::option::Option::Some("DATABASE_ENTITY_TYPE_UDT"),
            Self::MaterializedView => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW")
            }
            Self::Database => std::option::Option::Some("DATABASE_ENTITY_TYPE_DATABASE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEntityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEntityType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Schema,
            2 => Self::Table,
            3 => Self::Column,
            4 => Self::Constraint,
            5 => Self::Index,
            6 => Self::Trigger,
            7 => Self::View,
            8 => Self::Sequence,
            9 => Self::StoredProcedure,
            10 => Self::Function,
            11 => Self::Synonym,
            12 => Self::DatabasePackage,
            13 => Self::Udt,
            14 => Self::MaterializedView,
            15 => Self::Database,
            _ => Self::UnknownValue(database_entity_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEntityType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATABASE_ENTITY_TYPE_SCHEMA" => Self::Schema,
            "DATABASE_ENTITY_TYPE_TABLE" => Self::Table,
            "DATABASE_ENTITY_TYPE_COLUMN" => Self::Column,
            "DATABASE_ENTITY_TYPE_CONSTRAINT" => Self::Constraint,
            "DATABASE_ENTITY_TYPE_INDEX" => Self::Index,
            "DATABASE_ENTITY_TYPE_TRIGGER" => Self::Trigger,
            "DATABASE_ENTITY_TYPE_VIEW" => Self::View,
            "DATABASE_ENTITY_TYPE_SEQUENCE" => Self::Sequence,
            "DATABASE_ENTITY_TYPE_STORED_PROCEDURE" => Self::StoredProcedure,
            "DATABASE_ENTITY_TYPE_FUNCTION" => Self::Function,
            "DATABASE_ENTITY_TYPE_SYNONYM" => Self::Synonym,
            "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE" => Self::DatabasePackage,
            "DATABASE_ENTITY_TYPE_UDT" => Self::Udt,
            "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW" => Self::MaterializedView,
            "DATABASE_ENTITY_TYPE_DATABASE" => Self::Database,
            _ => Self::UnknownValue(database_entity_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Schema => serializer.serialize_i32(1),
            Self::Table => serializer.serialize_i32(2),
            Self::Column => serializer.serialize_i32(3),
            Self::Constraint => serializer.serialize_i32(4),
            Self::Index => serializer.serialize_i32(5),
            Self::Trigger => serializer.serialize_i32(6),
            Self::View => serializer.serialize_i32(7),
            Self::Sequence => serializer.serialize_i32(8),
            Self::StoredProcedure => serializer.serialize_i32(9),
            Self::Function => serializer.serialize_i32(10),
            Self::Synonym => serializer.serialize_i32(11),
            Self::DatabasePackage => serializer.serialize_i32(12),
            Self::Udt => serializer.serialize_i32(13),
            Self::MaterializedView => serializer.serialize_i32(14),
            Self::Database => serializer.serialize_i32(15),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEntityType>::new(
            ".google.cloud.clouddms.v1.DatabaseEntityType",
        ))
    }
}

/// Entity Name Transformation Types
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntityNameTransformation {
    /// Entity name transformation unspecified.
    Unspecified,
    /// No transformation.
    NoTransformation,
    /// Transform to lower case.
    LowerCase,
    /// Transform to upper case.
    UpperCase,
    /// Transform to capitalized case.
    CapitalizedCase,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntityNameTransformation::value] or
    /// [EntityNameTransformation::name].
    UnknownValue(entity_name_transformation::UnknownValue),
}

#[doc(hidden)]
pub mod entity_name_transformation {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntityNameTransformation {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoTransformation => std::option::Option::Some(1),
            Self::LowerCase => std::option::Option::Some(2),
            Self::UpperCase => std::option::Option::Some(3),
            Self::CapitalizedCase => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_UNSPECIFIED")
            }
            Self::NoTransformation => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION")
            }
            Self::LowerCase => std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_LOWER_CASE"),
            Self::UpperCase => std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_UPPER_CASE"),
            Self::CapitalizedCase => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntityNameTransformation {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntityNameTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntityNameTransformation {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoTransformation,
            2 => Self::LowerCase,
            3 => Self::UpperCase,
            4 => Self::CapitalizedCase,
            _ => Self::UnknownValue(entity_name_transformation::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EntityNameTransformation {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED" => Self::Unspecified,
            "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION" => Self::NoTransformation,
            "ENTITY_NAME_TRANSFORMATION_LOWER_CASE" => Self::LowerCase,
            "ENTITY_NAME_TRANSFORMATION_UPPER_CASE" => Self::UpperCase,
            "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE" => Self::CapitalizedCase,
            _ => Self::UnknownValue(entity_name_transformation::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EntityNameTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoTransformation => serializer.serialize_i32(1),
            Self::LowerCase => serializer.serialize_i32(2),
            Self::UpperCase => serializer.serialize_i32(3),
            Self::CapitalizedCase => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntityNameTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityNameTransformation>::new(
            ".google.cloud.clouddms.v1.EntityNameTransformation",
        ))
    }
}

/// The types of jobs that can be executed in the background.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackgroundJobType {
    /// Unspecified background job type.
    Unspecified,
    /// Job to seed from the source database.
    SourceSeed,
    /// Job to convert the source database into a draft of the destination
    /// database.
    Convert,
    /// Job to apply the draft tree onto the destination.
    ApplyDestination,
    /// Job to import and convert mapping rules from an external source such as an
    /// ora2pg config file.
    ImportRulesFile,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackgroundJobType::value] or
    /// [BackgroundJobType::name].
    UnknownValue(background_job_type::UnknownValue),
}

#[doc(hidden)]
pub mod background_job_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackgroundJobType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SourceSeed => std::option::Option::Some(1),
            Self::Convert => std::option::Option::Some(2),
            Self::ApplyDestination => std::option::Option::Some(3),
            Self::ImportRulesFile => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKGROUND_JOB_TYPE_UNSPECIFIED"),
            Self::SourceSeed => std::option::Option::Some("BACKGROUND_JOB_TYPE_SOURCE_SEED"),
            Self::Convert => std::option::Option::Some("BACKGROUND_JOB_TYPE_CONVERT"),
            Self::ApplyDestination => {
                std::option::Option::Some("BACKGROUND_JOB_TYPE_APPLY_DESTINATION")
            }
            Self::ImportRulesFile => {
                std::option::Option::Some("BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackgroundJobType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackgroundJobType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackgroundJobType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SourceSeed,
            2 => Self::Convert,
            3 => Self::ApplyDestination,
            5 => Self::ImportRulesFile,
            _ => Self::UnknownValue(background_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackgroundJobType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKGROUND_JOB_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BACKGROUND_JOB_TYPE_SOURCE_SEED" => Self::SourceSeed,
            "BACKGROUND_JOB_TYPE_CONVERT" => Self::Convert,
            "BACKGROUND_JOB_TYPE_APPLY_DESTINATION" => Self::ApplyDestination,
            "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE" => Self::ImportRulesFile,
            _ => Self::UnknownValue(background_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackgroundJobType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SourceSeed => serializer.serialize_i32(1),
            Self::Convert => serializer.serialize_i32(2),
            Self::ApplyDestination => serializer.serialize_i32(3),
            Self::ImportRulesFile => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackgroundJobType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackgroundJobType>::new(
            ".google.cloud.clouddms.v1.BackgroundJobType",
        ))
    }
}

/// The format for the import rules file.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ImportRulesFileFormat {
    /// Unspecified rules format.
    Unspecified,
    /// HarbourBridge session file.
    HarbourBridgeSessionFile,
    /// Ora2Pg configuration file.
    OratopgConfigFile,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ImportRulesFileFormat::value] or
    /// [ImportRulesFileFormat::name].
    UnknownValue(import_rules_file_format::UnknownValue),
}

#[doc(hidden)]
pub mod import_rules_file_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ImportRulesFileFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::HarbourBridgeSessionFile => std::option::Option::Some(1),
            Self::OratopgConfigFile => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_UNSPECIFIED"),
            Self::HarbourBridgeSessionFile => {
                std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE")
            }
            Self::OratopgConfigFile => {
                std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ImportRulesFileFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ImportRulesFileFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ImportRulesFileFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::HarbourBridgeSessionFile,
            2 => Self::OratopgConfigFile,
            _ => Self::UnknownValue(import_rules_file_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ImportRulesFileFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
            "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE" => {
                Self::HarbourBridgeSessionFile
            }
            "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE" => Self::OratopgConfigFile,
            _ => Self::UnknownValue(import_rules_file_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ImportRulesFileFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::HarbourBridgeSessionFile => serializer.serialize_i32(1),
            Self::OratopgConfigFile => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ImportRulesFileFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportRulesFileFormat>::new(
            ".google.cloud.clouddms.v1.ImportRulesFileFormat",
        ))
    }
}

/// Enum used by IntComparisonFilter and DoubleComparisonFilter to indicate the
/// relation between source value and compare value.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ValueComparison {
    /// Value comparison unspecified.
    Unspecified,
    /// Value is smaller than the Compare value.
    IfValueSmallerThan,
    /// Value is smaller or equal than the Compare value.
    IfValueSmallerEqualThan,
    /// Value is larger than the Compare value.
    IfValueLargerThan,
    /// Value is larger or equal than the Compare value.
    IfValueLargerEqualThan,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ValueComparison::value] or
    /// [ValueComparison::name].
    UnknownValue(value_comparison::UnknownValue),
}

#[doc(hidden)]
pub mod value_comparison {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ValueComparison {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IfValueSmallerThan => std::option::Option::Some(1),
            Self::IfValueSmallerEqualThan => std::option::Option::Some(2),
            Self::IfValueLargerThan => std::option::Option::Some(3),
            Self::IfValueLargerEqualThan => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VALUE_COMPARISON_UNSPECIFIED"),
            Self::IfValueSmallerThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_SMALLER_THAN")
            }
            Self::IfValueSmallerEqualThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN")
            }
            Self::IfValueLargerThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_LARGER_THAN")
            }
            Self::IfValueLargerEqualThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ValueComparison {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ValueComparison {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ValueComparison {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IfValueSmallerThan,
            2 => Self::IfValueSmallerEqualThan,
            3 => Self::IfValueLargerThan,
            4 => Self::IfValueLargerEqualThan,
            _ => Self::UnknownValue(value_comparison::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ValueComparison {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VALUE_COMPARISON_UNSPECIFIED" => Self::Unspecified,
            "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN" => Self::IfValueSmallerThan,
            "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN" => Self::IfValueSmallerEqualThan,
            "VALUE_COMPARISON_IF_VALUE_LARGER_THAN" => Self::IfValueLargerThan,
            "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN" => Self::IfValueLargerEqualThan,
            _ => Self::UnknownValue(value_comparison::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ValueComparison {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IfValueSmallerThan => serializer.serialize_i32(1),
            Self::IfValueSmallerEqualThan => serializer.serialize_i32(2),
            Self::IfValueLargerThan => serializer.serialize_i32(3),
            Self::IfValueLargerEqualThan => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ValueComparison {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueComparison>::new(
            ".google.cloud.clouddms.v1.ValueComparison",
        ))
    }
}

/// Specifies the columns on which numeric filter needs to be applied.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NumericFilterOption {
    /// Numeric filter option unspecified
    Unspecified,
    /// Numeric filter option that matches all numeric columns.
    All,
    /// Numeric filter option that matches columns having numeric datatypes with
    /// specified precision and scale within the limited range of filter.
    Limit,
    /// Numeric filter option that matches only the numeric columns with no
    /// precision and scale specified.
    Limitless,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NumericFilterOption::value] or
    /// [NumericFilterOption::name].
    UnknownValue(numeric_filter_option::UnknownValue),
}

#[doc(hidden)]
pub mod numeric_filter_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NumericFilterOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::Limit => std::option::Option::Some(2),
            Self::Limitless => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NUMERIC_FILTER_OPTION_UNSPECIFIED"),
            Self::All => std::option::Option::Some("NUMERIC_FILTER_OPTION_ALL"),
            Self::Limit => std::option::Option::Some("NUMERIC_FILTER_OPTION_LIMIT"),
            Self::Limitless => std::option::Option::Some("NUMERIC_FILTER_OPTION_LIMITLESS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NumericFilterOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NumericFilterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NumericFilterOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::Limit,
            3 => Self::Limitless,
            _ => Self::UnknownValue(numeric_filter_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NumericFilterOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NUMERIC_FILTER_OPTION_UNSPECIFIED" => Self::Unspecified,
            "NUMERIC_FILTER_OPTION_ALL" => Self::All,
            "NUMERIC_FILTER_OPTION_LIMIT" => Self::Limit,
            "NUMERIC_FILTER_OPTION_LIMITLESS" => Self::Limitless,
            _ => Self::UnknownValue(numeric_filter_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NumericFilterOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::Limit => serializer.serialize_i32(2),
            Self::Limitless => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NumericFilterOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NumericFilterOption>::new(
            ".google.cloud.clouddms.v1.NumericFilterOption",
        ))
    }
}
