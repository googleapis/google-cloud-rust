// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Retrieves a list of all migration jobs in a given project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationJobsRequest {
    /// Required. The parent which owns this collection of migrationJobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of migration jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 migration jobs will be
    /// returned. The maximum value is 1000; values above 1000 are coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// migrationJobs.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to migrationJobs.list must match the call
    /// that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters migration jobs listed in the response.
    /// The expression must specify the field name, a comparison operator, and the
    /// value that you want to use for filtering. The value must be a string,
    /// a number, or a boolean. The comparison operator must be
    /// either =, !=, >, or <. For example, list migration jobs created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.**
    /// You can also filter nested fields. For example, you could specify
    /// **reverseSshConnectivity.vmIp = "1.2.3.4"** to select all migration
    /// jobs connecting through the specific SSH tunnel bastion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sort the results based on the migration job name.
    /// Valid values are: "name", "name asc", and "name desc".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigrationJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigrationJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsRequest"
    }
}

/// Response message for 'ListMigrationJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationJobsResponse {
    /// The list of migration jobs objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migration_jobs: std::vec::Vec<crate::model::MigrationJob>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigrationJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_jobs][crate::model::ListMigrationJobsResponse::migration_jobs].
    pub fn set_migration_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationJob>,
    {
        use std::iter::Iterator;
        self.migration_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigrationJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigrationJobsResponse {
    type PageItem = crate::model::MigrationJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMigrationJobRequest {
    /// Required. Name of the migration job resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMigrationJobRequest"
    }
}

/// Request message to create a new Database Migration Service migration job
/// in the specified project and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMigrationJobRequest {
    /// Required. The parent which owns this collection of migration jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job_id: std::string::String,

    /// Required. Represents a [migration
    /// job](https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs)
    /// object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigrationJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migration_job_id][crate::model::CreateMigrationJobRequest::migration_job_id].
    pub fn set_migration_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job_id = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::CreateMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMigrationJobRequest"
    }
}

/// Request message for 'UpdateMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateMigrationJobRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The migration job parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigrationJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::UpdateMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateMigrationJobRequest"
    }
}

/// Request message for 'DeleteMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMigrationJobRequest {
    /// Required. Name of the migration job resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// The destination CloudSQL connection profile is always deleted with the
    /// migration job. In case of force delete, the destination CloudSQL replica
    /// database is also deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteMigrationJobRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMigrationJobRequest"
    }
}

/// Request message for 'StartMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartMigrationJobRequest {
    /// Name of the migration job resource to start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Start the migration job without running prior configuration
    /// verification. Defaults to `false`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_validation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::StartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StartMigrationJobRequest"
    }
}

/// Request message for 'StopMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopMigrationJobRequest {
    /// Name of the migration job resource to stop.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StopMigrationJobRequest"
    }
}

/// Request message for 'ResumeMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeMigrationJobRequest {
    /// Name of the migration job resource to resume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ResumeMigrationJobRequest"
    }
}

/// Request message for 'PromoteMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteMigrationJobRequest {
    /// Name of the migration job resource to promote.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PromoteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PromoteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PromoteMigrationJobRequest"
    }
}

/// Request message for 'VerifyMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyMigrationJobRequest {
    /// Name of the migration job resource to verify.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Field mask is used to specify the changed fields to be verified.
    /// It will not update the migration job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The changed migration job parameters to verify.
    /// It will not update the migration job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::VerifyMigrationJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::VerifyMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }
}

impl wkt::message::Message for VerifyMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VerifyMigrationJobRequest"
    }
}

/// Request message for 'RestartMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartMigrationJobRequest {
    /// Name of the migration job resource to restart.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Restart the migration job without running prior configuration
    /// verification. Defaults to `false`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_validation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::RestartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for RestartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RestartMigrationJobRequest"
    }
}

/// Request message for 'GenerateSshScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateSshScriptRequest {
    /// Name of the migration job resource to generate the SSH script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job: std::string::String,

    /// Required. Bastion VM Instance name to use or to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm: std::string::String,

    /// The port that will be open on the bastion host.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vm_port: i32,

    /// The VM configuration
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vm_config: std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateSshScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateSshScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::GenerateSshScriptRequest::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::GenerateSshScriptRequest::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config].
    ///
    /// Note that all the setters affecting `vm_config` are mutually
    /// exclusive.
    pub fn set_vm_config<
        T: std::convert::Into<
                std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = v.into();
        self
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmCreationConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v.into()),
        );
        self
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmSelectionConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_selection_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmSelectionConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmSelectionConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_selection_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmSelectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GenerateSshScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateSshScriptRequest"
    }
}

/// Defines additional types related to [GenerateSshScriptRequest].
pub mod generate_ssh_script_request {
    #[allow(unused_imports)]
    use super::*;

    /// The VM configuration
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VmConfig {
        /// The VM creation configuration
        VmCreationConfig(std::boxed::Box<crate::model::VmCreationConfig>),
        /// The VM selection configuration
        VmSelectionConfig(std::boxed::Box<crate::model::VmSelectionConfig>),
    }
}

/// VM creation configuration message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmCreationConfig {
    /// Required. VM instance machine type to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_machine_type: std::string::String,

    /// The Google Cloud Platform zone to create the VM in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,

    /// The subnet name the vm needs to be created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_machine_type][crate::model::VmCreationConfig::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::VmCreationConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VmCreationConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VmCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmCreationConfig"
    }
}

/// VM selection configuration message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmSelectionConfig {
    /// Required. The Google Cloud Platform zone the VM is located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmSelectionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_zone][crate::model::VmSelectionConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }
}

impl wkt::message::Message for VmSelectionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmSelectionConfig"
    }
}

/// Response message for 'GenerateSshScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SshScript {
    /// The ssh configuration script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SshScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::SshScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for SshScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SshScript"
    }
}

/// Request message for 'GenerateTcpProxyScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateTcpProxyScriptRequest {
    /// Name of the migration job resource to generate the TCP Proxy script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job: std::string::String,

    /// Required. The name of the Compute instance that will host the proxy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// Required. The type of the Compute instance that will host the proxy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_machine_type: std::string::String,

    /// Optional. The Google Cloud Platform zone to create the VM in. The fully
    /// qualified name of the zone must be specified, including the region name,
    /// for example "us-central1-b". If not specified, uses the "-b" zone of the
    /// destination Connection Profile's region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,

    /// Required. The name of the subnet the Compute instance will use for private
    /// connectivity. Must be supplied in the form of
    /// projects/{project}/regions/{region}/subnetworks/{subnetwork}.
    /// Note: the region for the subnet must match the Compute instance region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_subnet: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateTcpProxyScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateTcpProxyScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::GenerateTcpProxyScriptRequest::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_machine_type][crate::model::GenerateTcpProxyScriptRequest::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::GenerateTcpProxyScriptRequest::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [vm_subnet][crate::model::GenerateTcpProxyScriptRequest::vm_subnet].
    pub fn set_vm_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_subnet = v.into();
        self
    }
}

impl wkt::message::Message for GenerateTcpProxyScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateTcpProxyScriptRequest"
    }
}

/// Response message for 'GenerateTcpProxyScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TcpProxyScript {
    /// The TCP Proxy configuration script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TcpProxyScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::TcpProxyScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for TcpProxyScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TcpProxyScript"
    }
}

/// Request message for 'ListConnectionProfiles' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesRequest {
    /// Required. The parent which owns this collection of connection profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of connection profiles to return. The service may return
    /// fewer than this value. If unspecified, at most 50 connection profiles will
    /// be returned. The maximum value is 1000; values above 1000 are coerced
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous `ListConnectionProfiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectionProfiles`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters connection profiles listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list connection profiles created this year by
    /// specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z**. You can
    /// also filter nested fields. For example, you could specify **mySql.username
    /// = %lt;my_username%gt;** to list all connection profiles configured to
    /// connect with a specific username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A comma-separated list of fields to order results according to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesRequest"
    }
}

/// Response message for 'ListConnectionProfiles' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesResponse {
    /// The response list of connection profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connection_profiles: std::vec::Vec<crate::model::ConnectionProfile>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection_profiles][crate::model::ListConnectionProfilesResponse::connection_profiles].
    pub fn set_connection_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProfile>,
    {
        use std::iter::Iterator;
        self.connection_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionProfilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionProfilesResponse {
    type PageItem = crate::model::ConnectionProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connection_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionProfileRequest {
    /// Required. Name of the connection profile resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConnectionProfileRequest"
    }
}

/// Request message for 'CreateConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionProfileRequest {
    /// Required. The parent which owns this collection of connection profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The connection profile identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_profile_id: std::string::String,

    /// Required. The create request body including the connection profile data
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't create any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Create the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_validation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_profile_id][crate::model::CreateConnectionProfileRequest::connection_profile_id].
    pub fn set_connection_profile_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile_id = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<
        T: std::convert::Into<std::option::Option<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConnectionProfileRequest"
    }
}

/// Request message for 'UpdateConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionProfileRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connection profile parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't update any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. Update the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_validation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<
        T: std::convert::Into<std::option::Option<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::UpdateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConnectionProfileRequest"
    }
}

/// Request message for 'DeleteConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionProfileRequest {
    /// Required. Name of the connection profile resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// In case of force delete, the CloudSQL replica database is also deleted
    /// (only for CloudSQL connection profile).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConnectionProfileRequest"
    }
}

/// Request message to create a new private connection in the specified project
/// and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The parent that owns the collection of PrivateConnections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The private connection identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection_id: std::string::String,

    /// Required. The private connection resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, will skip validations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_validation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<
        T: std::convert::Into<std::option::Option<crate::model::PrivateConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreatePrivateConnectionRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreatePrivateConnectionRequest"
    }
}

/// Request message to retrieve a list of private connections in a given project
/// and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The parent that owns the collection of private connections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of private connections to return.
    /// If unspecified, at most 50 private connections that are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Page token received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters private connections listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list private connections created this year by
    /// specifying **createTime %gt; 2021-01-01T00:00:00.000000000Z**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsRequest"
    }
}

/// Response message for 'ListPrivateConnections' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// List of private connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message to delete a private connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The name of the private connection to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeletePrivateConnectionRequest"
    }
}

/// Request message to get a private connection resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The name of the private connection to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetPrivateConnectionRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OperationMetadata"
    }
}

/// Retrieve a list of all conversion workspaces in a given project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversionWorkspacesRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of conversion workspaces to return. The service may
    /// return fewer than this value. If unspecified, at most 50 sets are returned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// conversionWorkspaces.list, used in the subsequent request to retrieve the
    /// next page of results. On first call this should be left blank. When
    /// paginating, all other parameters provided to conversionWorkspaces.list must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters conversion workspaces listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list conversion workspaces created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.** You can
    /// also filter nested fields. For example, you could specify
    /// **source.version = "12.c.1"** to select all conversion workspaces with
    /// source database version equal to 12.c.1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversionWorkspacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversionWorkspacesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversionWorkspacesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversionWorkspacesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversionWorkspacesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesRequest"
    }
}

/// Response message for 'ListConversionWorkspaces' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversionWorkspacesResponse {
    /// The list of conversion workspace objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conversion_workspaces: std::vec::Vec<crate::model::ConversionWorkspace>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConversionWorkspacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspaces][crate::model::ListConversionWorkspacesResponse::conversion_workspaces].
    pub fn set_conversion_workspaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.conversion_workspaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversionWorkspacesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConversionWorkspacesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversionWorkspacesResponse {
    type PageItem = crate::model::ConversionWorkspace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversion_workspaces
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConversionWorkspaceRequest"
    }
}

/// Request message to create a new Conversion Workspace
/// in the specified project and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConversionWorkspaceRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the conversion workspace to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace_id: std::string::String,

    /// Required. Represents a conversion workspace object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversionWorkspaceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversion_workspace_id][crate::model::CreateConversionWorkspaceRequest::conversion_workspace_id].
    pub fn set_conversion_workspace_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace_id = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::CreateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConversionWorkspaceRequest"
    }
}

/// Request message for 'UpdateConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConversionWorkspaceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The conversion workspace parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversionWorkspaceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::UpdateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConversionWorkspaceRequest"
    }
}

/// Request message for 'DeleteConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Force delete the conversion workspace, even if there's a running migration
    /// that is using the workspace.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConversionWorkspaceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConversionWorkspaceRequest"
    }
}

/// Request message for 'CommitConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommitConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to commit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Optional name of the commit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_name][crate::model::CommitConversionWorkspaceRequest::commit_name].
    pub fn set_commit_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_name = v.into();
        self
    }
}

impl wkt::message::Message for CommitConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CommitConversionWorkspaceRequest"
    }
}

/// Request message for 'RollbackConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to roll back to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RollbackConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RollbackConversionWorkspaceRequest"
    }
}

/// Request message for 'ApplyConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyConversionWorkspaceRequest {
    /// Required. The name of the conversion workspace resource for which to apply
    /// the draft tree. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Filter which entities to apply. Leaving this field empty will apply all of
    /// the entities. Supports Google AIP 160 based filtering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Only validates the apply process, but doesn't change the
    /// destination database. Only works for PostgreSQL destination connection
    /// profile.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub dry_run: bool,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the apply.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_commit: bool,

    /// Which destination to use when applying the conversion workspace.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination:
        std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ApplyConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::ApplyConversionWorkspaceRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ApplyConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// if it holds a `ConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// to hold a `ConnectionProfile`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ApplyConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyConversionWorkspaceRequest"
    }
}

/// Defines additional types related to [ApplyConversionWorkspaceRequest].
pub mod apply_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// Which destination to use when applying the conversion workspace.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        ConnectionProfile(std::string::String),
    }
}

/// Retrieve a list of all mapping rules in a given conversion workspace.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMappingRulesRequest {
    /// Required. Name of the conversion workspace resource whose mapping rules are
    /// listed in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of rules to return. The service may return
    /// fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// mappingRules.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to mappingRules.list must match the call
    /// that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMappingRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMappingRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesRequest"
    }
}

/// Response message for 'ListMappingRulesRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMappingRulesResponse {
    /// The list of conversion workspace mapping rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mapping_rules: std::vec::Vec<crate::model::MappingRule>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMappingRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mapping_rules][crate::model::ListMappingRulesResponse::mapping_rules].
    pub fn set_mapping_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MappingRule>,
    {
        use std::iter::Iterator;
        self.mapping_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMappingRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMappingRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMappingRulesResponse {
    type PageItem = crate::model::MappingRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.mapping_rules
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetMappingRule' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMappingRuleRequest {
    /// Required. Name of the mapping rule resource to get.
    /// Example: conversionWorkspaces/123/mappingRules/rule123
    ///
    /// In order to retrieve a previous revision of the mapping rule, also provide
    /// the revision ID.
    /// Example:
    /// conversionWorkspace/123/mappingRules/rule123@c7cfa2a8c7cfa2a8c7cfa2a8c7cfa2a8
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMappingRuleRequest"
    }
}

/// Request message for 'SeedConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SeedConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to seed with new database
    /// structure, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Should the conversion workspace be committed automatically after the
    /// seed operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_commit: bool,

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub seed_from: std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SeedConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SeedConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::SeedConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from].
    ///
    /// Note that all the setters affecting `seed_from` are mutually
    /// exclusive.
    pub fn set_seed_from<
        T: std::convert::Into<
                std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = v.into();
        self
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `SourceConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `SourceConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_source_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v.into(),
            ),
        );
        self
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `DestinationConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn destination_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `DestinationConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_destination_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SeedConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SeedConversionWorkspaceRequest"
    }
}

/// Defines additional types related to [SeedConversionWorkspaceRequest].
pub mod seed_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SeedFrom {
        /// Optional. Fully qualified (Uri) name of the source connection profile.
        SourceConnectionProfile(std::string::String),
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        DestinationConnectionProfile(std::string::String),
    }
}

/// Request message for 'ConvertConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConvertConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to convert in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the conversion.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_commit: bool,

    /// Optional. Filter the entities to convert. Leaving this field empty will
    /// convert all of the entities. Supports Google AIP-160 style filtering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Automatically convert the full entity path for each entity
    /// specified by the filter. For example, if the filter specifies a table, that
    /// table schema (and database if there is one) will also be converted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub convert_full_path: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConvertConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConvertConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ConvertConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ConvertConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [convert_full_path][crate::model::ConvertConversionWorkspaceRequest::convert_full_path].
    pub fn set_convert_full_path<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.convert_full_path = v.into();
        self
    }
}

impl wkt::message::Message for ConvertConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertConversionWorkspaceRequest"
    }
}

/// Request message for 'ImportMappingRules' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportMappingRulesRequest {
    /// Required. Name of the conversion workspace resource to import the rules to
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The format of the rules content file.
    pub rules_format: crate::model::ImportRulesFileFormat,

    /// Required. One or more rules files.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules_files: std::vec::Vec<crate::model::import_mapping_rules_request::RulesFile>,

    /// Required. Should the conversion workspace be committed automatically after
    /// the import operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_commit: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rules_format][crate::model::ImportMappingRulesRequest::rules_format].
    pub fn set_rules_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules_format = v.into();
        self
    }

    /// Sets the value of [rules_files][crate::model::ImportMappingRulesRequest::rules_files].
    pub fn set_rules_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::import_mapping_rules_request::RulesFile>,
    {
        use std::iter::Iterator;
        self.rules_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ImportMappingRulesRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }
}

impl wkt::message::Message for ImportMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest"
    }
}

/// Defines additional types related to [ImportMappingRulesRequest].
pub mod import_mapping_rules_request {
    #[allow(unused_imports)]
    use super::*;

    /// Details of a single rules file.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RulesFile {
        /// Required. The filename of the rules that needs to be converted. The
        /// filename is used mainly so that future logs of the import rules job
        /// contain it, and can therefore be searched by it.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rules_source_filename: std::string::String,

        /// Required. The text content of the rules that needs to be converted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rules_content: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RulesFile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rules_source_filename][crate::model::import_mapping_rules_request::RulesFile::rules_source_filename].
        pub fn set_rules_source_filename<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_source_filename = v.into();
            self
        }

        /// Sets the value of [rules_content][crate::model::import_mapping_rules_request::RulesFile::rules_content].
        pub fn set_rules_content<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_content = v.into();
            self
        }
    }

    impl wkt::message::Message for RulesFile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest.RulesFile"
        }
    }
}

/// Request message for 'DescribeDatabaseEntities' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesRequest {
    /// Required. Name of the conversion workspace resource whose database entities
    /// are described. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. The maximum number of entities to return. The service may return
    /// fewer entities than the value specifies.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The nextPageToken value received in the previous call to
    /// conversionWorkspace.describeDatabaseEntities, used in the subsequent
    /// request to retrieve the next page of results. On first call this should be
    /// left blank. When paginating, all other parameters provided to
    /// conversionWorkspace.describeDatabaseEntities must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Required. The tree to fetch.
    pub tree: crate::model::describe_database_entities_request::DBTreeType,

    /// Optional. Whether to retrieve the latest committed version of the entities
    /// or the latest version. This field is ignored if a specific commit_id is
    /// specified.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub uncommitted: bool,

    /// Optional. Request a specific commit ID. If not specified, the entities from
    /// the latest commit are returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,

    /// Optional. Filter the returned entities based on AIP-160 standard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Results view based on AIP-157
    pub view: crate::model::DatabaseEntityView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeDatabaseEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeDatabaseEntitiesRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::DescribeDatabaseEntitiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::DescribeDatabaseEntitiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DescribeDatabaseEntitiesRequest::tree].
    pub fn set_tree<
        T: std::convert::Into<crate::model::describe_database_entities_request::DBTreeType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [uncommitted][crate::model::DescribeDatabaseEntitiesRequest::uncommitted].
    pub fn set_uncommitted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.uncommitted = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeDatabaseEntitiesRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::DescribeDatabaseEntitiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [view][crate::model::DescribeDatabaseEntitiesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::DatabaseEntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesRequest"
    }
}

/// Defines additional types related to [DescribeDatabaseEntitiesRequest].
pub mod describe_database_entities_request {
    #[allow(unused_imports)]
    use super::*;

    /// The type of a tree to return
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DBTreeType {
        /// Unspecified tree type.
        Unspecified,
        /// The source database tree.
        SourceTree,
        /// The draft database tree.
        DraftTree,
        /// The destination database tree.
        DestinationTree,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DBTreeType::value] or
        /// [DBTreeType::name].
        UnknownValue(db_tree_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod db_tree_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DBTreeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SourceTree => std::option::Option::Some(1),
                Self::DraftTree => std::option::Option::Some(2),
                Self::DestinationTree => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DB_TREE_TYPE_UNSPECIFIED"),
                Self::SourceTree => std::option::Option::Some("SOURCE_TREE"),
                Self::DraftTree => std::option::Option::Some("DRAFT_TREE"),
                Self::DestinationTree => std::option::Option::Some("DESTINATION_TREE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DBTreeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DBTreeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DBTreeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SourceTree,
                2 => Self::DraftTree,
                3 => Self::DestinationTree,
                _ => Self::UnknownValue(db_tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DBTreeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DB_TREE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE_TREE" => Self::SourceTree,
                "DRAFT_TREE" => Self::DraftTree,
                "DESTINATION_TREE" => Self::DestinationTree,
                _ => Self::UnknownValue(db_tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DBTreeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SourceTree => serializer.serialize_i32(1),
                Self::DraftTree => serializer.serialize_i32(2),
                Self::DestinationTree => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DBTreeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DBTreeType>::new(
                ".google.cloud.clouddms.v1.DescribeDatabaseEntitiesRequest.DBTreeType",
            ))
        }
    }
}

/// Response message for 'DescribeDatabaseEntities' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesResponse {
    /// The list of database entities for the conversion workspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_entities: std::vec::Vec<crate::model::DatabaseEntity>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeDatabaseEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_entities][crate::model::DescribeDatabaseEntitiesResponse::database_entities].
    pub fn set_database_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseEntity>,
    {
        use std::iter::Iterator;
        self.database_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::DescribeDatabaseEntitiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for DescribeDatabaseEntitiesResponse {
    type PageItem = crate::model::DatabaseEntity;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.database_entities
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'SearchBackgroundJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBackgroundJobsRequest {
    /// Required. Name of the conversion workspace resource whose jobs are listed,
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. Whether or not to return just the most recent job per job type,
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub return_most_recent_per_job_type: bool,

    /// Optional. The maximum number of jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 100 jobs are
    /// returned. The maximum value is 100; values above 100 are coerced to
    /// 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_size: i32,

    /// Optional. If provided, only returns jobs that completed until (not
    /// including) the given timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completed_until_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBackgroundJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::SearchBackgroundJobsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [return_most_recent_per_job_type][crate::model::SearchBackgroundJobsRequest::return_most_recent_per_job_type].
    pub fn set_return_most_recent_per_job_type<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.return_most_recent_per_job_type = v.into();
        self
    }

    /// Sets the value of [max_size][crate::model::SearchBackgroundJobsRequest::max_size].
    pub fn set_max_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_size = v.into();
        self
    }

    /// Sets the value of [completed_until_time][crate::model::SearchBackgroundJobsRequest::completed_until_time].
    pub fn set_completed_until_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completed_until_time = v.into();
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsRequest"
    }
}

/// Response message for 'SearchBackgroundJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBackgroundJobsResponse {
    /// The list of conversion workspace mapping rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::BackgroundJobLogEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBackgroundJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::SearchBackgroundJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackgroundJobLogEntry>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsResponse"
    }
}

/// Request message for 'DescribeConversionWorkspaceRevisions' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsRequest {
    /// Required. Name of the conversion workspace resource whose revisions are
    /// listed. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. Optional filter to request a specific commit ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeConversionWorkspaceRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeConversionWorkspaceRevisionsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeConversionWorkspaceRevisionsRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsRequest"
    }
}

/// Response message for 'DescribeConversionWorkspaceRevisions' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsResponse {
    /// The list of conversion workspace revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub revisions: std::vec::Vec<crate::model::ConversionWorkspace>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DescribeConversionWorkspaceRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revisions][crate::model::DescribeConversionWorkspaceRevisionsResponse::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsResponse"
    }
}

/// Request message for 'CreateMappingRule' command.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMappingRuleRequest {
    /// Required. The parent which owns this collection of mapping rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the rule to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mapping_rule_id: std::string::String,

    /// Required. Represents a [mapping rule]
    /// (<https://cloud.google.com/database-migration/reference/rest/v1/projects.locations.mappingRules>)
    /// object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mapping_rule: std::option::Option<crate::model::MappingRule>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMappingRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [mapping_rule_id][crate::model::CreateMappingRuleRequest::mapping_rule_id].
    pub fn set_mapping_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_rule_id = v.into();
        self
    }

    /// Sets the value of [mapping_rule][crate::model::CreateMappingRuleRequest::mapping_rule].
    pub fn set_mapping_rule<
        T: std::convert::Into<std::option::Option<crate::model::MappingRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mapping_rule = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMappingRuleRequest"
    }
}

/// Request message for 'DeleteMappingRule' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMappingRuleRequest {
    /// Required. Name of the mapping rule resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMappingRuleRequest"
    }
}

/// Request message for 'FetchStaticIps' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsRequest {
    /// Required. The resource name for the location for which static IPs should be
    /// returned. Must be in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Maximum number of IPs to return.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A page token, received from a previous `FetchStaticIps` call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchStaticIpsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStaticIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStaticIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsRequest"
    }
}

/// Response message for a 'FetchStaticIps' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsResponse {
    /// List of static IPs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub static_ips: std::vec::Vec<std::string::String>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStaticIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [static_ips][crate::model::FetchStaticIpsResponse::static_ips].
    pub fn set_static_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.static_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchStaticIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsResponse"
    }
}

/// SSL configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslConfig {
    /// Output only. The ssl config type according to 'client_key',
    /// 'client_certificate' and 'ca_certificate'.
    #[serde(rename = "type")]
    pub r#type: crate::model::ssl_config::SslType,

    /// Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key
    /// associated with the Client Certificate. If this field is used then the
    /// 'client_certificate' field is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// Input only. The x509 PEM-encoded certificate that will be used by the
    /// replica to authenticate against the source database server.If this field is
    /// used then the 'client_key' field is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// Required. Input only. The x509 PEM-encoded certificate of the CA that
    /// signed the source database server's certificate. The replica will use this
    /// certificate to verify it's connecting to the right host.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SslConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::ssl_config::SslType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::SslConfig::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::SslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SslConfig"
    }
}

/// Defines additional types related to [SslConfig].
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies The kind of ssl configuration used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SslType {
        /// Unspecified.
        Unspecified,
        /// Only 'ca_certificate' specified.
        ServerOnly,
        /// Both server ('ca_certificate'), and client ('client_key',
        /// 'client_certificate') specified.
        ServerClient,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SslType::value] or
        /// [SslType::name].
        UnknownValue(ssl_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ssl_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SslType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServerOnly => std::option::Option::Some(1),
                Self::ServerClient => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SSL_TYPE_UNSPECIFIED"),
                Self::ServerOnly => std::option::Option::Some("SERVER_ONLY"),
                Self::ServerClient => std::option::Option::Some("SERVER_CLIENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SslType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SslType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SslType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServerOnly,
                2 => Self::ServerClient,
                _ => Self::UnknownValue(ssl_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SslType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SSL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVER_ONLY" => Self::ServerOnly,
                "SERVER_CLIENT" => Self::ServerClient,
                _ => Self::UnknownValue(ssl_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SslType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServerOnly => serializer.serialize_i32(1),
                Self::ServerClient => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SslType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SslType>::new(
                ".google.cloud.clouddms.v1.SslConfig.SslType",
            ))
        }
    }
}

/// Specifies connection parameters required specifically for MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlConnectionProfile {
    /// Required. The IP or hostname of the source MySQL database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source MySQL database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MySqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::MySqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::MySqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::MySqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::MySqlConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::MySqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }
}

impl wkt::message::Message for MySqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MySqlConnectionProfile"
    }
}

/// Specifies connection parameters required specifically for PostgreSQL
/// databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgreSqlConnectionProfile {
    /// Required. The IP or hostname of the source PostgreSQL database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source PostgreSQL database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,

    /// Output only. If the source is a Cloud SQL database, this field indicates
    /// the network architecture it's associated with.
    pub network_architecture: crate::model::NetworkArchitecture,

    /// Connectivity options used to establish a connection to the database server.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity:
        std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostgreSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::PostgreSqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::PostgreSqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::PostgreSqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::PostgreSqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::PostgreSqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::PostgreSqlConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::PostgreSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [network_architecture][crate::model::PostgreSqlConnectionProfile::network_architecture].
    pub fn set_network_architecture<T: std::convert::Into<crate::model::NetworkArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_architecture = v.into();
        self
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<
                std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `PrivateServiceConnectConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_service_connect_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>
    {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `PrivateServiceConnectConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_service_connect_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for PostgreSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PostgreSqlConnectionProfile"
    }
}

/// Defines additional types related to [PostgreSqlConnectionProfile].
pub mod postgre_sql_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
        /// Private service connect connectivity.
        PrivateServiceConnectConnectivity(
            std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>,
        ),
    }
}

/// Specifies connection parameters required specifically for Oracle
/// databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleConnectionProfile {
    /// Required. The IP or hostname of the source Oracle database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source Oracle database.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates whether a new password is included in the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub password_set: bool,

    /// Required. Database service for the Oracle connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_service: std::string::String,

    /// SSL configuration for the connection to the source Oracle database.
    ///
    /// * Only `SERVER_ONLY` configuration is supported for Oracle SSL.
    /// * SSL is supported for Oracle versions 12 and above.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// Connectivity options used to establish a connection to the database server.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::oracle_connection_profile::Connectivity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OracleConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::OracleConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::OracleConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [database_service][crate::model::OracleConnectionProfile::database_service].
    pub fn set_database_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_service = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::OracleConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<
                std::option::Option<crate::model::oracle_connection_profile::Connectivity>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `StaticServiceIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_service_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticServiceIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `StaticServiceIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_service_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `ForwardSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn forward_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `ForwardSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_forward_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `PrivateConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `PrivateConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OracleConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OracleConnectionProfile"
    }
}

/// Defines additional types related to [OracleConnectionProfile].
pub mod oracle_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static Service IP connectivity.
        StaticServiceIpConnectivity(std::boxed::Box<crate::model::StaticServiceIpConnectivity>),
        /// Forward SSH tunnel connectivity.
        ForwardSshConnectivity(std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>),
        /// Private connectivity.
        PrivateConnectivity(std::boxed::Box<crate::model::PrivateConnectivity>),
    }
}

/// Specifies required connection parameters, and, optionally, the parameters
/// required to create a Cloud SQL destination database instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlConnectionProfile {
    /// Output only. The Cloud SQL instance ID that this connection profile is
    /// associated with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,

    /// Immutable. Metadata used to create the destination Cloud SQL database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::CloudSqlSettings>,

    /// Output only. The Cloud SQL database instance's private IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's public IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's additional (outgoing) public
    /// IP. Used when the Cloud SQL database availability type is REGIONAL (i.e.
    /// multiple zones / highly available).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub additional_public_ip: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_sql_id][crate::model::CloudSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::CloudSqlConnectionProfile::settings].
    pub fn set_settings<
        T: std::convert::Into<std::option::Option<crate::model::CloudSqlSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [private_ip][crate::model::CloudSqlConnectionProfile::private_ip].
    pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_ip = v.into();
        self
    }

    /// Sets the value of [public_ip][crate::model::CloudSqlConnectionProfile::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [additional_public_ip][crate::model::CloudSqlConnectionProfile::additional_public_ip].
    pub fn set_additional_public_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_public_ip = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlConnectionProfile"
    }
}

/// Specifies required connection parameters, and the parameters
/// required to create an AlloyDB destination cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlloyDbConnectionProfile {
    /// Required. The AlloyDB cluster ID that this connection profile is associated
    /// with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Immutable. Metadata used to create the destination AlloyDB cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::AlloyDbSettings>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlloyDbConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_id][crate::model::AlloyDbConnectionProfile::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::AlloyDbConnectionProfile::settings].
    pub fn set_settings<
        T: std::convert::Into<std::option::Option<crate::model::AlloyDbSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }
}

impl wkt::message::Message for AlloyDbConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbConnectionProfile"
    }
}

/// An entry for an Access Control list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlAclEntry {
    /// The allowlisted value for the access control list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// A label to identify this entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label: std::string::String,

    /// The access control entry entry expiration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::sql_acl_entry::Expiration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlAclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlAclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [label][crate::model::SqlAclEntry::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::sql_acl_entry::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::sql_acl_entry::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::sql_acl_entry::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for SqlAclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlAclEntry"
    }
}

/// Defines additional types related to [SqlAclEntry].
pub mod sql_acl_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The access control entry entry expiration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// The time when this access control entry expires in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example:
        /// `2012-11-15T16:19:00.094Z`.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The time-to-leave of this access control entry.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// IP Management configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlIpConfig {
    /// Whether the instance should be assigned an IPv4 address or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_ipv4: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_network: std::string::String,

    /// Optional. The name of the allocated IP address range for the private IP
    /// Cloud SQL instance. This name refers to an already allocated IP range
    /// address. If set, the instance IP address will be created in the allocated
    /// range. Note that this IP address range can't be modified after the instance
    /// is created. If you change the VPC when configuring connectivity settings
    /// for the migration job, this field is not relevant.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// Whether SSL connections over IP should be enforced or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. See
    /// <https://en.wikipedia.org/wiki/CIDR_notation#CIDR_notation>, also known as
    /// 'slash' notation (e.g. `192.168.100.0/24`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<crate::model::SqlAclEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SqlIpConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_ipv4][crate::model::SqlIpConfig::enable_ipv4].
    pub fn set_enable_ipv4<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_ipv4 = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::SqlIpConfig::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::SqlIpConfig::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::SqlIpConfig::require_ssl].
    pub fn set_require_ssl<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.require_ssl = v.into();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::SqlIpConfig::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlAclEntry>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlIpConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlIpConfig"
    }
}

/// Settings for creating a Cloud SQL database instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlSettings {
    /// The database engine type and version.
    pub database_version: crate::model::cloud_sql_settings::SqlDatabaseVersion,

    /// The resource labels for a Cloud SQL instance to use to annotate any related
    /// underlying resources such as Compute Engine VMs.
    /// An object containing a list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "18kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The tier (or machine type) for this instance, for example:
    /// `db-n1-standard-1` (MySQL instances) or
    /// `db-custom-1-3840` (PostgreSQL instances).
    /// For more information, see
    /// [Cloud SQL Instance
    /// Settings](https://cloud.google.com/sql/docs/mysql/instance-settings).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is 'RUNNABLE'. Valid values:
    ///
    /// 'ALWAYS': The instance is on, and remains so even in
    /// the absence of connection requests.
    ///
    /// `NEVER`: The instance is off; it is not activated, even if a
    /// connection request arrives.
    pub activation_policy: crate::model::cloud_sql_settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_config: std::option::Option<crate::model::SqlIpConfig>,

    /// [default: ON] If you enable this setting, Cloud SQL checks your available
    /// storage every 30 seconds. If the available storage falls below a threshold
    /// size, Cloud SQL automatically adds additional storage capacity. If the
    /// available storage repeatedly falls below the threshold size, Cloud SQL
    /// continues to add storage until it reaches the maximum of 30 TB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auto_storage_increase: std::option::Option<wkt::BoolValue>,

    /// The database flags passed to the Cloud SQL instance at startup.
    /// An object containing a list of "key": value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The type of storage: `PD_SSD` (default) or `PD_HDD`.
    pub data_disk_type: crate::model::cloud_sql_settings::SqlDataDiskType,

    /// The storage capacity available to the database, in GB.
    /// The minimum (and default) size is 10GB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// The Google Cloud Platform zone where your Cloud SQL database instance is
    /// located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Optional. The Google Cloud Platform zone where the failover Cloud SQL
    /// database instance is located. Used when the Cloud SQL database availability
    /// type is REGIONAL (i.e. multiple zones / highly available).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_zone: std::string::String,

    /// The Database Migration Service source connection profile ID,
    /// in the format:
    /// `projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_id: std::string::String,

    /// Input only. Initial root password.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_password: std::string::String,

    /// Output only. Indicates If this connection profile root password is stored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub root_password_set: bool,

    /// The Cloud SQL default instance level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// The KMS key name used for the csql instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmek_key_name: std::string::String,

    /// Optional. Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data availability.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    pub availability_type: crate::model::cloud_sql_settings::SqlAvailabilityType,

    /// Optional. The edition of the given Cloud SQL instance.
    pub edition: crate::model::cloud_sql_settings::Edition,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudSqlSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::CloudSqlSettings::database_version].
    pub fn set_database_version<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDatabaseVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::CloudSqlSettings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tier][crate::model::CloudSqlSettings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::CloudSqlSettings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_auto_resize_limit = v.into();
        self
    }

    /// Sets the value of [activation_policy][crate::model::CloudSqlSettings::activation_policy].
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_config][crate::model::CloudSqlSettings::ip_config].
    pub fn set_ip_config<T: std::convert::Into<std::option::Option<crate::model::SqlIpConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ip_config = v.into();
        self
    }

    /// Sets the value of [auto_storage_increase][crate::model::CloudSqlSettings::auto_storage_increase].
    pub fn set_auto_storage_increase<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_storage_increase = v.into();
        self
    }

    /// Sets the value of [database_flags][crate::model::CloudSqlSettings::database_flags].
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::CloudSqlSettings::data_disk_type].
    pub fn set_data_disk_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDataDiskType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::CloudSqlSettings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CloudSqlSettings::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::CloudSqlSettings::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CloudSqlSettings::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [root_password][crate::model::CloudSqlSettings::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [root_password_set][crate::model::CloudSqlSettings::root_password_set].
    pub fn set_root_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.root_password_set = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::CloudSqlSettings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::CloudSqlSettings::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::CloudSqlSettings::availability_type].
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlAvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::CloudSqlSettings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::cloud_sql_settings::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlSettings"
    }
}

/// Defines additional types related to [CloudSqlSettings].
pub mod cloud_sql_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when the instance should be activated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlActivationPolicy {
        /// unspecified policy.
        Unspecified,
        /// The instance is always up and running.
        Always,
        /// The instance should never spin up.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlActivationPolicy::value] or
        /// [SqlActivationPolicy::name].
        UnknownValue(sql_activation_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_activation_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlActivationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Never => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_ACTIVATION_POLICY_UNSPECIFIED"),
                Self::Always => std::option::Option::Some("ALWAYS"),
                Self::Never => std::option::Option::Some("NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlActivationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlActivationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Never,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlActivationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "ALWAYS" => Self::Always,
                "NEVER" => Self::Never,
                _ => Self::UnknownValue(sql_activation_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlActivationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Never => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlActivationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlActivationPolicy>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlActivationPolicy",
            ))
        }
    }

    /// The storage options for Cloud SQL databases.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlDataDiskType {
        /// Unspecified.
        Unspecified,
        /// SSD disk.
        PdSsd,
        /// HDD disk.
        PdHdd,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlDataDiskType::value] or
        /// [SqlDataDiskType::name].
        UnknownValue(sql_data_disk_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_data_disk_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlDataDiskType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PdSsd => std::option::Option::Some(1),
                Self::PdHdd => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_DATA_DISK_TYPE_UNSPECIFIED"),
                Self::PdSsd => std::option::Option::Some("PD_SSD"),
                Self::PdHdd => std::option::Option::Some("PD_HDD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlDataDiskType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlDataDiskType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlDataDiskType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PdSsd,
                2 => Self::PdHdd,
                _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlDataDiskType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PD_SSD" => Self::PdSsd,
                "PD_HDD" => Self::PdHdd,
                _ => Self::UnknownValue(sql_data_disk_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlDataDiskType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PdSsd => serializer.serialize_i32(1),
                Self::PdHdd => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlDataDiskType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDataDiskType>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlDataDiskType",
            ))
        }
    }

    /// The database engine type and version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlDatabaseVersion {
        /// Unspecified version.
        Unspecified,
        /// MySQL 5.6.
        Mysql56,
        /// MySQL 5.7.
        Mysql57,
        /// PostgreSQL 9.6.
        Postgres96,
        /// PostgreSQL 11.
        Postgres11,
        /// PostgreSQL 10.
        Postgres10,
        /// MySQL 8.0.
        Mysql80,
        /// PostgreSQL 12.
        Postgres12,
        /// PostgreSQL 13.
        Postgres13,
        /// PostgreSQL 14.
        Postgres14,
        /// PostgreSQL 15.
        Postgres15,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlDatabaseVersion::value] or
        /// [SqlDatabaseVersion::name].
        UnknownValue(sql_database_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_database_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlDatabaseVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Mysql56 => std::option::Option::Some(1),
                Self::Mysql57 => std::option::Option::Some(2),
                Self::Postgres96 => std::option::Option::Some(3),
                Self::Postgres11 => std::option::Option::Some(4),
                Self::Postgres10 => std::option::Option::Some(5),
                Self::Mysql80 => std::option::Option::Some(6),
                Self::Postgres12 => std::option::Option::Some(7),
                Self::Postgres13 => std::option::Option::Some(8),
                Self::Postgres14 => std::option::Option::Some(17),
                Self::Postgres15 => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_DATABASE_VERSION_UNSPECIFIED"),
                Self::Mysql56 => std::option::Option::Some("MYSQL_5_6"),
                Self::Mysql57 => std::option::Option::Some("MYSQL_5_7"),
                Self::Postgres96 => std::option::Option::Some("POSTGRES_9_6"),
                Self::Postgres11 => std::option::Option::Some("POSTGRES_11"),
                Self::Postgres10 => std::option::Option::Some("POSTGRES_10"),
                Self::Mysql80 => std::option::Option::Some("MYSQL_8_0"),
                Self::Postgres12 => std::option::Option::Some("POSTGRES_12"),
                Self::Postgres13 => std::option::Option::Some("POSTGRES_13"),
                Self::Postgres14 => std::option::Option::Some("POSTGRES_14"),
                Self::Postgres15 => std::option::Option::Some("POSTGRES_15"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlDatabaseVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlDatabaseVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlDatabaseVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Mysql56,
                2 => Self::Mysql57,
                3 => Self::Postgres96,
                4 => Self::Postgres11,
                5 => Self::Postgres10,
                6 => Self::Mysql80,
                7 => Self::Postgres12,
                8 => Self::Postgres13,
                17 => Self::Postgres14,
                18 => Self::Postgres15,
                _ => Self::UnknownValue(sql_database_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlDatabaseVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_DATABASE_VERSION_UNSPECIFIED" => Self::Unspecified,
                "MYSQL_5_6" => Self::Mysql56,
                "MYSQL_5_7" => Self::Mysql57,
                "POSTGRES_9_6" => Self::Postgres96,
                "POSTGRES_11" => Self::Postgres11,
                "POSTGRES_10" => Self::Postgres10,
                "MYSQL_8_0" => Self::Mysql80,
                "POSTGRES_12" => Self::Postgres12,
                "POSTGRES_13" => Self::Postgres13,
                "POSTGRES_14" => Self::Postgres14,
                "POSTGRES_15" => Self::Postgres15,
                _ => Self::UnknownValue(sql_database_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlDatabaseVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Mysql56 => serializer.serialize_i32(1),
                Self::Mysql57 => serializer.serialize_i32(2),
                Self::Postgres96 => serializer.serialize_i32(3),
                Self::Postgres11 => serializer.serialize_i32(4),
                Self::Postgres10 => serializer.serialize_i32(5),
                Self::Mysql80 => serializer.serialize_i32(6),
                Self::Postgres12 => serializer.serialize_i32(7),
                Self::Postgres13 => serializer.serialize_i32(8),
                Self::Postgres14 => serializer.serialize_i32(17),
                Self::Postgres15 => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlDatabaseVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlDatabaseVersion>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlDatabaseVersion",
            ))
        }
    }

    /// The availability type of the given Cloud SQL instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SqlAvailabilityType {
        /// This is an unknown Availability type.
        Unspecified,
        /// Zonal availablility instance.
        Zonal,
        /// Regional availability instance.
        Regional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SqlAvailabilityType::value] or
        /// [SqlAvailabilityType::name].
        UnknownValue(sql_availability_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sql_availability_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SqlAvailabilityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Zonal => std::option::Option::Some(1),
                Self::Regional => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SQL_AVAILABILITY_TYPE_UNSPECIFIED"),
                Self::Zonal => std::option::Option::Some("ZONAL"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SqlAvailabilityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SqlAvailabilityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SqlAvailabilityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Zonal,
                2 => Self::Regional,
                _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SqlAvailabilityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ZONAL" => Self::Zonal,
                "REGIONAL" => Self::Regional,
                _ => Self::UnknownValue(sql_availability_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SqlAvailabilityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Zonal => serializer.serialize_i32(1),
                Self::Regional => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SqlAvailabilityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SqlAvailabilityType>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.SqlAvailabilityType",
            ))
        }
    }

    /// The edition of the given Cloud SQL instance.
    /// Can be ENTERPRISE or ENTERPRISE_PLUS.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified,
        /// The instance is an enterprise edition.
        Enterprise,
        /// The instance is an enterprise plus edition.
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Edition::value] or
        /// [Edition::name].
        UnknownValue(edition::UnknownValue),
    }

    #[doc(hidden)]
    pub mod edition {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Edition {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EDITION_UNSPECIFIED"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Edition {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Edition {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Edition {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EDITION_UNSPECIFIED" => Self::Unspecified,
                "ENTERPRISE" => Self::Enterprise,
                "ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(edition::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Edition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Edition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Edition>::new(
                ".google.cloud.clouddms.v1.CloudSqlSettings.Edition",
            ))
        }
    }
}

/// Settings for creating an AlloyDB cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlloyDbSettings {
    /// Required. Input only. Initial user to setup during cluster creation.
    /// Required.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_user: std::option::Option<crate::model::alloy_db_settings::UserPassword>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: "projects/{project_number}/global/networks/{network_id}". This is
    /// required to create a cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_network: std::string::String,

    /// Labels for the AlloyDB cluster created by DMS. An object containing a list
    /// of 'key', 'value' pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_instance_settings:
        std::option::Option<crate::model::alloy_db_settings::PrimaryInstanceSettings>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::alloy_db_settings::EncryptionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AlloyDbSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_user][crate::model::AlloyDbSettings::initial_user].
    pub fn set_initial_user<
        T: std::convert::Into<std::option::Option<crate::model::alloy_db_settings::UserPassword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initial_user = v.into();
        self
    }

    /// Sets the value of [vpc_network][crate::model::AlloyDbSettings::vpc_network].
    pub fn set_vpc_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_network = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AlloyDbSettings::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [primary_instance_settings][crate::model::AlloyDbSettings::primary_instance_settings].
    pub fn set_primary_instance_settings<
        T: std::convert::Into<
                std::option::Option<crate::model::alloy_db_settings::PrimaryInstanceSettings>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.primary_instance_settings = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::AlloyDbSettings::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::alloy_db_settings::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for AlloyDbSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings"
    }
}

/// Defines additional types related to [AlloyDbSettings].
pub mod alloy_db_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The username/password for a database user. Used for specifying initial
    /// users at cluster creation time.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserPassword {
        /// The database username.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub user: std::string::String,

        /// The initial password for the user.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub password: std::string::String,

        /// Output only. Indicates if the initial_user.password field has been set.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub password_set: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UserPassword {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user][crate::model::alloy_db_settings::UserPassword::user].
        pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.user = v.into();
            self
        }

        /// Sets the value of [password][crate::model::alloy_db_settings::UserPassword::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [password_set][crate::model::alloy_db_settings::UserPassword::password_set].
        pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.password_set = v.into();
            self
        }
    }

    impl wkt::message::Message for UserPassword {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.UserPassword"
        }
    }

    /// Settings for the cluster's primary instance
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrimaryInstanceSettings {
        /// Required. The ID of the AlloyDB primary instance. The ID must satisfy the
        /// regex expression "[a-z0-9-]+".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Configuration for the machines that host the underlying
        /// database engine.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_config: std::option::Option<
            crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
        >,

        /// Database flags to pass to AlloyDB when DMS is creating the AlloyDB
        /// cluster and instances. See the AlloyDB documentation for how these can be
        /// used.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

        /// Labels for the AlloyDB primary instance created by DMS. An object
        /// containing a list of 'key', 'value' pairs.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// Output only. The private IP address for the Instance.
        /// This is the connection endpoint for an end-user application.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub private_ip: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrimaryInstanceSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::alloy_db_settings::PrimaryInstanceSettings::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [machine_config][crate::model::alloy_db_settings::PrimaryInstanceSettings::machine_config].
        pub fn set_machine_config<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_config = v.into();
            self
        }

        /// Sets the value of [database_flags][crate::model::alloy_db_settings::PrimaryInstanceSettings::database_flags].
        pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [labels][crate::model::alloy_db_settings::PrimaryInstanceSettings::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [private_ip][crate::model::alloy_db_settings::PrimaryInstanceSettings::private_ip].
        pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.private_ip = v.into();
            self
        }
    }

    impl wkt::message::Message for PrimaryInstanceSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings"
        }
    }

    /// Defines additional types related to [PrimaryInstanceSettings].
    pub mod primary_instance_settings {
        #[allow(unused_imports)]
        use super::*;

        /// MachineConfig describes the configuration of a machine.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MachineConfig {
            /// The number of CPU's in the VM instance.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub cpu_count: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MachineConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cpu_count][crate::model::alloy_db_settings::primary_instance_settings::MachineConfig::cpu_count].
            pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_count = v.into();
                self
            }
        }

        impl wkt::message::Message for MachineConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings.MachineConfig"
            }
        }
    }

    /// EncryptionConfig describes the encryption config of a cluster that is
    /// encrypted with a CMEK (customer-managed encryption key).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The fully-qualified resource name of the KMS key.
        /// Each Cloud KMS key is regionalized and has the following format:
        /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_name: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::alloy_db_settings::EncryptionConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.EncryptionConfig"
        }
    }
}

/// The source database will allow incoming connections from the public IP of the
/// destination database. You can retrieve the public IP of the Cloud SQL
/// instance from the Cloud SQL console or using Cloud SQL APIs. No additional
/// configuration is required.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticIpConnectivity {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticIpConnectivity"
    }
}

/// [Private Service Connect
/// connectivity](https://cloud.google.com/vpc/docs/private-service-connect#service-attachments)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateServiceConnectConnectivity {
    /// Required. A service attachment that exposes a database, and has the
    /// following format:
    /// projects/{project}/regions/{region}/serviceAttachments/{service_attachment_name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateServiceConnectConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PrivateServiceConnectConnectivity::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }
}

impl wkt::message::Message for PrivateServiceConnectConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateServiceConnectConnectivity"
    }
}

/// The details needed to configure a reverse SSH tunnel between the source and
/// destination databases. These details will be used when calling the
/// generateSshScript method (see
/// <https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs/generateSshScript>)
/// to produce the script that will help set up the reverse SSH tunnel, and to
/// set up the VPC peering between the Cloud SQL private network and the VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReverseSshConnectivity {
    /// Required. The IP of the virtual machine (Compute Engine) used as the
    /// bastion server for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_ip: std::string::String,

    /// Required. The forwarding port of the virtual machine (Compute Engine) used
    /// as the bastion server for the SSH tunnel.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vm_port: i32,

    /// The name of the virtual machine (Compute Engine) used as the bastion server
    /// for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm: std::string::String,

    /// The name of the VPC to peer with the Cloud SQL private network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReverseSshConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_ip][crate::model::ReverseSshConnectivity::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::ReverseSshConnectivity::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::ReverseSshConnectivity::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::ReverseSshConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for ReverseSshConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ReverseSshConnectivity"
    }
}

/// The details of the VPC where the source database is located in Google Cloud.
/// We will use this information to set up the VPC peering connection between
/// Cloud SQL and this VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcPeeringConnectivity {
    /// The name of the VPC network to peer with the Cloud SQL private network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc][crate::model::VpcPeeringConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConnectivity"
    }
}

/// Forward SSH Tunnel connectivity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForwardSshTunnelConnectivity {
    /// Required. Hostname for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Username for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Port for the SSH tunnel, default value is 22.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authentication_method:
        std::option::Option<crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ForwardSshTunnelConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::ForwardSshTunnelConnectivity::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ForwardSshTunnelConnectivity::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [port][crate::model::ForwardSshTunnelConnectivity::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method].
    ///
    /// Note that all the setters affecting `authentication_method` are mutually
    /// exclusive.
    pub fn set_authentication_method<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v.into()),
        );
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `PrivateKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn private_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `PrivateKey`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ForwardSshTunnelConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ForwardSshTunnelConnectivity"
    }
}

/// Defines additional types related to [ForwardSshTunnelConnectivity].
pub mod forward_ssh_tunnel_connectivity {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Input only. SSH password.
        Password(std::string::String),
        /// Input only. SSH private key.
        PrivateKey(std::string::String),
    }
}

/// Static IP address connectivity configured on service project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticServiceIpConnectivity {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StaticServiceIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticServiceIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticServiceIpConnectivity"
    }
}

/// Private Connectivity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnectivity {
    /// Required. The resource name (URI) of the private connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::PrivateConnectivity::private_connection].
    pub fn set_private_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnectivity"
    }
}

/// A message defining the database engine and provider.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseType {
    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The database engine.
    pub engine: crate::model::DatabaseEngine,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::DatabaseType::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::DatabaseType::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseType"
    }
}

/// Represents a Database Migration Service migration job object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationJob {
    /// The name (URI) of this migration job resource, in the form of:
    /// projects/{project}/locations/{location}/migrationJobs/{migrationJob}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the migration job resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the migration job resource was last
    /// updated. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for migration job to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The migration job display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The current migration job state.
    pub state: crate::model::migration_job::State,

    /// Output only. The current migration job phase.
    pub phase: crate::model::migration_job::Phase,

    /// Required. The migration job type.
    #[serde(rename = "type")]
    pub r#type: crate::model::migration_job::Type,

    /// The path to the dump file in Google Cloud Storage,
    /// in the format: (gs://[BUCKET_NAME]/[OBJECT_NAME]).
    /// This field and the "dump_flags" field are mutually exclusive.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_path: std::string::String,

    /// The initial dump flags.
    /// This field and the "dump_path" field are mutually exclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dump_flags: std::option::Option<crate::model::migration_job::DumpFlags>,

    /// Required. The resource name (URI) of the source connection profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    /// Required. The resource name (URI) of the destination connection profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    /// Output only. The duration of the migration job (in seconds). A duration in
    /// seconds with up to nine fractional digits, terminated by 's'. Example:
    /// "3.5s".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The database engine type and provider of the source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_database: std::option::Option<crate::model::DatabaseType>,

    /// The database engine type and provider of the destination.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_database: std::option::Option<crate::model::DatabaseType>,

    /// Output only. If the migration job is completed, the time when it was
    /// completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The conversion workspace used by the migration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspaceInfo>,

    /// This field can be used to select the entities to migrate as part of
    /// the migration job. It uses AIP-160 notation to select a subset of the
    /// entities configured on the associated conversion-workspace. This field
    /// should not be set on migration-jobs that are not associated with a
    /// conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The CMEK (customer-managed encryption key) fully qualified key name used
    /// for the migration job.
    /// This field supports all migration jobs types except for:
    ///
    /// * Mysql to Mysql (use the cmek field in the cloudsql connection profile
    ///   instead).
    /// * PostrgeSQL to PostgreSQL (use the cmek field in the cloudsql
    ///   connection profile instead).
    /// * PostgreSQL to AlloyDB (use the kms_key_name field in the alloydb
    ///   connection profile instead).
    ///   Each Cloud CMEK key has the following format:
    ///   projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmek_key_name: std::string::String,

    /// Optional. Data dump parallelism settings used by the migration.
    /// Currently applicable only for MySQL to Cloud SQL for MySQL migrations only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_config: std::option::Option<crate::model::migration_job::PerformanceConfig>,

    /// The connectivity method.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::migration_job::Connectivity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MigrationJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MigrationJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::MigrationJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::MigrationJob::phase].
    pub fn set_phase<T: std::convert::Into<crate::model::migration_job::Phase>>(
        mut self,
        v: T,
    ) -> Self {
        self.phase = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::migration_job::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dump_path][crate::model::MigrationJob::dump_path].
    pub fn set_dump_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_path = v.into();
        self
    }

    /// Sets the value of [dump_flags][crate::model::MigrationJob::dump_flags].
    pub fn set_dump_flags<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::DumpFlags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dump_flags = v.into();
        self
    }

    /// Sets the value of [source][crate::model::MigrationJob::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::MigrationJob::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::MigrationJob::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [error][crate::model::MigrationJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [source_database][crate::model::MigrationJob::source_database].
    pub fn set_source_database<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_database = v.into();
        self
    }

    /// Sets the value of [destination_database][crate::model::MigrationJob::destination_database].
    pub fn set_destination_database<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_database = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::MigrationJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::MigrationJob::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspaceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MigrationJob::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::MigrationJob::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [performance_config][crate::model::MigrationJob::performance_config].
    pub fn set_performance_config<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::PerformanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_config = v.into();
        self
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `ReverseSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn reverse_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReverseSshConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `ReverseSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_reverse_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ReverseSshConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `VpcPeeringConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_peering_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `VpcPeeringConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v.into()),
        );
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob"
    }
}

/// Defines additional types related to [MigrationJob].
pub mod migration_job {
    #[allow(unused_imports)]
    use super::*;

    /// Dump flag definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DumpFlag {
        /// The name of the flag
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The value of the flag.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DumpFlag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::migration_job::DumpFlag::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::migration_job::DumpFlag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for DumpFlag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlag"
        }
    }

    /// Dump flags definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DumpFlags {
        /// The flags for the initial dump.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dump_flags: std::vec::Vec<crate::model::migration_job::DumpFlag>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DumpFlags {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_flags][crate::model::migration_job::DumpFlags::dump_flags].
        pub fn set_dump_flags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migration_job::DumpFlag>,
        {
            use std::iter::Iterator;
            self.dump_flags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DumpFlags {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlags"
        }
    }

    /// Performance configuration definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceConfig {
        /// Initial dump parallelism level.
        pub dump_parallel_level: crate::model::migration_job::performance_config::DumpParallelLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_parallel_level][crate::model::migration_job::PerformanceConfig::dump_parallel_level].
        pub fn set_dump_parallel_level<
            T: std::convert::Into<crate::model::migration_job::performance_config::DumpParallelLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dump_parallel_level = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.PerformanceConfig"
        }
    }

    /// Defines additional types related to [PerformanceConfig].
    pub mod performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Describes the parallelism level during initial dump.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DumpParallelLevel {
            /// Unknown dump parallel level. Will be defaulted to OPTIMAL.
            Unspecified,
            /// Minimal parallel level.
            Min,
            /// Optimal parallel level.
            Optimal,
            /// Maximum parallel level.
            Max,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [DumpParallelLevel::value] or
            /// [DumpParallelLevel::name].
            UnknownValue(dump_parallel_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod dump_parallel_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl DumpParallelLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Min => std::option::Option::Some(1),
                    Self::Optimal => std::option::Option::Some(2),
                    Self::Max => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("DUMP_PARALLEL_LEVEL_UNSPECIFIED")
                    }
                    Self::Min => std::option::Option::Some("MIN"),
                    Self::Optimal => std::option::Option::Some("OPTIMAL"),
                    Self::Max => std::option::Option::Some("MAX"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for DumpParallelLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for DumpParallelLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for DumpParallelLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Min,
                    2 => Self::Optimal,
                    3 => Self::Max,
                    _ => Self::UnknownValue(dump_parallel_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for DumpParallelLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "DUMP_PARALLEL_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "MIN" => Self::Min,
                    "OPTIMAL" => Self::Optimal,
                    "MAX" => Self::Max,
                    _ => Self::UnknownValue(dump_parallel_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for DumpParallelLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Min => serializer.serialize_i32(1),
                    Self::Optimal => serializer.serialize_i32(2),
                    Self::Max => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for DumpParallelLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<DumpParallelLevel>::new(
                    ".google.cloud.clouddms.v1.MigrationJob.PerformanceConfig.DumpParallelLevel",
                ))
            }
        }
    }

    /// The current migration job states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the migration job is unknown.
        Unspecified,
        /// The migration job is down for maintenance.
        Maintenance,
        /// The migration job is in draft mode and no resources are created.
        Draft,
        /// The migration job is being created.
        Creating,
        /// The migration job is created and not started.
        NotStarted,
        /// The migration job is running.
        Running,
        /// The migration job failed.
        Failed,
        /// The migration job has been completed.
        Completed,
        /// The migration job is being deleted.
        Deleting,
        /// The migration job is being stopped.
        Stopping,
        /// The migration job is currently stopped.
        Stopped,
        /// The migration job has been deleted.
        Deleted,
        /// The migration job is being updated.
        Updating,
        /// The migration job is starting.
        Starting,
        /// The migration job is restarting.
        Restarting,
        /// The migration job is resuming.
        Resuming,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Maintenance => std::option::Option::Some(1),
                Self::Draft => std::option::Option::Some(2),
                Self::Creating => std::option::Option::Some(3),
                Self::NotStarted => std::option::Option::Some(4),
                Self::Running => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::Completed => std::option::Option::Some(7),
                Self::Deleting => std::option::Option::Some(8),
                Self::Stopping => std::option::Option::Some(9),
                Self::Stopped => std::option::Option::Some(10),
                Self::Deleted => std::option::Option::Some(11),
                Self::Updating => std::option::Option::Some(12),
                Self::Starting => std::option::Option::Some(13),
                Self::Restarting => std::option::Option::Some(14),
                Self::Resuming => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Restarting => std::option::Option::Some("RESTARTING"),
                Self::Resuming => std::option::Option::Some("RESUMING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Maintenance,
                2 => Self::Draft,
                3 => Self::Creating,
                4 => Self::NotStarted,
                5 => Self::Running,
                6 => Self::Failed,
                7 => Self::Completed,
                8 => Self::Deleting,
                9 => Self::Stopping,
                10 => Self::Stopped,
                11 => Self::Deleted,
                12 => Self::Updating,
                13 => Self::Starting,
                14 => Self::Restarting,
                15 => Self::Resuming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "MAINTENANCE" => Self::Maintenance,
                "DRAFT" => Self::Draft,
                "CREATING" => Self::Creating,
                "NOT_STARTED" => Self::NotStarted,
                "RUNNING" => Self::Running,
                "FAILED" => Self::Failed,
                "COMPLETED" => Self::Completed,
                "DELETING" => Self::Deleting,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                "STARTING" => Self::Starting,
                "RESTARTING" => Self::Restarting,
                "RESUMING" => Self::Resuming,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Maintenance => serializer.serialize_i32(1),
                Self::Draft => serializer.serialize_i32(2),
                Self::Creating => serializer.serialize_i32(3),
                Self::NotStarted => serializer.serialize_i32(4),
                Self::Running => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::Completed => serializer.serialize_i32(7),
                Self::Deleting => serializer.serialize_i32(8),
                Self::Stopping => serializer.serialize_i32(9),
                Self::Stopped => serializer.serialize_i32(10),
                Self::Deleted => serializer.serialize_i32(11),
                Self::Updating => serializer.serialize_i32(12),
                Self::Starting => serializer.serialize_i32(13),
                Self::Restarting => serializer.serialize_i32(14),
                Self::Resuming => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.MigrationJob.State",
            ))
        }
    }

    /// The current migration job phase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Phase {
        /// The phase of the migration job is unknown.
        Unspecified,
        /// The migration job is in the full dump phase.
        FullDump,
        /// The migration job is CDC phase.
        Cdc,
        /// The migration job is running the promote phase.
        PromoteInProgress,
        /// Only RDS flow - waiting for source writes to stop
        WaitingForSourceWritesToStop,
        /// Only RDS flow - the sources writes stopped, waiting for dump to begin
        PreparingTheDump,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Phase::value] or
        /// [Phase::name].
        UnknownValue(phase::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phase {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Phase {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FullDump => std::option::Option::Some(1),
                Self::Cdc => std::option::Option::Some(2),
                Self::PromoteInProgress => std::option::Option::Some(3),
                Self::WaitingForSourceWritesToStop => std::option::Option::Some(4),
                Self::PreparingTheDump => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PHASE_UNSPECIFIED"),
                Self::FullDump => std::option::Option::Some("FULL_DUMP"),
                Self::Cdc => std::option::Option::Some("CDC"),
                Self::PromoteInProgress => std::option::Option::Some("PROMOTE_IN_PROGRESS"),
                Self::WaitingForSourceWritesToStop => {
                    std::option::Option::Some("WAITING_FOR_SOURCE_WRITES_TO_STOP")
                }
                Self::PreparingTheDump => std::option::Option::Some("PREPARING_THE_DUMP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Phase {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Phase {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Phase {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FullDump,
                2 => Self::Cdc,
                3 => Self::PromoteInProgress,
                4 => Self::WaitingForSourceWritesToStop,
                5 => Self::PreparingTheDump,
                _ => Self::UnknownValue(phase::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Phase {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHASE_UNSPECIFIED" => Self::Unspecified,
                "FULL_DUMP" => Self::FullDump,
                "CDC" => Self::Cdc,
                "PROMOTE_IN_PROGRESS" => Self::PromoteInProgress,
                "WAITING_FOR_SOURCE_WRITES_TO_STOP" => Self::WaitingForSourceWritesToStop,
                "PREPARING_THE_DUMP" => Self::PreparingTheDump,
                _ => Self::UnknownValue(phase::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Phase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FullDump => serializer.serialize_i32(1),
                Self::Cdc => serializer.serialize_i32(2),
                Self::PromoteInProgress => serializer.serialize_i32(3),
                Self::WaitingForSourceWritesToStop => serializer.serialize_i32(4),
                Self::PreparingTheDump => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Phase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Phase>::new(
                ".google.cloud.clouddms.v1.MigrationJob.Phase",
            ))
        }
    }

    /// The type of migration job (one-time or continuous).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The type of the migration job is unknown.
        Unspecified,
        /// The migration job is a one time migration.
        OneTime,
        /// The migration job is a continuous migration.
        Continuous,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OneTime => std::option::Option::Some(1),
                Self::Continuous => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::OneTime => std::option::Option::Some("ONE_TIME"),
                Self::Continuous => std::option::Option::Some("CONTINUOUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OneTime,
                2 => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "ONE_TIME" => Self::OneTime,
                "CONTINUOUS" => Self::Continuous,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OneTime => serializer.serialize_i32(1),
                Self::Continuous => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.clouddms.v1.MigrationJob.Type",
            ))
        }
    }

    /// The connectivity method.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// The details needed to communicate to the source over Reverse SSH
        /// tunnel connectivity.
        ReverseSshConnectivity(std::boxed::Box<crate::model::ReverseSshConnectivity>),
        /// The details of the VPC network that the source database is located in.
        VpcPeeringConnectivity(std::boxed::Box<crate::model::VpcPeeringConnectivity>),
        /// static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
    }
}

/// A conversion workspace's version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversionWorkspaceInfo {
    /// The resource name (URI) of the conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The commit ID of the conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversionWorkspaceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspaceInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::ConversionWorkspaceInfo::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for ConversionWorkspaceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspaceInfo"
    }
}

/// A connection profile definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionProfile {
    /// The name of this connection profile resource in the form of
    /// projects/{project}/locations/{location}/connectionProfiles/{connectionProfile}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the resource was last updated.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for connection profile to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    pub state: crate::model::connection_profile::State,

    /// The connection profile display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The connection profile definition.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile:
        std::option::Option<crate::model::connection_profile::ConnectionProfile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ConnectionProfile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::ConnectionProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectionProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ConnectionProfile::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [provider][crate::model::ConnectionProfile::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile].
    ///
    /// Note that all the setters affecting `connection_profile` are mutually
    /// exclusive.
    pub fn set_connection_profile<
        T: std::convert::Into<
                std::option::Option<crate::model::connection_profile::ConnectionProfile>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Mysql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mysql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Mysql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Mysql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_mysql<
        T: std::convert::Into<std::boxed::Box<crate::model::MySqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Mysql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Postgresql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn postgresql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgreSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Postgresql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Postgresql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_postgresql<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgreSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Postgresql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Oracle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oracle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Oracle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Oracle`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_oracle<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Oracle(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Cloudsql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloudsql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Cloudsql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_cloudsql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v.into()),
        );
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Alloydb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn alloydb(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AlloyDbConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Alloydb(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Alloydb`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_alloydb<
        T: std::convert::Into<std::boxed::Box<crate::model::AlloyDbConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Alloydb(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConnectionProfile"
    }
}

/// Defines additional types related to [ConnectionProfile].
pub mod connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the connection profile is unknown.
        Unspecified,
        /// The connection profile is in draft mode and fully editable.
        Draft,
        /// The connection profile is being created.
        Creating,
        /// The connection profile is ready.
        Ready,
        /// The connection profile is being updated.
        Updating,
        /// The connection profile is being deleted.
        Deleting,
        /// The connection profile has been deleted.
        Deleted,
        /// The last action on the connection profile failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Updating => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Creating,
                3 => Self::Ready,
                4 => Self::Updating,
                5 => Self::Deleting,
                6 => Self::Deleted,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Updating => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.ConnectionProfile.State",
            ))
        }
    }

    /// The connection profile definition.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConnectionProfile {
        /// A MySQL database connection profile.
        Mysql(std::boxed::Box<crate::model::MySqlConnectionProfile>),
        /// A PostgreSQL database connection profile.
        Postgresql(std::boxed::Box<crate::model::PostgreSqlConnectionProfile>),
        /// An Oracle database connection profile.
        Oracle(std::boxed::Box<crate::model::OracleConnectionProfile>),
        /// A CloudSQL database connection profile.
        Cloudsql(std::boxed::Box<crate::model::CloudSqlConnectionProfile>),
        /// An AlloyDB cluster connection profile.
        Alloydb(std::boxed::Box<crate::model::AlloyDbConnectionProfile>),
    }
}

/// Error message of a verification Migration job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationJobVerificationError {
    /// Output only. An instance of ErrorCode specifying the error that occurred.
    pub error_code: crate::model::migration_job_verification_error::ErrorCode,

    /// Output only. A formatted message with further details about the error and a
    /// CTA.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// Output only. A specific detailed error message, if supplied by the engine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_detail_message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationJobVerificationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::MigrationJobVerificationError::error_code].
    pub fn set_error_code<
        T: std::convert::Into<crate::model::migration_job_verification_error::ErrorCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationJobVerificationError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [error_detail_message][crate::model::MigrationJobVerificationError::error_detail_message].
    pub fn set_error_detail_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_detail_message = v.into();
        self
    }
}

impl wkt::message::Message for MigrationJobVerificationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJobVerificationError"
    }
}

/// Defines additional types related to [MigrationJobVerificationError].
pub mod migration_job_verification_error {
    #[allow(unused_imports)]
    use super::*;

    /// A general error code describing the type of error that occurred.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// An unknown error occurred
        Unspecified,
        /// We failed to connect to one of the connection profile.
        ConnectionFailure,
        /// We failed to authenticate to one of the connection profile.
        AuthenticationFailure,
        /// One of the involved connection profiles has an invalid configuration.
        InvalidConnectionProfileConfig,
        /// The versions of the source and the destination are incompatible.
        VersionIncompatibility,
        /// The types of the source and the destination are incompatible.
        ConnectionProfileTypesIncompatibility,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses,
        /// Extensions installed are either not supported or having unsupported
        /// versions.
        UnsupportedExtensions,
        /// Unsupported migration type.
        UnsupportedMigrationType,
        /// Invalid RDS logical replication.
        InvalidRdsLogicalReplication,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode,
        /// The table definition is not support due to missing primary key or replica
        /// identity.
        UnsupportedTableDefinition,
        /// The definer is not supported.
        UnsupportedDefiner,
        /// Migration is already running at the time of restart request.
        CantRestartRunningMigration,
        /// The source already has a replication setup.
        SourceAlreadySetup,
        /// The source has tables with limited support.
        /// E.g. PostgreSQL tables without primary keys.
        TablesWithLimitedSupport,
        /// The source uses an unsupported locale.
        UnsupportedDatabaseLocale,
        /// The source uses an unsupported Foreign Data Wrapper configuration.
        UnsupportedDatabaseFdwConfig,
        /// There was an underlying RDBMS error.
        ErrorRdbms,
        /// The source DB size in Bytes exceeds a certain threshold. The migration
        /// might require an increase of quota, or might not be supported.
        SourceSizeExceedsThreshold,
        /// The destination DB contains existing databases that are conflicting with
        /// those in the source DB.
        ExistingConflictingDatabases,
        /// Insufficient privilege to enable the parallelism configuration.
        ParallelImportInsufficientPrivilege,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConnectionFailure => std::option::Option::Some(1),
                Self::AuthenticationFailure => std::option::Option::Some(2),
                Self::InvalidConnectionProfileConfig => std::option::Option::Some(3),
                Self::VersionIncompatibility => std::option::Option::Some(4),
                Self::ConnectionProfileTypesIncompatibility => std::option::Option::Some(5),
                Self::NoPglogicalInstalled => std::option::Option::Some(7),
                Self::PglogicalNodeAlreadyExists => std::option::Option::Some(8),
                Self::InvalidWalLevel => std::option::Option::Some(9),
                Self::InvalidSharedPreloadLibrary => std::option::Option::Some(10),
                Self::InsufficientMaxReplicationSlots => std::option::Option::Some(11),
                Self::InsufficientMaxWalSenders => std::option::Option::Some(12),
                Self::InsufficientMaxWorkerProcesses => std::option::Option::Some(13),
                Self::UnsupportedExtensions => std::option::Option::Some(14),
                Self::UnsupportedMigrationType => std::option::Option::Some(15),
                Self::InvalidRdsLogicalReplication => std::option::Option::Some(16),
                Self::UnsupportedGtidMode => std::option::Option::Some(17),
                Self::UnsupportedTableDefinition => std::option::Option::Some(18),
                Self::UnsupportedDefiner => std::option::Option::Some(19),
                Self::CantRestartRunningMigration => std::option::Option::Some(21),
                Self::SourceAlreadySetup => std::option::Option::Some(23),
                Self::TablesWithLimitedSupport => std::option::Option::Some(24),
                Self::UnsupportedDatabaseLocale => std::option::Option::Some(25),
                Self::UnsupportedDatabaseFdwConfig => std::option::Option::Some(26),
                Self::ErrorRdbms => std::option::Option::Some(27),
                Self::SourceSizeExceedsThreshold => std::option::Option::Some(28),
                Self::ExistingConflictingDatabases => std::option::Option::Some(29),
                Self::ParallelImportInsufficientPrivilege => std::option::Option::Some(30),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::ConnectionFailure => std::option::Option::Some("CONNECTION_FAILURE"),
                Self::AuthenticationFailure => std::option::Option::Some("AUTHENTICATION_FAILURE"),
                Self::InvalidConnectionProfileConfig => {
                    std::option::Option::Some("INVALID_CONNECTION_PROFILE_CONFIG")
                }
                Self::VersionIncompatibility => {
                    std::option::Option::Some("VERSION_INCOMPATIBILITY")
                }
                Self::ConnectionProfileTypesIncompatibility => {
                    std::option::Option::Some("CONNECTION_PROFILE_TYPES_INCOMPATIBILITY")
                }
                Self::NoPglogicalInstalled => std::option::Option::Some("NO_PGLOGICAL_INSTALLED"),
                Self::PglogicalNodeAlreadyExists => {
                    std::option::Option::Some("PGLOGICAL_NODE_ALREADY_EXISTS")
                }
                Self::InvalidWalLevel => std::option::Option::Some("INVALID_WAL_LEVEL"),
                Self::InvalidSharedPreloadLibrary => {
                    std::option::Option::Some("INVALID_SHARED_PRELOAD_LIBRARY")
                }
                Self::InsufficientMaxReplicationSlots => {
                    std::option::Option::Some("INSUFFICIENT_MAX_REPLICATION_SLOTS")
                }
                Self::InsufficientMaxWalSenders => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WAL_SENDERS")
                }
                Self::InsufficientMaxWorkerProcesses => {
                    std::option::Option::Some("INSUFFICIENT_MAX_WORKER_PROCESSES")
                }
                Self::UnsupportedExtensions => std::option::Option::Some("UNSUPPORTED_EXTENSIONS"),
                Self::UnsupportedMigrationType => {
                    std::option::Option::Some("UNSUPPORTED_MIGRATION_TYPE")
                }
                Self::InvalidRdsLogicalReplication => {
                    std::option::Option::Some("INVALID_RDS_LOGICAL_REPLICATION")
                }
                Self::UnsupportedGtidMode => std::option::Option::Some("UNSUPPORTED_GTID_MODE"),
                Self::UnsupportedTableDefinition => {
                    std::option::Option::Some("UNSUPPORTED_TABLE_DEFINITION")
                }
                Self::UnsupportedDefiner => std::option::Option::Some("UNSUPPORTED_DEFINER"),
                Self::CantRestartRunningMigration => {
                    std::option::Option::Some("CANT_RESTART_RUNNING_MIGRATION")
                }
                Self::SourceAlreadySetup => std::option::Option::Some("SOURCE_ALREADY_SETUP"),
                Self::TablesWithLimitedSupport => {
                    std::option::Option::Some("TABLES_WITH_LIMITED_SUPPORT")
                }
                Self::UnsupportedDatabaseLocale => {
                    std::option::Option::Some("UNSUPPORTED_DATABASE_LOCALE")
                }
                Self::UnsupportedDatabaseFdwConfig => {
                    std::option::Option::Some("UNSUPPORTED_DATABASE_FDW_CONFIG")
                }
                Self::ErrorRdbms => std::option::Option::Some("ERROR_RDBMS"),
                Self::SourceSizeExceedsThreshold => {
                    std::option::Option::Some("SOURCE_SIZE_EXCEEDS_THRESHOLD")
                }
                Self::ExistingConflictingDatabases => {
                    std::option::Option::Some("EXISTING_CONFLICTING_DATABASES")
                }
                Self::ParallelImportInsufficientPrivilege => {
                    std::option::Option::Some("PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConnectionFailure,
                2 => Self::AuthenticationFailure,
                3 => Self::InvalidConnectionProfileConfig,
                4 => Self::VersionIncompatibility,
                5 => Self::ConnectionProfileTypesIncompatibility,
                7 => Self::NoPglogicalInstalled,
                8 => Self::PglogicalNodeAlreadyExists,
                9 => Self::InvalidWalLevel,
                10 => Self::InvalidSharedPreloadLibrary,
                11 => Self::InsufficientMaxReplicationSlots,
                12 => Self::InsufficientMaxWalSenders,
                13 => Self::InsufficientMaxWorkerProcesses,
                14 => Self::UnsupportedExtensions,
                15 => Self::UnsupportedMigrationType,
                16 => Self::InvalidRdsLogicalReplication,
                17 => Self::UnsupportedGtidMode,
                18 => Self::UnsupportedTableDefinition,
                19 => Self::UnsupportedDefiner,
                21 => Self::CantRestartRunningMigration,
                23 => Self::SourceAlreadySetup,
                24 => Self::TablesWithLimitedSupport,
                25 => Self::UnsupportedDatabaseLocale,
                26 => Self::UnsupportedDatabaseFdwConfig,
                27 => Self::ErrorRdbms,
                28 => Self::SourceSizeExceedsThreshold,
                29 => Self::ExistingConflictingDatabases,
                30 => Self::ParallelImportInsufficientPrivilege,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "CONNECTION_FAILURE" => Self::ConnectionFailure,
                "AUTHENTICATION_FAILURE" => Self::AuthenticationFailure,
                "INVALID_CONNECTION_PROFILE_CONFIG" => Self::InvalidConnectionProfileConfig,
                "VERSION_INCOMPATIBILITY" => Self::VersionIncompatibility,
                "CONNECTION_PROFILE_TYPES_INCOMPATIBILITY" => {
                    Self::ConnectionProfileTypesIncompatibility
                }
                "NO_PGLOGICAL_INSTALLED" => Self::NoPglogicalInstalled,
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Self::PglogicalNodeAlreadyExists,
                "INVALID_WAL_LEVEL" => Self::InvalidWalLevel,
                "INVALID_SHARED_PRELOAD_LIBRARY" => Self::InvalidSharedPreloadLibrary,
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => Self::InsufficientMaxReplicationSlots,
                "INSUFFICIENT_MAX_WAL_SENDERS" => Self::InsufficientMaxWalSenders,
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => Self::InsufficientMaxWorkerProcesses,
                "UNSUPPORTED_EXTENSIONS" => Self::UnsupportedExtensions,
                "UNSUPPORTED_MIGRATION_TYPE" => Self::UnsupportedMigrationType,
                "INVALID_RDS_LOGICAL_REPLICATION" => Self::InvalidRdsLogicalReplication,
                "UNSUPPORTED_GTID_MODE" => Self::UnsupportedGtidMode,
                "UNSUPPORTED_TABLE_DEFINITION" => Self::UnsupportedTableDefinition,
                "UNSUPPORTED_DEFINER" => Self::UnsupportedDefiner,
                "CANT_RESTART_RUNNING_MIGRATION" => Self::CantRestartRunningMigration,
                "SOURCE_ALREADY_SETUP" => Self::SourceAlreadySetup,
                "TABLES_WITH_LIMITED_SUPPORT" => Self::TablesWithLimitedSupport,
                "UNSUPPORTED_DATABASE_LOCALE" => Self::UnsupportedDatabaseLocale,
                "UNSUPPORTED_DATABASE_FDW_CONFIG" => Self::UnsupportedDatabaseFdwConfig,
                "ERROR_RDBMS" => Self::ErrorRdbms,
                "SOURCE_SIZE_EXCEEDS_THRESHOLD" => Self::SourceSizeExceedsThreshold,
                "EXISTING_CONFLICTING_DATABASES" => Self::ExistingConflictingDatabases,
                "PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Self::ParallelImportInsufficientPrivilege
                }
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConnectionFailure => serializer.serialize_i32(1),
                Self::AuthenticationFailure => serializer.serialize_i32(2),
                Self::InvalidConnectionProfileConfig => serializer.serialize_i32(3),
                Self::VersionIncompatibility => serializer.serialize_i32(4),
                Self::ConnectionProfileTypesIncompatibility => serializer.serialize_i32(5),
                Self::NoPglogicalInstalled => serializer.serialize_i32(7),
                Self::PglogicalNodeAlreadyExists => serializer.serialize_i32(8),
                Self::InvalidWalLevel => serializer.serialize_i32(9),
                Self::InvalidSharedPreloadLibrary => serializer.serialize_i32(10),
                Self::InsufficientMaxReplicationSlots => serializer.serialize_i32(11),
                Self::InsufficientMaxWalSenders => serializer.serialize_i32(12),
                Self::InsufficientMaxWorkerProcesses => serializer.serialize_i32(13),
                Self::UnsupportedExtensions => serializer.serialize_i32(14),
                Self::UnsupportedMigrationType => serializer.serialize_i32(15),
                Self::InvalidRdsLogicalReplication => serializer.serialize_i32(16),
                Self::UnsupportedGtidMode => serializer.serialize_i32(17),
                Self::UnsupportedTableDefinition => serializer.serialize_i32(18),
                Self::UnsupportedDefiner => serializer.serialize_i32(19),
                Self::CantRestartRunningMigration => serializer.serialize_i32(21),
                Self::SourceAlreadySetup => serializer.serialize_i32(23),
                Self::TablesWithLimitedSupport => serializer.serialize_i32(24),
                Self::UnsupportedDatabaseLocale => serializer.serialize_i32(25),
                Self::UnsupportedDatabaseFdwConfig => serializer.serialize_i32(26),
                Self::ErrorRdbms => serializer.serialize_i32(27),
                Self::SourceSizeExceedsThreshold => serializer.serialize_i32(28),
                Self::ExistingConflictingDatabases => serializer.serialize_i32(29),
                Self::ParallelImportInsufficientPrivilege => serializer.serialize_i32(30),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.clouddms.v1.MigrationJobVerificationError.ErrorCode",
            ))
        }
    }
}

/// The PrivateConnection resource is used to establish private connectivity
/// with the customer's network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnection {
    /// The name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for private connections to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The private connection display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The state of the private connection.
    pub state: crate::model::private_connection::State,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::private_connection::Connectivity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::PrivateConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::PrivateConnection::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PrivateConnection::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [connectivity][crate::model::PrivateConnection::connectivity].
    ///
    /// Note that all the setters affecting `connectivity` are mutually
    /// exclusive.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::private_connection::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// if it holds a `VpcPeeringConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vpc_peering_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConfig>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// to hold a `VpcPeeringConfig`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnection"
    }
}

/// Defines additional types related to [PrivateConnection].
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Private Connection state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Unspecified,
        /// The private connection is in creation state - creating resources.
        Creating,
        /// The private connection has been created with all of its resources.
        Created,
        /// The private connection creation has failed.
        Failed,
        /// The private connection is being deleted.
        Deleting,
        /// Delete request has failed, resource is in invalid state.
        FailedToDelete,
        /// The private connection has been deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Created => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::FailedToDelete => std::option::Option::Some(5),
                Self::Deleted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::FailedToDelete => std::option::Option::Some("FAILED_TO_DELETE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Created,
                3 => Self::Failed,
                4 => Self::Deleting,
                5 => Self::FailedToDelete,
                6 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "CREATED" => Self::Created,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "FAILED_TO_DELETE" => Self::FailedToDelete,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Created => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::FailedToDelete => serializer.serialize_i32(5),
                Self::Deleted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.PrivateConnection.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// VPC peering configuration.
        VpcPeeringConfig(std::boxed::Box<crate::model::VpcPeeringConfig>),
    }
}

/// The VPC peering configuration is used to create VPC peering with the
/// consumer's VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcPeeringConfig {
    /// Required. Fully qualified name of the VPC that Database Migration Service
    /// will peer to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_name: std::string::String,

    /// Required. A free subnet for peering. (CIDR of /29)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpcPeeringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_name][crate::model::VpcPeeringConfig::vpc_name].
    pub fn set_vpc_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_name = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VpcPeeringConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConfig"
    }
}

/// The type and version of a source or destination database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseEngineInfo {
    /// Required. Engine type.
    pub engine: crate::model::DatabaseEngine,

    /// Required. Engine named version, for example 12.c.1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEngineInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engine][crate::model::DatabaseEngineInfo::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatabaseEngineInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseEngineInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEngineInfo"
    }
}

/// The main conversion workspace resource entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversionWorkspace {
    /// Full name of the workspace resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The source engine details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Required. The destination engine details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Optional. A generic list of settings for the workspace.
    /// The settings are database pair dependant and can indicate default behavior
    /// for the mapping rules engine or turn on or off specific features.
    /// Such examples can be: convert_foreign_key_to_interleave=true,
    /// skip_triggers=false, ignore_non_table_synonyms=true
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub global_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Whether the workspace has uncommitted changes (changes which
    /// were made after the workspace was committed).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub has_uncommitted_changes: bool,

    /// Output only. The latest commit ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_commit_id: std::string::String,

    /// Output only. The timestamp when the workspace was committed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_commit_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The display name for the workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConversionWorkspace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspace::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ConversionWorkspace::source].
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEngineInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ConversionWorkspace::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEngineInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [global_settings][crate::model::ConversionWorkspace::global_settings].
    pub fn set_global_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.global_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [has_uncommitted_changes][crate::model::ConversionWorkspace::has_uncommitted_changes].
    pub fn set_has_uncommitted_changes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_uncommitted_changes = v.into();
        self
    }

    /// Sets the value of [latest_commit_id][crate::model::ConversionWorkspace::latest_commit_id].
    pub fn set_latest_commit_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_commit_id = v.into();
        self
    }

    /// Sets the value of [latest_commit_time][crate::model::ConversionWorkspace::latest_commit_time].
    pub fn set_latest_commit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_commit_time = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConversionWorkspace::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConversionWorkspace::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversionWorkspace::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for ConversionWorkspace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspace"
    }
}

/// Execution log of a background job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackgroundJobLogEntry {
    /// The background job log entry ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of job that was executed.
    pub job_type: crate::model::BackgroundJobType,

    /// The timestamp when the background job was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the background job was finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Job completion state, i.e. the final state after the job
    /// completed.
    pub completion_state: crate::model::background_job_log_entry::JobCompletionState,

    /// Output only. Job completion comment, such as how many entities were seeded,
    /// how many warnings were found during conversion, and similar information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub completion_comment: std::string::String,

    /// Output only. Whether the client requested the conversion workspace to be
    /// committed after a successful completion of the job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub request_autocommit: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job_details: std::option::Option<crate::model::background_job_log_entry::JobDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackgroundJobLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BackgroundJobLogEntry::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::BackgroundJobLogEntry::job_type].
    pub fn set_job_type<T: std::convert::Into<crate::model::BackgroundJobType>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackgroundJobLogEntry::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::BackgroundJobLogEntry::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::BackgroundJobLogEntry::completion_state].
    pub fn set_completion_state<
        T: std::convert::Into<crate::model::background_job_log_entry::JobCompletionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }

    /// Sets the value of [completion_comment][crate::model::BackgroundJobLogEntry::completion_comment].
    pub fn set_completion_comment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_comment = v.into();
        self
    }

    /// Sets the value of [request_autocommit][crate::model::BackgroundJobLogEntry::request_autocommit].
    pub fn set_request_autocommit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.request_autocommit = v.into();
        self
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details].
    ///
    /// Note that all the setters affecting `job_details` are mutually
    /// exclusive.
    pub fn set_job_details<
        T: std::convert::Into<std::option::Option<crate::model::background_job_log_entry::JobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = v.into();
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `SeedJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn seed_job_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>
    {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `SeedJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_seed_job_details<
        T: std::convert::Into<std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ImportRulesJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_rules_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ImportRulesJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_import_rules_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ConvertJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn convert_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ConvertJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_convert_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v.into()),
        );
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ApplyJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn apply_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ApplyJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_apply_job_details<
        T: std::convert::Into<
                std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackgroundJobLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry"
    }
}

/// Defines additional types related to [BackgroundJobLogEntry].
pub mod background_job_log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Details regarding a Seed background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SeedJobDetails {
        /// Output only. The connection profile which was used for the seed job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection_profile: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SeedJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::SeedJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }
    }

    impl wkt::message::Message for SeedJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.SeedJobDetails"
        }
    }

    /// Details regarding an Import Rules background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportRulesJobDetails {
        /// Output only. File names used for the import rules job.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub files: std::vec::Vec<std::string::String>,

        /// Output only. The requested file format.
        pub file_format: crate::model::ImportRulesFileFormat,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportRulesJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [files][crate::model::background_job_log_entry::ImportRulesJobDetails::files].
        pub fn set_files<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.files = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [file_format][crate::model::background_job_log_entry::ImportRulesJobDetails::file_format].
        pub fn set_file_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
            mut self,
            v: T,
        ) -> Self {
            self.file_format = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportRulesJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ImportRulesJobDetails"
        }
    }

    /// Details regarding a Convert background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConvertJobDetails {
        /// Output only. AIP-160 based filter used to specify the entities to convert
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConvertJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ConvertJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ConvertJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ConvertJobDetails"
        }
    }

    /// Details regarding an Apply background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ApplyJobDetails {
        /// Output only. The connection profile which was used for the apply job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection_profile: std::string::String,

        /// Output only. AIP-160 based filter used to specify the entities to apply
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ApplyJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::ApplyJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ApplyJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ApplyJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ApplyJobDetails"
        }
    }

    /// Final state after a job completes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobCompletionState {
        /// The status is not specified. This state is used when job is not yet
        /// finished.
        Unspecified,
        /// Success.
        Succeeded,
        /// Error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobCompletionState::value] or
        /// [JobCompletionState::name].
        UnknownValue(job_completion_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_completion_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobCompletionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("JOB_COMPLETION_STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobCompletionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobCompletionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobCompletionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                _ => Self::UnknownValue(job_completion_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobCompletionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "JOB_COMPLETION_STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(job_completion_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobCompletionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobCompletionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobCompletionState>::new(
                ".google.cloud.clouddms.v1.BackgroundJobLogEntry.JobCompletionState",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum JobDetails {
        /// Output only. Seed job details.
        SeedJobDetails(std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>),
        /// Output only. Import rules job details.
        ImportRulesJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
        ),
        /// Output only. Convert job details.
        ConvertJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
        ),
        /// Output only. Apply job details.
        ApplyJobDetails(std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>),
    }
}

/// A filter defining the entities that a mapping rule should be applied to.
/// When more than one field is specified, the rule is applied only to
/// entities which match all the fields.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MappingRuleFilter {
    /// Optional. The rule should be applied to entities whose parent entity
    /// (fully qualified name) matches the given value.
    /// For example, if the rule applies to a table entity, the expected value
    /// should be a schema (schema). If the rule applies to a column or index
    /// entity, the expected value can be either a schema (schema) or a table
    /// (schema.table)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_entity: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// starts with the given prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_prefix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// ends with the given suffix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_suffix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// contains the given string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_contains: std::string::String,

    /// Optional. The rule should be applied to specific entities defined by their
    /// fully qualified names.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MappingRuleFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_entity][crate::model::MappingRuleFilter::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [entity_name_prefix][crate::model::MappingRuleFilter::entity_name_prefix].
    pub fn set_entity_name_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_prefix = v.into();
        self
    }

    /// Sets the value of [entity_name_suffix][crate::model::MappingRuleFilter::entity_name_suffix].
    pub fn set_entity_name_suffix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_suffix = v.into();
        self
    }

    /// Sets the value of [entity_name_contains][crate::model::MappingRuleFilter::entity_name_contains].
    pub fn set_entity_name_contains<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_contains = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::MappingRuleFilter::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MappingRuleFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRuleFilter"
    }
}

/// Definition of a transformation that is to be applied to a group of entities
/// in the source schema. Several such transformations can be applied to an
/// entity sequentially to define the corresponding entity in the target schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MappingRule {
    /// Full name of the mapping rule resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human readable name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The mapping rule state
    pub state: crate::model::mapping_rule::State,

    /// Required. The rule scope
    pub rule_scope: crate::model::DatabaseEntityType,

    /// Required. The rule filter
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::MappingRuleFilter>,

    /// Required. The order in which the rule is applied. Lower order rules are
    /// applied before higher value rules so they may end up being overridden.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rule_order: i64,

    /// Output only. The revision ID of the mapping rule.
    /// A new revision is committed whenever the mapping rule is changed in any
    /// way. The format is an 8-character hexadecimal string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The rule specific details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::mapping_rule::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MappingRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MappingRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MappingRule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MappingRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::mapping_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rule_scope][crate::model::MappingRule::rule_scope].
    pub fn set_rule_scope<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_scope = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MappingRule::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::MappingRuleFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [rule_order][crate::model::MappingRule::rule_order].
    pub fn set_rule_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rule_order = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::MappingRule::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::MappingRule::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::mapping_rule::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleEntityRename(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiEntityRename(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `EntityMove`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_move(&self) -> std::option::Option<&std::boxed::Box<crate::model::EntityMove>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::EntityMove(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `EntityMove`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_entity_move<T: std::convert::Into<std::boxed::Box<crate::model::EntityMove>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::mapping_rule::Details::EntityMove(v.into()));
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleColumnChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_column_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleColumnChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleColumnChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleColumnChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_column_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleColumnChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleColumnChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiColumnDataTypeChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_column_data_type_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiColumnDatatypeChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiColumnDataTypeChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_column_data_type_change<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiColumnDatatypeChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConditionalColumnSetValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn conditional_column_set_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConditionalColumnSetValue>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConditionalColumnSetValue`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_conditional_column_set_value<
        T: std::convert::Into<std::boxed::Box<crate::model::ConditionalColumnSetValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConvertRowidColumn`, `None` if the field is not set or
    /// holds a different branch.
    pub fn convert_rowid_column(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConvertRowIdToColumn>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConvertRowidColumn(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConvertRowidColumn`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_convert_rowid_column<
        T: std::convert::Into<std::boxed::Box<crate::model::ConvertRowIdToColumn>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConvertRowidColumn(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SetTablePrimaryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_table_primary_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SetTablePrimaryKey>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SetTablePrimaryKey`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_set_table_primary_key<
        T: std::convert::Into<std::boxed::Box<crate::model::SetTablePrimaryKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SinglePackageChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_package_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SinglePackageChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SinglePackageChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SinglePackageChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_package_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SinglePackageChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SinglePackageChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SourceSqlChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_sql_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceSqlChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SourceSqlChange(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SourceSqlChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_source_sql_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceSqlChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SourceSqlChange(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `FilterTableColumns`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_table_columns(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FilterTableColumns>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::FilterTableColumns(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `FilterTableColumns`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_filter_table_columns<
        T: std::convert::Into<std::boxed::Box<crate::model::FilterTableColumns>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::FilterTableColumns(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MappingRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRule"
    }
}

/// Defines additional types related to [MappingRule].
pub mod mapping_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The current mapping rule state such as enabled, disabled or deleted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the mapping rule is unknown.
        Unspecified,
        /// The rule is enabled.
        Enabled,
        /// The rule is disabled.
        Disabled,
        /// The rule is logically deleted.
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Deleted => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Deleted => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.clouddms.v1.MappingRule.State",
            ))
        }
    }

    /// The rule specific details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Optional. Rule to specify how a single entity should be renamed.
        SingleEntityRename(std::boxed::Box<crate::model::SingleEntityRename>),
        /// Optional. Rule to specify how multiple entities should be renamed.
        MultiEntityRename(std::boxed::Box<crate::model::MultiEntityRename>),
        /// Optional. Rule to specify how multiple entities should be relocated into
        /// a different schema.
        EntityMove(std::boxed::Box<crate::model::EntityMove>),
        /// Optional. Rule to specify how a single column is converted.
        SingleColumnChange(std::boxed::Box<crate::model::SingleColumnChange>),
        /// Optional. Rule to specify how multiple columns should be converted to a
        /// different data type.
        MultiColumnDataTypeChange(std::boxed::Box<crate::model::MultiColumnDatatypeChange>),
        /// Optional. Rule to specify how the data contained in a column should be
        /// transformed (such as trimmed, rounded, etc) provided that the data meets
        /// certain criteria.
        ConditionalColumnSetValue(std::boxed::Box<crate::model::ConditionalColumnSetValue>),
        /// Optional. Rule to specify how multiple tables should be converted with an
        /// additional rowid column.
        ConvertRowidColumn(std::boxed::Box<crate::model::ConvertRowIdToColumn>),
        /// Optional. Rule to specify the primary key for a table
        SetTablePrimaryKey(std::boxed::Box<crate::model::SetTablePrimaryKey>),
        /// Optional. Rule to specify how a single package is converted.
        SinglePackageChange(std::boxed::Box<crate::model::SinglePackageChange>),
        /// Optional. Rule to change the sql code for an entity, for example,
        /// function, procedure.
        SourceSqlChange(std::boxed::Box<crate::model::SourceSqlChange>),
        /// Optional. Rule to specify the list of columns to include or exclude from
        /// a table.
        FilterTableColumns(std::boxed::Box<crate::model::FilterTableColumns>),
    }
}

/// Options to configure rule type SingleEntityRename.
/// The rule is used to rename an entity.
///
/// The rule filter field can refer to only one entity.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT,
/// Synonym
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleEntityRename {
    /// Required. The new name of the destination entity
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name][crate::model::SingleEntityRename::new_name].
    pub fn set_new_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_name = v.into();
        self
    }
}

impl wkt::message::Message for SingleEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleEntityRename"
    }
}

/// Options to configure rule type MultiEntityRename.
/// The rule is used to rename multiple entities.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MultiEntityRename {
    /// Optional. The pattern used to generate the new entity's name. This pattern
    /// must include the characters '{name}', which will be replaced with the name
    /// of the original entity. For example, the pattern 't_{name}' for an entity
    /// name jobs would be converted to 't_jobs'.
    ///
    /// If unspecified, the default value for this field is '{name}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_name_pattern: std::string::String,

    /// Optional. Additional transformation that can be done on the source entity
    /// name before it is being used by the new_name_pattern, for example lower
    /// case. If no transformation is desired, use NO_TRANSFORMATION
    pub source_name_transformation: crate::model::EntityNameTransformation,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name_pattern][crate::model::MultiEntityRename::new_name_pattern].
    pub fn set_new_name_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_name_pattern = v.into();
        self
    }

    /// Sets the value of [source_name_transformation][crate::model::MultiEntityRename::source_name_transformation].
    pub fn set_source_name_transformation<
        T: std::convert::Into<crate::model::EntityNameTransformation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_name_transformation = v.into();
        self
    }
}

impl wkt::message::Message for MultiEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiEntityRename"
    }
}

/// Options to configure rule type EntityMove.
/// The rule is used to move an entity to a new schema.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table, Column, Constraint, Index, View,
/// Function, Stored Procedure, Materialized View, Sequence, UDT
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMove {
    /// Required. The new schema
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_schema: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMove {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_schema][crate::model::EntityMove::new_schema].
    pub fn set_new_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_schema = v.into();
        self
    }
}

impl wkt::message::Message for EntityMove {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMove"
    }
}

/// Options to configure rule type SingleColumnChange.
/// The rule is used to change the properties of a column.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Column.
///
/// When using this rule, if a field is not specified than the destination
/// column's configuration will be the same as the one in the source column..
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleColumnChange {
    /// Optional. Column data type name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Optional. Charset override - instead of table level charset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// Optional. Collation override - instead of table level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub length: i64,

    /// Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub precision: i32,

    /// Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub scale: i32,

    /// Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2)
    ///
    /// - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub fractional_seconds_precision: i32,

    /// Optional. Is the column of array type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub array: bool,

    /// Optional. The length of the array, only relevant if the column type is an
    /// array.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub array_length: i32,

    /// Optional. Is the column nullable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// Optional. Is the column auto-generated/identity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_generated: bool,

    /// Optional. Is the column a UDT (User-defined Type).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub udt: bool,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Optional. Specifies the list of values allowed in the column.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub set_values: std::vec::Vec<std::string::String>,

    /// Optional. Comment associated with the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SingleColumnChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_type][crate::model::SingleColumnChange::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::SingleColumnChange::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::SingleColumnChange::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::SingleColumnChange::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::SingleColumnChange::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::SingleColumnChange::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::SingleColumnChange::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::SingleColumnChange::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::SingleColumnChange::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::SingleColumnChange::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::SingleColumnChange::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::SingleColumnChange::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SingleColumnChange::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [set_values][crate::model::SingleColumnChange::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [comment][crate::model::SingleColumnChange::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }
}

impl wkt::message::Message for SingleColumnChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleColumnChange"
    }
}

/// Options to configure rule type MultiColumnDatatypeChange.
/// The rule is used to change the data type and associated properties of
/// multiple columns at once.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of:Column.
///
/// This rule requires additional filters to be specified beyond the basic rule
/// filter field, which is the source data type, but the rule supports additional
/// filtering capabilities such as the minimum and maximum field length. All
/// additional filters which are specified are required to be met in order for
/// the rule to be applied (logical AND between the fields).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MultiColumnDatatypeChange {
    /// Required. Filter on source data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_data_type_filter: std::string::String,

    /// Required. New data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_data_type: std::string::String,

    /// Optional. Column length - e.g. varchar (50) - if not specified and relevant
    /// uses the source column length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub override_length: i64,

    /// Optional. Column scale - when relevant - if not specified and relevant
    /// uses the source column scale.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub override_scale: i32,

    /// Optional. Column precision - when relevant - if not specified and relevant
    /// uses the source column precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub override_precision: i32,

    /// Optional. Column fractional seconds precision - used only for timestamp
    /// based datatypes - if not specified and relevant uses the source column
    /// fractional seconds precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub override_fractional_seconds_precision: i32,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Filter on source column parameters.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_filter:
        std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiColumnDatatypeChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_data_type_filter][crate::model::MultiColumnDatatypeChange::source_data_type_filter].
    pub fn set_source_data_type_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_data_type_filter = v.into();
        self
    }

    /// Sets the value of [new_data_type][crate::model::MultiColumnDatatypeChange::new_data_type].
    pub fn set_new_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_data_type = v.into();
        self
    }

    /// Sets the value of [override_length][crate::model::MultiColumnDatatypeChange::override_length].
    pub fn set_override_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.override_length = v.into();
        self
    }

    /// Sets the value of [override_scale][crate::model::MultiColumnDatatypeChange::override_scale].
    pub fn set_override_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_scale = v.into();
        self
    }

    /// Sets the value of [override_precision][crate::model::MultiColumnDatatypeChange::override_precision].
    pub fn set_override_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_precision = v.into();
        self
    }

    /// Sets the value of [override_fractional_seconds_precision][crate::model::MultiColumnDatatypeChange::override_fractional_seconds_precision].
    pub fn set_override_fractional_seconds_precision<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MultiColumnDatatypeChange::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter].
    ///
    /// Note that all the setters affecting `source_filter` are mutually
    /// exclusive.
    pub fn set_source_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MultiColumnDatatypeChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiColumnDatatypeChange"
    }
}

/// Defines additional types related to [MultiColumnDatatypeChange].
pub mod multi_column_datatype_change {
    #[allow(unused_imports)]
    use super::*;

    /// Filter on source column parameters.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Filter for text-based data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Filter for fixed point number data types such as
        /// NUMERIC/NUMBER.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Filter for text-based data types like varchar.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceTextFilter {
    /// Optional. The filter will match columns with length greater than or equal
    /// to this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub source_min_length_filter: i64,

    /// Optional. The filter will match columns with length smaller than or equal
    /// to this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub source_max_length_filter: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceTextFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_length_filter][crate::model::SourceTextFilter::source_min_length_filter].
    pub fn set_source_min_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_min_length_filter = v.into();
        self
    }

    /// Sets the value of [source_max_length_filter][crate::model::SourceTextFilter::source_max_length_filter].
    pub fn set_source_max_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_max_length_filter = v.into();
        self
    }
}

impl wkt::message::Message for SourceTextFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceTextFilter"
    }
}

/// Filter for fixed point number data types such as NUMERIC/NUMBER
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceNumericFilter {
    /// Optional. The filter will match columns with scale greater than or equal to
    /// this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub source_min_scale_filter: i32,

    /// Optional. The filter will match columns with scale smaller than or equal to
    /// this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub source_max_scale_filter: i32,

    /// Optional. The filter will match columns with precision greater than or
    /// equal to this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub source_min_precision_filter: i32,

    /// Optional. The filter will match columns with precision smaller than or
    /// equal to this number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub source_max_precision_filter: i32,

    /// Required. Enum to set the option defining the datatypes numeric filter has
    /// to be applied to
    pub numeric_filter_option: crate::model::NumericFilterOption,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceNumericFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_scale_filter][crate::model::SourceNumericFilter::source_min_scale_filter].
    pub fn set_source_min_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_max_scale_filter][crate::model::SourceNumericFilter::source_max_scale_filter].
    pub fn set_source_max_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_min_precision_filter][crate::model::SourceNumericFilter::source_min_precision_filter].
    pub fn set_source_min_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_precision_filter = v.into();
        self
    }

    /// Sets the value of [source_max_precision_filter][crate::model::SourceNumericFilter::source_max_precision_filter].
    pub fn set_source_max_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_precision_filter = v.into();
        self
    }

    /// Sets the value of [numeric_filter_option][crate::model::SourceNumericFilter::numeric_filter_option].
    pub fn set_numeric_filter_option<T: std::convert::Into<crate::model::NumericFilterOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.numeric_filter_option = v.into();
        self
    }
}

impl wkt::message::Message for SourceNumericFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceNumericFilter"
    }
}

/// Options to configure rule type ConditionalColumnSetValue.
/// The rule is used to transform the data which is being replicated/migrated.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConditionalColumnSetValue {
    /// Required. Description of data transformation during migration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value_transformation: std::option::Option<crate::model::ValueTransformation>,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_filter:
        std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConditionalColumnSetValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_transformation][crate::model::ConditionalColumnSetValue::value_transformation].
    pub fn set_value_transformation<
        T: std::convert::Into<std::option::Option<crate::model::ValueTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_transformation = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ConditionalColumnSetValue::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter].
    ///
    /// Note that all the setters affecting `source_filter` are mutually
    /// exclusive.
    pub fn set_source_filter<
        T: std::convert::Into<
                std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConditionalColumnSetValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConditionalColumnSetValue"
    }
}

/// Defines additional types related to [ConditionalColumnSetValue].
pub mod conditional_column_set_value {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Optional filter on source column length. Used for text based
        /// data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Optional filter on source column precision and scale. Used for
        /// fixed point numbers such as NUMERIC/NUMBER data types.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Description of data transformation during migration as part of the
/// ConditionalColumnSetValue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueTransformation {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::value_transformation::Filter>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::value_transformation::Action>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter].
    ///
    /// Note that all the setters affecting `filter` are mutually
    /// exclusive.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IsNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn is_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IsNull(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IsNull`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_is_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.filter =
            std::option::Option::Some(crate::model::value_transformation::Filter::IsNull(v.into()));
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `ValueList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn value_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValueListFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::ValueList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `ValueList`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_value_list<T: std::convert::Into<std::boxed::Box<crate::model::ValueListFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::ValueList(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IntComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IntComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IntComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_int_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::IntComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::IntComparison(v.into()),
        );
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `DoubleComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DoubleComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::DoubleComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `DoubleComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_double_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::DoubleComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::DoubleComparison(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignNull(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignNull`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignNull(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignSpecificValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_specific_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AssignSpecificValue>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignSpecificValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignSpecificValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_specific_value<
        T: std::convert::Into<std::boxed::Box<crate::model::AssignSpecificValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignSpecificValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMinValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_min_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMinValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMinValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_min_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMinValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMaxValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assign_max_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMaxValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMaxValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_max_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMaxValue(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `RoundScale`, `None` if the field is not set or
    /// holds a different branch.
    pub fn round_scale(&self) -> std::option::Option<&std::boxed::Box<crate::model::RoundToScale>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::RoundScale(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `RoundScale`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_round_scale<T: std::convert::Into<std::boxed::Box<crate::model::RoundToScale>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::RoundScale(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `ApplyHash`, `None` if the field is not set or
    /// holds a different branch.
    pub fn apply_hash(&self) -> std::option::Option<&std::boxed::Box<crate::model::ApplyHash>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::ApplyHash(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `ApplyHash`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_apply_hash<T: std::convert::Into<std::boxed::Box<crate::model::ApplyHash>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::ApplyHash(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValueTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueTransformation"
    }
}

/// Defines additional types related to [ValueTransformation].
pub mod value_transformation {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. Value is null
        IsNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Value is found in the specified list.
        ValueList(std::boxed::Box<crate::model::ValueListFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type integer.
        IntComparison(std::boxed::Box<crate::model::IntComparisonFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type double.
        DoubleComparison(std::boxed::Box<crate::model::DoubleComparisonFilter>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Optional. Set to null
        AssignNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to a specific value (value is converted to fit the target
        /// data type)
        AssignSpecificValue(std::boxed::Box<crate::model::AssignSpecificValue>),
        /// Optional. Set to min_value - if integer or numeric, will use
        /// int.minvalue, etc
        AssignMinValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to max_value - if integer or numeric, will use
        /// int.maxvalue, etc
        AssignMaxValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Allows the data to change scale
        RoundScale(std::boxed::Box<crate::model::RoundToScale>),
        /// Optional. Applies a hash function on the data
        ApplyHash(std::boxed::Box<crate::model::ApplyHash>),
    }
}

/// Options to configure rule type ConvertROWIDToColumn.
/// The rule is used to add column rowid to destination tables based on an Oracle
/// rowid function/property.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table.
///
/// This rule requires additional filter to be specified beyond the basic rule
/// filter field, which is whether or not to work on tables which already have a
/// primary key defined.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConvertRowIdToColumn {
    /// Required. Only work on tables without primary key defined
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub only_if_no_primary_key: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConvertRowIdToColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [only_if_no_primary_key][crate::model::ConvertRowIdToColumn::only_if_no_primary_key].
    pub fn set_only_if_no_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.only_if_no_primary_key = v.into();
        self
    }
}

impl wkt::message::Message for ConvertRowIdToColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertRowIdToColumn"
    }
}

/// Options to configure rule type SetTablePrimaryKey.
/// The rule is used to specify the columns and name to configure/alter the
/// primary key of a table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetTablePrimaryKey {
    /// Required. List of column names for the primary key
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub primary_key_columns: std::vec::Vec<std::string::String>,

    /// Optional. Name for the primary key
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetTablePrimaryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_key_columns][crate::model::SetTablePrimaryKey::primary_key_columns].
    pub fn set_primary_key_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.primary_key_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [primary_key][crate::model::SetTablePrimaryKey::primary_key].
    pub fn set_primary_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }
}

impl wkt::message::Message for SetTablePrimaryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SetTablePrimaryKey"
    }
}

/// Options to configure rule type SinglePackageChange.
/// The rule is used to alter the sql code for a package entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Package
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SinglePackageChange {
    /// Optional. Sql code for package description
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_description: std::string::String,

    /// Optional. Sql code for package body
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_body: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SinglePackageChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_description][crate::model::SinglePackageChange::package_description].
    pub fn set_package_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_description = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::SinglePackageChange::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }
}

impl wkt::message::Message for SinglePackageChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SinglePackageChange"
    }
}

/// Options to configure rule type SourceSqlChange.
/// The rule is used to alter the sql code for database entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: StoredProcedure, Function, Trigger, View
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceSqlChange {
    /// Required. Sql code for source (stored procedure, function, trigger or view)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceSqlChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::SourceSqlChange::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }
}

impl wkt::message::Message for SourceSqlChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceSqlChange"
    }
}

/// Options to configure rule type FilterTableColumns.
/// The rule is used to filter the list of columns to include or exclude from a
/// table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Table
///
/// Only one of the two lists can be specified for the rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterTableColumns {
    /// Optional. List of columns to be included for a particular table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_columns: std::vec::Vec<std::string::String>,

    /// Optional. List of columns to be excluded for a particular table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclude_columns: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FilterTableColumns {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_columns][crate::model::FilterTableColumns::include_columns].
    pub fn set_include_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_columns][crate::model::FilterTableColumns::exclude_columns].
    pub fn set_exclude_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FilterTableColumns {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FilterTableColumns"
    }
}

/// A list of values to filter by in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueListFilter {
    /// Required. Indicates whether the filter matches rows with values that are
    /// present in the list or those with values not present in it.
    pub value_present_list: crate::model::ValuePresentInList,

    /// Required. The list to be used to filter by
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    /// Required. Whether to ignore case when filtering by values. Defaults to
    /// false
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ignore_case: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueListFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_present_list][crate::model::ValueListFilter::value_present_list].
    pub fn set_value_present_list<T: std::convert::Into<crate::model::ValuePresentInList>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_present_list = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ValueListFilter::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_case][crate::model::ValueListFilter::ignore_case].
    pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_case = v.into();
        self
    }
}

impl wkt::message::Message for ValueListFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueListFilter"
    }
}

/// Filter based on relation between source value and compare value of type
/// integer in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Integer compare value to be used
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub value: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::IntComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::IntComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for IntComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IntComparisonFilter"
    }
}

/// Filter based on relation between source
/// value and compare value of type double in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DoubleComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Double compare value to be used
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub value: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DoubleComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::DoubleComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DoubleComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DoubleComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DoubleComparisonFilter"
    }
}

/// Set to a specific value (value is converted to fit the target data type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignSpecificValue {
    /// Required. Specific value to be assigned
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssignSpecificValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AssignSpecificValue::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for AssignSpecificValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AssignSpecificValue"
    }
}

/// Apply a hash function on the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyHash {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub hash_function: std::option::Option<crate::model::apply_hash::HashFunction>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplyHash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hash_function][crate::model::ApplyHash::hash_function].
    ///
    /// Note that all the setters affecting `hash_function` are mutually
    /// exclusive.
    pub fn set_hash_function<
        T: std::convert::Into<std::option::Option<crate::model::apply_hash::HashFunction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = v.into();
        self
    }

    /// The value of [hash_function][crate::model::ApplyHash::hash_function]
    /// if it holds a `UuidFromBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uuid_from_bytes(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.hash_function.as_ref().and_then(|v| match v {
            crate::model::apply_hash::HashFunction::UuidFromBytes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hash_function][crate::model::ApplyHash::hash_function]
    /// to hold a `UuidFromBytes`.
    ///
    /// Note that all the setters affecting `hash_function` are
    /// mutually exclusive.
    pub fn set_uuid_from_bytes<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = std::option::Option::Some(
            crate::model::apply_hash::HashFunction::UuidFromBytes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ApplyHash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyHash"
    }
}

/// Defines additional types related to [ApplyHash].
pub mod apply_hash {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HashFunction {
        /// Optional. Generate UUID from the data's byte array
        UuidFromBytes(std::boxed::Box<wkt::Empty>),
    }
}

/// This allows the data to change scale, for example if the source is 2 digits
/// after the decimal point, specify round to scale value = 2. If for example the
/// value needs to be converted to an integer, use round to scale value = 0.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RoundToScale {
    /// Required. Scale value to be used
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub scale: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RoundToScale {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scale][crate::model::RoundToScale::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }
}

impl wkt::message::Message for RoundToScale {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RoundToScale"
    }
}

/// The base entity type for all the database related entities.
/// The message contains the entity name, the name of its parent, the entity
/// type, and the specific details per entity type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseEntity {
    /// The short name (e.g. table name) of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub short_name: std::string::String,

    /// The full name of the parent entity (e.g. schema name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_entity: std::string::String,

    /// The type of tree the entity belongs to.
    pub tree: crate::model::database_entity::TreeType,

    /// The type of the database entity (table, view, index, ...).
    pub entity_type: crate::model::DatabaseEntityType,

    /// Details about entity mappings.
    /// For source tree entities, this holds the draft entities which were
    /// generated by the mapping rules.
    /// For draft tree entities, this holds the source entities which were
    /// converted to form the draft entity.
    /// Destination entities will have no mapping details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mappings: std::vec::Vec<crate::model::EntityMapping>,

    /// Details about the entity DDL script. Multiple DDL scripts are provided for
    /// child entities such as a table entity will have one DDL for the table with
    /// additional DDLs for each index, constraint and such.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_ddl: std::vec::Vec<crate::model::EntityDdl>,

    /// Details about the various issues found for the entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issues: std::vec::Vec<crate::model::EntityIssue>,

    /// The specific body for each entity type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entity_body: std::option::Option<crate::model::database_entity::EntityBody>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [short_name][crate::model::DatabaseEntity::short_name].
    pub fn set_short_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_name = v.into();
        self
    }

    /// Sets the value of [parent_entity][crate::model::DatabaseEntity::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DatabaseEntity::tree].
    pub fn set_tree<T: std::convert::Into<crate::model::database_entity::TreeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::DatabaseEntity::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [mappings][crate::model::DatabaseEntity::mappings].
    pub fn set_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMapping>,
    {
        use std::iter::Iterator;
        self.mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_ddl][crate::model::DatabaseEntity::entity_ddl].
    pub fn set_entity_ddl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityDdl>,
    {
        use std::iter::Iterator;
        self.entity_ddl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [issues][crate::model::DatabaseEntity::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityIssue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body].
    ///
    /// Note that all the setters affecting `entity_body` are mutually
    /// exclusive.
    pub fn set_entity_body<
        T: std::convert::Into<std::option::Option<crate::model::database_entity::EntityBody>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = v.into();
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Database`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseInstanceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Database(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Database`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseInstanceEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Database(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::SchemaEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Schema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::SchemaEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Schema(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::TableEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Table(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `View`, `None` if the field is not set or
    /// holds a different branch.
    pub fn view(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::View(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `View`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_view<T: std::convert::Into<std::boxed::Box<crate::model::ViewEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::View(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Sequence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sequence(&self) -> std::option::Option<&std::boxed::Box<crate::model::SequenceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Sequence(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Sequence`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_sequence<T: std::convert::Into<std::boxed::Box<crate::model::SequenceEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Sequence(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `StoredProcedure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn stored_procedure(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StoredProcedureEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::StoredProcedure(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `StoredProcedure`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_stored_procedure<
        T: std::convert::Into<std::boxed::Box<crate::model::StoredProcedureEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::StoredProcedure(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabaseFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_function(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabaseFunction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabaseFunction`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_function<
        T: std::convert::Into<std::boxed::Box<crate::model::FunctionEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabaseFunction(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Synonym`, `None` if the field is not set or
    /// holds a different branch.
    pub fn synonym(&self) -> std::option::Option<&std::boxed::Box<crate::model::SynonymEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Synonym(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Synonym`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_synonym<T: std::convert::Into<std::boxed::Box<crate::model::SynonymEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Synonym(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabasePackage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn database_package(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PackageEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabasePackage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabasePackage`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_package<
        T: std::convert::Into<std::boxed::Box<crate::model::PackageEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabasePackage(v.into()),
        );
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Udt`, `None` if the field is not set or
    /// holds a different branch.
    pub fn udt(&self) -> std::option::Option<&std::boxed::Box<crate::model::UDTEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Udt(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Udt`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_udt<T: std::convert::Into<std::boxed::Box<crate::model::UDTEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Udt(v.into()));
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `MaterializedView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn materialized_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaterializedViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::MaterializedView(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `MaterializedView`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_materialized_view<
        T: std::convert::Into<std::boxed::Box<crate::model::MaterializedViewEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::MaterializedView(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEntity"
    }
}

/// Defines additional types related to [DatabaseEntity].
pub mod database_entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of database entities tree.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TreeType {
        /// Tree type unspecified.
        Unspecified,
        /// Tree of entities loaded from a source database.
        Source,
        /// Tree of entities converted from the source tree using the mapping rules.
        Draft,
        /// Tree of entities observed on the destination database.
        Destination,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TreeType::value] or
        /// [TreeType::name].
        UnknownValue(tree_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tree_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TreeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Source => std::option::Option::Some(1),
                Self::Draft => std::option::Option::Some(2),
                Self::Destination => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TREE_TYPE_UNSPECIFIED"),
                Self::Source => std::option::Option::Some("SOURCE"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Destination => std::option::Option::Some("DESTINATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TreeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TreeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TreeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Source,
                2 => Self::Draft,
                3 => Self::Destination,
                _ => Self::UnknownValue(tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TreeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TREE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SOURCE" => Self::Source,
                "DRAFT" => Self::Draft,
                "DESTINATION" => Self::Destination,
                _ => Self::UnknownValue(tree_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TreeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Source => serializer.serialize_i32(1),
                Self::Draft => serializer.serialize_i32(2),
                Self::Destination => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TreeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TreeType>::new(
                ".google.cloud.clouddms.v1.DatabaseEntity.TreeType",
            ))
        }
    }

    /// The specific body for each entity type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EntityBody {
        /// Database.
        Database(std::boxed::Box<crate::model::DatabaseInstanceEntity>),
        /// Schema.
        Schema(std::boxed::Box<crate::model::SchemaEntity>),
        /// Table.
        Table(std::boxed::Box<crate::model::TableEntity>),
        /// View.
        View(std::boxed::Box<crate::model::ViewEntity>),
        /// Sequence.
        Sequence(std::boxed::Box<crate::model::SequenceEntity>),
        /// Stored procedure.
        StoredProcedure(std::boxed::Box<crate::model::StoredProcedureEntity>),
        /// Function.
        DatabaseFunction(std::boxed::Box<crate::model::FunctionEntity>),
        /// Synonym.
        Synonym(std::boxed::Box<crate::model::SynonymEntity>),
        /// Package.
        DatabasePackage(std::boxed::Box<crate::model::PackageEntity>),
        /// UDT.
        Udt(std::boxed::Box<crate::model::UDTEntity>),
        /// Materialized view.
        MaterializedView(std::boxed::Box<crate::model::MaterializedViewEntity>),
    }
}

/// DatabaseInstance acts as a parent entity to other database entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseInstanceEntity {
    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseInstanceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::DatabaseInstanceEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseInstanceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseInstanceEntity"
    }
}

/// Schema typically has no parent entity, but can have a parent entity
/// DatabaseInstance (for database engines which support it).  For some database
/// engines, the terms  schema and user can be used interchangeably when they
/// refer to a namespace or a collection of other database entities. Can store
/// additional information which is schema specific.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SchemaEntity {
    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchemaEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::SchemaEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SchemaEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SchemaEntity"
    }
}

/// Table's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableEntity {
    /// Table columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::ColumnEntity>,

    /// Table constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,

    /// Table indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indices: std::vec::Vec<crate::model::IndexEntity>,

    /// Table triggers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::TriggerEntity>,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Comment associated with the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TableEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [columns][crate::model::TableEntity::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnEntity>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraints][crate::model::TableEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [indices][crate::model::TableEntity::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexEntity>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [triggers][crate::model::TableEntity::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TriggerEntity>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_features][crate::model::TableEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::TableEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }
}

impl wkt::message::Message for TableEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TableEntity"
    }
}

/// Column is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnEntity {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Column data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Charset override - instead of table level charset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// Collation override - instead of table level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Column length - e.g. varchar (50).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub length: i64,

    /// Column precision - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub precision: i32,

    /// Column scale - when relevant.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub scale: i32,

    /// Column fractional second precision - used for timestamp based datatypes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub fractional_seconds_precision: i32,

    /// Is the column of array type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub array: bool,

    /// If the column is array, of which length.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub array_length: i32,

    /// Is the column nullable.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub nullable: bool,

    /// Is the column auto-generated/identity.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub auto_generated: bool,

    /// Is the column a UDT.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub udt: bool,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Specifies the list of values allowed in the column.
    /// Only used for set data type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub set_values: std::vec::Vec<std::string::String>,

    /// Comment associated with the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    /// Column order in the table.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ordinal_position: i32,

    /// Default value of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_value: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::ColumnEntity::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::ColumnEntity::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::ColumnEntity::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::ColumnEntity::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::ColumnEntity::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::ColumnEntity::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::ColumnEntity::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::ColumnEntity::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::ColumnEntity::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::ColumnEntity::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::ColumnEntity::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::ColumnEntity::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ColumnEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [set_values][crate::model::ColumnEntity::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [comment][crate::model::ColumnEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnEntity::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnEntity::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }
}

impl wkt::message::Message for ColumnEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ColumnEntity"
    }
}

/// Constraint is not used as an independent entity, it is retrieved
/// as part of another entity such as Table or View.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConstraintEntity {
    /// The name of the table constraint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of constraint, for example unique, primary key, foreign key (currently
    /// only primary key is supported).
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Table columns used as part of the Constraint, for example primary key
    /// constraint should list the columns which constitutes the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Reference columns which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full names
    /// of referenced columns by the foreign key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reference_columns: std::vec::Vec<std::string::String>,

    /// Reference table which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full name
    /// of the referenced table by the foreign key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reference_table: std::string::String,

    /// Table which is associated with the constraint. In case the constraint
    /// is defined on a table, this field is left empty as this information is
    /// stored in parent_name. However, if constraint is defined on a view, this
    /// field stores the table name on which the view is defined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConstraintEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConstraintEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ConstraintEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::ConstraintEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_features][crate::model::ConstraintEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [reference_columns][crate::model::ConstraintEntity::reference_columns].
    pub fn set_reference_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reference_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reference_table][crate::model::ConstraintEntity::reference_table].
    pub fn set_reference_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_table = v.into();
        self
    }

    /// Sets the value of [table_name][crate::model::ConstraintEntity::table_name].
    pub fn set_table_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_name = v.into();
        self
    }
}

impl wkt::message::Message for ConstraintEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConstraintEntity"
    }
}

/// Index is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexEntity {
    /// The name of the index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of index, for example B-TREE.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Table columns used as part of the Index, for example B-TREE index should
    /// list the columns which constitutes the index.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Boolean value indicating whether the index is unique.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub unique: bool,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IndexEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IndexEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::IndexEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::IndexEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unique][crate::model::IndexEntity::unique].
    pub fn set_unique<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::IndexEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for IndexEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IndexEntity"
    }
}

/// Trigger is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TriggerEntity {
    /// The name of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The DML, DDL, or database events that fire the trigger, for example
    /// INSERT, UPDATE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggering_events: std::vec::Vec<std::string::String>,

    /// Indicates when the trigger fires, for example BEFORE STATEMENT, AFTER EACH
    /// ROW.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_type: std::string::String,

    /// The SQL code which creates the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TriggerEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TriggerEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [triggering_events][crate::model::TriggerEntity::triggering_events].
    pub fn set_triggering_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.triggering_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trigger_type][crate::model::TriggerEntity::trigger_type].
    pub fn set_trigger_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_type = v.into();
        self
    }

    /// Sets the value of [sql_code][crate::model::TriggerEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::TriggerEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for TriggerEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TriggerEntity"
    }
}

/// View's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViewEntity {
    /// The SQL code which creates the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// View constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::ViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ViewEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ViewEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ViewEntity"
    }
}

/// Sequence's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SequenceEntity {
    /// Increment value for the sequence.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub increment: i64,

    /// Start number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub start_value: ::bytes::Bytes,

    /// Maximum number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub max_value: ::bytes::Bytes,

    /// Minimum number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub min_value: ::bytes::Bytes,

    /// Indicates whether the sequence value should cycle through.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub cycle: bool,

    /// Indicates number of entries to cache / precreate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub cache: i64,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SequenceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [increment][crate::model::SequenceEntity::increment].
    pub fn set_increment<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.increment = v.into();
        self
    }

    /// Sets the value of [start_value][crate::model::SequenceEntity::start_value].
    pub fn set_start_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.start_value = v.into();
        self
    }

    /// Sets the value of [max_value][crate::model::SequenceEntity::max_value].
    pub fn set_max_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.max_value = v.into();
        self
    }

    /// Sets the value of [min_value][crate::model::SequenceEntity::min_value].
    pub fn set_min_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.min_value = v.into();
        self
    }

    /// Sets the value of [cycle][crate::model::SequenceEntity::cycle].
    pub fn set_cycle<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cycle = v.into();
        self
    }

    /// Sets the value of [cache][crate::model::SequenceEntity::cache].
    pub fn set_cache<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cache = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SequenceEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SequenceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SequenceEntity"
    }
}

/// Stored procedure's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredProcedureEntity {
    /// The SQL code which creates the stored procedure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StoredProcedureEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::StoredProcedureEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::StoredProcedureEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for StoredProcedureEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StoredProcedureEntity"
    }
}

/// Function's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionEntity {
    /// The SQL code which creates the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FunctionEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::FunctionEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::FunctionEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for FunctionEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FunctionEntity"
    }
}

/// MaterializedView's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedViewEntity {
    /// The SQL code which creates the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaterializedViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::MaterializedViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MaterializedViewEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MaterializedViewEntity"
    }
}

/// Synonym's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SynonymEntity {
    /// The name of the entity for which the synonym is being created (the source).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_entity: std::string::String,

    /// The type of the entity for which the synonym is being created
    /// (usually a table or a sequence).
    pub source_type: crate::model::DatabaseEntityType,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynonymEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::SynonymEntity::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::SynonymEntity::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SynonymEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SynonymEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SynonymEntity"
    }
}

/// Package's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PackageEntity {
    /// The SQL code which creates the package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_sql_code: std::string::String,

    /// The SQL code which creates the package body. If the package specification
    /// has cursors or subprograms, then the package body is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_body: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PackageEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_sql_code][crate::model::PackageEntity::package_sql_code].
    pub fn set_package_sql_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_sql_code = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::PackageEntity::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::PackageEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for PackageEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PackageEntity"
    }
}

/// UDT's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UDTEntity {
    /// The SQL code which creates the udt.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub udt_sql_code: std::string::String,

    /// The SQL code which creates the udt body.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub udt_body: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UDTEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [udt_sql_code][crate::model::UDTEntity::udt_sql_code].
    pub fn set_udt_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_sql_code = v.into();
        self
    }

    /// Sets the value of [udt_body][crate::model::UDTEntity::udt_body].
    pub fn set_udt_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::UDTEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for UDTEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UDTEntity"
    }
}

/// Details of the mappings of a database entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMapping {
    /// Source entity full name.
    /// The source entity can also be a column, index or constraint using the
    /// same naming notation schema.table.column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_entity: std::string::String,

    /// Target entity full name.
    /// The draft entity can also include a column, index or constraint using the
    /// same naming notation schema.table.column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub draft_entity: std::string::String,

    /// Type of source entity.
    pub source_type: crate::model::DatabaseEntityType,

    /// Type of draft entity.
    pub draft_type: crate::model::DatabaseEntityType,

    /// Entity mapping log entries.
    /// Multiple rules can be effective and contribute changes to a converted
    /// entity, such as a rule can handle the entity name, another rule can handle
    /// an entity type. In addition, rules which did not change the entity are also
    /// logged along with the reason preventing them to do so.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mapping_log: std::vec::Vec<crate::model::EntityMappingLogEntry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::EntityMapping::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [draft_entity][crate::model::EntityMapping::draft_entity].
    pub fn set_draft_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.draft_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::EntityMapping::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [draft_type][crate::model::EntityMapping::draft_type].
    pub fn set_draft_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.draft_type = v.into();
        self
    }

    /// Sets the value of [mapping_log][crate::model::EntityMapping::mapping_log].
    pub fn set_mapping_log<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMappingLogEntry>,
    {
        use std::iter::Iterator;
        self.mapping_log = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMapping"
    }
}

/// A single record of a rule which was used for a mapping.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMappingLogEntry {
    /// Which rule caused this log entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// Rule revision ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_revision_id: std::string::String,

    /// Comment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mapping_comment: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityMappingLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::EntityMappingLogEntry::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [rule_revision_id][crate::model::EntityMappingLogEntry::rule_revision_id].
    pub fn set_rule_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_revision_id = v.into();
        self
    }

    /// Sets the value of [mapping_comment][crate::model::EntityMappingLogEntry::mapping_comment].
    pub fn set_mapping_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_comment = v.into();
        self
    }
}

impl wkt::message::Message for EntityMappingLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMappingLogEntry"
    }
}

/// A single DDL statement for a specific entity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityDdl {
    /// Type of DDL (Create, Alter).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ddl_type: std::string::String,

    /// The name of the database entity the ddl refers to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity: std::string::String,

    /// The actual ddl code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ddl: std::string::String,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,

    /// EntityIssues found for this ddl.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issue_id: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityDdl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ddl_type][crate::model::EntityDdl::ddl_type].
    pub fn set_ddl_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl_type = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::EntityDdl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityDdl::ddl].
    pub fn set_ddl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityDdl::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [issue_id][crate::model::EntityDdl::issue_id].
    pub fn set_issue_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.issue_id = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityDdl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityDdl"
    }
}

/// Issue related to the entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityIssue {
    /// Unique Issue ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of the issue.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity_issue::IssueType,

    /// Severity of the issue
    pub severity: crate::model::entity_issue::IssueSeverity,

    /// Issue detailed message
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Error/Warning code
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// The ddl which caused the issue, if relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl: std::option::Option<std::string::String>,

    /// The position of the issue found, if relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub position: std::option::Option<crate::model::entity_issue::Position>,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityIssue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EntityIssue::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityIssue::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_issue::IssueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::EntityIssue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::entity_issue::IssueSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [message][crate::model::EntityIssue::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [code][crate::model::EntityIssue::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityIssue::ddl].
    pub fn set_ddl<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ddl = v.into();
        self
    }

    /// Sets the value of [position][crate::model::EntityIssue::position].
    pub fn set_position<
        T: std::convert::Into<std::option::Option<crate::model::entity_issue::Position>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.position = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityIssue::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }
}

impl wkt::message::Message for EntityIssue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue"
    }
}

/// Defines additional types related to [EntityIssue].
pub mod entity_issue {
    #[allow(unused_imports)]
    use super::*;

    /// Issue position.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Position {
        /// Issue line number
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub line: i32,

        /// Issue column number
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub column: i32,

        /// Issue offset
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub offset: i32,

        /// Issue length
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub length: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Position {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line][crate::model::entity_issue::Position::line].
        pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line = v.into();
            self
        }

        /// Sets the value of [column][crate::model::entity_issue::Position::column].
        pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [offset][crate::model::entity_issue::Position::offset].
        pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset = v.into();
            self
        }

        /// Sets the value of [length][crate::model::entity_issue::Position::length].
        pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.length = v.into();
            self
        }
    }

    impl wkt::message::Message for Position {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue.Position"
        }
    }

    /// Type of issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueType {
        /// Unspecified issue type.
        Unspecified,
        /// Issue originated from the DDL
        Ddl,
        /// Issue originated during the apply process
        Apply,
        /// Issue originated during the convert process
        Convert,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueType::value] or
        /// [IssueType::name].
        UnknownValue(issue_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ddl => std::option::Option::Some(1),
                Self::Apply => std::option::Option::Some(2),
                Self::Convert => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ISSUE_TYPE_UNSPECIFIED"),
                Self::Ddl => std::option::Option::Some("ISSUE_TYPE_DDL"),
                Self::Apply => std::option::Option::Some("ISSUE_TYPE_APPLY"),
                Self::Convert => std::option::Option::Some("ISSUE_TYPE_CONVERT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ddl,
                2 => Self::Apply,
                3 => Self::Convert,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ISSUE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ISSUE_TYPE_DDL" => Self::Ddl,
                "ISSUE_TYPE_APPLY" => Self::Apply,
                "ISSUE_TYPE_CONVERT" => Self::Convert,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ddl => serializer.serialize_i32(1),
                Self::Apply => serializer.serialize_i32(2),
                Self::Convert => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueType>::new(
                ".google.cloud.clouddms.v1.EntityIssue.IssueType",
            ))
        }
    }

    /// Severity of issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueSeverity {
        /// Unspecified issue severity
        Unspecified,
        /// Info
        Info,
        /// Warning
        Warning,
        /// Error
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueSeverity::value] or
        /// [IssueSeverity::name].
        UnknownValue(issue_severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueSeverity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ISSUE_SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("ISSUE_SEVERITY_INFO"),
                Self::Warning => std::option::Option::Some("ISSUE_SEVERITY_WARNING"),
                Self::Error => std::option::Option::Some("ISSUE_SEVERITY_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueSeverity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueSeverity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueSeverity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(issue_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueSeverity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ISSUE_SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ISSUE_SEVERITY_INFO" => Self::Info,
                "ISSUE_SEVERITY_WARNING" => Self::Warning,
                "ISSUE_SEVERITY_ERROR" => Self::Error,
                _ => Self::UnknownValue(issue_severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueSeverity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueSeverity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueSeverity>::new(
                ".google.cloud.clouddms.v1.EntityIssue.IssueSeverity",
            ))
        }
    }
}

/// AIP-157 Partial Response view for Database Entity.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEntityView {
    /// Unspecified view. Defaults to basic view.
    Unspecified,
    /// Default view. Does not return DDLs or Issues.
    Basic,
    /// Return full entity details including mappings, ddl and issues.
    Full,
    /// Top-most (Database, Schema) nodes which are returned contains summary
    /// details for their decendents such as the number of entities per type and
    /// issues rollups. When this view is used, only a single page of result is
    /// returned and the page_size property of the request is ignored. The
    /// returned page will only include the top-most node types.
    RootSummary,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEntityView::value] or
    /// [DatabaseEntityView::name].
    UnknownValue(database_entity_view::UnknownValue),
}

#[doc(hidden)]
pub mod database_entity_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEntityView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::RootSummary => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENTITY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("DATABASE_ENTITY_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("DATABASE_ENTITY_VIEW_FULL"),
            Self::RootSummary => std::option::Option::Some("DATABASE_ENTITY_VIEW_ROOT_SUMMARY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEntityView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEntityView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEntityView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::RootSummary,
            _ => Self::UnknownValue(database_entity_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEntityView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "DATABASE_ENTITY_VIEW_BASIC" => Self::Basic,
            "DATABASE_ENTITY_VIEW_FULL" => Self::Full,
            "DATABASE_ENTITY_VIEW_ROOT_SUMMARY" => Self::RootSummary,
            _ => Self::UnknownValue(database_entity_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEntityView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::RootSummary => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEntityView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEntityView>::new(
            ".google.cloud.clouddms.v1.DatabaseEntityView",
        ))
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NetworkArchitecture {
    Unspecified,
    /// Instance is in Cloud SQL's old producer network architecture.
    OldCsqlProducer,
    /// Instance is in Cloud SQL's new producer network architecture.
    NewCsqlProducer,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NetworkArchitecture::value] or
    /// [NetworkArchitecture::name].
    UnknownValue(network_architecture::UnknownValue),
}

#[doc(hidden)]
pub mod network_architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NetworkArchitecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::OldCsqlProducer => std::option::Option::Some(1),
            Self::NewCsqlProducer => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NETWORK_ARCHITECTURE_UNSPECIFIED"),
            Self::OldCsqlProducer => {
                std::option::Option::Some("NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER")
            }
            Self::NewCsqlProducer => {
                std::option::Option::Some("NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NetworkArchitecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NetworkArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NetworkArchitecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::OldCsqlProducer,
            2 => Self::NewCsqlProducer,
            _ => Self::UnknownValue(network_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NetworkArchitecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NETWORK_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER" => Self::OldCsqlProducer,
            "NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER" => Self::NewCsqlProducer,
            _ => Self::UnknownValue(network_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NetworkArchitecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::OldCsqlProducer => serializer.serialize_i32(1),
            Self::NewCsqlProducer => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NetworkArchitecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkArchitecture>::new(
            ".google.cloud.clouddms.v1.NetworkArchitecture",
        ))
    }
}

/// The database engine types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEngine {
    /// The source database engine of the migration job is unknown.
    Unspecified,
    /// The source engine is MySQL.
    Mysql,
    /// The source engine is PostgreSQL.
    Postgresql,
    /// The source engine is Oracle.
    Oracle,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEngine::value] or
    /// [DatabaseEngine::name].
    UnknownValue(database_engine::UnknownValue),
}

#[doc(hidden)]
pub mod database_engine {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEngine {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Mysql => std::option::Option::Some(1),
            Self::Postgresql => std::option::Option::Some(2),
            Self::Oracle => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENGINE_UNSPECIFIED"),
            Self::Mysql => std::option::Option::Some("MYSQL"),
            Self::Postgresql => std::option::Option::Some("POSTGRESQL"),
            Self::Oracle => std::option::Option::Some("ORACLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEngine {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEngine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEngine {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Mysql,
            2 => Self::Postgresql,
            4 => Self::Oracle,
            _ => Self::UnknownValue(database_engine::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEngine {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENGINE_UNSPECIFIED" => Self::Unspecified,
            "MYSQL" => Self::Mysql,
            "POSTGRESQL" => Self::Postgresql,
            "ORACLE" => Self::Oracle,
            _ => Self::UnknownValue(database_engine::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEngine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Mysql => serializer.serialize_i32(1),
            Self::Postgresql => serializer.serialize_i32(2),
            Self::Oracle => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEngine {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEngine>::new(
            ".google.cloud.clouddms.v1.DatabaseEngine",
        ))
    }
}

/// The database providers.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseProvider {
    /// The database provider is unknown.
    Unspecified,
    /// CloudSQL runs the database.
    Cloudsql,
    /// RDS runs the database.
    Rds,
    /// Amazon Aurora.
    Aurora,
    /// AlloyDB.
    Alloydb,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseProvider::value] or
    /// [DatabaseProvider::name].
    UnknownValue(database_provider::UnknownValue),
}

#[doc(hidden)]
pub mod database_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Cloudsql => std::option::Option::Some(1),
            Self::Rds => std::option::Option::Some(2),
            Self::Aurora => std::option::Option::Some(3),
            Self::Alloydb => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_PROVIDER_UNSPECIFIED"),
            Self::Cloudsql => std::option::Option::Some("CLOUDSQL"),
            Self::Rds => std::option::Option::Some("RDS"),
            Self::Aurora => std::option::Option::Some("AURORA"),
            Self::Alloydb => std::option::Option::Some("ALLOYDB"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Cloudsql,
            2 => Self::Rds,
            3 => Self::Aurora,
            4 => Self::Alloydb,
            _ => Self::UnknownValue(database_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "CLOUDSQL" => Self::Cloudsql,
            "RDS" => Self::Rds,
            "AURORA" => Self::Aurora,
            "ALLOYDB" => Self::Alloydb,
            _ => Self::UnknownValue(database_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Cloudsql => serializer.serialize_i32(1),
            Self::Rds => serializer.serialize_i32(2),
            Self::Aurora => serializer.serialize_i32(3),
            Self::Alloydb => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseProvider>::new(
            ".google.cloud.clouddms.v1.DatabaseProvider",
        ))
    }
}

/// Enum used by ValueListFilter to indicate whether the source value is in the
/// supplied list
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ValuePresentInList {
    /// Value present in list unspecified
    Unspecified,
    /// If the source value is in the supplied list at value_list
    IfValueList,
    /// If the source value is not in the supplied list at value_list
    IfValueNotList,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ValuePresentInList::value] or
    /// [ValuePresentInList::name].
    UnknownValue(value_present_in_list::UnknownValue),
}

#[doc(hidden)]
pub mod value_present_in_list {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ValuePresentInList {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IfValueList => std::option::Option::Some(1),
            Self::IfValueNotList => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VALUE_PRESENT_IN_LIST_UNSPECIFIED"),
            Self::IfValueList => std::option::Option::Some("VALUE_PRESENT_IN_LIST_IF_VALUE_LIST"),
            Self::IfValueNotList => {
                std::option::Option::Some("VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ValuePresentInList {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ValuePresentInList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ValuePresentInList {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IfValueList,
            2 => Self::IfValueNotList,
            _ => Self::UnknownValue(value_present_in_list::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ValuePresentInList {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VALUE_PRESENT_IN_LIST_UNSPECIFIED" => Self::Unspecified,
            "VALUE_PRESENT_IN_LIST_IF_VALUE_LIST" => Self::IfValueList,
            "VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST" => Self::IfValueNotList,
            _ => Self::UnknownValue(value_present_in_list::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ValuePresentInList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IfValueList => serializer.serialize_i32(1),
            Self::IfValueNotList => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ValuePresentInList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValuePresentInList>::new(
            ".google.cloud.clouddms.v1.ValuePresentInList",
        ))
    }
}

/// The type of database entities supported,
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatabaseEntityType {
    /// Unspecified database entity type.
    Unspecified,
    /// Schema.
    Schema,
    /// Table.
    Table,
    /// Column.
    Column,
    /// Constraint.
    Constraint,
    /// Index.
    Index,
    /// Trigger.
    Trigger,
    /// View.
    View,
    /// Sequence.
    Sequence,
    /// Stored Procedure.
    StoredProcedure,
    /// Function.
    Function,
    /// Synonym.
    Synonym,
    /// Package.
    DatabasePackage,
    /// UDT.
    Udt,
    /// Materialized View.
    MaterializedView,
    /// Database.
    Database,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatabaseEntityType::value] or
    /// [DatabaseEntityType::name].
    UnknownValue(database_entity_type::UnknownValue),
}

#[doc(hidden)]
pub mod database_entity_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatabaseEntityType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Schema => std::option::Option::Some(1),
            Self::Table => std::option::Option::Some(2),
            Self::Column => std::option::Option::Some(3),
            Self::Constraint => std::option::Option::Some(4),
            Self::Index => std::option::Option::Some(5),
            Self::Trigger => std::option::Option::Some(6),
            Self::View => std::option::Option::Some(7),
            Self::Sequence => std::option::Option::Some(8),
            Self::StoredProcedure => std::option::Option::Some(9),
            Self::Function => std::option::Option::Some(10),
            Self::Synonym => std::option::Option::Some(11),
            Self::DatabasePackage => std::option::Option::Some(12),
            Self::Udt => std::option::Option::Some(13),
            Self::MaterializedView => std::option::Option::Some(14),
            Self::Database => std::option::Option::Some(15),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATABASE_ENTITY_TYPE_UNSPECIFIED"),
            Self::Schema => std::option::Option::Some("DATABASE_ENTITY_TYPE_SCHEMA"),
            Self::Table => std::option::Option::Some("DATABASE_ENTITY_TYPE_TABLE"),
            Self::Column => std::option::Option::Some("DATABASE_ENTITY_TYPE_COLUMN"),
            Self::Constraint => std::option::Option::Some("DATABASE_ENTITY_TYPE_CONSTRAINT"),
            Self::Index => std::option::Option::Some("DATABASE_ENTITY_TYPE_INDEX"),
            Self::Trigger => std::option::Option::Some("DATABASE_ENTITY_TYPE_TRIGGER"),
            Self::View => std::option::Option::Some("DATABASE_ENTITY_TYPE_VIEW"),
            Self::Sequence => std::option::Option::Some("DATABASE_ENTITY_TYPE_SEQUENCE"),
            Self::StoredProcedure => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_STORED_PROCEDURE")
            }
            Self::Function => std::option::Option::Some("DATABASE_ENTITY_TYPE_FUNCTION"),
            Self::Synonym => std::option::Option::Some("DATABASE_ENTITY_TYPE_SYNONYM"),
            Self::DatabasePackage => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_DATABASE_PACKAGE")
            }
            Self::Udt => std::option::Option::Some("DATABASE_ENTITY_TYPE_UDT"),
            Self::MaterializedView => {
                std::option::Option::Some("DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW")
            }
            Self::Database => std::option::Option::Some("DATABASE_ENTITY_TYPE_DATABASE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatabaseEntityType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatabaseEntityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatabaseEntityType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Schema,
            2 => Self::Table,
            3 => Self::Column,
            4 => Self::Constraint,
            5 => Self::Index,
            6 => Self::Trigger,
            7 => Self::View,
            8 => Self::Sequence,
            9 => Self::StoredProcedure,
            10 => Self::Function,
            11 => Self::Synonym,
            12 => Self::DatabasePackage,
            13 => Self::Udt,
            14 => Self::MaterializedView,
            15 => Self::Database,
            _ => Self::UnknownValue(database_entity_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatabaseEntityType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATABASE_ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATABASE_ENTITY_TYPE_SCHEMA" => Self::Schema,
            "DATABASE_ENTITY_TYPE_TABLE" => Self::Table,
            "DATABASE_ENTITY_TYPE_COLUMN" => Self::Column,
            "DATABASE_ENTITY_TYPE_CONSTRAINT" => Self::Constraint,
            "DATABASE_ENTITY_TYPE_INDEX" => Self::Index,
            "DATABASE_ENTITY_TYPE_TRIGGER" => Self::Trigger,
            "DATABASE_ENTITY_TYPE_VIEW" => Self::View,
            "DATABASE_ENTITY_TYPE_SEQUENCE" => Self::Sequence,
            "DATABASE_ENTITY_TYPE_STORED_PROCEDURE" => Self::StoredProcedure,
            "DATABASE_ENTITY_TYPE_FUNCTION" => Self::Function,
            "DATABASE_ENTITY_TYPE_SYNONYM" => Self::Synonym,
            "DATABASE_ENTITY_TYPE_DATABASE_PACKAGE" => Self::DatabasePackage,
            "DATABASE_ENTITY_TYPE_UDT" => Self::Udt,
            "DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW" => Self::MaterializedView,
            "DATABASE_ENTITY_TYPE_DATABASE" => Self::Database,
            _ => Self::UnknownValue(database_entity_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatabaseEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Schema => serializer.serialize_i32(1),
            Self::Table => serializer.serialize_i32(2),
            Self::Column => serializer.serialize_i32(3),
            Self::Constraint => serializer.serialize_i32(4),
            Self::Index => serializer.serialize_i32(5),
            Self::Trigger => serializer.serialize_i32(6),
            Self::View => serializer.serialize_i32(7),
            Self::Sequence => serializer.serialize_i32(8),
            Self::StoredProcedure => serializer.serialize_i32(9),
            Self::Function => serializer.serialize_i32(10),
            Self::Synonym => serializer.serialize_i32(11),
            Self::DatabasePackage => serializer.serialize_i32(12),
            Self::Udt => serializer.serialize_i32(13),
            Self::MaterializedView => serializer.serialize_i32(14),
            Self::Database => serializer.serialize_i32(15),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatabaseEntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatabaseEntityType>::new(
            ".google.cloud.clouddms.v1.DatabaseEntityType",
        ))
    }
}

/// Entity Name Transformation Types
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntityNameTransformation {
    /// Entity name transformation unspecified.
    Unspecified,
    /// No transformation.
    NoTransformation,
    /// Transform to lower case.
    LowerCase,
    /// Transform to upper case.
    UpperCase,
    /// Transform to capitalized case.
    CapitalizedCase,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntityNameTransformation::value] or
    /// [EntityNameTransformation::name].
    UnknownValue(entity_name_transformation::UnknownValue),
}

#[doc(hidden)]
pub mod entity_name_transformation {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntityNameTransformation {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoTransformation => std::option::Option::Some(1),
            Self::LowerCase => std::option::Option::Some(2),
            Self::UpperCase => std::option::Option::Some(3),
            Self::CapitalizedCase => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_UNSPECIFIED")
            }
            Self::NoTransformation => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION")
            }
            Self::LowerCase => std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_LOWER_CASE"),
            Self::UpperCase => std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_UPPER_CASE"),
            Self::CapitalizedCase => {
                std::option::Option::Some("ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntityNameTransformation {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntityNameTransformation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntityNameTransformation {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoTransformation,
            2 => Self::LowerCase,
            3 => Self::UpperCase,
            4 => Self::CapitalizedCase,
            _ => Self::UnknownValue(entity_name_transformation::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EntityNameTransformation {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTITY_NAME_TRANSFORMATION_UNSPECIFIED" => Self::Unspecified,
            "ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION" => Self::NoTransformation,
            "ENTITY_NAME_TRANSFORMATION_LOWER_CASE" => Self::LowerCase,
            "ENTITY_NAME_TRANSFORMATION_UPPER_CASE" => Self::UpperCase,
            "ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE" => Self::CapitalizedCase,
            _ => Self::UnknownValue(entity_name_transformation::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EntityNameTransformation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoTransformation => serializer.serialize_i32(1),
            Self::LowerCase => serializer.serialize_i32(2),
            Self::UpperCase => serializer.serialize_i32(3),
            Self::CapitalizedCase => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntityNameTransformation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityNameTransformation>::new(
            ".google.cloud.clouddms.v1.EntityNameTransformation",
        ))
    }
}

/// The types of jobs that can be executed in the background.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BackgroundJobType {
    /// Unspecified background job type.
    Unspecified,
    /// Job to seed from the source database.
    SourceSeed,
    /// Job to convert the source database into a draft of the destination
    /// database.
    Convert,
    /// Job to apply the draft tree onto the destination.
    ApplyDestination,
    /// Job to import and convert mapping rules from an external source such as an
    /// ora2pg config file.
    ImportRulesFile,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BackgroundJobType::value] or
    /// [BackgroundJobType::name].
    UnknownValue(background_job_type::UnknownValue),
}

#[doc(hidden)]
pub mod background_job_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BackgroundJobType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::SourceSeed => std::option::Option::Some(1),
            Self::Convert => std::option::Option::Some(2),
            Self::ApplyDestination => std::option::Option::Some(3),
            Self::ImportRulesFile => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BACKGROUND_JOB_TYPE_UNSPECIFIED"),
            Self::SourceSeed => std::option::Option::Some("BACKGROUND_JOB_TYPE_SOURCE_SEED"),
            Self::Convert => std::option::Option::Some("BACKGROUND_JOB_TYPE_CONVERT"),
            Self::ApplyDestination => {
                std::option::Option::Some("BACKGROUND_JOB_TYPE_APPLY_DESTINATION")
            }
            Self::ImportRulesFile => {
                std::option::Option::Some("BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BackgroundJobType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BackgroundJobType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BackgroundJobType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::SourceSeed,
            2 => Self::Convert,
            3 => Self::ApplyDestination,
            5 => Self::ImportRulesFile,
            _ => Self::UnknownValue(background_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BackgroundJobType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BACKGROUND_JOB_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BACKGROUND_JOB_TYPE_SOURCE_SEED" => Self::SourceSeed,
            "BACKGROUND_JOB_TYPE_CONVERT" => Self::Convert,
            "BACKGROUND_JOB_TYPE_APPLY_DESTINATION" => Self::ApplyDestination,
            "BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE" => Self::ImportRulesFile,
            _ => Self::UnknownValue(background_job_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BackgroundJobType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::SourceSeed => serializer.serialize_i32(1),
            Self::Convert => serializer.serialize_i32(2),
            Self::ApplyDestination => serializer.serialize_i32(3),
            Self::ImportRulesFile => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BackgroundJobType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackgroundJobType>::new(
            ".google.cloud.clouddms.v1.BackgroundJobType",
        ))
    }
}

/// The format for the import rules file.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ImportRulesFileFormat {
    /// Unspecified rules format.
    Unspecified,
    /// HarbourBridge session file.
    HarbourBridgeSessionFile,
    /// Ora2Pg configuration file.
    OratopgConfigFile,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ImportRulesFileFormat::value] or
    /// [ImportRulesFileFormat::name].
    UnknownValue(import_rules_file_format::UnknownValue),
}

#[doc(hidden)]
pub mod import_rules_file_format {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ImportRulesFileFormat {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::HarbourBridgeSessionFile => std::option::Option::Some(1),
            Self::OratopgConfigFile => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_UNSPECIFIED"),
            Self::HarbourBridgeSessionFile => {
                std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE")
            }
            Self::OratopgConfigFile => {
                std::option::Option::Some("IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ImportRulesFileFormat {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ImportRulesFileFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ImportRulesFileFormat {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::HarbourBridgeSessionFile,
            2 => Self::OratopgConfigFile,
            _ => Self::UnknownValue(import_rules_file_format::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ImportRulesFileFormat {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IMPORT_RULES_FILE_FORMAT_UNSPECIFIED" => Self::Unspecified,
            "IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE" => {
                Self::HarbourBridgeSessionFile
            }
            "IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE" => Self::OratopgConfigFile,
            _ => Self::UnknownValue(import_rules_file_format::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ImportRulesFileFormat {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::HarbourBridgeSessionFile => serializer.serialize_i32(1),
            Self::OratopgConfigFile => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ImportRulesFileFormat {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportRulesFileFormat>::new(
            ".google.cloud.clouddms.v1.ImportRulesFileFormat",
        ))
    }
}

/// Enum used by IntComparisonFilter and DoubleComparisonFilter to indicate the
/// relation between source value and compare value.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ValueComparison {
    /// Value comparison unspecified.
    Unspecified,
    /// Value is smaller than the Compare value.
    IfValueSmallerThan,
    /// Value is smaller or equal than the Compare value.
    IfValueSmallerEqualThan,
    /// Value is larger than the Compare value.
    IfValueLargerThan,
    /// Value is larger or equal than the Compare value.
    IfValueLargerEqualThan,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ValueComparison::value] or
    /// [ValueComparison::name].
    UnknownValue(value_comparison::UnknownValue),
}

#[doc(hidden)]
pub mod value_comparison {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ValueComparison {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::IfValueSmallerThan => std::option::Option::Some(1),
            Self::IfValueSmallerEqualThan => std::option::Option::Some(2),
            Self::IfValueLargerThan => std::option::Option::Some(3),
            Self::IfValueLargerEqualThan => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VALUE_COMPARISON_UNSPECIFIED"),
            Self::IfValueSmallerThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_SMALLER_THAN")
            }
            Self::IfValueSmallerEqualThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN")
            }
            Self::IfValueLargerThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_LARGER_THAN")
            }
            Self::IfValueLargerEqualThan => {
                std::option::Option::Some("VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ValueComparison {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ValueComparison {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ValueComparison {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::IfValueSmallerThan,
            2 => Self::IfValueSmallerEqualThan,
            3 => Self::IfValueLargerThan,
            4 => Self::IfValueLargerEqualThan,
            _ => Self::UnknownValue(value_comparison::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ValueComparison {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VALUE_COMPARISON_UNSPECIFIED" => Self::Unspecified,
            "VALUE_COMPARISON_IF_VALUE_SMALLER_THAN" => Self::IfValueSmallerThan,
            "VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN" => Self::IfValueSmallerEqualThan,
            "VALUE_COMPARISON_IF_VALUE_LARGER_THAN" => Self::IfValueLargerThan,
            "VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN" => Self::IfValueLargerEqualThan,
            _ => Self::UnknownValue(value_comparison::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ValueComparison {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::IfValueSmallerThan => serializer.serialize_i32(1),
            Self::IfValueSmallerEqualThan => serializer.serialize_i32(2),
            Self::IfValueLargerThan => serializer.serialize_i32(3),
            Self::IfValueLargerEqualThan => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ValueComparison {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ValueComparison>::new(
            ".google.cloud.clouddms.v1.ValueComparison",
        ))
    }
}

/// Specifies the columns on which numeric filter needs to be applied.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NumericFilterOption {
    /// Numeric filter option unspecified
    Unspecified,
    /// Numeric filter option that matches all numeric columns.
    All,
    /// Numeric filter option that matches columns having numeric datatypes with
    /// specified precision and scale within the limited range of filter.
    Limit,
    /// Numeric filter option that matches only the numeric columns with no
    /// precision and scale specified.
    Limitless,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NumericFilterOption::value] or
    /// [NumericFilterOption::name].
    UnknownValue(numeric_filter_option::UnknownValue),
}

#[doc(hidden)]
pub mod numeric_filter_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NumericFilterOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::All => std::option::Option::Some(1),
            Self::Limit => std::option::Option::Some(2),
            Self::Limitless => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NUMERIC_FILTER_OPTION_UNSPECIFIED"),
            Self::All => std::option::Option::Some("NUMERIC_FILTER_OPTION_ALL"),
            Self::Limit => std::option::Option::Some("NUMERIC_FILTER_OPTION_LIMIT"),
            Self::Limitless => std::option::Option::Some("NUMERIC_FILTER_OPTION_LIMITLESS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NumericFilterOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NumericFilterOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NumericFilterOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::All,
            2 => Self::Limit,
            3 => Self::Limitless,
            _ => Self::UnknownValue(numeric_filter_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NumericFilterOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NUMERIC_FILTER_OPTION_UNSPECIFIED" => Self::Unspecified,
            "NUMERIC_FILTER_OPTION_ALL" => Self::All,
            "NUMERIC_FILTER_OPTION_LIMIT" => Self::Limit,
            "NUMERIC_FILTER_OPTION_LIMITLESS" => Self::Limitless,
            _ => Self::UnknownValue(numeric_filter_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NumericFilterOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::All => serializer.serialize_i32(1),
            Self::Limit => serializer.serialize_i32(2),
            Self::Limitless => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NumericFilterOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NumericFilterOption>::new(
            ".google.cloud.clouddms.v1.NumericFilterOption",
        ))
    }
}
