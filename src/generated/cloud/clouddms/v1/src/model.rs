// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Retrieves a list of all migration jobs in a given project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationJobsRequest {
    /// Required. The parent which owns this collection of migrationJobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of migration jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 50 migration jobs will be
    /// returned. The maximum value is 1000; values above 1000 are coerced to
    /// 1000.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// migrationJobs.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to migrationJobs.list must match the call
    /// that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters migration jobs listed in the response.
    /// The expression must specify the field name, a comparison operator, and the
    /// value that you want to use for filtering. The value must be a string,
    /// a number, or a boolean. The comparison operator must be
    /// either =, !=, >, or <. For example, list migration jobs created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.**
    /// You can also filter nested fields. For example, you could specify
    /// **reverseSshConnectivity.vmIp = "1.2.3.4"** to select all migration
    /// jobs connecting through the specific SSH tunnel bastion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Sort the results based on the migration job name.
    /// Valid values are: "name", "name asc", and "name desc".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListMigrationJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigrationJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigrationJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigrationJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigrationJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigrationJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsRequest"
    }
}

/// Response message for 'ListMigrationJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigrationJobsResponse {
    /// The list of migration jobs objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migration_jobs: std::vec::Vec<crate::model::MigrationJob>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListMigrationJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMigrationJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [migration_jobs][crate::model::ListMigrationJobsResponse::migration_jobs].
    pub fn set_migration_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationJob>,
    {
        use std::iter::Iterator;
        self.migration_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigrationJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigrationJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMigrationJobsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMigrationJobsResponse {
    type PageItem = crate::model::MigrationJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migration_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for 'GetMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMigrationJobRequest {
    /// Required. Name of the migration job resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMigrationJobRequest"
    }
}

/// Request message to create a new Database Migration Service migration job
/// in the specified project and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMigrationJobRequest {
    /// Required. The parent which owns this collection of migration jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the instance to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job_id: std::string::String,

    /// Required. Represents a [migration
    /// job](https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs)
    /// object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigrationJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migration_job_id][crate::model::CreateMigrationJobRequest::migration_job_id].
    pub fn set_migration_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job_id = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::CreateMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMigrationJobRequest"
    }
}

/// Request message for 'UpdateMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateMigrationJobRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The migration job parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigrationJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::UpdateMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateMigrationJobRequest"
    }
}

/// Request message for 'DeleteMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMigrationJobRequest {
    /// Required. Name of the migration job resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// The destination CloudSQL connection profile is always deleted with the
    /// migration job. In case of force delete, the destination CloudSQL replica
    /// database is also deleted.
    pub force: bool,
}

impl DeleteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteMigrationJobRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMigrationJobRequest"
    }
}

/// Request message for 'StartMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartMigrationJobRequest {
    /// Name of the migration job resource to start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Start the migration job without running prior configuration
    /// verification. Defaults to `false`.
    pub skip_validation: bool,
}

impl StartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::StartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StartMigrationJobRequest"
    }
}

/// Request message for 'StopMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopMigrationJobRequest {
    /// Name of the migration job resource to stop.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StopMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StopMigrationJobRequest"
    }
}

/// Request message for 'ResumeMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeMigrationJobRequest {
    /// Name of the migration job resource to resume.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResumeMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ResumeMigrationJobRequest"
    }
}

/// Request message for 'PromoteMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PromoteMigrationJobRequest {
    /// Name of the migration job resource to promote.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl PromoteMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PromoteMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PromoteMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PromoteMigrationJobRequest"
    }
}

/// Request message for 'VerifyMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyMigrationJobRequest {
    /// Name of the migration job resource to verify.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Field mask is used to specify the changed fields to be verified.
    /// It will not update the migration job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The changed migration job parameters to verify.
    /// It will not update the migration job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migration_job: std::option::Option<crate::model::MigrationJob>,
}

impl VerifyMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::VerifyMigrationJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [migration_job][crate::model::VerifyMigrationJobRequest::migration_job].
    pub fn set_migration_job<
        T: std::convert::Into<std::option::Option<crate::model::MigrationJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_job = v.into();
        self
    }
}

impl wkt::message::Message for VerifyMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VerifyMigrationJobRequest"
    }
}

/// Request message for 'RestartMigrationJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestartMigrationJobRequest {
    /// Name of the migration job resource to restart.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Restart the migration job without running prior configuration
    /// verification. Defaults to `false`.
    pub skip_validation: bool,
}

impl RestartMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestartMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::RestartMigrationJobRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for RestartMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RestartMigrationJobRequest"
    }
}

/// Request message for 'GenerateSshScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateSshScriptRequest {
    /// Name of the migration job resource to generate the SSH script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job: std::string::String,

    /// Required. Bastion VM Instance name to use or to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm: std::string::String,

    /// The port that will be open on the bastion host.
    pub vm_port: i32,

    /// The VM configuration
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vm_config: std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,
}

impl GenerateSshScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateSshScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::GenerateSshScriptRequest::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::GenerateSshScriptRequest::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of `vm_config`.
    pub fn set_vm_config<
        T: std::convert::Into<
            std::option::Option<crate::model::generate_ssh_script_request::VmConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = v.into();
        self
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmCreationConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vm_creation_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmCreationConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// if it holds a `VmSelectionConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vm_selection_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmSelectionConfig>> {
        #[allow(unreachable_patterns)]
        self.vm_config.as_ref().and_then(|v| match v {
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmCreationConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_creation_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmCreationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmCreationConfig(v.into()),
        );
        self
    }

    /// Sets the value of [vm_config][crate::model::GenerateSshScriptRequest::vm_config]
    /// to hold a `VmSelectionConfig`.
    ///
    /// Note that all the setters affecting `vm_config` are
    /// mutually exclusive.
    pub fn set_vm_selection_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VmSelectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_config = std::option::Option::Some(
            crate::model::generate_ssh_script_request::VmConfig::VmSelectionConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GenerateSshScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateSshScriptRequest"
    }
}

/// Defines additional types related to GenerateSshScriptRequest
pub mod generate_ssh_script_request {
    #[allow(unused_imports)]
    use super::*;

    /// The VM configuration
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VmConfig {
        /// The VM creation configuration
        VmCreationConfig(std::boxed::Box<crate::model::VmCreationConfig>),
        /// The VM selection configuration
        VmSelectionConfig(std::boxed::Box<crate::model::VmSelectionConfig>),
    }
}

/// VM creation configuration message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmCreationConfig {
    /// Required. VM instance machine type to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_machine_type: std::string::String,

    /// The Google Cloud Platform zone to create the VM in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,

    /// The subnet name the vm needs to be created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,
}

impl VmCreationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_machine_type][crate::model::VmCreationConfig::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::VmCreationConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VmCreationConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VmCreationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmCreationConfig"
    }
}

/// VM selection configuration message
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmSelectionConfig {
    /// Required. The Google Cloud Platform zone the VM is located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,
}

impl VmSelectionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_zone][crate::model::VmSelectionConfig::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }
}

impl wkt::message::Message for VmSelectionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VmSelectionConfig"
    }
}

/// Response message for 'GenerateSshScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SshScript {
    /// The ssh configuration script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,
}

impl SshScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::SshScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for SshScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SshScript"
    }
}

/// Request message for 'GenerateTcpProxyScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateTcpProxyScriptRequest {
    /// Name of the migration job resource to generate the TCP Proxy script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migration_job: std::string::String,

    /// Required. The name of the Compute instance that will host the proxy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// Required. The type of the Compute instance that will host the proxy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_machine_type: std::string::String,

    /// Optional. The Google Cloud Platform zone to create the VM in. The fully
    /// qualified name of the zone must be specified, including the region name,
    /// for example "us-central1-b". If not specified, uses the "-b" zone of the
    /// destination Connection Profile's region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_zone: std::string::String,

    /// Required. The name of the subnet the Compute instance will use for private
    /// connectivity. Must be supplied in the form of
    /// projects/{project}/regions/{region}/subnetworks/{subnetwork}.
    /// Note: the region for the subnet must match the Compute instance region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_subnet: std::string::String,
}

impl GenerateTcpProxyScriptRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migration_job][crate::model::GenerateTcpProxyScriptRequest::migration_job].
    pub fn set_migration_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migration_job = v.into();
        self
    }

    /// Sets the value of [vm_name][crate::model::GenerateTcpProxyScriptRequest::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [vm_machine_type][crate::model::GenerateTcpProxyScriptRequest::vm_machine_type].
    pub fn set_vm_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_machine_type = v.into();
        self
    }

    /// Sets the value of [vm_zone][crate::model::GenerateTcpProxyScriptRequest::vm_zone].
    pub fn set_vm_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_zone = v.into();
        self
    }

    /// Sets the value of [vm_subnet][crate::model::GenerateTcpProxyScriptRequest::vm_subnet].
    pub fn set_vm_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_subnet = v.into();
        self
    }
}

impl wkt::message::Message for GenerateTcpProxyScriptRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GenerateTcpProxyScriptRequest"
    }
}

/// Response message for 'GenerateTcpProxyScript' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TcpProxyScript {
    /// The TCP Proxy configuration script.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub script: std::string::String,
}

impl TcpProxyScript {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script][crate::model::TcpProxyScript::script].
    pub fn set_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.script = v.into();
        self
    }
}

impl wkt::message::Message for TcpProxyScript {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TcpProxyScript"
    }
}

/// Request message for 'ListConnectionProfiles' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesRequest {
    /// Required. The parent which owns this collection of connection profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of connection profiles to return. The service may return
    /// fewer than this value. If unspecified, at most 50 connection profiles will
    /// be returned. The maximum value is 1000; values above 1000 are coerced
    /// to 1000.
    pub page_size: i32,

    /// A page token, received from a previous `ListConnectionProfiles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListConnectionProfiles`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters connection profiles listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list connection profiles created this year by
    /// specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z**. You can
    /// also filter nested fields. For example, you could specify **mySql.username
    /// = %lt;my_username%gt;** to list all connection profiles configured to
    /// connect with a specific username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// A comma-separated list of fields to order results according to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListConnectionProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionProfilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionProfilesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesRequest"
    }
}

/// Response message for 'ListConnectionProfiles' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionProfilesResponse {
    /// The response list of connection profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connection_profiles: std::vec::Vec<crate::model::ConnectionProfile>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListConnectionProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [connection_profiles][crate::model::ListConnectionProfilesResponse::connection_profiles].
    pub fn set_connection_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionProfile>,
    {
        use std::iter::Iterator;
        self.connection_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionProfilesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConnectionProfilesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListConnectionProfilesResponse {
    type PageItem = crate::model::ConnectionProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connection_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for 'GetConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionProfileRequest {
    /// Required. Name of the connection profile resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConnectionProfileRequest"
    }
}

/// Request message for 'CreateConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionProfileRequest {
    /// Required. The parent which owns this collection of connection profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The connection profile identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_profile_id: std::string::String,

    /// Required. The create request body including the connection profile data
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't create any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    pub validate_only: bool,

    /// Optional. Create the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    pub skip_validation: bool,
}

impl CreateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_profile_id][crate::model::CreateConnectionProfileRequest::connection_profile_id].
    pub fn set_connection_profile_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile_id = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::CreateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<
        T: std::convert::Into<std::option::Option<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConnectionProfileRequest"
    }
}

/// Request message for 'UpdateConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionProfileRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The connection profile parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile: std::option::Option<crate::model::ConnectionProfile>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Only validate the connection profile, but don't update any
    /// resources. The default is false. Only supported for Oracle connection
    /// profiles.
    pub validate_only: bool,

    /// Optional. Update the connection profile without validating it.
    /// The default is false.
    /// Only supported for Oracle connection profiles.
    pub skip_validation: bool,
}

impl UpdateConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionProfileRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [connection_profile][crate::model::UpdateConnectionProfileRequest::connection_profile].
    pub fn set_connection_profile<
        T: std::convert::Into<std::option::Option<crate::model::ConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionProfileRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::UpdateConnectionProfileRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConnectionProfileRequest"
    }
}

/// Request message for 'DeleteConnectionProfile' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionProfileRequest {
    /// Required. Name of the connection profile resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// In case of force delete, the CloudSQL replica database is also deleted
    /// (only for CloudSQL connection profile).
    pub force: bool,
}

impl DeleteConnectionProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionProfileRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConnectionProfileRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConnectionProfileRequest"
    }
}

/// Request message to create a new private connection in the specified project
/// and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePrivateConnectionRequest {
    /// Required. The parent that owns the collection of PrivateConnections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The private connection identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection_id: std::string::String,

    /// Required. The private connection resource to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_connection: std::option::Option<crate::model::PrivateConnection>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, will skip validations.
    pub skip_validation: bool,
}

impl CreatePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePrivateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [private_connection_id][crate::model::CreatePrivateConnectionRequest::private_connection_id].
    pub fn set_private_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection_id = v.into();
        self
    }

    /// Sets the value of [private_connection][crate::model::CreatePrivateConnectionRequest::private_connection].
    pub fn set_private_connection<
        T: std::convert::Into<std::option::Option<crate::model::PrivateConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [skip_validation][crate::model::CreatePrivateConnectionRequest::skip_validation].
    pub fn set_skip_validation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_validation = v.into();
        self
    }
}

impl wkt::message::Message for CreatePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreatePrivateConnectionRequest"
    }
}

/// Request message to retrieve a list of private connections in a given project
/// and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsRequest {
    /// Required. The parent that owns the collection of private connections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of private connections to return.
    /// If unspecified, at most 50 private connections that are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    pub page_size: i32,

    /// Page token received from a previous `ListPrivateConnections` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateConnections` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters private connections listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list private connections created this year by
    /// specifying **createTime %gt; 2021-01-01T00:00:00.000000000Z**.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListPrivateConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPrivateConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPrivateConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPrivateConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPrivateConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPrivateConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsRequest"
    }
}

/// Response message for 'ListPrivateConnections' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPrivateConnectionsResponse {
    /// List of private connections.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub private_connections: std::vec::Vec<crate::model::PrivateConnection>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListPrivateConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPrivateConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [private_connections][crate::model::ListPrivateConnectionsResponse::private_connections].
    pub fn set_private_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PrivateConnection>,
    {
        use std::iter::Iterator;
        self.private_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPrivateConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPrivateConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListPrivateConnectionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListPrivateConnectionsResponse {
    type PageItem = crate::model::PrivateConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.private_connections
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message to delete a private connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePrivateConnectionRequest {
    /// Required. The name of the private connection to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeletePrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePrivateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeletePrivateConnectionRequest"
    }
}

/// Request message to get a private connection resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPrivateConnectionRequest {
    /// Required. The name of the private connection to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPrivateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPrivateConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPrivateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetPrivateConnectionRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OperationMetadata"
    }
}

/// Retrieve a list of all conversion workspaces in a given project and location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversionWorkspacesRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of conversion workspaces to return. The service may
    /// return fewer than this value. If unspecified, at most 50 sets are returned.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// conversionWorkspaces.list, used in the subsequent request to retrieve the
    /// next page of results. On first call this should be left blank. When
    /// paginating, all other parameters provided to conversionWorkspaces.list must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// A filter expression that filters conversion workspaces listed in the
    /// response. The expression must specify the field name, a comparison
    /// operator, and the value that you want to use for filtering. The value must
    /// be a string, a number, or a boolean. The comparison operator must be either
    /// =, !=, >, or <. For example, list conversion workspaces created this year
    /// by specifying **createTime %gt; 2020-01-01T00:00:00.000000000Z.** You can
    /// also filter nested fields. For example, you could specify
    /// **source.version = "12.c.1"** to select all conversion workspaces with
    /// source database version equal to 12.c.1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListConversionWorkspacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversionWorkspacesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversionWorkspacesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversionWorkspacesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversionWorkspacesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesRequest"
    }
}

/// Response message for 'ListConversionWorkspaces' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConversionWorkspacesResponse {
    /// The list of conversion workspace objects.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conversion_workspaces: std::vec::Vec<crate::model::ConversionWorkspace>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListConversionWorkspacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListConversionWorkspacesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [conversion_workspaces][crate::model::ListConversionWorkspacesResponse::conversion_workspaces].
    pub fn set_conversion_workspaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.conversion_workspaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConversionWorkspacesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConversionWorkspacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListConversionWorkspacesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListConversionWorkspacesResponse {
    type PageItem = crate::model::ConversionWorkspace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversion_workspaces
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for 'GetConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to get.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetConversionWorkspaceRequest"
    }
}

/// Request message to create a new Conversion Workspace
/// in the specified project and region.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConversionWorkspaceRequest {
    /// Required. The parent which owns this collection of conversion workspaces.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the conversion workspace to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace_id: std::string::String,

    /// Required. Represents a conversion workspace object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversionWorkspaceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversion_workspace_id][crate::model::CreateConversionWorkspaceRequest::conversion_workspace_id].
    pub fn set_conversion_workspace_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace_id = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::CreateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateConversionWorkspaceRequest"
    }
}

/// Request message for 'UpdateConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConversionWorkspaceRequest {
    /// Required. Field mask is used to specify the fields to be overwritten by the
    /// update in the conversion workspace resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The conversion workspace parameters to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspace>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversionWorkspaceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::UpdateConversionWorkspaceRequest::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspace>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UpdateConversionWorkspaceRequest"
    }
}

/// Request message for 'DeleteConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Force delete the conversion workspace, even if there's a running migration
    /// that is using the workspace.
    pub force: bool,
}

impl DeleteConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConversionWorkspaceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteConversionWorkspaceRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteConversionWorkspaceRequest"
    }
}

/// Request message for 'CommitConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CommitConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to commit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Optional name of the commit.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_name: std::string::String,
}

impl CommitConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_name][crate::model::CommitConversionWorkspaceRequest::commit_name].
    pub fn set_commit_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_name = v.into();
        self
    }
}

impl wkt::message::Message for CommitConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CommitConversionWorkspaceRequest"
    }
}

/// Request message for 'RollbackConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackConversionWorkspaceRequest {
    /// Required. Name of the conversion workspace resource to roll back to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl RollbackConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RollbackConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RollbackConversionWorkspaceRequest"
    }
}

/// Request message for 'ApplyConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyConversionWorkspaceRequest {
    /// Required. The name of the conversion workspace resource for which to apply
    /// the draft tree. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Filter which entities to apply. Leaving this field empty will apply all of
    /// the entities. Supports Google AIP 160 based filtering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Only validates the apply process, but doesn't change the
    /// destination database. Only works for PostgreSQL destination connection
    /// profile.
    pub dry_run: bool,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the apply.
    pub auto_commit: bool,

    /// Which destination to use when applying the conversion workspace.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination:
        std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,
}

impl ApplyConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApplyConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ApplyConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [dry_run][crate::model::ApplyConversionWorkspaceRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ApplyConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<
            std::option::Option<crate::model::apply_conversion_workspace_request::Destination>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// if it holds a `ConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ApplyConversionWorkspaceRequest::destination]
    /// to hold a `ConnectionProfile`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::apply_conversion_workspace_request::Destination::ConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ApplyConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyConversionWorkspaceRequest"
    }
}

/// Defines additional types related to ApplyConversionWorkspaceRequest
pub mod apply_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// Which destination to use when applying the conversion workspace.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        ConnectionProfile(std::string::String),
    }
}

/// Retrieve a list of all mapping rules in a given conversion workspace.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMappingRulesRequest {
    /// Required. Name of the conversion workspace resource whose mapping rules are
    /// listed in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of rules to return. The service may return
    /// fewer than this value.
    pub page_size: i32,

    /// The nextPageToken value received in the previous call to
    /// mappingRules.list, used in the subsequent request to retrieve the next
    /// page of results. On first call this should be left blank. When paginating,
    /// all other parameters provided to mappingRules.list must match the call
    /// that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMappingRulesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMappingRulesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesRequest"
    }
}

/// Response message for 'ListMappingRulesRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMappingRulesResponse {
    /// The list of conversion workspace mapping rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mapping_rules: std::vec::Vec<crate::model::MappingRule>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListMappingRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMappingRulesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [mapping_rules][crate::model::ListMappingRulesResponse::mapping_rules].
    pub fn set_mapping_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MappingRule>,
    {
        use std::iter::Iterator;
        self.mapping_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMappingRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ListMappingRulesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMappingRulesResponse {
    type PageItem = crate::model::MappingRule;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.mapping_rules
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for 'GetMappingRule' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMappingRuleRequest {
    /// Required. Name of the mapping rule resource to get.
    /// Example: conversionWorkspaces/123/mappingRules/rule123
    ///
    /// In order to retrieve a previous revision of the mapping rule, also provide
    /// the revision ID.
    /// Example:
    /// conversionWorkspace/123/mappingRules/rule123@c7cfa2a8c7cfa2a8c7cfa2a8c7cfa2a8
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.GetMappingRuleRequest"
    }
}

/// Request message for 'SeedConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SeedConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to seed with new database
    /// structure, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Should the conversion workspace be committed automatically after the
    /// seed operation.
    pub auto_commit: bool,

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub seed_from: std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,
}

impl SeedConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SeedConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::SeedConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of `seed_from`.
    pub fn set_seed_from<
        T: std::convert::Into<
            std::option::Option<crate::model::seed_conversion_workspace_request::SeedFrom>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = v.into();
        self
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `SourceConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// if it holds a `DestinationConnectionProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_destination_connection_profile(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.seed_from.as_ref().and_then(|v| match v {
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `SourceConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_source_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::SourceConnectionProfile(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [seed_from][crate::model::SeedConversionWorkspaceRequest::seed_from]
    /// to hold a `DestinationConnectionProfile`.
    ///
    /// Note that all the setters affecting `seed_from` are
    /// mutually exclusive.
    pub fn set_destination_connection_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.seed_from = std::option::Option::Some(
            crate::model::seed_conversion_workspace_request::SeedFrom::DestinationConnectionProfile(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for SeedConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SeedConversionWorkspaceRequest"
    }
}

/// Defines additional types related to SeedConversionWorkspaceRequest
pub mod seed_conversion_workspace_request {
    #[allow(unused_imports)]
    use super::*;

    /// The input to be used for seeding the conversion workspace. The input can
    /// either be from the source or destination databases and it can be provided
    /// through a connection profile or a DDL file.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SeedFrom {
        /// Optional. Fully qualified (Uri) name of the source connection profile.
        SourceConnectionProfile(std::string::String),
        /// Optional. Fully qualified (Uri) name of the destination connection
        /// profile.
        DestinationConnectionProfile(std::string::String),
    }
}

/// Request message for 'ConvertConversionWorkspace' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConvertConversionWorkspaceRequest {
    /// Name of the conversion workspace resource to convert in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Specifies whether the conversion workspace is to be committed
    /// automatically after the conversion.
    pub auto_commit: bool,

    /// Optional. Filter the entities to convert. Leaving this field empty will
    /// convert all of the entities. Supports Google AIP-160 style filtering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Automatically convert the full entity path for each entity
    /// specified by the filter. For example, if the filter specifies a table, that
    /// table schema (and database if there is one) will also be converted.
    pub convert_full_path: bool,
}

impl ConvertConversionWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConvertConversionWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ConvertConversionWorkspaceRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ConvertConversionWorkspaceRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [convert_full_path][crate::model::ConvertConversionWorkspaceRequest::convert_full_path].
    pub fn set_convert_full_path<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.convert_full_path = v.into();
        self
    }
}

impl wkt::message::Message for ConvertConversionWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertConversionWorkspaceRequest"
    }
}

/// Request message for 'ImportMappingRules' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportMappingRulesRequest {
    /// Required. Name of the conversion workspace resource to import the rules to
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The format of the rules content file.
    pub rules_format: crate::model::ImportRulesFileFormat,

    /// Required. One or more rules files.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules_files: std::vec::Vec<crate::model::import_mapping_rules_request::RulesFile>,

    /// Required. Should the conversion workspace be committed automatically after
    /// the import operation.
    pub auto_commit: bool,
}

impl ImportMappingRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportMappingRulesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [rules_format][crate::model::ImportMappingRulesRequest::rules_format].
    pub fn set_rules_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.rules_format = v.into();
        self
    }

    /// Sets the value of [auto_commit][crate::model::ImportMappingRulesRequest::auto_commit].
    pub fn set_auto_commit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_commit = v.into();
        self
    }

    /// Sets the value of [rules_files][crate::model::ImportMappingRulesRequest::rules_files].
    pub fn set_rules_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::import_mapping_rules_request::RulesFile>,
    {
        use std::iter::Iterator;
        self.rules_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportMappingRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest"
    }
}

/// Defines additional types related to ImportMappingRulesRequest
pub mod import_mapping_rules_request {
    #[allow(unused_imports)]
    use super::*;

    /// Details of a single rules file.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RulesFile {
        /// Required. The filename of the rules that needs to be converted. The
        /// filename is used mainly so that future logs of the import rules job
        /// contain it, and can therefore be searched by it.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rules_source_filename: std::string::String,

        /// Required. The text content of the rules that needs to be converted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub rules_content: std::string::String,
    }

    impl RulesFile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rules_source_filename][crate::model::import_mapping_rules_request::RulesFile::rules_source_filename].
        pub fn set_rules_source_filename<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_source_filename = v.into();
            self
        }

        /// Sets the value of [rules_content][crate::model::import_mapping_rules_request::RulesFile::rules_content].
        pub fn set_rules_content<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rules_content = v.into();
            self
        }
    }

    impl wkt::message::Message for RulesFile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.ImportMappingRulesRequest.RulesFile"
        }
    }
}

/// Request message for 'DescribeDatabaseEntities' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesRequest {
    /// Required. Name of the conversion workspace resource whose database entities
    /// are described. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. The maximum number of entities to return. The service may return
    /// fewer entities than the value specifies.
    pub page_size: i32,

    /// Optional. The nextPageToken value received in the previous call to
    /// conversionWorkspace.describeDatabaseEntities, used in the subsequent
    /// request to retrieve the next page of results. On first call this should be
    /// left blank. When paginating, all other parameters provided to
    /// conversionWorkspace.describeDatabaseEntities must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Required. The tree to fetch.
    pub tree: crate::model::describe_database_entities_request::DBTreeType,

    /// Optional. Whether to retrieve the latest committed version of the entities
    /// or the latest version. This field is ignored if a specific commit_id is
    /// specified.
    pub uncommitted: bool,

    /// Optional. Request a specific commit ID. If not specified, the entities from
    /// the latest commit are returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,

    /// Optional. Filter the returned entities based on AIP-160 standard.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Results view based on AIP-157
    pub view: crate::model::DatabaseEntityView,
}

impl DescribeDatabaseEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeDatabaseEntitiesRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::DescribeDatabaseEntitiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::DescribeDatabaseEntitiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DescribeDatabaseEntitiesRequest::tree].
    pub fn set_tree<
        T: std::convert::Into<crate::model::describe_database_entities_request::DBTreeType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [uncommitted][crate::model::DescribeDatabaseEntitiesRequest::uncommitted].
    pub fn set_uncommitted<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.uncommitted = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeDatabaseEntitiesRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::DescribeDatabaseEntitiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [view][crate::model::DescribeDatabaseEntitiesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::DatabaseEntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesRequest"
    }
}

/// Defines additional types related to DescribeDatabaseEntitiesRequest
pub mod describe_database_entities_request {
    #[allow(unused_imports)]
    use super::*;

    /// The type of a tree to return
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct DBTreeType(std::borrow::Cow<'static, str>);

    impl DBTreeType {
        /// Creates a new DBTreeType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [DBTreeType](DBTreeType)
    pub mod db_tree_type {
        use super::DBTreeType;

        /// Unspecified tree type.
        pub const DB_TREE_TYPE_UNSPECIFIED: DBTreeType =
            DBTreeType::new("DB_TREE_TYPE_UNSPECIFIED");

        /// The source database tree.
        pub const SOURCE_TREE: DBTreeType = DBTreeType::new("SOURCE_TREE");

        /// The draft database tree.
        pub const DRAFT_TREE: DBTreeType = DBTreeType::new("DRAFT_TREE");

        /// The destination database tree.
        pub const DESTINATION_TREE: DBTreeType = DBTreeType::new("DESTINATION_TREE");
    }

    impl std::convert::From<std::string::String> for DBTreeType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for DBTreeType {
        fn default() -> Self {
            db_tree_type::DB_TREE_TYPE_UNSPECIFIED
        }
    }
}

/// Response message for 'DescribeDatabaseEntities' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeDatabaseEntitiesResponse {
    /// The list of database entities for the conversion workspace.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub database_entities: std::vec::Vec<crate::model::DatabaseEntity>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl DescribeDatabaseEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::DescribeDatabaseEntitiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [database_entities][crate::model::DescribeDatabaseEntitiesResponse::database_entities].
    pub fn set_database_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatabaseEntity>,
    {
        use std::iter::Iterator;
        self.database_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DescribeDatabaseEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeDatabaseEntitiesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for DescribeDatabaseEntitiesResponse {
    type PageItem = crate::model::DatabaseEntity;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.database_entities
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for 'SearchBackgroundJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBackgroundJobsRequest {
    /// Required. Name of the conversion workspace resource whose jobs are listed,
    /// in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. Whether or not to return just the most recent job per job type,
    pub return_most_recent_per_job_type: bool,

    /// Optional. The maximum number of jobs to return. The service may return
    /// fewer than this value. If unspecified, at most 100 jobs are
    /// returned. The maximum value is 100; values above 100 are coerced to
    /// 100.
    pub max_size: i32,

    /// Optional. If provided, only returns jobs that completed until (not
    /// including) the given timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub completed_until_time: std::option::Option<wkt::Timestamp>,
}

impl SearchBackgroundJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::SearchBackgroundJobsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [return_most_recent_per_job_type][crate::model::SearchBackgroundJobsRequest::return_most_recent_per_job_type].
    pub fn set_return_most_recent_per_job_type<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.return_most_recent_per_job_type = v.into();
        self
    }

    /// Sets the value of [max_size][crate::model::SearchBackgroundJobsRequest::max_size].
    pub fn set_max_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_size = v.into();
        self
    }

    /// Sets the value of [completed_until_time][crate::model::SearchBackgroundJobsRequest::completed_until_time].
    pub fn set_completed_until_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.completed_until_time = v.into();
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsRequest"
    }
}

/// Response message for 'SearchBackgroundJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBackgroundJobsResponse {
    /// The list of conversion workspace mapping rules.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::BackgroundJobLogEntry>,
}

impl SearchBackgroundJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::SearchBackgroundJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackgroundJobLogEntry>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchBackgroundJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SearchBackgroundJobsResponse"
    }
}

/// Request message for 'DescribeConversionWorkspaceRevisions' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsRequest {
    /// Required. Name of the conversion workspace resource whose revisions are
    /// listed. Must be in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub conversion_workspace: std::string::String,

    /// Optional. Optional filter to request a specific commit ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,
}

impl DescribeConversionWorkspaceRevisionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversion_workspace][crate::model::DescribeConversionWorkspaceRevisionsRequest::conversion_workspace].
    pub fn set_conversion_workspace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::DescribeConversionWorkspaceRevisionsRequest::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsRequest"
    }
}

/// Response message for 'DescribeConversionWorkspaceRevisions' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DescribeConversionWorkspaceRevisionsResponse {
    /// The list of conversion workspace revisions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub revisions: std::vec::Vec<crate::model::ConversionWorkspace>,
}

impl DescribeConversionWorkspaceRevisionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [revisions][crate::model::DescribeConversionWorkspaceRevisionsResponse::revisions].
    pub fn set_revisions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversionWorkspace>,
    {
        use std::iter::Iterator;
        self.revisions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DescribeConversionWorkspaceRevisionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DescribeConversionWorkspaceRevisionsResponse"
    }
}

/// Request message for 'CreateMappingRule' command.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMappingRuleRequest {
    /// Required. The parent which owns this collection of mapping rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the rule to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mapping_rule_id: std::string::String,

    /// Required. Represents a [mapping rule]
    /// (<https://cloud.google.com/database-migration/reference/rest/v1/projects.locations.mappingRules>)
    /// object.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub mapping_rule: std::option::Option<crate::model::MappingRule>,

    /// A unique ID used to identify the request. If the server receives two
    /// requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMappingRuleRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [mapping_rule_id][crate::model::CreateMappingRuleRequest::mapping_rule_id].
    pub fn set_mapping_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_rule_id = v.into();
        self
    }

    /// Sets the value of [mapping_rule][crate::model::CreateMappingRuleRequest::mapping_rule].
    pub fn set_mapping_rule<
        T: std::convert::Into<std::option::Option<crate::model::MappingRule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mapping_rule = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CreateMappingRuleRequest"
    }
}

/// Request message for 'DeleteMappingRule' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMappingRuleRequest {
    /// Required. Name of the mapping rule resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two requests with the same ID, then the second request is ignored.
    ///
    /// It is recommended to always set this value to a UUID.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteMappingRuleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMappingRuleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteMappingRuleRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMappingRuleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DeleteMappingRuleRequest"
    }
}

/// Request message for 'FetchStaticIps' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsRequest {
    /// Required. The resource name for the location for which static IPs should be
    /// returned. Must be in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Maximum number of IPs to return.
    pub page_size: i32,

    /// A page token, received from a previous `FetchStaticIps` call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl FetchStaticIpsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchStaticIpsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStaticIpsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStaticIpsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsRequest"
    }
}

/// Response message for a 'FetchStaticIps' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchStaticIpsResponse {
    /// List of static IPs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub static_ips: std::vec::Vec<std::string::String>,

    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl FetchStaticIpsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::FetchStaticIpsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [static_ips][crate::model::FetchStaticIpsResponse::static_ips].
    pub fn set_static_ips<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.static_ips = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchStaticIpsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FetchStaticIpsResponse"
    }
}

/// SSL configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SslConfig {
    /// Output only. The ssl config type according to 'client_key',
    /// 'client_certificate' and 'ca_certificate'.
    #[serde(rename = "type")]
    pub r#type: crate::model::ssl_config::SslType,

    /// Input only. The unencrypted PKCS#1 or PKCS#8 PEM-encoded private key
    /// associated with the Client Certificate. If this field is used then the
    /// 'client_certificate' field is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// Input only. The x509 PEM-encoded certificate that will be used by the
    /// replica to authenticate against the source database server.If this field is
    /// used then the 'client_key' field is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// Required. Input only. The x509 PEM-encoded certificate of the CA that
    /// signed the source database server's certificate. The replica will use this
    /// certificate to verify it's connecting to the right host.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ca_certificate: std::string::String,
}

impl SslConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SslConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::ssl_config::SslType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::SslConfig::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::SslConfig::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [ca_certificate][crate::model::SslConfig::ca_certificate].
    pub fn set_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for SslConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SslConfig"
    }
}

/// Defines additional types related to SslConfig
pub mod ssl_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies The kind of ssl configuration used.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SslType(std::borrow::Cow<'static, str>);

    impl SslType {
        /// Creates a new SslType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SslType](SslType)
    pub mod ssl_type {
        use super::SslType;

        /// Unspecified.
        pub const SSL_TYPE_UNSPECIFIED: SslType = SslType::new("SSL_TYPE_UNSPECIFIED");

        /// Only 'ca_certificate' specified.
        pub const SERVER_ONLY: SslType = SslType::new("SERVER_ONLY");

        /// Both server ('ca_certificate'), and client ('client_key',
        /// 'client_certificate') specified.
        pub const SERVER_CLIENT: SslType = SslType::new("SERVER_CLIENT");
    }

    impl std::convert::From<std::string::String> for SslType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for SslType {
        fn default() -> Self {
            ssl_type::SSL_TYPE_UNSPECIFIED
        }
    }
}

/// Specifies connection parameters required specifically for MySQL databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MySqlConnectionProfile {
    /// Required. The IP or hostname of the source MySQL database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source MySQL database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,
}

impl MySqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::MySqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::MySqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::MySqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MySqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::MySqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::MySqlConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::MySqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }
}

impl wkt::message::Message for MySqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MySqlConnectionProfile"
    }
}

/// Specifies connection parameters required specifically for PostgreSQL
/// databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostgreSqlConnectionProfile {
    /// Required. The IP or hostname of the source PostgreSQL database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source PostgreSQL database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates If this connection profile password is stored.
    pub password_set: bool,

    /// SSL configuration for the destination to connect to the source database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// If the source is a Cloud SQL database, use this field to
    /// provide the Cloud SQL instance ID of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,

    /// Output only. If the source is a Cloud SQL database, this field indicates
    /// the network architecture it's associated with.
    pub network_architecture: crate::model::NetworkArchitecture,

    /// Connectivity options used to establish a connection to the database server.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity:
        std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,
}

impl PostgreSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::PostgreSqlConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::PostgreSqlConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::PostgreSqlConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::PostgreSqlConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::PostgreSqlConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::PostgreSqlConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of [cloud_sql_id][crate::model::PostgreSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [network_architecture][crate::model::PostgreSqlConnectionProfile::network_architecture].
    pub fn set_network_architecture<T: std::convert::Into<crate::model::NetworkArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_architecture = v.into();
        self
    }

    /// Sets the value of `connectivity`.
    pub fn set_connectivity<
        T: std::convert::Into<
            std::option::Option<crate::model::postgre_sql_connection_profile::Connectivity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// if it holds a `PrivateServiceConnectConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_private_service_connect_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>
    {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::StaticIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::PostgreSqlConnectionProfile::connectivity]
    /// to hold a `PrivateServiceConnectConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_service_connect_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::postgre_sql_connection_profile::Connectivity::PrivateServiceConnectConnectivity(
                v.into()
            )
        );
        self
    }
}

impl wkt::message::Message for PostgreSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PostgreSqlConnectionProfile"
    }
}

/// Defines additional types related to PostgreSqlConnectionProfile
pub mod postgre_sql_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
        /// Private service connect connectivity.
        PrivateServiceConnectConnectivity(
            std::boxed::Box<crate::model::PrivateServiceConnectConnectivity>,
        ),
    }
}

/// Specifies connection parameters required specifically for Oracle
/// databases.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OracleConnectionProfile {
    /// Required. The IP or hostname of the source Oracle database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,

    /// Required. The network port of the source Oracle database.
    pub port: i32,

    /// Required. The username that Database Migration Service will use to connect
    /// to the database. The value is encrypted when stored in Database Migration
    /// Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Required. Input only. The password for the user that Database Migration
    /// Service will be using to connect to the database. This field is not
    /// returned on request, and the value is encrypted when stored in Database
    /// Migration Service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// Output only. Indicates whether a new password is included in the request.
    pub password_set: bool,

    /// Required. Database service for the Oracle connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub database_service: std::string::String,

    /// SSL configuration for the connection to the source Oracle database.
    ///
    /// * Only `SERVER_ONLY` configuration is supported for Oracle SSL.
    /// * SSL is supported for Oracle versions 12 and above.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ssl: std::option::Option<crate::model::SslConfig>,

    /// Connectivity options used to establish a connection to the database server.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::oracle_connection_profile::Connectivity>,
}

impl OracleConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host][crate::model::OracleConnectionProfile::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [port][crate::model::OracleConnectionProfile::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OracleConnectionProfile::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::OracleConnectionProfile::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [password_set][crate::model::OracleConnectionProfile::password_set].
    pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.password_set = v.into();
        self
    }

    /// Sets the value of [database_service][crate::model::OracleConnectionProfile::database_service].
    pub fn set_database_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.database_service = v.into();
        self
    }

    /// Sets the value of [ssl][crate::model::OracleConnectionProfile::ssl].
    pub fn set_ssl<T: std::convert::Into<std::option::Option<crate::model::SslConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl = v.into();
        self
    }

    /// Sets the value of `connectivity`.
    pub fn set_connectivity<
        T: std::convert::Into<
            std::option::Option<crate::model::oracle_connection_profile::Connectivity>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `StaticServiceIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_static_service_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticServiceIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `ForwardSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_forward_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// if it holds a `PrivateConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_private_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PrivateConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `StaticServiceIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_service_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticServiceIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::StaticServiceIpConnectivity(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `ForwardSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_forward_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::ForwardSshConnectivity(v.into()),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::OracleConnectionProfile::connectivity]
    /// to hold a `PrivateConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_private_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::PrivateConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::oracle_connection_profile::Connectivity::PrivateConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OracleConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.OracleConnectionProfile"
    }
}

/// Defines additional types related to OracleConnectionProfile
pub mod oracle_connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Connectivity options used to establish a connection to the database server.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// Static Service IP connectivity.
        StaticServiceIpConnectivity(std::boxed::Box<crate::model::StaticServiceIpConnectivity>),
        /// Forward SSH tunnel connectivity.
        ForwardSshConnectivity(std::boxed::Box<crate::model::ForwardSshTunnelConnectivity>),
        /// Private connectivity.
        PrivateConnectivity(std::boxed::Box<crate::model::PrivateConnectivity>),
    }
}

/// Specifies required connection parameters, and, optionally, the parameters
/// required to create a Cloud SQL destination database instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlConnectionProfile {
    /// Output only. The Cloud SQL instance ID that this connection profile is
    /// associated with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cloud_sql_id: std::string::String,

    /// Immutable. Metadata used to create the destination Cloud SQL database.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::CloudSqlSettings>,

    /// Output only. The Cloud SQL database instance's private IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's public IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip: std::string::String,

    /// Output only. The Cloud SQL database instance's additional (outgoing) public
    /// IP. Used when the Cloud SQL database availability type is REGIONAL (i.e.
    /// multiple zones / highly available).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub additional_public_ip: std::string::String,
}

impl CloudSqlConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cloud_sql_id][crate::model::CloudSqlConnectionProfile::cloud_sql_id].
    pub fn set_cloud_sql_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cloud_sql_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::CloudSqlConnectionProfile::settings].
    pub fn set_settings<
        T: std::convert::Into<std::option::Option<crate::model::CloudSqlSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }

    /// Sets the value of [private_ip][crate::model::CloudSqlConnectionProfile::private_ip].
    pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_ip = v.into();
        self
    }

    /// Sets the value of [public_ip][crate::model::CloudSqlConnectionProfile::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [additional_public_ip][crate::model::CloudSqlConnectionProfile::additional_public_ip].
    pub fn set_additional_public_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additional_public_ip = v.into();
        self
    }
}

impl wkt::message::Message for CloudSqlConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlConnectionProfile"
    }
}

/// Specifies required connection parameters, and the parameters
/// required to create an AlloyDB destination cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlloyDbConnectionProfile {
    /// Required. The AlloyDB cluster ID that this connection profile is associated
    /// with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Immutable. Metadata used to create the destination AlloyDB cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub settings: std::option::Option<crate::model::AlloyDbSettings>,
}

impl AlloyDbConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_id][crate::model::AlloyDbConnectionProfile::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [settings][crate::model::AlloyDbConnectionProfile::settings].
    pub fn set_settings<
        T: std::convert::Into<std::option::Option<crate::model::AlloyDbSettings>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.settings = v.into();
        self
    }
}

impl wkt::message::Message for AlloyDbConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbConnectionProfile"
    }
}

/// An entry for an Access Control list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlAclEntry {
    /// The allowlisted value for the access control list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// A label to identify this entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub label: std::string::String,

    /// The access control entry entry expiration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::sql_acl_entry::Expiration>,
}

impl SqlAclEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::SqlAclEntry::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [label][crate::model::SqlAclEntry::label].
    pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.label = v.into();
        self
    }

    /// Sets the value of `expiration`.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::sql_acl_entry::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [expiration][crate::model::SqlAclEntry::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::sql_acl_entry::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::sql_acl_entry::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// Sets the value of [expiration][crate::model::SqlAclEntry::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::sql_acl_entry::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for SqlAclEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlAclEntry"
    }
}

/// Defines additional types related to SqlAclEntry
pub mod sql_acl_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The access control entry entry expiration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// The time when this access control entry expires in
        /// [RFC 3339](https://tools.ietf.org/html/rfc3339) format, for example:
        /// `2012-11-15T16:19:00.094Z`.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The time-to-leave of this access control entry.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// IP Management configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SqlIpConfig {
    /// Whether the instance should be assigned an IPv4 address or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_ipv4: std::option::Option<wkt::BoolValue>,

    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_network: std::string::String,

    /// Optional. The name of the allocated IP address range for the private IP
    /// Cloud SQL instance. This name refers to an already allocated IP range
    /// address. If set, the instance IP address will be created in the allocated
    /// range. Note that this IP address range can't be modified after the instance
    /// is created. If you change the VPC when configuring connectivity settings
    /// for the migration job, this field is not relevant.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub allocated_ip_range: std::string::String,

    /// Whether SSL connections over IP should be enforced or not.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub require_ssl: std::option::Option<wkt::BoolValue>,

    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. See
    /// <https://en.wikipedia.org/wiki/CIDR_notation#CIDR_notation>, also known as
    /// 'slash' notation (e.g. `192.168.100.0/24`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<crate::model::SqlAclEntry>,
}

impl SqlIpConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_ipv4][crate::model::SqlIpConfig::enable_ipv4].
    pub fn set_enable_ipv4<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_ipv4 = v.into();
        self
    }

    /// Sets the value of [private_network][crate::model::SqlIpConfig::private_network].
    pub fn set_private_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.private_network = v.into();
        self
    }

    /// Sets the value of [allocated_ip_range][crate::model::SqlIpConfig::allocated_ip_range].
    pub fn set_allocated_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.allocated_ip_range = v.into();
        self
    }

    /// Sets the value of [require_ssl][crate::model::SqlIpConfig::require_ssl].
    pub fn set_require_ssl<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.require_ssl = v.into();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::SqlIpConfig::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SqlAclEntry>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SqlIpConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SqlIpConfig"
    }
}

/// Settings for creating a Cloud SQL database instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloudSqlSettings {
    /// The database engine type and version.
    pub database_version: crate::model::cloud_sql_settings::SqlDatabaseVersion,

    /// The resource labels for a Cloud SQL instance to use to annotate any related
    /// underlying resources such as Compute Engine VMs.
    /// An object containing a list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "18kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The tier (or machine type) for this instance, for example:
    /// `db-n1-standard-1` (MySQL instances) or
    /// `db-custom-1-3840` (PostgreSQL instances).
    /// For more information, see
    /// [Cloud SQL Instance
    /// Settings](https://cloud.google.com/sql/docs/mysql/instance-settings).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tier: std::string::String,

    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub storage_auto_resize_limit: std::option::Option<wkt::Int64Value>,

    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is 'RUNNABLE'. Valid values:
    ///
    /// 'ALWAYS': The instance is on, and remains so even in
    /// the absence of connection requests.
    ///
    /// `NEVER`: The instance is off; it is not activated, even if a
    /// connection request arrives.
    pub activation_policy: crate::model::cloud_sql_settings::SqlActivationPolicy,

    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ip_config: std::option::Option<crate::model::SqlIpConfig>,

    /// [default: ON] If you enable this setting, Cloud SQL checks your available
    /// storage every 30 seconds. If the available storage falls below a threshold
    /// size, Cloud SQL automatically adds additional storage capacity. If the
    /// available storage repeatedly falls below the threshold size, Cloud SQL
    /// continues to add storage until it reaches the maximum of 30 TB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auto_storage_increase: std::option::Option<wkt::BoolValue>,

    /// The database flags passed to the Cloud SQL instance at startup.
    /// An object containing a list of "key": value pairs.
    /// Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The type of storage: `PD_SSD` (default) or `PD_HDD`.
    pub data_disk_type: crate::model::cloud_sql_settings::SqlDataDiskType,

    /// The storage capacity available to the database, in GB.
    /// The minimum (and default) size is 10GB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_disk_size_gb: std::option::Option<wkt::Int64Value>,

    /// The Google Cloud Platform zone where your Cloud SQL database instance is
    /// located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Optional. The Google Cloud Platform zone where the failover Cloud SQL
    /// database instance is located. Used when the Cloud SQL database availability
    /// type is REGIONAL (i.e. multiple zones / highly available).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub secondary_zone: std::string::String,

    /// The Database Migration Service source connection profile ID,
    /// in the format:
    /// `projects/my_project_name/locations/us-central1/connectionProfiles/connection_profile_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_id: std::string::String,

    /// Input only. Initial root password.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_password: std::string::String,

    /// Output only. Indicates If this connection profile root password is stored.
    pub root_password_set: bool,

    /// The Cloud SQL default instance level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// The KMS key name used for the csql instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmek_key_name: std::string::String,

    /// Optional. Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data availability.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available).
    pub availability_type: crate::model::cloud_sql_settings::SqlAvailabilityType,

    /// Optional. The edition of the given Cloud SQL instance.
    pub edition: crate::model::cloud_sql_settings::Edition,
}

impl CloudSqlSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database_version][crate::model::CloudSqlSettings::database_version].
    pub fn set_database_version<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDatabaseVersion>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.database_version = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::CloudSqlSettings::tier].
    pub fn set_tier<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [storage_auto_resize_limit][crate::model::CloudSqlSettings::storage_auto_resize_limit].
    pub fn set_storage_auto_resize_limit<
        T: std::convert::Into<std::option::Option<wkt::Int64Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_auto_resize_limit = v.into();
        self
    }

    /// Sets the value of [activation_policy][crate::model::CloudSqlSettings::activation_policy].
    pub fn set_activation_policy<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlActivationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.activation_policy = v.into();
        self
    }

    /// Sets the value of [ip_config][crate::model::CloudSqlSettings::ip_config].
    pub fn set_ip_config<T: std::convert::Into<std::option::Option<crate::model::SqlIpConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ip_config = v.into();
        self
    }

    /// Sets the value of [auto_storage_increase][crate::model::CloudSqlSettings::auto_storage_increase].
    pub fn set_auto_storage_increase<T: std::convert::Into<std::option::Option<wkt::BoolValue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_storage_increase = v.into();
        self
    }

    /// Sets the value of [data_disk_type][crate::model::CloudSqlSettings::data_disk_type].
    pub fn set_data_disk_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlDataDiskType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_type = v.into();
        self
    }

    /// Sets the value of [data_disk_size_gb][crate::model::CloudSqlSettings::data_disk_size_gb].
    pub fn set_data_disk_size_gb<T: std::convert::Into<std::option::Option<wkt::Int64Value>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CloudSqlSettings::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [secondary_zone][crate::model::CloudSqlSettings::secondary_zone].
    pub fn set_secondary_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secondary_zone = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CloudSqlSettings::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [root_password][crate::model::CloudSqlSettings::root_password].
    pub fn set_root_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.root_password = v.into();
        self
    }

    /// Sets the value of [root_password_set][crate::model::CloudSqlSettings::root_password_set].
    pub fn set_root_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.root_password_set = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::CloudSqlSettings::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::CloudSqlSettings::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [availability_type][crate::model::CloudSqlSettings::availability_type].
    pub fn set_availability_type<
        T: std::convert::Into<crate::model::cloud_sql_settings::SqlAvailabilityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.availability_type = v.into();
        self
    }

    /// Sets the value of [edition][crate::model::CloudSqlSettings::edition].
    pub fn set_edition<T: std::convert::Into<crate::model::cloud_sql_settings::Edition>>(
        mut self,
        v: T,
    ) -> Self {
        self.edition = v.into();
        self
    }

    /// Sets the value of [user_labels][crate::model::CloudSqlSettings::user_labels].
    pub fn set_user_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [database_flags][crate::model::CloudSqlSettings::database_flags].
    pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CloudSqlSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.CloudSqlSettings"
    }
}

/// Defines additional types related to CloudSqlSettings
pub mod cloud_sql_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies when the instance should be activated.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SqlActivationPolicy(std::borrow::Cow<'static, str>);

    impl SqlActivationPolicy {
        /// Creates a new SqlActivationPolicy instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SqlActivationPolicy](SqlActivationPolicy)
    pub mod sql_activation_policy {
        use super::SqlActivationPolicy;

        /// unspecified policy.
        pub const SQL_ACTIVATION_POLICY_UNSPECIFIED: SqlActivationPolicy =
            SqlActivationPolicy::new("SQL_ACTIVATION_POLICY_UNSPECIFIED");

        /// The instance is always up and running.
        pub const ALWAYS: SqlActivationPolicy = SqlActivationPolicy::new("ALWAYS");

        /// The instance should never spin up.
        pub const NEVER: SqlActivationPolicy = SqlActivationPolicy::new("NEVER");
    }

    impl std::convert::From<std::string::String> for SqlActivationPolicy {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for SqlActivationPolicy {
        fn default() -> Self {
            sql_activation_policy::SQL_ACTIVATION_POLICY_UNSPECIFIED
        }
    }

    /// The storage options for Cloud SQL databases.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SqlDataDiskType(std::borrow::Cow<'static, str>);

    impl SqlDataDiskType {
        /// Creates a new SqlDataDiskType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SqlDataDiskType](SqlDataDiskType)
    pub mod sql_data_disk_type {
        use super::SqlDataDiskType;

        /// Unspecified.
        pub const SQL_DATA_DISK_TYPE_UNSPECIFIED: SqlDataDiskType =
            SqlDataDiskType::new("SQL_DATA_DISK_TYPE_UNSPECIFIED");

        /// SSD disk.
        pub const PD_SSD: SqlDataDiskType = SqlDataDiskType::new("PD_SSD");

        /// HDD disk.
        pub const PD_HDD: SqlDataDiskType = SqlDataDiskType::new("PD_HDD");
    }

    impl std::convert::From<std::string::String> for SqlDataDiskType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for SqlDataDiskType {
        fn default() -> Self {
            sql_data_disk_type::SQL_DATA_DISK_TYPE_UNSPECIFIED
        }
    }

    /// The database engine type and version.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SqlDatabaseVersion(std::borrow::Cow<'static, str>);

    impl SqlDatabaseVersion {
        /// Creates a new SqlDatabaseVersion instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SqlDatabaseVersion](SqlDatabaseVersion)
    pub mod sql_database_version {
        use super::SqlDatabaseVersion;

        /// Unspecified version.
        pub const SQL_DATABASE_VERSION_UNSPECIFIED: SqlDatabaseVersion =
            SqlDatabaseVersion::new("SQL_DATABASE_VERSION_UNSPECIFIED");

        /// MySQL 5.6.
        pub const MYSQL_5_6: SqlDatabaseVersion = SqlDatabaseVersion::new("MYSQL_5_6");

        /// MySQL 5.7.
        pub const MYSQL_5_7: SqlDatabaseVersion = SqlDatabaseVersion::new("MYSQL_5_7");

        /// PostgreSQL 9.6.
        pub const POSTGRES_9_6: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_9_6");

        /// PostgreSQL 11.
        pub const POSTGRES_11: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_11");

        /// PostgreSQL 10.
        pub const POSTGRES_10: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_10");

        /// MySQL 8.0.
        pub const MYSQL_8_0: SqlDatabaseVersion = SqlDatabaseVersion::new("MYSQL_8_0");

        /// PostgreSQL 12.
        pub const POSTGRES_12: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_12");

        /// PostgreSQL 13.
        pub const POSTGRES_13: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_13");

        /// PostgreSQL 14.
        pub const POSTGRES_14: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_14");

        /// PostgreSQL 15.
        pub const POSTGRES_15: SqlDatabaseVersion = SqlDatabaseVersion::new("POSTGRES_15");
    }

    impl std::convert::From<std::string::String> for SqlDatabaseVersion {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for SqlDatabaseVersion {
        fn default() -> Self {
            sql_database_version::SQL_DATABASE_VERSION_UNSPECIFIED
        }
    }

    /// The availability type of the given Cloud SQL instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct SqlAvailabilityType(std::borrow::Cow<'static, str>);

    impl SqlAvailabilityType {
        /// Creates a new SqlAvailabilityType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [SqlAvailabilityType](SqlAvailabilityType)
    pub mod sql_availability_type {
        use super::SqlAvailabilityType;

        /// This is an unknown Availability type.
        pub const SQL_AVAILABILITY_TYPE_UNSPECIFIED: SqlAvailabilityType =
            SqlAvailabilityType::new("SQL_AVAILABILITY_TYPE_UNSPECIFIED");

        /// Zonal availablility instance.
        pub const ZONAL: SqlAvailabilityType = SqlAvailabilityType::new("ZONAL");

        /// Regional availability instance.
        pub const REGIONAL: SqlAvailabilityType = SqlAvailabilityType::new("REGIONAL");
    }

    impl std::convert::From<std::string::String> for SqlAvailabilityType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for SqlAvailabilityType {
        fn default() -> Self {
            sql_availability_type::SQL_AVAILABILITY_TYPE_UNSPECIFIED
        }
    }

    /// The edition of the given Cloud SQL instance.
    /// Can be ENTERPRISE or ENTERPRISE_PLUS.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Edition(std::borrow::Cow<'static, str>);

    impl Edition {
        /// Creates a new Edition instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Edition](Edition)
    pub mod edition {
        use super::Edition;

        /// The instance did not specify the edition.
        pub const EDITION_UNSPECIFIED: Edition = Edition::new("EDITION_UNSPECIFIED");

        /// The instance is an enterprise edition.
        pub const ENTERPRISE: Edition = Edition::new("ENTERPRISE");

        /// The instance is an enterprise plus edition.
        pub const ENTERPRISE_PLUS: Edition = Edition::new("ENTERPRISE_PLUS");
    }

    impl std::convert::From<std::string::String> for Edition {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Edition {
        fn default() -> Self {
            edition::EDITION_UNSPECIFIED
        }
    }
}

/// Settings for creating an AlloyDB cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AlloyDbSettings {
    /// Required. Input only. Initial user to setup during cluster creation.
    /// Required.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub initial_user: std::option::Option<crate::model::alloy_db_settings::UserPassword>,

    /// Required. The resource link for the VPC network in which cluster resources
    /// are created and from which they are accessible via Private IP. The network
    /// must belong to the same project as the cluster. It is specified in the
    /// form: "projects/{project_number}/global/networks/{network_id}". This is
    /// required to create a cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_network: std::string::String,

    /// Labels for the AlloyDB cluster created by DMS. An object containing a list
    /// of 'key', 'value' pairs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_instance_settings:
        std::option::Option<crate::model::alloy_db_settings::PrimaryInstanceSettings>,

    /// Optional. The encryption config can be specified to encrypt the data disks
    /// and other persistent data resources of a cluster with a
    /// customer-managed encryption key (CMEK). When this field is not
    /// specified, the cluster will then use default encryption scheme to
    /// protect the user data.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::alloy_db_settings::EncryptionConfig>,
}

impl AlloyDbSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_user][crate::model::AlloyDbSettings::initial_user].
    pub fn set_initial_user<
        T: std::convert::Into<std::option::Option<crate::model::alloy_db_settings::UserPassword>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.initial_user = v.into();
        self
    }

    /// Sets the value of [vpc_network][crate::model::AlloyDbSettings::vpc_network].
    pub fn set_vpc_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_network = v.into();
        self
    }

    /// Sets the value of [primary_instance_settings][crate::model::AlloyDbSettings::primary_instance_settings].
    pub fn set_primary_instance_settings<
        T: std::convert::Into<
            std::option::Option<crate::model::alloy_db_settings::PrimaryInstanceSettings>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.primary_instance_settings = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::AlloyDbSettings::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::alloy_db_settings::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AlloyDbSettings::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AlloyDbSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings"
    }
}

/// Defines additional types related to AlloyDbSettings
pub mod alloy_db_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The username/password for a database user. Used for specifying initial
    /// users at cluster creation time.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UserPassword {
        /// The database username.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub user: std::string::String,

        /// The initial password for the user.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub password: std::string::String,

        /// Output only. Indicates if the initial_user.password field has been set.
        pub password_set: bool,
    }

    impl UserPassword {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [user][crate::model::alloy_db_settings::UserPassword::user].
        pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.user = v.into();
            self
        }

        /// Sets the value of [password][crate::model::alloy_db_settings::UserPassword::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [password_set][crate::model::alloy_db_settings::UserPassword::password_set].
        pub fn set_password_set<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.password_set = v.into();
            self
        }
    }

    impl wkt::message::Message for UserPassword {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.UserPassword"
        }
    }

    /// Settings for the cluster's primary instance
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrimaryInstanceSettings {
        /// Required. The ID of the AlloyDB primary instance. The ID must satisfy the
        /// regex expression "[a-z0-9-]+".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Configuration for the machines that host the underlying
        /// database engine.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_config: std::option::Option<
            crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
        >,

        /// Database flags to pass to AlloyDB when DMS is creating the AlloyDB
        /// cluster and instances. See the AlloyDB documentation for how these can be
        /// used.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub database_flags: std::collections::HashMap<std::string::String, std::string::String>,

        /// Labels for the AlloyDB primary instance created by DMS. An object
        /// containing a list of 'key', 'value' pairs.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// Output only. The private IP address for the Instance.
        /// This is the connection endpoint for an end-user application.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub private_ip: std::string::String,
    }

    impl PrimaryInstanceSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::alloy_db_settings::PrimaryInstanceSettings::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [machine_config][crate::model::alloy_db_settings::PrimaryInstanceSettings::machine_config].
        pub fn set_machine_config<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::alloy_db_settings::primary_instance_settings::MachineConfig,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.machine_config = v.into();
            self
        }

        /// Sets the value of [private_ip][crate::model::alloy_db_settings::PrimaryInstanceSettings::private_ip].
        pub fn set_private_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.private_ip = v.into();
            self
        }

        /// Sets the value of [database_flags][crate::model::alloy_db_settings::PrimaryInstanceSettings::database_flags].
        pub fn set_database_flags<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.database_flags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [labels][crate::model::alloy_db_settings::PrimaryInstanceSettings::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for PrimaryInstanceSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings"
        }
    }

    /// Defines additional types related to PrimaryInstanceSettings
    pub mod primary_instance_settings {
        #[allow(unused_imports)]
        use super::*;

        /// MachineConfig describes the configuration of a machine.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct MachineConfig {
            /// The number of CPU's in the VM instance.
            pub cpu_count: i32,
        }

        impl MachineConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cpu_count][crate::model::alloy_db_settings::primary_instance_settings::MachineConfig::cpu_count].
            pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.cpu_count = v.into();
                self
            }
        }

        impl wkt::message::Message for MachineConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.PrimaryInstanceSettings.MachineConfig"
            }
        }
    }

    /// EncryptionConfig describes the encryption config of a cluster that is
    /// encrypted with a CMEK (customer-managed encryption key).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// The fully-qualified resource name of the KMS key.
        /// Each Cloud KMS key is regionalized and has the following format:
        /// projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_name: std::string::String,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::alloy_db_settings::EncryptionConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.AlloyDbSettings.EncryptionConfig"
        }
    }
}

/// The source database will allow incoming connections from the public IP of the
/// destination database. You can retrieve the public IP of the Cloud SQL
/// instance from the Cloud SQL console or using Cloud SQL APIs. No additional
/// configuration is required.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticIpConnectivity {}

impl StaticIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticIpConnectivity"
    }
}

/// [Private Service Connect
/// connectivity](https://cloud.google.com/vpc/docs/private-service-connect#service-attachments)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateServiceConnectConnectivity {
    /// Required. A service attachment that exposes a database, and has the
    /// following format:
    /// projects/{project}/regions/{region}/serviceAttachments/{service_attachment_name}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,
}

impl PrivateServiceConnectConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PrivateServiceConnectConnectivity::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }
}

impl wkt::message::Message for PrivateServiceConnectConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateServiceConnectConnectivity"
    }
}

/// The details needed to configure a reverse SSH tunnel between the source and
/// destination databases. These details will be used when calling the
/// generateSshScript method (see
/// <https://cloud.google.com/database-migration/docs/reference/rest/v1/projects.locations.migrationJobs/generateSshScript>)
/// to produce the script that will help set up the reverse SSH tunnel, and to
/// set up the VPC peering between the Cloud SQL private network and the VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReverseSshConnectivity {
    /// Required. The IP of the virtual machine (Compute Engine) used as the
    /// bastion server for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_ip: std::string::String,

    /// Required. The forwarding port of the virtual machine (Compute Engine) used
    /// as the bastion server for the SSH tunnel.
    pub vm_port: i32,

    /// The name of the virtual machine (Compute Engine) used as the bastion server
    /// for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm: std::string::String,

    /// The name of the VPC to peer with the Cloud SQL private network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,
}

impl ReverseSshConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_ip][crate::model::ReverseSshConnectivity::vm_ip].
    pub fn set_vm_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_ip = v.into();
        self
    }

    /// Sets the value of [vm_port][crate::model::ReverseSshConnectivity::vm_port].
    pub fn set_vm_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_port = v.into();
        self
    }

    /// Sets the value of [vm][crate::model::ReverseSshConnectivity::vm].
    pub fn set_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::ReverseSshConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for ReverseSshConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ReverseSshConnectivity"
    }
}

/// The details of the VPC where the source database is located in Google Cloud.
/// We will use this information to set up the VPC peering connection between
/// Cloud SQL and this VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcPeeringConnectivity {
    /// The name of the VPC network to peer with the Cloud SQL private network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,
}

impl VpcPeeringConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc][crate::model::VpcPeeringConnectivity::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConnectivity"
    }
}

/// Forward SSH Tunnel connectivity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ForwardSshTunnelConnectivity {
    /// Required. Hostname for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    /// Required. Username for the SSH tunnel.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Port for the SSH tunnel, default value is 22.
    pub port: i32,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authentication_method:
        std::option::Option<crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod>,
}

impl ForwardSshTunnelConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::ForwardSshTunnelConnectivity::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [username][crate::model::ForwardSshTunnelConnectivity::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [port][crate::model::ForwardSshTunnelConnectivity::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of `authentication_method`.
    pub fn set_authentication_method<
        T: std::convert::Into<
            std::option::Option<
                crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod,
            >,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_method = v.into();
        self
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `Password`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_password(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// if it holds a `PrivateKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_private_key(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.authentication_method.as_ref().and_then(|v| match v {
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `Password`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::Password(v.into()),
        );
        self
    }

    /// Sets the value of [authentication_method][crate::model::ForwardSshTunnelConnectivity::authentication_method]
    /// to hold a `PrivateKey`.
    ///
    /// Note that all the setters affecting `authentication_method` are
    /// mutually exclusive.
    pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.authentication_method = std::option::Option::Some(
            crate::model::forward_ssh_tunnel_connectivity::AuthenticationMethod::PrivateKey(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ForwardSshTunnelConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ForwardSshTunnelConnectivity"
    }
}

/// Defines additional types related to ForwardSshTunnelConnectivity
pub mod forward_ssh_tunnel_connectivity {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthenticationMethod {
        /// Input only. SSH password.
        Password(std::string::String),
        /// Input only. SSH private key.
        PrivateKey(std::string::String),
    }
}

/// Static IP address connectivity configured on service project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StaticServiceIpConnectivity {}

impl StaticServiceIpConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StaticServiceIpConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StaticServiceIpConnectivity"
    }
}

/// Private Connectivity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnectivity {
    /// Required. The resource name (URI) of the private connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_connection: std::string::String,
}

impl PrivateConnectivity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_connection][crate::model::PrivateConnectivity::private_connection].
    pub fn set_private_connection<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_connection = v.into();
        self
    }
}

impl wkt::message::Message for PrivateConnectivity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnectivity"
    }
}

/// A message defining the database engine and provider.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseType {
    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The database engine.
    pub engine: crate::model::DatabaseEngine,
}

impl DatabaseType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::DatabaseType::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [engine][crate::model::DatabaseType::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseType"
    }
}

/// Represents a Database Migration Service migration job object.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationJob {
    /// The name (URI) of this migration job resource, in the form of:
    /// projects/{project}/locations/{location}/migrationJobs/{migrationJob}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the migration job resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the migration job resource was last
    /// updated. A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for migration job to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The migration job display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The current migration job state.
    pub state: crate::model::migration_job::State,

    /// Output only. The current migration job phase.
    pub phase: crate::model::migration_job::Phase,

    /// Required. The migration job type.
    #[serde(rename = "type")]
    pub r#type: crate::model::migration_job::Type,

    /// The path to the dump file in Google Cloud Storage,
    /// in the format: (gs://[BUCKET_NAME]/[OBJECT_NAME]).
    /// This field and the "dump_flags" field are mutually exclusive.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dump_path: std::string::String,

    /// The initial dump flags.
    /// This field and the "dump_path" field are mutually exclusive.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dump_flags: std::option::Option<crate::model::migration_job::DumpFlags>,

    /// Required. The resource name (URI) of the source connection profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    /// Required. The resource name (URI) of the destination connection profile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub destination: std::string::String,

    /// Output only. The duration of the migration job (in seconds). A duration in
    /// seconds with up to nine fractional digits, terminated by 's'. Example:
    /// "3.5s".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub duration: std::option::Option<wkt::Duration>,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The database engine type and provider of the source.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_database: std::option::Option<crate::model::DatabaseType>,

    /// The database engine type and provider of the destination.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination_database: std::option::Option<crate::model::DatabaseType>,

    /// Output only. If the migration job is completed, the time when it was
    /// completed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The conversion workspace used by the migration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub conversion_workspace: std::option::Option<crate::model::ConversionWorkspaceInfo>,

    /// This field can be used to select the entities to migrate as part of
    /// the migration job. It uses AIP-160 notation to select a subset of the
    /// entities configured on the associated conversion-workspace. This field
    /// should not be set on migration-jobs that are not associated with a
    /// conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// The CMEK (customer-managed encryption key) fully qualified key name used
    /// for the migration job.
    /// This field supports all migration jobs types except for:
    ///
    /// * Mysql to Mysql (use the cmek field in the cloudsql connection profile
    ///   instead).
    /// * PostrgeSQL to PostgreSQL (use the cmek field in the cloudsql
    ///   connection profile instead).
    /// * PostgreSQL to AlloyDB (use the kms_key_name field in the alloydb
    ///   connection profile instead).
    ///   Each Cloud CMEK key has the following format:
    ///   projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cmek_key_name: std::string::String,

    /// Optional. Data dump parallelism settings used by the migration.
    /// Currently applicable only for MySQL to Cloud SQL for MySQL migrations only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_config: std::option::Option<crate::model::migration_job::PerformanceConfig>,

    /// The connectivity method.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::migration_job::Connectivity>,
}

impl MigrationJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigrationJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MigrationJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MigrationJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigrationJob::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MigrationJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::migration_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [phase][crate::model::MigrationJob::phase].
    pub fn set_phase<T: std::convert::Into<crate::model::migration_job::Phase>>(
        mut self,
        v: T,
    ) -> Self {
        self.phase = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::MigrationJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::migration_job::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [dump_path][crate::model::MigrationJob::dump_path].
    pub fn set_dump_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dump_path = v.into();
        self
    }

    /// Sets the value of [dump_flags][crate::model::MigrationJob::dump_flags].
    pub fn set_dump_flags<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::DumpFlags>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dump_flags = v.into();
        self
    }

    /// Sets the value of [source][crate::model::MigrationJob::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::MigrationJob::destination].
    pub fn set_destination<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::MigrationJob::duration].
    pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.duration = v.into();
        self
    }

    /// Sets the value of [error][crate::model::MigrationJob::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [source_database][crate::model::MigrationJob::source_database].
    pub fn set_source_database<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_database = v.into();
        self
    }

    /// Sets the value of [destination_database][crate::model::MigrationJob::destination_database].
    pub fn set_destination_database<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination_database = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::MigrationJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [conversion_workspace][crate::model::MigrationJob::conversion_workspace].
    pub fn set_conversion_workspace<
        T: std::convert::Into<std::option::Option<crate::model::ConversionWorkspaceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_workspace = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MigrationJob::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [cmek_key_name][crate::model::MigrationJob::cmek_key_name].
    pub fn set_cmek_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cmek_key_name = v.into();
        self
    }

    /// Sets the value of [performance_config][crate::model::MigrationJob::performance_config].
    pub fn set_performance_config<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::PerformanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MigrationJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `connectivity`.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::migration_job::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `ReverseSshConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_reverse_ssh_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReverseSshConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `VpcPeeringConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpc_peering_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connectivity][crate::model::MigrationJob::connectivity]
    /// if it holds a `StaticIpConnectivity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_static_ip_connectivity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StaticIpConnectivity>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `ReverseSshConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_reverse_ssh_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::ReverseSshConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::ReverseSshConnectivity(v.into()),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `VpcPeeringConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::VpcPeeringConnectivity(v.into()),
        );
        self
    }

    /// Sets the value of [connectivity][crate::model::MigrationJob::connectivity]
    /// to hold a `StaticIpConnectivity`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_static_ip_connectivity<
        T: std::convert::Into<std::boxed::Box<crate::model::StaticIpConnectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::migration_job::Connectivity::StaticIpConnectivity(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigrationJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob"
    }
}

/// Defines additional types related to MigrationJob
pub mod migration_job {
    #[allow(unused_imports)]
    use super::*;

    /// Dump flag definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DumpFlag {
        /// The name of the flag
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// The value of the flag.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,
    }

    impl DumpFlag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::migration_job::DumpFlag::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::migration_job::DumpFlag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for DumpFlag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlag"
        }
    }

    /// Dump flags definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DumpFlags {
        /// The flags for the initial dump.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub dump_flags: std::vec::Vec<crate::model::migration_job::DumpFlag>,
    }

    impl DumpFlags {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_flags][crate::model::migration_job::DumpFlags::dump_flags].
        pub fn set_dump_flags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::migration_job::DumpFlag>,
        {
            use std::iter::Iterator;
            self.dump_flags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DumpFlags {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.DumpFlags"
        }
    }

    /// Performance configuration definition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceConfig {
        /// Initial dump parallelism level.
        pub dump_parallel_level: crate::model::migration_job::performance_config::DumpParallelLevel,
    }

    impl PerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dump_parallel_level][crate::model::migration_job::PerformanceConfig::dump_parallel_level].
        pub fn set_dump_parallel_level<
            T: std::convert::Into<crate::model::migration_job::performance_config::DumpParallelLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dump_parallel_level = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.MigrationJob.PerformanceConfig"
        }
    }

    /// Defines additional types related to PerformanceConfig
    pub mod performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Describes the parallelism level during initial dump.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct DumpParallelLevel(std::borrow::Cow<'static, str>);

        impl DumpParallelLevel {
            /// Creates a new DumpParallelLevel instance.
            pub const fn new(v: &'static str) -> Self {
                Self(std::borrow::Cow::Borrowed(v))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [DumpParallelLevel](DumpParallelLevel)
        pub mod dump_parallel_level {
            use super::DumpParallelLevel;

            /// Unknown dump parallel level. Will be defaulted to OPTIMAL.
            pub const DUMP_PARALLEL_LEVEL_UNSPECIFIED: DumpParallelLevel =
                DumpParallelLevel::new("DUMP_PARALLEL_LEVEL_UNSPECIFIED");

            /// Minimal parallel level.
            pub const MIN: DumpParallelLevel = DumpParallelLevel::new("MIN");

            /// Optimal parallel level.
            pub const OPTIMAL: DumpParallelLevel = DumpParallelLevel::new("OPTIMAL");

            /// Maximum parallel level.
            pub const MAX: DumpParallelLevel = DumpParallelLevel::new("MAX");
        }

        impl std::convert::From<std::string::String> for DumpParallelLevel {
            fn from(value: std::string::String) -> Self {
                Self(std::borrow::Cow::Owned(value))
            }
        }

        impl std::default::Default for DumpParallelLevel {
            fn default() -> Self {
                dump_parallel_level::DUMP_PARALLEL_LEVEL_UNSPECIFIED
            }
        }
    }

    /// The current migration job states.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state of the migration job is unknown.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The migration job is down for maintenance.
        pub const MAINTENANCE: State = State::new("MAINTENANCE");

        /// The migration job is in draft mode and no resources are created.
        pub const DRAFT: State = State::new("DRAFT");

        /// The migration job is being created.
        pub const CREATING: State = State::new("CREATING");

        /// The migration job is created and not started.
        pub const NOT_STARTED: State = State::new("NOT_STARTED");

        /// The migration job is running.
        pub const RUNNING: State = State::new("RUNNING");

        /// The migration job failed.
        pub const FAILED: State = State::new("FAILED");

        /// The migration job has been completed.
        pub const COMPLETED: State = State::new("COMPLETED");

        /// The migration job is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// The migration job is being stopped.
        pub const STOPPING: State = State::new("STOPPING");

        /// The migration job is currently stopped.
        pub const STOPPED: State = State::new("STOPPED");

        /// The migration job has been deleted.
        pub const DELETED: State = State::new("DELETED");

        /// The migration job is being updated.
        pub const UPDATING: State = State::new("UPDATING");

        /// The migration job is starting.
        pub const STARTING: State = State::new("STARTING");

        /// The migration job is restarting.
        pub const RESTARTING: State = State::new("RESTARTING");

        /// The migration job is resuming.
        pub const RESUMING: State = State::new("RESUMING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }

    /// The current migration job phase.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Phase(std::borrow::Cow<'static, str>);

    impl Phase {
        /// Creates a new Phase instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Phase](Phase)
    pub mod phase {
        use super::Phase;

        /// The phase of the migration job is unknown.
        pub const PHASE_UNSPECIFIED: Phase = Phase::new("PHASE_UNSPECIFIED");

        /// The migration job is in the full dump phase.
        pub const FULL_DUMP: Phase = Phase::new("FULL_DUMP");

        /// The migration job is CDC phase.
        pub const CDC: Phase = Phase::new("CDC");

        /// The migration job is running the promote phase.
        pub const PROMOTE_IN_PROGRESS: Phase = Phase::new("PROMOTE_IN_PROGRESS");

        /// Only RDS flow - waiting for source writes to stop
        pub const WAITING_FOR_SOURCE_WRITES_TO_STOP: Phase =
            Phase::new("WAITING_FOR_SOURCE_WRITES_TO_STOP");

        /// Only RDS flow - the sources writes stopped, waiting for dump to begin
        pub const PREPARING_THE_DUMP: Phase = Phase::new("PREPARING_THE_DUMP");
    }

    impl std::convert::From<std::string::String> for Phase {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Phase {
        fn default() -> Self {
            phase::PHASE_UNSPECIFIED
        }
    }

    /// The type of migration job (one-time or continuous).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::borrow::Cow<'static, str>);

    impl Type {
        /// Creates a new Type instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {
        use super::Type;

        /// The type of the migration job is unknown.
        pub const TYPE_UNSPECIFIED: Type = Type::new("TYPE_UNSPECIFIED");

        /// The migration job is a one time migration.
        pub const ONE_TIME: Type = Type::new("ONE_TIME");

        /// The migration job is a continuous migration.
        pub const CONTINUOUS: Type = Type::new("CONTINUOUS");
    }

    impl std::convert::From<std::string::String> for Type {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            r#type::TYPE_UNSPECIFIED
        }
    }

    /// The connectivity method.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// The details needed to communicate to the source over Reverse SSH
        /// tunnel connectivity.
        ReverseSshConnectivity(std::boxed::Box<crate::model::ReverseSshConnectivity>),
        /// The details of the VPC network that the source database is located in.
        VpcPeeringConnectivity(std::boxed::Box<crate::model::VpcPeeringConnectivity>),
        /// static ip connectivity data (default, no additional details needed).
        StaticIpConnectivity(std::boxed::Box<crate::model::StaticIpConnectivity>),
    }
}

/// A conversion workspace's version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversionWorkspaceInfo {
    /// The resource name (URI) of the conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The commit ID of the conversion workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub commit_id: std::string::String,
}

impl ConversionWorkspaceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspaceInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_id][crate::model::ConversionWorkspaceInfo::commit_id].
    pub fn set_commit_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_id = v.into();
        self
    }
}

impl wkt::message::Message for ConversionWorkspaceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspaceInfo"
    }
}

/// A connection profile definition.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionProfile {
    /// The name of this connection profile resource in the form of
    /// projects/{project}/locations/{location}/connectionProfiles/{connectionProfile}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp when the resource was created.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the resource was last updated.
    /// A timestamp in RFC3339 UTC "Zulu" format, accurate to nanoseconds.
    /// Example: "2014-10-02T15:01:23.045123456Z".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for connection profile to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    pub state: crate::model::connection_profile::State,

    /// The connection profile display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The database provider.
    pub provider: crate::model::DatabaseProvider,

    /// The connection profile definition.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection_profile:
        std::option::Option<crate::model::connection_profile::ConnectionProfile>,
}

impl ConnectionProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConnectionProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConnectionProfile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConnectionProfile::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::ConnectionProfile::state].
    pub fn set_state<T: std::convert::Into<crate::model::connection_profile::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConnectionProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ConnectionProfile::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [provider][crate::model::ConnectionProfile::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::DatabaseProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ConnectionProfile::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `connection_profile`.
    pub fn set_connection_profile<
        T: std::convert::Into<
            std::option::Option<crate::model::connection_profile::ConnectionProfile>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = v.into();
        self
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Mysql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_mysql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MySqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Mysql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Postgresql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_postgresql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostgreSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Postgresql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Oracle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_oracle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::OracleConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Oracle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Cloudsql`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_cloudsql(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CloudSqlConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// if it holds a `Alloydb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_alloydb(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AlloyDbConnectionProfile>> {
        #[allow(unreachable_patterns)]
        self.connection_profile.as_ref().and_then(|v| match v {
            crate::model::connection_profile::ConnectionProfile::Alloydb(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Mysql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_mysql<
        T: std::convert::Into<std::boxed::Box<crate::model::MySqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Mysql(v.into()),
        );
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Postgresql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_postgresql<
        T: std::convert::Into<std::boxed::Box<crate::model::PostgreSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Postgresql(v.into()),
        );
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Oracle`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_oracle<
        T: std::convert::Into<std::boxed::Box<crate::model::OracleConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Oracle(v.into()),
        );
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Cloudsql`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_cloudsql<
        T: std::convert::Into<std::boxed::Box<crate::model::CloudSqlConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Cloudsql(v.into()),
        );
        self
    }

    /// Sets the value of [connection_profile][crate::model::ConnectionProfile::connection_profile]
    /// to hold a `Alloydb`.
    ///
    /// Note that all the setters affecting `connection_profile` are
    /// mutually exclusive.
    pub fn set_alloydb<
        T: std::convert::Into<std::boxed::Box<crate::model::AlloyDbConnectionProfile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_profile = std::option::Option::Some(
            crate::model::connection_profile::ConnectionProfile::Alloydb(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConnectionProfile"
    }
}

/// Defines additional types related to ConnectionProfile
pub mod connection_profile {
    #[allow(unused_imports)]
    use super::*;

    /// The current connection profile state (e.g. DRAFT, READY, or FAILED).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state of the connection profile is unknown.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The connection profile is in draft mode and fully editable.
        pub const DRAFT: State = State::new("DRAFT");

        /// The connection profile is being created.
        pub const CREATING: State = State::new("CREATING");

        /// The connection profile is ready.
        pub const READY: State = State::new("READY");

        /// The connection profile is being updated.
        pub const UPDATING: State = State::new("UPDATING");

        /// The connection profile is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// The connection profile has been deleted.
        pub const DELETED: State = State::new("DELETED");

        /// The last action on the connection profile failed.
        pub const FAILED: State = State::new("FAILED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }

    /// The connection profile definition.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConnectionProfile {
        /// A MySQL database connection profile.
        Mysql(std::boxed::Box<crate::model::MySqlConnectionProfile>),
        /// A PostgreSQL database connection profile.
        Postgresql(std::boxed::Box<crate::model::PostgreSqlConnectionProfile>),
        /// An Oracle database connection profile.
        Oracle(std::boxed::Box<crate::model::OracleConnectionProfile>),
        /// A CloudSQL database connection profile.
        Cloudsql(std::boxed::Box<crate::model::CloudSqlConnectionProfile>),
        /// An AlloyDB cluster connection profile.
        Alloydb(std::boxed::Box<crate::model::AlloyDbConnectionProfile>),
    }
}

/// Error message of a verification Migration job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationJobVerificationError {
    /// Output only. An instance of ErrorCode specifying the error that occurred.
    pub error_code: crate::model::migration_job_verification_error::ErrorCode,

    /// Output only. A formatted message with further details about the error and a
    /// CTA.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_message: std::string::String,

    /// Output only. A specific detailed error message, if supplied by the engine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error_detail_message: std::string::String,
}

impl MigrationJobVerificationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_code][crate::model::MigrationJobVerificationError::error_code].
    pub fn set_error_code<
        T: std::convert::Into<crate::model::migration_job_verification_error::ErrorCode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error_code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationJobVerificationError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }

    /// Sets the value of [error_detail_message][crate::model::MigrationJobVerificationError::error_detail_message].
    pub fn set_error_detail_message<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.error_detail_message = v.into();
        self
    }
}

impl wkt::message::Message for MigrationJobVerificationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MigrationJobVerificationError"
    }
}

/// Defines additional types related to MigrationJobVerificationError
pub mod migration_job_verification_error {
    #[allow(unused_imports)]
    use super::*;

    /// A general error code describing the type of error that occurred.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ErrorCode(std::borrow::Cow<'static, str>);

    impl ErrorCode {
        /// Creates a new ErrorCode instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ErrorCode](ErrorCode)
    pub mod error_code {
        use super::ErrorCode;

        /// An unknown error occurred
        pub const ERROR_CODE_UNSPECIFIED: ErrorCode = ErrorCode::new("ERROR_CODE_UNSPECIFIED");

        /// We failed to connect to one of the connection profile.
        pub const CONNECTION_FAILURE: ErrorCode = ErrorCode::new("CONNECTION_FAILURE");

        /// We failed to authenticate to one of the connection profile.
        pub const AUTHENTICATION_FAILURE: ErrorCode = ErrorCode::new("AUTHENTICATION_FAILURE");

        /// One of the involved connection profiles has an invalid configuration.
        pub const INVALID_CONNECTION_PROFILE_CONFIG: ErrorCode =
            ErrorCode::new("INVALID_CONNECTION_PROFILE_CONFIG");

        /// The versions of the source and the destination are incompatible.
        pub const VERSION_INCOMPATIBILITY: ErrorCode = ErrorCode::new("VERSION_INCOMPATIBILITY");

        /// The types of the source and the destination are incompatible.
        pub const CONNECTION_PROFILE_TYPES_INCOMPATIBILITY: ErrorCode =
            ErrorCode::new("CONNECTION_PROFILE_TYPES_INCOMPATIBILITY");

        /// No pglogical extension installed on databases, applicable for postgres.
        pub const NO_PGLOGICAL_INSTALLED: ErrorCode = ErrorCode::new("NO_PGLOGICAL_INSTALLED");

        /// pglogical node already exists on databases, applicable for postgres.
        pub const PGLOGICAL_NODE_ALREADY_EXISTS: ErrorCode =
            ErrorCode::new("PGLOGICAL_NODE_ALREADY_EXISTS");

        /// The value of parameter wal_level is not set to logical.
        pub const INVALID_WAL_LEVEL: ErrorCode = ErrorCode::new("INVALID_WAL_LEVEL");

        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        pub const INVALID_SHARED_PRELOAD_LIBRARY: ErrorCode =
            ErrorCode::new("INVALID_SHARED_PRELOAD_LIBRARY");

        /// The value of parameter max_replication_slots is not sufficient.
        pub const INSUFFICIENT_MAX_REPLICATION_SLOTS: ErrorCode =
            ErrorCode::new("INSUFFICIENT_MAX_REPLICATION_SLOTS");

        /// The value of parameter max_wal_senders is not sufficient.
        pub const INSUFFICIENT_MAX_WAL_SENDERS: ErrorCode =
            ErrorCode::new("INSUFFICIENT_MAX_WAL_SENDERS");

        /// The value of parameter max_worker_processes is not sufficient.
        pub const INSUFFICIENT_MAX_WORKER_PROCESSES: ErrorCode =
            ErrorCode::new("INSUFFICIENT_MAX_WORKER_PROCESSES");

        /// Extensions installed are either not supported or having unsupported
        /// versions.
        pub const UNSUPPORTED_EXTENSIONS: ErrorCode = ErrorCode::new("UNSUPPORTED_EXTENSIONS");

        /// Unsupported migration type.
        pub const UNSUPPORTED_MIGRATION_TYPE: ErrorCode =
            ErrorCode::new("UNSUPPORTED_MIGRATION_TYPE");

        /// Invalid RDS logical replication.
        pub const INVALID_RDS_LOGICAL_REPLICATION: ErrorCode =
            ErrorCode::new("INVALID_RDS_LOGICAL_REPLICATION");

        /// The gtid_mode is not supported, applicable for MySQL.
        pub const UNSUPPORTED_GTID_MODE: ErrorCode = ErrorCode::new("UNSUPPORTED_GTID_MODE");

        /// The table definition is not support due to missing primary key or replica
        /// identity.
        pub const UNSUPPORTED_TABLE_DEFINITION: ErrorCode =
            ErrorCode::new("UNSUPPORTED_TABLE_DEFINITION");

        /// The definer is not supported.
        pub const UNSUPPORTED_DEFINER: ErrorCode = ErrorCode::new("UNSUPPORTED_DEFINER");

        /// Migration is already running at the time of restart request.
        pub const CANT_RESTART_RUNNING_MIGRATION: ErrorCode =
            ErrorCode::new("CANT_RESTART_RUNNING_MIGRATION");

        /// The source already has a replication setup.
        pub const SOURCE_ALREADY_SETUP: ErrorCode = ErrorCode::new("SOURCE_ALREADY_SETUP");

        /// The source has tables with limited support.
        /// E.g. PostgreSQL tables without primary keys.
        pub const TABLES_WITH_LIMITED_SUPPORT: ErrorCode =
            ErrorCode::new("TABLES_WITH_LIMITED_SUPPORT");

        /// The source uses an unsupported locale.
        pub const UNSUPPORTED_DATABASE_LOCALE: ErrorCode =
            ErrorCode::new("UNSUPPORTED_DATABASE_LOCALE");

        /// The source uses an unsupported Foreign Data Wrapper configuration.
        pub const UNSUPPORTED_DATABASE_FDW_CONFIG: ErrorCode =
            ErrorCode::new("UNSUPPORTED_DATABASE_FDW_CONFIG");

        /// There was an underlying RDBMS error.
        pub const ERROR_RDBMS: ErrorCode = ErrorCode::new("ERROR_RDBMS");

        /// The source DB size in Bytes exceeds a certain threshold. The migration
        /// might require an increase of quota, or might not be supported.
        pub const SOURCE_SIZE_EXCEEDS_THRESHOLD: ErrorCode =
            ErrorCode::new("SOURCE_SIZE_EXCEEDS_THRESHOLD");

        /// The destination DB contains existing databases that are conflicting with
        /// those in the source DB.
        pub const EXISTING_CONFLICTING_DATABASES: ErrorCode =
            ErrorCode::new("EXISTING_CONFLICTING_DATABASES");

        /// Insufficient privilege to enable the parallelism configuration.
        pub const PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE: ErrorCode =
            ErrorCode::new("PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE");
    }

    impl std::convert::From<std::string::String> for ErrorCode {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            error_code::ERROR_CODE_UNSPECIFIED
        }
    }
}

/// The PrivateConnection resource is used to establish private connectivity
/// with the customer's network.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivateConnection {
    /// The name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The resource labels for private connections to use to annotate any related
    /// underlying resources such as Compute Engine VMs. An object containing a
    /// list of "key": "value" pairs.
    ///
    /// Example: `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The private connection display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The state of the private connection.
    pub state: crate::model::private_connection::State,

    /// Output only. The error details in case of state FAILED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connectivity: std::option::Option<crate::model::private_connection::Connectivity>,
}

impl PrivateConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PrivateConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PrivateConnection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PrivateConnection::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PrivateConnection::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PrivateConnection::state].
    pub fn set_state<T: std::convert::Into<crate::model::private_connection::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::PrivateConnection::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::PrivateConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `connectivity`.
    pub fn set_connectivity<
        T: std::convert::Into<std::option::Option<crate::model::private_connection::Connectivity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = v.into();
        self
    }

    /// The value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// if it holds a `VpcPeeringConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vpc_peering_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VpcPeeringConfig>> {
        #[allow(unreachable_patterns)]
        self.connectivity.as_ref().and_then(|v| match v {
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connectivity][crate::model::PrivateConnection::connectivity]
    /// to hold a `VpcPeeringConfig`.
    ///
    /// Note that all the setters affecting `connectivity` are
    /// mutually exclusive.
    pub fn set_vpc_peering_config<
        T: std::convert::Into<std::boxed::Box<crate::model::VpcPeeringConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connectivity = std::option::Option::Some(
            crate::model::private_connection::Connectivity::VpcPeeringConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivateConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PrivateConnection"
    }
}

/// Defines additional types related to PrivateConnection
pub mod private_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Private Connection state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The private connection is in creation state - creating resources.
        pub const CREATING: State = State::new("CREATING");

        /// The private connection has been created with all of its resources.
        pub const CREATED: State = State::new("CREATED");

        /// The private connection creation has failed.
        pub const FAILED: State = State::new("FAILED");

        /// The private connection is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// Delete request has failed, resource is in invalid state.
        pub const FAILED_TO_DELETE: State = State::new("FAILED_TO_DELETE");

        /// The private connection has been deleted.
        pub const DELETED: State = State::new("DELETED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connectivity {
        /// VPC peering configuration.
        VpcPeeringConfig(std::boxed::Box<crate::model::VpcPeeringConfig>),
    }
}

/// The VPC peering configuration is used to create VPC peering with the
/// consumer's VPC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpcPeeringConfig {
    /// Required. Fully qualified name of the VPC that Database Migration Service
    /// will peer to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_name: std::string::String,

    /// Required. A free subnet for peering. (CIDR of /29)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,
}

impl VpcPeeringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpc_name][crate::model::VpcPeeringConfig::vpc_name].
    pub fn set_vpc_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_name = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::VpcPeeringConfig::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }
}

impl wkt::message::Message for VpcPeeringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.VpcPeeringConfig"
    }
}

/// The type and version of a source or destination database.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseEngineInfo {
    /// Required. Engine type.
    pub engine: crate::model::DatabaseEngine,

    /// Required. Engine named version, for example 12.c.1.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,
}

impl DatabaseEngineInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engine][crate::model::DatabaseEngineInfo::engine].
    pub fn set_engine<T: std::convert::Into<crate::model::DatabaseEngine>>(mut self, v: T) -> Self {
        self.engine = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatabaseEngineInfo::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseEngineInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEngineInfo"
    }
}

/// The main conversion workspace resource entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConversionWorkspace {
    /// Full name of the workspace resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{conversion_workspace}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The source engine details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Required. The destination engine details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::DatabaseEngineInfo>,

    /// Optional. A generic list of settings for the workspace.
    /// The settings are database pair dependant and can indicate default behavior
    /// for the mapping rules engine or turn on or off specific features.
    /// Such examples can be: convert_foreign_key_to_interleave=true,
    /// skip_triggers=false, ignore_non_table_synonyms=true
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub global_settings: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Whether the workspace has uncommitted changes (changes which
    /// were made after the workspace was committed).
    pub has_uncommitted_changes: bool,

    /// Output only. The latest commit ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub latest_commit_id: std::string::String,

    /// Output only. The timestamp when the workspace was committed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latest_commit_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when the workspace resource was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The display name for the workspace.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,
}

impl ConversionWorkspace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversionWorkspace::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ConversionWorkspace::source].
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEngineInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ConversionWorkspace::destination].
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::DatabaseEngineInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// Sets the value of [has_uncommitted_changes][crate::model::ConversionWorkspace::has_uncommitted_changes].
    pub fn set_has_uncommitted_changes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.has_uncommitted_changes = v.into();
        self
    }

    /// Sets the value of [latest_commit_id][crate::model::ConversionWorkspace::latest_commit_id].
    pub fn set_latest_commit_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_commit_id = v.into();
        self
    }

    /// Sets the value of [latest_commit_time][crate::model::ConversionWorkspace::latest_commit_time].
    pub fn set_latest_commit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.latest_commit_time = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConversionWorkspace::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ConversionWorkspace::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversionWorkspace::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [global_settings][crate::model::ConversionWorkspace::global_settings].
    pub fn set_global_settings<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.global_settings = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ConversionWorkspace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConversionWorkspace"
    }
}

/// Execution log of a background job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackgroundJobLogEntry {
    /// The background job log entry ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of job that was executed.
    pub job_type: crate::model::BackgroundJobType,

    /// The timestamp when the background job was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the background job was finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Job completion state, i.e. the final state after the job
    /// completed.
    pub completion_state: crate::model::background_job_log_entry::JobCompletionState,

    /// Output only. Job completion comment, such as how many entities were seeded,
    /// how many warnings were found during conversion, and similar information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub completion_comment: std::string::String,

    /// Output only. Whether the client requested the conversion workspace to be
    /// committed after a successful completion of the job.
    pub request_autocommit: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job_details: std::option::Option<crate::model::background_job_log_entry::JobDetails>,
}

impl BackgroundJobLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::BackgroundJobLogEntry::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [job_type][crate::model::BackgroundJobLogEntry::job_type].
    pub fn set_job_type<T: std::convert::Into<crate::model::BackgroundJobType>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackgroundJobLogEntry::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::BackgroundJobLogEntry::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }

    /// Sets the value of [completion_state][crate::model::BackgroundJobLogEntry::completion_state].
    pub fn set_completion_state<
        T: std::convert::Into<crate::model::background_job_log_entry::JobCompletionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.completion_state = v.into();
        self
    }

    /// Sets the value of [completion_comment][crate::model::BackgroundJobLogEntry::completion_comment].
    pub fn set_completion_comment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_comment = v.into();
        self
    }

    /// Sets the value of [request_autocommit][crate::model::BackgroundJobLogEntry::request_autocommit].
    pub fn set_request_autocommit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.request_autocommit = v.into();
        self
    }

    /// Sets the value of `job_details`.
    pub fn set_job_details<
        T: std::convert::Into<std::option::Option<crate::model::background_job_log_entry::JobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = v.into();
        self
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `SeedJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_seed_job_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>
    {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ImportRulesJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_import_rules_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ConvertJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_convert_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// if it holds a `ApplyJobDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_apply_job_details(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
    > {
        #[allow(unreachable_patterns)]
        self.job_details.as_ref().and_then(|v| match v {
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `SeedJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_seed_job_details<
        T: std::convert::Into<std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::SeedJobDetails(v.into()),
        );
        self
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ImportRulesJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_import_rules_job_details<
        T: std::convert::Into<
            std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ImportRulesJobDetails(v.into()),
        );
        self
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ConvertJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_convert_job_details<
        T: std::convert::Into<
            std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ConvertJobDetails(v.into()),
        );
        self
    }

    /// Sets the value of [job_details][crate::model::BackgroundJobLogEntry::job_details]
    /// to hold a `ApplyJobDetails`.
    ///
    /// Note that all the setters affecting `job_details` are
    /// mutually exclusive.
    pub fn set_apply_job_details<
        T: std::convert::Into<
            std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_details = std::option::Option::Some(
            crate::model::background_job_log_entry::JobDetails::ApplyJobDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BackgroundJobLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry"
    }
}

/// Defines additional types related to BackgroundJobLogEntry
pub mod background_job_log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Details regarding a Seed background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SeedJobDetails {
        /// Output only. The connection profile which was used for the seed job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection_profile: std::string::String,
    }

    impl SeedJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::SeedJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }
    }

    impl wkt::message::Message for SeedJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.SeedJobDetails"
        }
    }

    /// Details regarding an Import Rules background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportRulesJobDetails {
        /// Output only. File names used for the import rules job.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub files: std::vec::Vec<std::string::String>,

        /// Output only. The requested file format.
        pub file_format: crate::model::ImportRulesFileFormat,
    }

    impl ImportRulesJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [file_format][crate::model::background_job_log_entry::ImportRulesJobDetails::file_format].
        pub fn set_file_format<T: std::convert::Into<crate::model::ImportRulesFileFormat>>(
            mut self,
            v: T,
        ) -> Self {
            self.file_format = v.into();
            self
        }

        /// Sets the value of [files][crate::model::background_job_log_entry::ImportRulesJobDetails::files].
        pub fn set_files<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.files = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ImportRulesJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ImportRulesJobDetails"
        }
    }

    /// Details regarding a Convert background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConvertJobDetails {
        /// Output only. AIP-160 based filter used to specify the entities to convert
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,
    }

    impl ConvertJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ConvertJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ConvertJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ConvertJobDetails"
        }
    }

    /// Details regarding an Apply background job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ApplyJobDetails {
        /// Output only. The connection profile which was used for the apply job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection_profile: std::string::String,

        /// Output only. AIP-160 based filter used to specify the entities to apply
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub filter: std::string::String,
    }

    impl ApplyJobDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [connection_profile][crate::model::background_job_log_entry::ApplyJobDetails::connection_profile].
        pub fn set_connection_profile<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.connection_profile = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::background_job_log_entry::ApplyJobDetails::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for ApplyJobDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.BackgroundJobLogEntry.ApplyJobDetails"
        }
    }

    /// Final state after a job completes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct JobCompletionState(std::borrow::Cow<'static, str>);

    impl JobCompletionState {
        /// Creates a new JobCompletionState instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [JobCompletionState](JobCompletionState)
    pub mod job_completion_state {
        use super::JobCompletionState;

        /// The status is not specified. This state is used when job is not yet
        /// finished.
        pub const JOB_COMPLETION_STATE_UNSPECIFIED: JobCompletionState =
            JobCompletionState::new("JOB_COMPLETION_STATE_UNSPECIFIED");

        /// Success.
        pub const SUCCEEDED: JobCompletionState = JobCompletionState::new("SUCCEEDED");

        /// Error.
        pub const FAILED: JobCompletionState = JobCompletionState::new("FAILED");
    }

    impl std::convert::From<std::string::String> for JobCompletionState {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for JobCompletionState {
        fn default() -> Self {
            job_completion_state::JOB_COMPLETION_STATE_UNSPECIFIED
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum JobDetails {
        /// Output only. Seed job details.
        SeedJobDetails(std::boxed::Box<crate::model::background_job_log_entry::SeedJobDetails>),
        /// Output only. Import rules job details.
        ImportRulesJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ImportRulesJobDetails>,
        ),
        /// Output only. Convert job details.
        ConvertJobDetails(
            std::boxed::Box<crate::model::background_job_log_entry::ConvertJobDetails>,
        ),
        /// Output only. Apply job details.
        ApplyJobDetails(std::boxed::Box<crate::model::background_job_log_entry::ApplyJobDetails>),
    }
}

/// A filter defining the entities that a mapping rule should be applied to.
/// When more than one field is specified, the rule is applied only to
/// entities which match all the fields.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MappingRuleFilter {
    /// Optional. The rule should be applied to entities whose parent entity
    /// (fully qualified name) matches the given value.
    /// For example, if the rule applies to a table entity, the expected value
    /// should be a schema (schema). If the rule applies to a column or index
    /// entity, the expected value can be either a schema (schema) or a table
    /// (schema.table)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_entity: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// starts with the given prefix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_prefix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// ends with the given suffix.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_suffix: std::string::String,

    /// Optional. The rule should be applied to entities whose non-qualified name
    /// contains the given string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity_name_contains: std::string::String,

    /// Optional. The rule should be applied to specific entities defined by their
    /// fully qualified names.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<std::string::String>,
}

impl MappingRuleFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent_entity][crate::model::MappingRuleFilter::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [entity_name_prefix][crate::model::MappingRuleFilter::entity_name_prefix].
    pub fn set_entity_name_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_prefix = v.into();
        self
    }

    /// Sets the value of [entity_name_suffix][crate::model::MappingRuleFilter::entity_name_suffix].
    pub fn set_entity_name_suffix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_suffix = v.into();
        self
    }

    /// Sets the value of [entity_name_contains][crate::model::MappingRuleFilter::entity_name_contains].
    pub fn set_entity_name_contains<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_name_contains = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::MappingRuleFilter::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MappingRuleFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRuleFilter"
    }
}

/// Definition of a transformation that is to be applied to a group of entities
/// in the source schema. Several such transformations can be applied to an
/// entity sequentially to define the corresponding entity in the target schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MappingRule {
    /// Full name of the mapping rule resource, in the form of:
    /// projects/{project}/locations/{location}/conversionWorkspaces/{set}/mappingRule/{rule}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A human readable name
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. The mapping rule state
    pub state: crate::model::mapping_rule::State,

    /// Required. The rule scope
    pub rule_scope: crate::model::DatabaseEntityType,

    /// Required. The rule filter
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::MappingRuleFilter>,

    /// Required. The order in which the rule is applied. Lower order rules are
    /// applied before higher value rules so they may end up being overridden.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub rule_order: i64,

    /// Output only. The revision ID of the mapping rule.
    /// A new revision is committed whenever the mapping rule is changed in any
    /// way. The format is an 8-character hexadecimal string.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,

    /// Output only. The timestamp that the revision was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub revision_create_time: std::option::Option<wkt::Timestamp>,

    /// The rule specific details.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::mapping_rule::Details>,
}

impl MappingRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MappingRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MappingRule::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::MappingRule::state].
    pub fn set_state<T: std::convert::Into<crate::model::mapping_rule::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [rule_scope][crate::model::MappingRule::rule_scope].
    pub fn set_rule_scope<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_scope = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::MappingRule::filter].
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::MappingRuleFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [rule_order][crate::model::MappingRule::rule_order].
    pub fn set_rule_order<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rule_order = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::MappingRule::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [revision_create_time][crate::model::MappingRule::revision_create_time].
    pub fn set_revision_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.revision_create_time = v.into();
        self
    }

    /// Sets the value of `details`.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::mapping_rule::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_single_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiEntityRename`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_multi_entity_rename(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiEntityRename>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiEntityRename(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `EntityMove`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_entity_move(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EntityMove>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::EntityMove(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SingleColumnChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_single_column_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SingleColumnChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SingleColumnChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `MultiColumnDataTypeChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_multi_column_data_type_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiColumnDatatypeChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConditionalColumnSetValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_conditional_column_set_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConditionalColumnSetValue>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `ConvertRowidColumn`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_convert_rowid_column(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ConvertRowIdToColumn>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::ConvertRowidColumn(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SetTablePrimaryKey`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_set_table_primary_key(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SetTablePrimaryKey>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SinglePackageChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_single_package_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SinglePackageChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SinglePackageChange(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `SourceSqlChange`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_sql_change(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceSqlChange>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::SourceSqlChange(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [details][crate::model::MappingRule::details]
    /// if it holds a `FilterTableColumns`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_filter_table_columns(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FilterTableColumns>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::mapping_rule::Details::FilterTableColumns(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleEntityRename(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiEntityRename`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_entity_rename<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiEntityRename>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiEntityRename(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `EntityMove`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_entity_move<T: std::convert::Into<std::boxed::Box<crate::model::EntityMove>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::mapping_rule::Details::EntityMove(v.into()));
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SingleColumnChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_column_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SingleColumnChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SingleColumnChange(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `MultiColumnDataTypeChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_multi_column_data_type_change<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiColumnDatatypeChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::MultiColumnDataTypeChange(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConditionalColumnSetValue`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_conditional_column_set_value<
        T: std::convert::Into<std::boxed::Box<crate::model::ConditionalColumnSetValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConditionalColumnSetValue(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `ConvertRowidColumn`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_convert_rowid_column<
        T: std::convert::Into<std::boxed::Box<crate::model::ConvertRowIdToColumn>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::ConvertRowidColumn(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SetTablePrimaryKey`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_set_table_primary_key<
        T: std::convert::Into<std::boxed::Box<crate::model::SetTablePrimaryKey>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SetTablePrimaryKey(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SinglePackageChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_single_package_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SinglePackageChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SinglePackageChange(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `SourceSqlChange`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_source_sql_change<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceSqlChange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::SourceSqlChange(v.into()),
        );
        self
    }

    /// Sets the value of [details][crate::model::MappingRule::details]
    /// to hold a `FilterTableColumns`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_filter_table_columns<
        T: std::convert::Into<std::boxed::Box<crate::model::FilterTableColumns>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::mapping_rule::Details::FilterTableColumns(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MappingRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MappingRule"
    }
}

/// Defines additional types related to MappingRule
pub mod mapping_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The current mapping rule state such as enabled, disabled or deleted.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// The state of the mapping rule is unknown.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The rule is enabled.
        pub const ENABLED: State = State::new("ENABLED");

        /// The rule is disabled.
        pub const DISABLED: State = State::new("DISABLED");

        /// The rule is logically deleted.
        pub const DELETED: State = State::new("DELETED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            state::STATE_UNSPECIFIED
        }
    }

    /// The rule specific details.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Optional. Rule to specify how a single entity should be renamed.
        SingleEntityRename(std::boxed::Box<crate::model::SingleEntityRename>),
        /// Optional. Rule to specify how multiple entities should be renamed.
        MultiEntityRename(std::boxed::Box<crate::model::MultiEntityRename>),
        /// Optional. Rule to specify how multiple entities should be relocated into
        /// a different schema.
        EntityMove(std::boxed::Box<crate::model::EntityMove>),
        /// Optional. Rule to specify how a single column is converted.
        SingleColumnChange(std::boxed::Box<crate::model::SingleColumnChange>),
        /// Optional. Rule to specify how multiple columns should be converted to a
        /// different data type.
        MultiColumnDataTypeChange(std::boxed::Box<crate::model::MultiColumnDatatypeChange>),
        /// Optional. Rule to specify how the data contained in a column should be
        /// transformed (such as trimmed, rounded, etc) provided that the data meets
        /// certain criteria.
        ConditionalColumnSetValue(std::boxed::Box<crate::model::ConditionalColumnSetValue>),
        /// Optional. Rule to specify how multiple tables should be converted with an
        /// additional rowid column.
        ConvertRowidColumn(std::boxed::Box<crate::model::ConvertRowIdToColumn>),
        /// Optional. Rule to specify the primary key for a table
        SetTablePrimaryKey(std::boxed::Box<crate::model::SetTablePrimaryKey>),
        /// Optional. Rule to specify how a single package is converted.
        SinglePackageChange(std::boxed::Box<crate::model::SinglePackageChange>),
        /// Optional. Rule to change the sql code for an entity, for example,
        /// function, procedure.
        SourceSqlChange(std::boxed::Box<crate::model::SourceSqlChange>),
        /// Optional. Rule to specify the list of columns to include or exclude from
        /// a table.
        FilterTableColumns(std::boxed::Box<crate::model::FilterTableColumns>),
    }
}

/// Options to configure rule type SingleEntityRename.
/// The rule is used to rename an entity.
///
/// The rule filter field can refer to only one entity.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT,
/// Synonym
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleEntityRename {
    /// Required. The new name of the destination entity
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_name: std::string::String,
}

impl SingleEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name][crate::model::SingleEntityRename::new_name].
    pub fn set_new_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_name = v.into();
        self
    }
}

impl wkt::message::Message for SingleEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleEntityRename"
    }
}

/// Options to configure rule type MultiEntityRename.
/// The rule is used to rename multiple entities.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Database, Schema, Table, Column, Constraint,
/// Index, View, Function, Stored Procedure, Materialized View, Sequence, UDT
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MultiEntityRename {
    /// Optional. The pattern used to generate the new entity's name. This pattern
    /// must include the characters '{name}', which will be replaced with the name
    /// of the original entity. For example, the pattern 't_{name}' for an entity
    /// name jobs would be converted to 't_jobs'.
    ///
    /// If unspecified, the default value for this field is '{name}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_name_pattern: std::string::String,

    /// Optional. Additional transformation that can be done on the source entity
    /// name before it is being used by the new_name_pattern, for example lower
    /// case. If no transformation is desired, use NO_TRANSFORMATION
    pub source_name_transformation: crate::model::EntityNameTransformation,
}

impl MultiEntityRename {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_name_pattern][crate::model::MultiEntityRename::new_name_pattern].
    pub fn set_new_name_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_name_pattern = v.into();
        self
    }

    /// Sets the value of [source_name_transformation][crate::model::MultiEntityRename::source_name_transformation].
    pub fn set_source_name_transformation<
        T: std::convert::Into<crate::model::EntityNameTransformation>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_name_transformation = v.into();
        self
    }
}

impl wkt::message::Message for MultiEntityRename {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiEntityRename"
    }
}

/// Options to configure rule type EntityMove.
/// The rule is used to move an entity to a new schema.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table, Column, Constraint, Index, View,
/// Function, Stored Procedure, Materialized View, Sequence, UDT
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMove {
    /// Required. The new schema
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_schema: std::string::String,
}

impl EntityMove {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_schema][crate::model::EntityMove::new_schema].
    pub fn set_new_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_schema = v.into();
        self
    }
}

impl wkt::message::Message for EntityMove {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMove"
    }
}

/// Options to configure rule type SingleColumnChange.
/// The rule is used to change the properties of a column.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Column.
///
/// When using this rule, if a field is not specified than the destination
/// column's configuration will be the same as the one in the source column..
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SingleColumnChange {
    /// Optional. Column data type name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Optional. Charset override - instead of table level charset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// Optional. Collation override - instead of table level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Optional. Column length - e.g. 50 as in varchar (50) - when relevant.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub length: i64,

    /// Optional. Column precision - e.g. 8 as in double (8,2) - when relevant.
    pub precision: i32,

    /// Optional. Column scale - e.g. 2 as in double (8,2) - when relevant.
    pub scale: i32,

    /// Optional. Column fractional seconds precision - e.g. 2 as in timestamp (2)
    ///
    /// - when relevant.
    pub fractional_seconds_precision: i32,

    /// Optional. Is the column of array type.
    pub array: bool,

    /// Optional. The length of the array, only relevant if the column type is an
    /// array.
    pub array_length: i32,

    /// Optional. Is the column nullable.
    pub nullable: bool,

    /// Optional. Is the column auto-generated/identity.
    pub auto_generated: bool,

    /// Optional. Is the column a UDT (User-defined Type).
    pub udt: bool,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Optional. Specifies the list of values allowed in the column.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub set_values: std::vec::Vec<std::string::String>,

    /// Optional. Comment associated with the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,
}

impl SingleColumnChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_type][crate::model::SingleColumnChange::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::SingleColumnChange::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::SingleColumnChange::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::SingleColumnChange::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::SingleColumnChange::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::SingleColumnChange::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::SingleColumnChange::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::SingleColumnChange::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::SingleColumnChange::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::SingleColumnChange::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::SingleColumnChange::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::SingleColumnChange::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SingleColumnChange::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::SingleColumnChange::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [set_values][crate::model::SingleColumnChange::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SingleColumnChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SingleColumnChange"
    }
}

/// Options to configure rule type MultiColumnDatatypeChange.
/// The rule is used to change the data type and associated properties of
/// multiple columns at once.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of:Column.
///
/// This rule requires additional filters to be specified beyond the basic rule
/// filter field, which is the source data type, but the rule supports additional
/// filtering capabilities such as the minimum and maximum field length. All
/// additional filters which are specified are required to be met in order for
/// the rule to be applied (logical AND between the fields).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MultiColumnDatatypeChange {
    /// Required. Filter on source data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_data_type_filter: std::string::String,

    /// Required. New data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub new_data_type: std::string::String,

    /// Optional. Column length - e.g. varchar (50) - if not specified and relevant
    /// uses the source column length.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub override_length: i64,

    /// Optional. Column scale - when relevant - if not specified and relevant
    /// uses the source column scale.
    pub override_scale: i32,

    /// Optional. Column precision - when relevant - if not specified and relevant
    /// uses the source column precision.
    pub override_precision: i32,

    /// Optional. Column fractional seconds precision - used only for timestamp
    /// based datatypes - if not specified and relevant uses the source column
    /// fractional seconds precision.
    pub override_fractional_seconds_precision: i32,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Filter on source column parameters.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_filter:
        std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,
}

impl MultiColumnDatatypeChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_data_type_filter][crate::model::MultiColumnDatatypeChange::source_data_type_filter].
    pub fn set_source_data_type_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_data_type_filter = v.into();
        self
    }

    /// Sets the value of [new_data_type][crate::model::MultiColumnDatatypeChange::new_data_type].
    pub fn set_new_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_data_type = v.into();
        self
    }

    /// Sets the value of [override_length][crate::model::MultiColumnDatatypeChange::override_length].
    pub fn set_override_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.override_length = v.into();
        self
    }

    /// Sets the value of [override_scale][crate::model::MultiColumnDatatypeChange::override_scale].
    pub fn set_override_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_scale = v.into();
        self
    }

    /// Sets the value of [override_precision][crate::model::MultiColumnDatatypeChange::override_precision].
    pub fn set_override_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.override_precision = v.into();
        self
    }

    /// Sets the value of [override_fractional_seconds_precision][crate::model::MultiColumnDatatypeChange::override_fractional_seconds_precision].
    pub fn set_override_fractional_seconds_precision<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.override_fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MultiColumnDatatypeChange::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of `source_filter`.
    pub fn set_source_filter<
        T: std::convert::Into<
            std::option::Option<crate::model::multi_column_datatype_change::SourceFilter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// Sets the value of [source_filter][crate::model::MultiColumnDatatypeChange::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::multi_column_datatype_change::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MultiColumnDatatypeChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MultiColumnDatatypeChange"
    }
}

/// Defines additional types related to MultiColumnDatatypeChange
pub mod multi_column_datatype_change {
    #[allow(unused_imports)]
    use super::*;

    /// Filter on source column parameters.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Filter for text-based data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Filter for fixed point number data types such as
        /// NUMERIC/NUMBER.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Filter for text-based data types like varchar.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceTextFilter {
    /// Optional. The filter will match columns with length greater than or equal
    /// to this number.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub source_min_length_filter: i64,

    /// Optional. The filter will match columns with length smaller than or equal
    /// to this number.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub source_max_length_filter: i64,
}

impl SourceTextFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_length_filter][crate::model::SourceTextFilter::source_min_length_filter].
    pub fn set_source_min_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_min_length_filter = v.into();
        self
    }

    /// Sets the value of [source_max_length_filter][crate::model::SourceTextFilter::source_max_length_filter].
    pub fn set_source_max_length_filter<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.source_max_length_filter = v.into();
        self
    }
}

impl wkt::message::Message for SourceTextFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceTextFilter"
    }
}

/// Filter for fixed point number data types such as NUMERIC/NUMBER
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceNumericFilter {
    /// Optional. The filter will match columns with scale greater than or equal to
    /// this number.
    pub source_min_scale_filter: i32,

    /// Optional. The filter will match columns with scale smaller than or equal to
    /// this number.
    pub source_max_scale_filter: i32,

    /// Optional. The filter will match columns with precision greater than or
    /// equal to this number.
    pub source_min_precision_filter: i32,

    /// Optional. The filter will match columns with precision smaller than or
    /// equal to this number.
    pub source_max_precision_filter: i32,

    /// Required. Enum to set the option defining the datatypes numeric filter has
    /// to be applied to
    pub numeric_filter_option: crate::model::NumericFilterOption,
}

impl SourceNumericFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_min_scale_filter][crate::model::SourceNumericFilter::source_min_scale_filter].
    pub fn set_source_min_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_max_scale_filter][crate::model::SourceNumericFilter::source_max_scale_filter].
    pub fn set_source_max_scale_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_scale_filter = v.into();
        self
    }

    /// Sets the value of [source_min_precision_filter][crate::model::SourceNumericFilter::source_min_precision_filter].
    pub fn set_source_min_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_min_precision_filter = v.into();
        self
    }

    /// Sets the value of [source_max_precision_filter][crate::model::SourceNumericFilter::source_max_precision_filter].
    pub fn set_source_max_precision_filter<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_max_precision_filter = v.into();
        self
    }

    /// Sets the value of [numeric_filter_option][crate::model::SourceNumericFilter::numeric_filter_option].
    pub fn set_numeric_filter_option<T: std::convert::Into<crate::model::NumericFilterOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.numeric_filter_option = v.into();
        self
    }
}

impl wkt::message::Message for SourceNumericFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceNumericFilter"
    }
}

/// Options to configure rule type ConditionalColumnSetValue.
/// The rule is used to transform the data which is being replicated/migrated.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Column.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConditionalColumnSetValue {
    /// Required. Description of data transformation during migration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value_transformation: std::option::Option<crate::model::ValueTransformation>,

    /// Optional. Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_filter:
        std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,
}

impl ConditionalColumnSetValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_transformation][crate::model::ConditionalColumnSetValue::value_transformation].
    pub fn set_value_transformation<
        T: std::convert::Into<std::option::Option<crate::model::ValueTransformation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value_transformation = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ConditionalColumnSetValue::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of `source_filter`.
    pub fn set_source_filter<
        T: std::convert::Into<
            std::option::Option<crate::model::conditional_column_set_value::SourceFilter>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = v.into();
        self
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceTextFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_text_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceTextFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// if it holds a `SourceNumericFilter`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_source_numeric_filter(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SourceNumericFilter>> {
        #[allow(unreachable_patterns)]
        self.source_filter.as_ref().and_then(|v| match v {
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceTextFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_text_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceTextFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceTextFilter(v.into()),
        );
        self
    }

    /// Sets the value of [source_filter][crate::model::ConditionalColumnSetValue::source_filter]
    /// to hold a `SourceNumericFilter`.
    ///
    /// Note that all the setters affecting `source_filter` are
    /// mutually exclusive.
    pub fn set_source_numeric_filter<
        T: std::convert::Into<std::boxed::Box<crate::model::SourceNumericFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_filter = std::option::Option::Some(
            crate::model::conditional_column_set_value::SourceFilter::SourceNumericFilter(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConditionalColumnSetValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConditionalColumnSetValue"
    }
}

/// Defines additional types related to ConditionalColumnSetValue
pub mod conditional_column_set_value {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceFilter {
        /// Optional. Optional filter on source column length. Used for text based
        /// data types like varchar.
        SourceTextFilter(std::boxed::Box<crate::model::SourceTextFilter>),
        /// Optional. Optional filter on source column precision and scale. Used for
        /// fixed point numbers such as NUMERIC/NUMBER data types.
        SourceNumericFilter(std::boxed::Box<crate::model::SourceNumericFilter>),
    }
}

/// Description of data transformation during migration as part of the
/// ConditionalColumnSetValue.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueTransformation {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub filter: std::option::Option<crate::model::value_transformation::Filter>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub action: std::option::Option<crate::model::value_transformation::Action>,
}

impl ValueTransformation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `filter`.
    pub fn set_filter<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Filter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IsNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_is_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IsNull(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `ValueList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_value_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ValueListFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::ValueList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `IntComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::IntComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [filter][crate::model::ValueTransformation::filter]
    /// if it holds a `DoubleComparison`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_comparison(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DoubleComparisonFilter>> {
        #[allow(unreachable_patterns)]
        self.filter.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Filter::DoubleComparison(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IsNull`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_is_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(mut self, v: T) -> Self {
        self.filter =
            std::option::Option::Some(crate::model::value_transformation::Filter::IsNull(v.into()));
        self
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `ValueList`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_value_list<T: std::convert::Into<std::boxed::Box<crate::model::ValueListFilter>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::ValueList(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `IntComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_int_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::IntComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::IntComparison(v.into()),
        );
        self
    }

    /// Sets the value of [filter][crate::model::ValueTransformation::filter]
    /// to hold a `DoubleComparison`.
    ///
    /// Note that all the setters affecting `filter` are
    /// mutually exclusive.
    pub fn set_double_comparison<
        T: std::convert::Into<std::boxed::Box<crate::model::DoubleComparisonFilter>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filter = std::option::Option::Some(
            crate::model::value_transformation::Filter::DoubleComparison(v.into()),
        );
        self
    }

    /// Sets the value of `action`.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::value_transformation::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignNull`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_assign_null(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignNull(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignSpecificValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_assign_specific_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AssignSpecificValue>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignSpecificValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMinValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_assign_min_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMinValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `AssignMaxValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_assign_max_value(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::AssignMaxValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `RoundScale`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_round_scale(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RoundToScale>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::RoundScale(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [action][crate::model::ValueTransformation::action]
    /// if it holds a `ApplyHash`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_apply_hash(&self) -> std::option::Option<&std::boxed::Box<crate::model::ApplyHash>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::value_transformation::Action::ApplyHash(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignNull`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_null<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignNull(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignSpecificValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_specific_value<
        T: std::convert::Into<std::boxed::Box<crate::model::AssignSpecificValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignSpecificValue(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMinValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_min_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMinValue(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `AssignMaxValue`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_assign_max_value<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::AssignMaxValue(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `RoundScale`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_round_scale<T: std::convert::Into<std::boxed::Box<crate::model::RoundToScale>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::RoundScale(v.into()),
        );
        self
    }

    /// Sets the value of [action][crate::model::ValueTransformation::action]
    /// to hold a `ApplyHash`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_apply_hash<T: std::convert::Into<std::boxed::Box<crate::model::ApplyHash>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::value_transformation::Action::ApplyHash(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ValueTransformation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueTransformation"
    }
}

/// Defines additional types related to ValueTransformation
pub mod value_transformation {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Filter {
        /// Optional. Value is null
        IsNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Value is found in the specified list.
        ValueList(std::boxed::Box<crate::model::ValueListFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type integer.
        IntComparison(std::boxed::Box<crate::model::IntComparisonFilter>),
        /// Optional. Filter on relation between source value and compare value of
        /// type double.
        DoubleComparison(std::boxed::Box<crate::model::DoubleComparisonFilter>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Action {
        /// Optional. Set to null
        AssignNull(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to a specific value (value is converted to fit the target
        /// data type)
        AssignSpecificValue(std::boxed::Box<crate::model::AssignSpecificValue>),
        /// Optional. Set to min_value - if integer or numeric, will use
        /// int.minvalue, etc
        AssignMinValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Set to max_value - if integer or numeric, will use
        /// int.maxvalue, etc
        AssignMaxValue(std::boxed::Box<wkt::Empty>),
        /// Optional. Allows the data to change scale
        RoundScale(std::boxed::Box<crate::model::RoundToScale>),
        /// Optional. Applies a hash function on the data
        ApplyHash(std::boxed::Box<crate::model::ApplyHash>),
    }
}

/// Options to configure rule type ConvertROWIDToColumn.
/// The rule is used to add column rowid to destination tables based on an Oracle
/// rowid function/property.
///
/// The rule filter field can refer to one or more entities.
///
/// The rule scope can be one of: Table.
///
/// This rule requires additional filter to be specified beyond the basic rule
/// filter field, which is whether or not to work on tables which already have a
/// primary key defined.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConvertRowIdToColumn {
    /// Required. Only work on tables without primary key defined
    pub only_if_no_primary_key: bool,
}

impl ConvertRowIdToColumn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [only_if_no_primary_key][crate::model::ConvertRowIdToColumn::only_if_no_primary_key].
    pub fn set_only_if_no_primary_key<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.only_if_no_primary_key = v.into();
        self
    }
}

impl wkt::message::Message for ConvertRowIdToColumn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConvertRowIdToColumn"
    }
}

/// Options to configure rule type SetTablePrimaryKey.
/// The rule is used to specify the columns and name to configure/alter the
/// primary key of a table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be one of: Table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetTablePrimaryKey {
    /// Required. List of column names for the primary key
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub primary_key_columns: std::vec::Vec<std::string::String>,

    /// Optional. Name for the primary key
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_key: std::string::String,
}

impl SetTablePrimaryKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [primary_key][crate::model::SetTablePrimaryKey::primary_key].
    pub fn set_primary_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.primary_key = v.into();
        self
    }

    /// Sets the value of [primary_key_columns][crate::model::SetTablePrimaryKey::primary_key_columns].
    pub fn set_primary_key_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.primary_key_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SetTablePrimaryKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SetTablePrimaryKey"
    }
}

/// Options to configure rule type SinglePackageChange.
/// The rule is used to alter the sql code for a package entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Package
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SinglePackageChange {
    /// Optional. Sql code for package description
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_description: std::string::String,

    /// Optional. Sql code for package body
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_body: std::string::String,
}

impl SinglePackageChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_description][crate::model::SinglePackageChange::package_description].
    pub fn set_package_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_description = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::SinglePackageChange::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }
}

impl wkt::message::Message for SinglePackageChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SinglePackageChange"
    }
}

/// Options to configure rule type SourceSqlChange.
/// The rule is used to alter the sql code for database entities.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: StoredProcedure, Function, Trigger, View
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SourceSqlChange {
    /// Required. Sql code for source (stored procedure, function, trigger or view)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,
}

impl SourceSqlChange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::SourceSqlChange::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }
}

impl wkt::message::Message for SourceSqlChange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SourceSqlChange"
    }
}

/// Options to configure rule type FilterTableColumns.
/// The rule is used to filter the list of columns to include or exclude from a
/// table.
///
/// The rule filter field can refer to one entity.
///
/// The rule scope can be: Table
///
/// Only one of the two lists can be specified for the rule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FilterTableColumns {
    /// Optional. List of columns to be included for a particular table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub include_columns: std::vec::Vec<std::string::String>,

    /// Optional. List of columns to be excluded for a particular table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exclude_columns: std::vec::Vec<std::string::String>,
}

impl FilterTableColumns {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_columns][crate::model::FilterTableColumns::include_columns].
    pub fn set_include_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.include_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exclude_columns][crate::model::FilterTableColumns::exclude_columns].
    pub fn set_exclude_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exclude_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FilterTableColumns {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FilterTableColumns"
    }
}

/// A list of values to filter by in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueListFilter {
    /// Required. Indicates whether the filter matches rows with values that are
    /// present in the list or those with values not present in it.
    pub value_present_list: crate::model::ValuePresentInList,

    /// Required. The list to be used to filter by
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    /// Required. Whether to ignore case when filtering by values. Defaults to
    /// false
    pub ignore_case: bool,
}

impl ValueListFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_present_list][crate::model::ValueListFilter::value_present_list].
    pub fn set_value_present_list<T: std::convert::Into<crate::model::ValuePresentInList>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_present_list = v.into();
        self
    }

    /// Sets the value of [ignore_case][crate::model::ValueListFilter::ignore_case].
    pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_case = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ValueListFilter::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValueListFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ValueListFilter"
    }
}

/// Filter based on relation between source value and compare value of type
/// integer in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IntComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Integer compare value to be used
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub value: i64,
}

impl IntComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::IntComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::IntComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for IntComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IntComparisonFilter"
    }
}

/// Filter based on relation between source
/// value and compare value of type double in ConditionalColumnSetValue
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DoubleComparisonFilter {
    /// Required. Relation between source value and compare value
    pub value_comparison: crate::model::ValueComparison,

    /// Required. Double compare value to be used
    pub value: f64,
}

impl DoubleComparisonFilter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value_comparison][crate::model::DoubleComparisonFilter::value_comparison].
    pub fn set_value_comparison<T: std::convert::Into<crate::model::ValueComparison>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_comparison = v.into();
        self
    }

    /// Sets the value of [value][crate::model::DoubleComparisonFilter::value].
    pub fn set_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for DoubleComparisonFilter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DoubleComparisonFilter"
    }
}

/// Set to a specific value (value is converted to fit the target data type)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssignSpecificValue {
    /// Required. Specific value to be assigned
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,
}

impl AssignSpecificValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::AssignSpecificValue::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for AssignSpecificValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.AssignSpecificValue"
    }
}

/// Apply a hash function on the value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplyHash {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub hash_function: std::option::Option<crate::model::apply_hash::HashFunction>,
}

impl ApplyHash {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `hash_function`.
    pub fn set_hash_function<
        T: std::convert::Into<std::option::Option<crate::model::apply_hash::HashFunction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = v.into();
        self
    }

    /// The value of [hash_function][crate::model::ApplyHash::hash_function]
    /// if it holds a `UuidFromBytes`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_uuid_from_bytes(&self) -> std::option::Option<&std::boxed::Box<wkt::Empty>> {
        #[allow(unreachable_patterns)]
        self.hash_function.as_ref().and_then(|v| match v {
            crate::model::apply_hash::HashFunction::UuidFromBytes(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [hash_function][crate::model::ApplyHash::hash_function]
    /// to hold a `UuidFromBytes`.
    ///
    /// Note that all the setters affecting `hash_function` are
    /// mutually exclusive.
    pub fn set_uuid_from_bytes<T: std::convert::Into<std::boxed::Box<wkt::Empty>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hash_function = std::option::Option::Some(
            crate::model::apply_hash::HashFunction::UuidFromBytes(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ApplyHash {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ApplyHash"
    }
}

/// Defines additional types related to ApplyHash
pub mod apply_hash {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum HashFunction {
        /// Optional. Generate UUID from the data's byte array
        UuidFromBytes(std::boxed::Box<wkt::Empty>),
    }
}

/// This allows the data to change scale, for example if the source is 2 digits
/// after the decimal point, specify round to scale value = 2. If for example the
/// value needs to be converted to an integer, use round to scale value = 0.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RoundToScale {
    /// Required. Scale value to be used
    pub scale: i32,
}

impl RoundToScale {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scale][crate::model::RoundToScale::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }
}

impl wkt::message::Message for RoundToScale {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.RoundToScale"
    }
}

/// The base entity type for all the database related entities.
/// The message contains the entity name, the name of its parent, the entity
/// type, and the specific details per entity type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseEntity {
    /// The short name (e.g. table name) of the entity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub short_name: std::string::String,

    /// The full name of the parent entity (e.g. schema name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_entity: std::string::String,

    /// The type of tree the entity belongs to.
    pub tree: crate::model::database_entity::TreeType,

    /// The type of the database entity (table, view, index, ...).
    pub entity_type: crate::model::DatabaseEntityType,

    /// Details about entity mappings.
    /// For source tree entities, this holds the draft entities which were
    /// generated by the mapping rules.
    /// For draft tree entities, this holds the source entities which were
    /// converted to form the draft entity.
    /// Destination entities will have no mapping details.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mappings: std::vec::Vec<crate::model::EntityMapping>,

    /// Details about the entity DDL script. Multiple DDL scripts are provided for
    /// child entities such as a table entity will have one DDL for the table with
    /// additional DDLs for each index, constraint and such.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entity_ddl: std::vec::Vec<crate::model::EntityDdl>,

    /// Details about the various issues found for the entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issues: std::vec::Vec<crate::model::EntityIssue>,

    /// The specific body for each entity type.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub entity_body: std::option::Option<crate::model::database_entity::EntityBody>,
}

impl DatabaseEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [short_name][crate::model::DatabaseEntity::short_name].
    pub fn set_short_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.short_name = v.into();
        self
    }

    /// Sets the value of [parent_entity][crate::model::DatabaseEntity::parent_entity].
    pub fn set_parent_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entity = v.into();
        self
    }

    /// Sets the value of [tree][crate::model::DatabaseEntity::tree].
    pub fn set_tree<T: std::convert::Into<crate::model::database_entity::TreeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.tree = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::DatabaseEntity::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [mappings][crate::model::DatabaseEntity::mappings].
    pub fn set_mappings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMapping>,
    {
        use std::iter::Iterator;
        self.mappings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entity_ddl][crate::model::DatabaseEntity::entity_ddl].
    pub fn set_entity_ddl<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityDdl>,
    {
        use std::iter::Iterator;
        self.entity_ddl = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [issues][crate::model::DatabaseEntity::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityIssue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `entity_body`.
    pub fn set_entity_body<
        T: std::convert::Into<std::option::Option<crate::model::database_entity::EntityBody>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = v.into();
        self
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Database`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_database(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DatabaseInstanceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Database(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Schema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_schema(&self) -> std::option::Option<&std::boxed::Box<crate::model::SchemaEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Schema(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_table(&self) -> std::option::Option<&std::boxed::Box<crate::model::TableEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `View`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_view(&self) -> std::option::Option<&std::boxed::Box<crate::model::ViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::View(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Sequence`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_sequence(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SequenceEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Sequence(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `StoredProcedure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_stored_procedure(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StoredProcedureEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::StoredProcedure(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabaseFunction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_database_function(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FunctionEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabaseFunction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Synonym`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_synonym(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SynonymEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Synonym(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `DatabasePackage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_database_package(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PackageEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::DatabasePackage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `Udt`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_udt(&self) -> std::option::Option<&std::boxed::Box<crate::model::UDTEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::Udt(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// if it holds a `MaterializedView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_materialized_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaterializedViewEntity>> {
        #[allow(unreachable_patterns)]
        self.entity_body.as_ref().and_then(|v| match v {
            crate::model::database_entity::EntityBody::MaterializedView(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Database`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database<
        T: std::convert::Into<std::boxed::Box<crate::model::DatabaseInstanceEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Database(v.into()),
        );
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Schema`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_schema<T: std::convert::Into<std::boxed::Box<crate::model::SchemaEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Schema(v.into()));
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_table<T: std::convert::Into<std::boxed::Box<crate::model::TableEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Table(v.into()));
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `View`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_view<T: std::convert::Into<std::boxed::Box<crate::model::ViewEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::View(v.into()));
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Sequence`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_sequence<T: std::convert::Into<std::boxed::Box<crate::model::SequenceEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::Sequence(v.into()),
        );
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `StoredProcedure`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_stored_procedure<
        T: std::convert::Into<std::boxed::Box<crate::model::StoredProcedureEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::StoredProcedure(v.into()),
        );
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabaseFunction`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_function<
        T: std::convert::Into<std::boxed::Box<crate::model::FunctionEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabaseFunction(v.into()),
        );
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Synonym`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_synonym<T: std::convert::Into<std::boxed::Box<crate::model::SynonymEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Synonym(v.into()));
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `DatabasePackage`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_database_package<
        T: std::convert::Into<std::boxed::Box<crate::model::PackageEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::DatabasePackage(v.into()),
        );
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `Udt`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_udt<T: std::convert::Into<std::boxed::Box<crate::model::UDTEntity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body =
            std::option::Option::Some(crate::model::database_entity::EntityBody::Udt(v.into()));
        self
    }

    /// Sets the value of [entity_body][crate::model::DatabaseEntity::entity_body]
    /// to hold a `MaterializedView`.
    ///
    /// Note that all the setters affecting `entity_body` are
    /// mutually exclusive.
    pub fn set_materialized_view<
        T: std::convert::Into<std::boxed::Box<crate::model::MaterializedViewEntity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_body = std::option::Option::Some(
            crate::model::database_entity::EntityBody::MaterializedView(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatabaseEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseEntity"
    }
}

/// Defines additional types related to DatabaseEntity
pub mod database_entity {
    #[allow(unused_imports)]
    use super::*;

    /// The type of database entities tree.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TreeType(std::borrow::Cow<'static, str>);

    impl TreeType {
        /// Creates a new TreeType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [TreeType](TreeType)
    pub mod tree_type {
        use super::TreeType;

        /// Tree type unspecified.
        pub const TREE_TYPE_UNSPECIFIED: TreeType = TreeType::new("TREE_TYPE_UNSPECIFIED");

        /// Tree of entities loaded from a source database.
        pub const SOURCE: TreeType = TreeType::new("SOURCE");

        /// Tree of entities converted from the source tree using the mapping rules.
        pub const DRAFT: TreeType = TreeType::new("DRAFT");

        /// Tree of entities observed on the destination database.
        pub const DESTINATION: TreeType = TreeType::new("DESTINATION");
    }

    impl std::convert::From<std::string::String> for TreeType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for TreeType {
        fn default() -> Self {
            tree_type::TREE_TYPE_UNSPECIFIED
        }
    }

    /// The specific body for each entity type.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum EntityBody {
        /// Database.
        Database(std::boxed::Box<crate::model::DatabaseInstanceEntity>),
        /// Schema.
        Schema(std::boxed::Box<crate::model::SchemaEntity>),
        /// Table.
        Table(std::boxed::Box<crate::model::TableEntity>),
        /// View.
        View(std::boxed::Box<crate::model::ViewEntity>),
        /// Sequence.
        Sequence(std::boxed::Box<crate::model::SequenceEntity>),
        /// Stored procedure.
        StoredProcedure(std::boxed::Box<crate::model::StoredProcedureEntity>),
        /// Function.
        DatabaseFunction(std::boxed::Box<crate::model::FunctionEntity>),
        /// Synonym.
        Synonym(std::boxed::Box<crate::model::SynonymEntity>),
        /// Package.
        DatabasePackage(std::boxed::Box<crate::model::PackageEntity>),
        /// UDT.
        Udt(std::boxed::Box<crate::model::UDTEntity>),
        /// Materialized view.
        MaterializedView(std::boxed::Box<crate::model::MaterializedViewEntity>),
    }
}

/// DatabaseInstance acts as a parent entity to other database entities.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatabaseInstanceEntity {
    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl DatabaseInstanceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::DatabaseInstanceEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for DatabaseInstanceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.DatabaseInstanceEntity"
    }
}

/// Schema typically has no parent entity, but can have a parent entity
/// DatabaseInstance (for database engines which support it).  For some database
/// engines, the terms  schema and user can be used interchangeably when they
/// refer to a namespace or a collection of other database entities. Can store
/// additional information which is schema specific.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SchemaEntity {
    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl SchemaEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::SchemaEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SchemaEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SchemaEntity"
    }
}

/// Table's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TableEntity {
    /// Table columns.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::ColumnEntity>,

    /// Table constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,

    /// Table indices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub indices: std::vec::Vec<crate::model::IndexEntity>,

    /// Table triggers.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggers: std::vec::Vec<crate::model::TriggerEntity>,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Comment associated with the table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,
}

impl TableEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_features][crate::model::TableEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::TableEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::TableEntity::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColumnEntity>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [constraints][crate::model::TableEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [indices][crate::model::TableEntity::indices].
    pub fn set_indices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::IndexEntity>,
    {
        use std::iter::Iterator;
        self.indices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [triggers][crate::model::TableEntity::triggers].
    pub fn set_triggers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TriggerEntity>,
    {
        use std::iter::Iterator;
        self.triggers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TableEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TableEntity"
    }
}

/// Column is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnEntity {
    /// Column name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Column data type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_type: std::string::String,

    /// Charset override - instead of table level charset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub charset: std::string::String,

    /// Collation override - instead of table level collation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub collation: std::string::String,

    /// Column length - e.g. varchar (50).
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub length: i64,

    /// Column precision - when relevant.
    pub precision: i32,

    /// Column scale - when relevant.
    pub scale: i32,

    /// Column fractional second precision - used for timestamp based datatypes.
    pub fractional_seconds_precision: i32,

    /// Is the column of array type.
    pub array: bool,

    /// If the column is array, of which length.
    pub array_length: i32,

    /// Is the column nullable.
    pub nullable: bool,

    /// Is the column auto-generated/identity.
    pub auto_generated: bool,

    /// Is the column a UDT.
    pub udt: bool,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Specifies the list of values allowed in the column.
    /// Only used for set data type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub set_values: std::vec::Vec<std::string::String>,

    /// Comment associated with the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub comment: std::string::String,

    /// Column order in the table.
    pub ordinal_position: i32,

    /// Default value of the column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_value: std::string::String,
}

impl ColumnEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ColumnEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [data_type][crate::model::ColumnEntity::data_type].
    pub fn set_data_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_type = v.into();
        self
    }

    /// Sets the value of [charset][crate::model::ColumnEntity::charset].
    pub fn set_charset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.charset = v.into();
        self
    }

    /// Sets the value of [collation][crate::model::ColumnEntity::collation].
    pub fn set_collation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.collation = v.into();
        self
    }

    /// Sets the value of [length][crate::model::ColumnEntity::length].
    pub fn set_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.length = v.into();
        self
    }

    /// Sets the value of [precision][crate::model::ColumnEntity::precision].
    pub fn set_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.precision = v.into();
        self
    }

    /// Sets the value of [scale][crate::model::ColumnEntity::scale].
    pub fn set_scale<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.scale = v.into();
        self
    }

    /// Sets the value of [fractional_seconds_precision][crate::model::ColumnEntity::fractional_seconds_precision].
    pub fn set_fractional_seconds_precision<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.fractional_seconds_precision = v.into();
        self
    }

    /// Sets the value of [array][crate::model::ColumnEntity::array].
    pub fn set_array<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.array = v.into();
        self
    }

    /// Sets the value of [array_length][crate::model::ColumnEntity::array_length].
    pub fn set_array_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.array_length = v.into();
        self
    }

    /// Sets the value of [nullable][crate::model::ColumnEntity::nullable].
    pub fn set_nullable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.nullable = v.into();
        self
    }

    /// Sets the value of [auto_generated][crate::model::ColumnEntity::auto_generated].
    pub fn set_auto_generated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_generated = v.into();
        self
    }

    /// Sets the value of [udt][crate::model::ColumnEntity::udt].
    pub fn set_udt<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.udt = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ColumnEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::ColumnEntity::comment].
    pub fn set_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.comment = v.into();
        self
    }

    /// Sets the value of [ordinal_position][crate::model::ColumnEntity::ordinal_position].
    pub fn set_ordinal_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.ordinal_position = v.into();
        self
    }

    /// Sets the value of [default_value][crate::model::ColumnEntity::default_value].
    pub fn set_default_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_value = v.into();
        self
    }

    /// Sets the value of [set_values][crate::model::ColumnEntity::set_values].
    pub fn set_set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.set_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColumnEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ColumnEntity"
    }
}

/// Constraint is not used as an independent entity, it is retrieved
/// as part of another entity such as Table or View.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConstraintEntity {
    /// The name of the table constraint.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of constraint, for example unique, primary key, foreign key (currently
    /// only primary key is supported).
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Table columns used as part of the Constraint, for example primary key
    /// constraint should list the columns which constitutes the key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// Reference columns which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full names
    /// of referenced columns by the foreign key.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reference_columns: std::vec::Vec<std::string::String>,

    /// Reference table which may be associated with the constraint. For example,
    /// if the constraint is a FOREIGN_KEY, this represents the list of full name
    /// of the referenced table by the foreign key.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reference_table: std::string::String,

    /// Table which is associated with the constraint. In case the constraint
    /// is defined on a table, this field is left empty as this information is
    /// stored in parent_name. However, if constraint is defined on a view, this
    /// field stores the table name on which the view is defined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_name: std::string::String,
}

impl ConstraintEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConstraintEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ConstraintEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ConstraintEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [reference_table][crate::model::ConstraintEntity::reference_table].
    pub fn set_reference_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reference_table = v.into();
        self
    }

    /// Sets the value of [table_name][crate::model::ConstraintEntity::table_name].
    pub fn set_table_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_name = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::ConstraintEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reference_columns][crate::model::ConstraintEntity::reference_columns].
    pub fn set_reference_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.reference_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConstraintEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ConstraintEntity"
    }
}

/// Index is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IndexEntity {
    /// The name of the index.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Type of index, for example B-TREE.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub r#type: std::string::String,

    /// Table columns used as part of the Index, for example B-TREE index should
    /// list the columns which constitutes the index.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub table_columns: std::vec::Vec<std::string::String>,

    /// Boolean value indicating whether the index is unique.
    pub unique: bool,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl IndexEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::IndexEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::IndexEntity::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [unique][crate::model::IndexEntity::unique].
    pub fn set_unique<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unique = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::IndexEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [table_columns][crate::model::IndexEntity::table_columns].
    pub fn set_table_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_columns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for IndexEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.IndexEntity"
    }
}

/// Trigger is not used as an independent entity, it is retrieved as part of a
/// Table entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TriggerEntity {
    /// The name of the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The DML, DDL, or database events that fire the trigger, for example
    /// INSERT, UPDATE.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub triggering_events: std::vec::Vec<std::string::String>,

    /// Indicates when the trigger fires, for example BEFORE STATEMENT, AFTER EACH
    /// ROW.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trigger_type: std::string::String,

    /// The SQL code which creates the trigger.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl TriggerEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TriggerEntity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trigger_type][crate::model::TriggerEntity::trigger_type].
    pub fn set_trigger_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trigger_type = v.into();
        self
    }

    /// Sets the value of [sql_code][crate::model::TriggerEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::TriggerEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [triggering_events][crate::model::TriggerEntity::triggering_events].
    pub fn set_triggering_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.triggering_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TriggerEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.TriggerEntity"
    }
}

/// View's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ViewEntity {
    /// The SQL code which creates the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,

    /// View constraints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub constraints: std::vec::Vec<crate::model::ConstraintEntity>,
}

impl ViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::ViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::ViewEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }

    /// Sets the value of [constraints][crate::model::ViewEntity::constraints].
    pub fn set_constraints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConstraintEntity>,
    {
        use std::iter::Iterator;
        self.constraints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.ViewEntity"
    }
}

/// Sequence's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SequenceEntity {
    /// Increment value for the sequence.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub increment: i64,

    /// Start number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub start_value: bytes::Bytes,

    /// Maximum number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub max_value: bytes::Bytes,

    /// Minimum number for the sequence represented as bytes to accommodate large.
    /// numbers
    #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub min_value: bytes::Bytes,

    /// Indicates whether the sequence value should cycle through.
    pub cycle: bool,

    /// Indicates number of entries to cache / precreate.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub cache: i64,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl SequenceEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [increment][crate::model::SequenceEntity::increment].
    pub fn set_increment<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.increment = v.into();
        self
    }

    /// Sets the value of [start_value][crate::model::SequenceEntity::start_value].
    pub fn set_start_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.start_value = v.into();
        self
    }

    /// Sets the value of [max_value][crate::model::SequenceEntity::max_value].
    pub fn set_max_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.max_value = v.into();
        self
    }

    /// Sets the value of [min_value][crate::model::SequenceEntity::min_value].
    pub fn set_min_value<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
        self.min_value = v.into();
        self
    }

    /// Sets the value of [cycle][crate::model::SequenceEntity::cycle].
    pub fn set_cycle<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cycle = v.into();
        self
    }

    /// Sets the value of [cache][crate::model::SequenceEntity::cache].
    pub fn set_cache<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cache = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SequenceEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SequenceEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SequenceEntity"
    }
}

/// Stored procedure's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StoredProcedureEntity {
    /// The SQL code which creates the stored procedure.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl StoredProcedureEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::StoredProcedureEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::StoredProcedureEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for StoredProcedureEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.StoredProcedureEntity"
    }
}

/// Function's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FunctionEntity {
    /// The SQL code which creates the function.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl FunctionEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::FunctionEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::FunctionEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for FunctionEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.FunctionEntity"
    }
}

/// MaterializedView's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaterializedViewEntity {
    /// The SQL code which creates the view.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub sql_code: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl MaterializedViewEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sql_code][crate::model::MaterializedViewEntity::sql_code].
    pub fn set_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.sql_code = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::MaterializedViewEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedViewEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.MaterializedViewEntity"
    }
}

/// Synonym's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SynonymEntity {
    /// The name of the entity for which the synonym is being created (the source).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_entity: std::string::String,

    /// The type of the entity for which the synonym is being created
    /// (usually a table or a sequence).
    pub source_type: crate::model::DatabaseEntityType,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl SynonymEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::SynonymEntity::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::SynonymEntity::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::SynonymEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for SynonymEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.SynonymEntity"
    }
}

/// Package's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PackageEntity {
    /// The SQL code which creates the package.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_sql_code: std::string::String,

    /// The SQL code which creates the package body. If the package specification
    /// has cursors or subprograms, then the package body is mandatory.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub package_body: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl PackageEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [package_sql_code][crate::model::PackageEntity::package_sql_code].
    pub fn set_package_sql_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.package_sql_code = v.into();
        self
    }

    /// Sets the value of [package_body][crate::model::PackageEntity::package_body].
    pub fn set_package_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.package_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::PackageEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for PackageEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.PackageEntity"
    }
}

/// UDT's parent is a schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UDTEntity {
    /// The SQL code which creates the udt.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub udt_sql_code: std::string::String,

    /// The SQL code which creates the udt body.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub udt_body: std::string::String,

    /// Custom engine specific features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub custom_features: std::option::Option<wkt::Struct>,
}

impl UDTEntity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [udt_sql_code][crate::model::UDTEntity::udt_sql_code].
    pub fn set_udt_sql_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_sql_code = v.into();
        self
    }

    /// Sets the value of [udt_body][crate::model::UDTEntity::udt_body].
    pub fn set_udt_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.udt_body = v.into();
        self
    }

    /// Sets the value of [custom_features][crate::model::UDTEntity::custom_features].
    pub fn set_custom_features<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_features = v.into();
        self
    }
}

impl wkt::message::Message for UDTEntity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.UDTEntity"
    }
}

/// Details of the mappings of a database entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMapping {
    /// Source entity full name.
    /// The source entity can also be a column, index or constraint using the
    /// same naming notation schema.table.column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_entity: std::string::String,

    /// Target entity full name.
    /// The draft entity can also include a column, index or constraint using the
    /// same naming notation schema.table.column.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub draft_entity: std::string::String,

    /// Type of source entity.
    pub source_type: crate::model::DatabaseEntityType,

    /// Type of draft entity.
    pub draft_type: crate::model::DatabaseEntityType,

    /// Entity mapping log entries.
    /// Multiple rules can be effective and contribute changes to a converted
    /// entity, such as a rule can handle the entity name, another rule can handle
    /// an entity type. In addition, rules which did not change the entity are also
    /// logged along with the reason preventing them to do so.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub mapping_log: std::vec::Vec<crate::model::EntityMappingLogEntry>,
}

impl EntityMapping {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_entity][crate::model::EntityMapping::source_entity].
    pub fn set_source_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_entity = v.into();
        self
    }

    /// Sets the value of [draft_entity][crate::model::EntityMapping::draft_entity].
    pub fn set_draft_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.draft_entity = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::EntityMapping::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [draft_type][crate::model::EntityMapping::draft_type].
    pub fn set_draft_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.draft_type = v.into();
        self
    }

    /// Sets the value of [mapping_log][crate::model::EntityMapping::mapping_log].
    pub fn set_mapping_log<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityMappingLogEntry>,
    {
        use std::iter::Iterator;
        self.mapping_log = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityMapping {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMapping"
    }
}

/// A single record of a rule which was used for a mapping.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityMappingLogEntry {
    /// Which rule caused this log entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_id: std::string::String,

    /// Rule revision ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_revision_id: std::string::String,

    /// Comment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mapping_comment: std::string::String,
}

impl EntityMappingLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule_id][crate::model::EntityMappingLogEntry::rule_id].
    pub fn set_rule_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_id = v.into();
        self
    }

    /// Sets the value of [rule_revision_id][crate::model::EntityMappingLogEntry::rule_revision_id].
    pub fn set_rule_revision_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule_revision_id = v.into();
        self
    }

    /// Sets the value of [mapping_comment][crate::model::EntityMappingLogEntry::mapping_comment].
    pub fn set_mapping_comment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mapping_comment = v.into();
        self
    }
}

impl wkt::message::Message for EntityMappingLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityMappingLogEntry"
    }
}

/// A single DDL statement for a specific entity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityDdl {
    /// Type of DDL (Create, Alter).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ddl_type: std::string::String,

    /// The name of the database entity the ddl refers to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entity: std::string::String,

    /// The actual ddl code.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ddl: std::string::String,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,

    /// EntityIssues found for this ddl.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub issue_id: std::vec::Vec<std::string::String>,
}

impl EntityDdl {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ddl_type][crate::model::EntityDdl::ddl_type].
    pub fn set_ddl_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl_type = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::EntityDdl::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityDdl::ddl].
    pub fn set_ddl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ddl = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityDdl::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [issue_id][crate::model::EntityDdl::issue_id].
    pub fn set_issue_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.issue_id = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityDdl {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityDdl"
    }
}

/// Issue related to the entity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityIssue {
    /// Unique Issue ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The type of the issue.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity_issue::IssueType,

    /// Severity of the issue
    pub severity: crate::model::entity_issue::IssueSeverity,

    /// Issue detailed message
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Error/Warning code
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub code: std::string::String,

    /// The ddl which caused the issue, if relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ddl: std::option::Option<std::string::String>,

    /// The position of the issue found, if relevant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub position: std::option::Option<crate::model::entity_issue::Position>,

    /// The entity type (if the DDL is for a sub entity).
    pub entity_type: crate::model::DatabaseEntityType,
}

impl EntityIssue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::EntityIssue::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::EntityIssue::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity_issue::IssueType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::EntityIssue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::entity_issue::IssueSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [message][crate::model::EntityIssue::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [code][crate::model::EntityIssue::code].
    pub fn set_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [ddl][crate::model::EntityIssue::ddl].
    pub fn set_ddl<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ddl = v.into();
        self
    }

    /// Sets the value of [position][crate::model::EntityIssue::position].
    pub fn set_position<
        T: std::convert::Into<std::option::Option<crate::model::entity_issue::Position>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.position = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::EntityIssue::entity_type].
    pub fn set_entity_type<T: std::convert::Into<crate::model::DatabaseEntityType>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type = v.into();
        self
    }
}

impl wkt::message::Message for EntityIssue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue"
    }
}

/// Defines additional types related to EntityIssue
pub mod entity_issue {
    #[allow(unused_imports)]
    use super::*;

    /// Issue position.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Position {
        /// Issue line number
        pub line: i32,

        /// Issue column number
        pub column: i32,

        /// Issue offset
        pub offset: i32,

        /// Issue length
        pub length: i32,
    }

    impl Position {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [line][crate::model::entity_issue::Position::line].
        pub fn set_line<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.line = v.into();
            self
        }

        /// Sets the value of [column][crate::model::entity_issue::Position::column].
        pub fn set_column<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }

        /// Sets the value of [offset][crate::model::entity_issue::Position::offset].
        pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.offset = v.into();
            self
        }

        /// Sets the value of [length][crate::model::entity_issue::Position::length].
        pub fn set_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.length = v.into();
            self
        }
    }

    impl wkt::message::Message for Position {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.clouddms.v1.EntityIssue.Position"
        }
    }

    /// Type of issue.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IssueType(std::borrow::Cow<'static, str>);

    impl IssueType {
        /// Creates a new IssueType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [IssueType](IssueType)
    pub mod issue_type {
        use super::IssueType;

        /// Unspecified issue type.
        pub const ISSUE_TYPE_UNSPECIFIED: IssueType = IssueType::new("ISSUE_TYPE_UNSPECIFIED");

        /// Issue originated from the DDL
        pub const ISSUE_TYPE_DDL: IssueType = IssueType::new("ISSUE_TYPE_DDL");

        /// Issue originated during the apply process
        pub const ISSUE_TYPE_APPLY: IssueType = IssueType::new("ISSUE_TYPE_APPLY");

        /// Issue originated during the convert process
        pub const ISSUE_TYPE_CONVERT: IssueType = IssueType::new("ISSUE_TYPE_CONVERT");
    }

    impl std::convert::From<std::string::String> for IssueType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for IssueType {
        fn default() -> Self {
            issue_type::ISSUE_TYPE_UNSPECIFIED
        }
    }

    /// Severity of issue.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct IssueSeverity(std::borrow::Cow<'static, str>);

    impl IssueSeverity {
        /// Creates a new IssueSeverity instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [IssueSeverity](IssueSeverity)
    pub mod issue_severity {
        use super::IssueSeverity;

        /// Unspecified issue severity
        pub const ISSUE_SEVERITY_UNSPECIFIED: IssueSeverity =
            IssueSeverity::new("ISSUE_SEVERITY_UNSPECIFIED");

        /// Info
        pub const ISSUE_SEVERITY_INFO: IssueSeverity = IssueSeverity::new("ISSUE_SEVERITY_INFO");

        /// Warning
        pub const ISSUE_SEVERITY_WARNING: IssueSeverity =
            IssueSeverity::new("ISSUE_SEVERITY_WARNING");

        /// Error
        pub const ISSUE_SEVERITY_ERROR: IssueSeverity = IssueSeverity::new("ISSUE_SEVERITY_ERROR");
    }

    impl std::convert::From<std::string::String> for IssueSeverity {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }

    impl std::default::Default for IssueSeverity {
        fn default() -> Self {
            issue_severity::ISSUE_SEVERITY_UNSPECIFIED
        }
    }
}

/// AIP-157 Partial Response view for Database Entity.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DatabaseEntityView(std::borrow::Cow<'static, str>);

impl DatabaseEntityView {
    /// Creates a new DatabaseEntityView instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DatabaseEntityView](DatabaseEntityView)
pub mod database_entity_view {
    use super::DatabaseEntityView;

    /// Unspecified view. Defaults to basic view.
    pub const DATABASE_ENTITY_VIEW_UNSPECIFIED: DatabaseEntityView =
        DatabaseEntityView::new("DATABASE_ENTITY_VIEW_UNSPECIFIED");

    /// Default view. Does not return DDLs or Issues.
    pub const DATABASE_ENTITY_VIEW_BASIC: DatabaseEntityView =
        DatabaseEntityView::new("DATABASE_ENTITY_VIEW_BASIC");

    /// Return full entity details including mappings, ddl and issues.
    pub const DATABASE_ENTITY_VIEW_FULL: DatabaseEntityView =
        DatabaseEntityView::new("DATABASE_ENTITY_VIEW_FULL");

    /// Top-most (Database, Schema) nodes which are returned contains summary
    /// details for their decendents such as the number of entities per type and
    /// issues rollups. When this view is used, only a single page of result is
    /// returned and the page_size property of the request is ignored. The
    /// returned page will only include the top-most node types.
    pub const DATABASE_ENTITY_VIEW_ROOT_SUMMARY: DatabaseEntityView =
        DatabaseEntityView::new("DATABASE_ENTITY_VIEW_ROOT_SUMMARY");
}

impl std::convert::From<std::string::String> for DatabaseEntityView {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DatabaseEntityView {
    fn default() -> Self {
        database_entity_view::DATABASE_ENTITY_VIEW_UNSPECIFIED
    }
}

#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NetworkArchitecture(std::borrow::Cow<'static, str>);

impl NetworkArchitecture {
    /// Creates a new NetworkArchitecture instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [NetworkArchitecture](NetworkArchitecture)
pub mod network_architecture {
    use super::NetworkArchitecture;

    pub const NETWORK_ARCHITECTURE_UNSPECIFIED: NetworkArchitecture =
        NetworkArchitecture::new("NETWORK_ARCHITECTURE_UNSPECIFIED");

    /// Instance is in Cloud SQL's old producer network architecture.
    pub const NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER: NetworkArchitecture =
        NetworkArchitecture::new("NETWORK_ARCHITECTURE_OLD_CSQL_PRODUCER");

    /// Instance is in Cloud SQL's new producer network architecture.
    pub const NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER: NetworkArchitecture =
        NetworkArchitecture::new("NETWORK_ARCHITECTURE_NEW_CSQL_PRODUCER");
}

impl std::convert::From<std::string::String> for NetworkArchitecture {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for NetworkArchitecture {
    fn default() -> Self {
        network_architecture::NETWORK_ARCHITECTURE_UNSPECIFIED
    }
}

/// The database engine types.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DatabaseEngine(std::borrow::Cow<'static, str>);

impl DatabaseEngine {
    /// Creates a new DatabaseEngine instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DatabaseEngine](DatabaseEngine)
pub mod database_engine {
    use super::DatabaseEngine;

    /// The source database engine of the migration job is unknown.
    pub const DATABASE_ENGINE_UNSPECIFIED: DatabaseEngine =
        DatabaseEngine::new("DATABASE_ENGINE_UNSPECIFIED");

    /// The source engine is MySQL.
    pub const MYSQL: DatabaseEngine = DatabaseEngine::new("MYSQL");

    /// The source engine is PostgreSQL.
    pub const POSTGRESQL: DatabaseEngine = DatabaseEngine::new("POSTGRESQL");

    /// The source engine is Oracle.
    pub const ORACLE: DatabaseEngine = DatabaseEngine::new("ORACLE");
}

impl std::convert::From<std::string::String> for DatabaseEngine {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DatabaseEngine {
    fn default() -> Self {
        database_engine::DATABASE_ENGINE_UNSPECIFIED
    }
}

/// The database providers.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DatabaseProvider(std::borrow::Cow<'static, str>);

impl DatabaseProvider {
    /// Creates a new DatabaseProvider instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DatabaseProvider](DatabaseProvider)
pub mod database_provider {
    use super::DatabaseProvider;

    /// The database provider is unknown.
    pub const DATABASE_PROVIDER_UNSPECIFIED: DatabaseProvider =
        DatabaseProvider::new("DATABASE_PROVIDER_UNSPECIFIED");

    /// CloudSQL runs the database.
    pub const CLOUDSQL: DatabaseProvider = DatabaseProvider::new("CLOUDSQL");

    /// RDS runs the database.
    pub const RDS: DatabaseProvider = DatabaseProvider::new("RDS");

    /// Amazon Aurora.
    pub const AURORA: DatabaseProvider = DatabaseProvider::new("AURORA");

    /// AlloyDB.
    pub const ALLOYDB: DatabaseProvider = DatabaseProvider::new("ALLOYDB");
}

impl std::convert::From<std::string::String> for DatabaseProvider {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DatabaseProvider {
    fn default() -> Self {
        database_provider::DATABASE_PROVIDER_UNSPECIFIED
    }
}

/// Enum used by ValueListFilter to indicate whether the source value is in the
/// supplied list
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ValuePresentInList(std::borrow::Cow<'static, str>);

impl ValuePresentInList {
    /// Creates a new ValuePresentInList instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ValuePresentInList](ValuePresentInList)
pub mod value_present_in_list {
    use super::ValuePresentInList;

    /// Value present in list unspecified
    pub const VALUE_PRESENT_IN_LIST_UNSPECIFIED: ValuePresentInList =
        ValuePresentInList::new("VALUE_PRESENT_IN_LIST_UNSPECIFIED");

    /// If the source value is in the supplied list at value_list
    pub const VALUE_PRESENT_IN_LIST_IF_VALUE_LIST: ValuePresentInList =
        ValuePresentInList::new("VALUE_PRESENT_IN_LIST_IF_VALUE_LIST");

    /// If the source value is not in the supplied list at value_list
    pub const VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST: ValuePresentInList =
        ValuePresentInList::new("VALUE_PRESENT_IN_LIST_IF_VALUE_NOT_LIST");
}

impl std::convert::From<std::string::String> for ValuePresentInList {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for ValuePresentInList {
    fn default() -> Self {
        value_present_in_list::VALUE_PRESENT_IN_LIST_UNSPECIFIED
    }
}

/// The type of database entities supported,
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct DatabaseEntityType(std::borrow::Cow<'static, str>);

impl DatabaseEntityType {
    /// Creates a new DatabaseEntityType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [DatabaseEntityType](DatabaseEntityType)
pub mod database_entity_type {
    use super::DatabaseEntityType;

    /// Unspecified database entity type.
    pub const DATABASE_ENTITY_TYPE_UNSPECIFIED: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_UNSPECIFIED");

    /// Schema.
    pub const DATABASE_ENTITY_TYPE_SCHEMA: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_SCHEMA");

    /// Table.
    pub const DATABASE_ENTITY_TYPE_TABLE: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_TABLE");

    /// Column.
    pub const DATABASE_ENTITY_TYPE_COLUMN: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_COLUMN");

    /// Constraint.
    pub const DATABASE_ENTITY_TYPE_CONSTRAINT: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_CONSTRAINT");

    /// Index.
    pub const DATABASE_ENTITY_TYPE_INDEX: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_INDEX");

    /// Trigger.
    pub const DATABASE_ENTITY_TYPE_TRIGGER: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_TRIGGER");

    /// View.
    pub const DATABASE_ENTITY_TYPE_VIEW: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_VIEW");

    /// Sequence.
    pub const DATABASE_ENTITY_TYPE_SEQUENCE: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_SEQUENCE");

    /// Stored Procedure.
    pub const DATABASE_ENTITY_TYPE_STORED_PROCEDURE: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_STORED_PROCEDURE");

    /// Function.
    pub const DATABASE_ENTITY_TYPE_FUNCTION: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_FUNCTION");

    /// Synonym.
    pub const DATABASE_ENTITY_TYPE_SYNONYM: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_SYNONYM");

    /// Package.
    pub const DATABASE_ENTITY_TYPE_DATABASE_PACKAGE: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_DATABASE_PACKAGE");

    /// UDT.
    pub const DATABASE_ENTITY_TYPE_UDT: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_UDT");

    /// Materialized View.
    pub const DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_MATERIALIZED_VIEW");

    /// Database.
    pub const DATABASE_ENTITY_TYPE_DATABASE: DatabaseEntityType =
        DatabaseEntityType::new("DATABASE_ENTITY_TYPE_DATABASE");
}

impl std::convert::From<std::string::String> for DatabaseEntityType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for DatabaseEntityType {
    fn default() -> Self {
        database_entity_type::DATABASE_ENTITY_TYPE_UNSPECIFIED
    }
}

/// Entity Name Transformation Types
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct EntityNameTransformation(std::borrow::Cow<'static, str>);

impl EntityNameTransformation {
    /// Creates a new EntityNameTransformation instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [EntityNameTransformation](EntityNameTransformation)
pub mod entity_name_transformation {
    use super::EntityNameTransformation;

    /// Entity name transformation unspecified.
    pub const ENTITY_NAME_TRANSFORMATION_UNSPECIFIED: EntityNameTransformation =
        EntityNameTransformation::new("ENTITY_NAME_TRANSFORMATION_UNSPECIFIED");

    /// No transformation.
    pub const ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION: EntityNameTransformation =
        EntityNameTransformation::new("ENTITY_NAME_TRANSFORMATION_NO_TRANSFORMATION");

    /// Transform to lower case.
    pub const ENTITY_NAME_TRANSFORMATION_LOWER_CASE: EntityNameTransformation =
        EntityNameTransformation::new("ENTITY_NAME_TRANSFORMATION_LOWER_CASE");

    /// Transform to upper case.
    pub const ENTITY_NAME_TRANSFORMATION_UPPER_CASE: EntityNameTransformation =
        EntityNameTransformation::new("ENTITY_NAME_TRANSFORMATION_UPPER_CASE");

    /// Transform to capitalized case.
    pub const ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE: EntityNameTransformation =
        EntityNameTransformation::new("ENTITY_NAME_TRANSFORMATION_CAPITALIZED_CASE");
}

impl std::convert::From<std::string::String> for EntityNameTransformation {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for EntityNameTransformation {
    fn default() -> Self {
        entity_name_transformation::ENTITY_NAME_TRANSFORMATION_UNSPECIFIED
    }
}

/// The types of jobs that can be executed in the background.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct BackgroundJobType(std::borrow::Cow<'static, str>);

impl BackgroundJobType {
    /// Creates a new BackgroundJobType instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [BackgroundJobType](BackgroundJobType)
pub mod background_job_type {
    use super::BackgroundJobType;

    /// Unspecified background job type.
    pub const BACKGROUND_JOB_TYPE_UNSPECIFIED: BackgroundJobType =
        BackgroundJobType::new("BACKGROUND_JOB_TYPE_UNSPECIFIED");

    /// Job to seed from the source database.
    pub const BACKGROUND_JOB_TYPE_SOURCE_SEED: BackgroundJobType =
        BackgroundJobType::new("BACKGROUND_JOB_TYPE_SOURCE_SEED");

    /// Job to convert the source database into a draft of the destination
    /// database.
    pub const BACKGROUND_JOB_TYPE_CONVERT: BackgroundJobType =
        BackgroundJobType::new("BACKGROUND_JOB_TYPE_CONVERT");

    /// Job to apply the draft tree onto the destination.
    pub const BACKGROUND_JOB_TYPE_APPLY_DESTINATION: BackgroundJobType =
        BackgroundJobType::new("BACKGROUND_JOB_TYPE_APPLY_DESTINATION");

    /// Job to import and convert mapping rules from an external source such as an
    /// ora2pg config file.
    pub const BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE: BackgroundJobType =
        BackgroundJobType::new("BACKGROUND_JOB_TYPE_IMPORT_RULES_FILE");
}

impl std::convert::From<std::string::String> for BackgroundJobType {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for BackgroundJobType {
    fn default() -> Self {
        background_job_type::BACKGROUND_JOB_TYPE_UNSPECIFIED
    }
}

/// The format for the import rules file.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ImportRulesFileFormat(std::borrow::Cow<'static, str>);

impl ImportRulesFileFormat {
    /// Creates a new ImportRulesFileFormat instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ImportRulesFileFormat](ImportRulesFileFormat)
pub mod import_rules_file_format {
    use super::ImportRulesFileFormat;

    /// Unspecified rules format.
    pub const IMPORT_RULES_FILE_FORMAT_UNSPECIFIED: ImportRulesFileFormat =
        ImportRulesFileFormat::new("IMPORT_RULES_FILE_FORMAT_UNSPECIFIED");

    /// HarbourBridge session file.
    pub const IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE: ImportRulesFileFormat =
        ImportRulesFileFormat::new("IMPORT_RULES_FILE_FORMAT_HARBOUR_BRIDGE_SESSION_FILE");

    /// Ora2Pg configuration file.
    pub const IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE: ImportRulesFileFormat =
        ImportRulesFileFormat::new("IMPORT_RULES_FILE_FORMAT_ORATOPG_CONFIG_FILE");
}

impl std::convert::From<std::string::String> for ImportRulesFileFormat {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for ImportRulesFileFormat {
    fn default() -> Self {
        import_rules_file_format::IMPORT_RULES_FILE_FORMAT_UNSPECIFIED
    }
}

/// Enum used by IntComparisonFilter and DoubleComparisonFilter to indicate the
/// relation between source value and compare value.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ValueComparison(std::borrow::Cow<'static, str>);

impl ValueComparison {
    /// Creates a new ValueComparison instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [ValueComparison](ValueComparison)
pub mod value_comparison {
    use super::ValueComparison;

    /// Value comparison unspecified.
    pub const VALUE_COMPARISON_UNSPECIFIED: ValueComparison =
        ValueComparison::new("VALUE_COMPARISON_UNSPECIFIED");

    /// Value is smaller than the Compare value.
    pub const VALUE_COMPARISON_IF_VALUE_SMALLER_THAN: ValueComparison =
        ValueComparison::new("VALUE_COMPARISON_IF_VALUE_SMALLER_THAN");

    /// Value is smaller or equal than the Compare value.
    pub const VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN: ValueComparison =
        ValueComparison::new("VALUE_COMPARISON_IF_VALUE_SMALLER_EQUAL_THAN");

    /// Value is larger than the Compare value.
    pub const VALUE_COMPARISON_IF_VALUE_LARGER_THAN: ValueComparison =
        ValueComparison::new("VALUE_COMPARISON_IF_VALUE_LARGER_THAN");

    /// Value is larger or equal than the Compare value.
    pub const VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN: ValueComparison =
        ValueComparison::new("VALUE_COMPARISON_IF_VALUE_LARGER_EQUAL_THAN");
}

impl std::convert::From<std::string::String> for ValueComparison {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for ValueComparison {
    fn default() -> Self {
        value_comparison::VALUE_COMPARISON_UNSPECIFIED
    }
}

/// Specifies the columns on which numeric filter needs to be applied.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NumericFilterOption(std::borrow::Cow<'static, str>);

impl NumericFilterOption {
    /// Creates a new NumericFilterOption instance.
    pub const fn new(v: &'static str) -> Self {
        Self(std::borrow::Cow::Borrowed(v))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [NumericFilterOption](NumericFilterOption)
pub mod numeric_filter_option {
    use super::NumericFilterOption;

    /// Numeric filter option unspecified
    pub const NUMERIC_FILTER_OPTION_UNSPECIFIED: NumericFilterOption =
        NumericFilterOption::new("NUMERIC_FILTER_OPTION_UNSPECIFIED");

    /// Numeric filter option that matches all numeric columns.
    pub const NUMERIC_FILTER_OPTION_ALL: NumericFilterOption =
        NumericFilterOption::new("NUMERIC_FILTER_OPTION_ALL");

    /// Numeric filter option that matches columns having numeric datatypes with
    /// specified precision and scale within the limited range of filter.
    pub const NUMERIC_FILTER_OPTION_LIMIT: NumericFilterOption =
        NumericFilterOption::new("NUMERIC_FILTER_OPTION_LIMIT");

    /// Numeric filter option that matches only the numeric columns with no
    /// precision and scale specified.
    pub const NUMERIC_FILTER_OPTION_LIMITLESS: NumericFilterOption =
        NumericFilterOption::new("NUMERIC_FILTER_OPTION_LIMITLESS");
}

impl std::convert::From<std::string::String> for NumericFilterOption {
    fn from(value: std::string::String) -> Self {
        Self(std::borrow::Cow::Owned(value))
    }
}

impl std::default::Default for NumericFilterOption {
    fn default() -> Self {
        numeric_filter_option::NUMERIC_FILTER_OPTION_UNSPECIFIED
    }
}
