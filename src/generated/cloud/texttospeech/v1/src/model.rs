// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The top-level message sent by the client for the `ListVoices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVoicesRequest {
    /// Optional. Recommended.
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
    /// If not specified, the API will return all supported voices.
    /// If specified, the ListVoices call will only return voices that can be used
    /// to synthesize this language_code. For example, if you specify `"en-NZ"`,
    /// all `"en-NZ"` voices will be returned. If you specify `"no"`, both
    /// `"no-\*"` (Norwegian) and `"nb-\*"` (Norwegian Bokmal) voices will be
    /// returned.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVoicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::ListVoicesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

impl wkt::message::Message for ListVoicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.ListVoicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVoicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVoicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVoicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVoicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVoicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message returned to the client by the `ListVoices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVoicesResponse {
    /// The list of voices.
    pub voices: std::vec::Vec<crate::model::Voice>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVoicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [voices][crate::model::ListVoicesResponse::voices].
    pub fn set_voices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Voice>,
    {
        use std::iter::Iterator;
        self.voices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVoicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.ListVoicesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVoicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVoicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voices" => Ok(__FieldTag::__voices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVoicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVoicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voices => {
                            if !fields.insert(__FieldTag::__voices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voices",
                                ));
                            }
                            result.voices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Voice>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVoicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.voices.is_empty() {
            state.serialize_entry("voices", &self.voices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of a voice supported by the TTS service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Voice {
    /// The languages that this voice supports, expressed as
    /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags (e.g.
    /// "en-US", "es-419", "cmn-tw").
    pub language_codes: std::vec::Vec<std::string::String>,

    /// The name of this voice.  Each distinct voice has a unique name.
    pub name: std::string::String,

    /// The gender of this voice.
    pub ssml_gender: crate::model::SsmlVoiceGender,

    /// The natural sample rate (in hertz) for this voice.
    pub natural_sample_rate_hertz: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Voice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_codes][crate::model::Voice::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::Voice::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssml_gender][crate::model::Voice::ssml_gender].
    pub fn set_ssml_gender<T: std::convert::Into<crate::model::SsmlVoiceGender>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssml_gender = v.into();
        self
    }

    /// Sets the value of [natural_sample_rate_hertz][crate::model::Voice::natural_sample_rate_hertz].
    pub fn set_natural_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.natural_sample_rate_hertz = v.into();
        self
    }
}

impl wkt::message::Message for Voice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.Voice"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Voice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_codes,
            __name,
            __ssml_gender,
            __natural_sample_rate_hertz,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Voice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            "naturalSampleRateHertz" => Ok(__FieldTag::__natural_sample_rate_hertz),
                            "natural_sample_rate_hertz" => {
                                Ok(__FieldTag::__natural_sample_rate_hertz)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Voice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Voice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__natural_sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__natural_sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for natural_sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.natural_sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Voice {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if !wkt::internal::is_default(&self.natural_sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "naturalSampleRateHertz",
                &__With(&self.natural_sample_rate_hertz),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Used for advanced voice options.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedVoiceOptions {
    /// Only for Journey voices. If false, the synthesis is context aware
    /// and has a higher latency.
    pub low_latency_journey_synthesis: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedVoiceOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [low_latency_journey_synthesis][crate::model::AdvancedVoiceOptions::low_latency_journey_synthesis].
    pub fn set_low_latency_journey_synthesis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.low_latency_journey_synthesis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [low_latency_journey_synthesis][crate::model::AdvancedVoiceOptions::low_latency_journey_synthesis].
    pub fn set_or_clear_low_latency_journey_synthesis<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.low_latency_journey_synthesis = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvancedVoiceOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.AdvancedVoiceOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedVoiceOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __low_latency_journey_synthesis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedVoiceOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lowLatencyJourneySynthesis" => {
                                Ok(__FieldTag::__low_latency_journey_synthesis)
                            }
                            "low_latency_journey_synthesis" => {
                                Ok(__FieldTag::__low_latency_journey_synthesis)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedVoiceOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedVoiceOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__low_latency_journey_synthesis => {
                            if !fields.insert(__FieldTag::__low_latency_journey_synthesis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low_latency_journey_synthesis",
                                ));
                            }
                            result.low_latency_journey_synthesis =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvancedVoiceOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.low_latency_journey_synthesis.is_some() {
            state.serialize_entry(
                "lowLatencyJourneySynthesis",
                &self.low_latency_journey_synthesis,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message sent by the client for the `SynthesizeSpeech` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeSpeechRequest {
    /// Required. The Synthesizer requires either plain text or SSML as input.
    pub input: std::option::Option<crate::model::SynthesisInput>,

    /// Required. The desired voice of the synthesized audio.
    pub voice: std::option::Option<crate::model::VoiceSelectionParams>,

    /// Required. The configuration of the synthesized audio.
    pub audio_config: std::option::Option<crate::model::AudioConfig>,

    /// Advanced voice options.
    pub advanced_voice_options: std::option::Option<crate::model::AdvancedVoiceOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesizeSpeechRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input][crate::model::SynthesizeSpeechRequest::input].
    pub fn set_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SynthesisInput>,
    {
        self.input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input][crate::model::SynthesizeSpeechRequest::input].
    pub fn set_or_clear_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SynthesisInput>,
    {
        self.input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [voice][crate::model::SynthesizeSpeechRequest::voice].
    pub fn set_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice][crate::model::SynthesizeSpeechRequest::voice].
    pub fn set_or_clear_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio_config][crate::model::SynthesizeSpeechRequest::audio_config].
    pub fn set_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AudioConfig>,
    {
        self.audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio_config][crate::model::SynthesizeSpeechRequest::audio_config].
    pub fn set_or_clear_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AudioConfig>,
    {
        self.audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_voice_options][crate::model::SynthesizeSpeechRequest::advanced_voice_options].
    pub fn set_advanced_voice_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedVoiceOptions>,
    {
        self.advanced_voice_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_voice_options][crate::model::SynthesizeSpeechRequest::advanced_voice_options].
    pub fn set_or_clear_advanced_voice_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedVoiceOptions>,
    {
        self.advanced_voice_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SynthesizeSpeechRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesizeSpeechRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeSpeechRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input,
            __voice,
            __audio_config,
            __advanced_voice_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "input" => Ok(__FieldTag::__input),
                            "voice" => Ok(__FieldTag::__voice),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "advancedVoiceOptions" => Ok(__FieldTag::__advanced_voice_options),
                            "advanced_voice_options" => Ok(__FieldTag::__advanced_voice_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeSpeechRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input = map
                                .next_value::<std::option::Option<crate::model::SynthesisInput>>(
                                )?;
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            result.audio_config =
                                map.next_value::<std::option::Option<crate::model::AudioConfig>>()?;
                        }
                        __FieldTag::__advanced_voice_options => {
                            if !fields.insert(__FieldTag::__advanced_voice_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_voice_options",
                                ));
                            }
                            result.advanced_voice_options = map.next_value::<std::option::Option<crate::model::AdvancedVoiceOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeSpeechRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input.is_some() {
            state.serialize_entry("input", &self.input)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if self.audio_config.is_some() {
            state.serialize_entry("audioConfig", &self.audio_config)?;
        }
        if self.advanced_voice_options.is_some() {
            state.serialize_entry("advancedVoiceOptions", &self.advanced_voice_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Pronunciation customization for a phrase.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomPronunciationParams {
    /// The phrase to which the customization is applied.
    /// The phrase can be multiple words, such as proper nouns, but shouldn't span
    /// the length of the sentence.
    pub phrase: std::option::Option<std::string::String>,

    /// The phonetic encoding of the phrase.
    pub phonetic_encoding:
        std::option::Option<crate::model::custom_pronunciation_params::PhoneticEncoding>,

    /// The pronunciation of the phrase. This must be in the phonetic encoding
    /// specified above.
    pub pronunciation: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomPronunciationParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrase][crate::model::CustomPronunciationParams::phrase].
    pub fn set_phrase<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.phrase = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phrase][crate::model::CustomPronunciationParams::phrase].
    pub fn set_or_clear_phrase<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.phrase = v.map(|x| x.into());
        self
    }

    /// Sets the value of [phonetic_encoding][crate::model::CustomPronunciationParams::phonetic_encoding].
    pub fn set_phonetic_encoding<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::custom_pronunciation_params::PhoneticEncoding>,
    {
        self.phonetic_encoding = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phonetic_encoding][crate::model::CustomPronunciationParams::phonetic_encoding].
    pub fn set_or_clear_phonetic_encoding<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::custom_pronunciation_params::PhoneticEncoding>,
    {
        self.phonetic_encoding = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pronunciation][crate::model::CustomPronunciationParams::pronunciation].
    pub fn set_pronunciation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.pronunciation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pronunciation][crate::model::CustomPronunciationParams::pronunciation].
    pub fn set_or_clear_pronunciation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.pronunciation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CustomPronunciationParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.CustomPronunciationParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomPronunciationParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase,
            __phonetic_encoding,
            __pronunciation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPronunciationParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phrase" => Ok(__FieldTag::__phrase),
                            "phoneticEncoding" => Ok(__FieldTag::__phonetic_encoding),
                            "phonetic_encoding" => Ok(__FieldTag::__phonetic_encoding),
                            "pronunciation" => Ok(__FieldTag::__pronunciation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomPronunciationParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPronunciationParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase => {
                            if !fields.insert(__FieldTag::__phrase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase",
                                ));
                            }
                            result.phrase =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__phonetic_encoding => {
                            if !fields.insert(__FieldTag::__phonetic_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phonetic_encoding",
                                ));
                            }
                            result.phonetic_encoding = map.next_value::<std::option::Option<
                                crate::model::custom_pronunciation_params::PhoneticEncoding,
                            >>()?;
                        }
                        __FieldTag::__pronunciation => {
                            if !fields.insert(__FieldTag::__pronunciation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pronunciation",
                                ));
                            }
                            result.pronunciation =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomPronunciationParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.phrase.is_some() {
            state.serialize_entry("phrase", &self.phrase)?;
        }
        if self.phonetic_encoding.is_some() {
            state.serialize_entry("phoneticEncoding", &self.phonetic_encoding)?;
        }
        if self.pronunciation.is_some() {
            state.serialize_entry("pronunciation", &self.pronunciation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomPronunciationParams].
pub mod custom_pronunciation_params {
    #[allow(unused_imports)]
    use super::*;

    /// The phonetic encoding of the phrase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PhoneticEncoding {
        /// Not specified.
        Unspecified,
        /// IPA, such as apple -> ˈæpəl.
        /// <https://en.wikipedia.org/wiki/International_Phonetic_Alphabet>
        Ipa,
        /// X-SAMPA, such as apple -> "{p@l".
        /// <https://en.wikipedia.org/wiki/X-SAMPA>
        XSampa,
        /// For reading-to-pron conversion to work well, the `pronunciation` field
        /// should only contain Kanji, Hiragana, and Katakana.
        ///
        /// The pronunciation can also contain pitch accents.
        /// The start of a pitch phrase is specified with `^` and the down-pitch
        /// position is specified with `!`, for example:
        ///
        /// ```norust
        /// phrase:端  pronunciation:^はし
        /// phrase:箸  pronunciation:^は!し
        /// phrase:橋  pronunciation:^はし!
        /// ```
        ///
        /// We currently only support the Tokyo dialect, which allows at most one
        /// down-pitch per phrase (i.e. at most one `!` between `^`).
        JapaneseYomigana,
        /// Used to specify pronunciations for Mandarin words. See
        /// <https://en.wikipedia.org/wiki/Pinyin>.
        ///
        /// For example: 朝阳, the pronunciation is "chao2 yang2". The number
        /// represents the tone, and there is a space between syllables. Neutral
        /// tones are represented by 5, for example 孩子 "hai2 zi5".
        Pinyin,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PhoneticEncoding::value] or
        /// [PhoneticEncoding::name].
        UnknownValue(phonetic_encoding::UnknownValue),
    }

    #[doc(hidden)]
    pub mod phonetic_encoding {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PhoneticEncoding {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ipa => std::option::Option::Some(1),
                Self::XSampa => std::option::Option::Some(2),
                Self::JapaneseYomigana => std::option::Option::Some(3),
                Self::Pinyin => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PHONETIC_ENCODING_UNSPECIFIED"),
                Self::Ipa => std::option::Option::Some("PHONETIC_ENCODING_IPA"),
                Self::XSampa => std::option::Option::Some("PHONETIC_ENCODING_X_SAMPA"),
                Self::JapaneseYomigana => {
                    std::option::Option::Some("PHONETIC_ENCODING_JAPANESE_YOMIGANA")
                }
                Self::Pinyin => std::option::Option::Some("PHONETIC_ENCODING_PINYIN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PhoneticEncoding {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PhoneticEncoding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PhoneticEncoding {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ipa,
                2 => Self::XSampa,
                3 => Self::JapaneseYomigana,
                4 => Self::Pinyin,
                _ => Self::UnknownValue(phonetic_encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PhoneticEncoding {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PHONETIC_ENCODING_UNSPECIFIED" => Self::Unspecified,
                "PHONETIC_ENCODING_IPA" => Self::Ipa,
                "PHONETIC_ENCODING_X_SAMPA" => Self::XSampa,
                "PHONETIC_ENCODING_JAPANESE_YOMIGANA" => Self::JapaneseYomigana,
                "PHONETIC_ENCODING_PINYIN" => Self::Pinyin,
                _ => Self::UnknownValue(phonetic_encoding::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PhoneticEncoding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ipa => serializer.serialize_i32(1),
                Self::XSampa => serializer.serialize_i32(2),
                Self::JapaneseYomigana => serializer.serialize_i32(3),
                Self::Pinyin => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PhoneticEncoding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PhoneticEncoding>::new(
                ".google.cloud.texttospeech.v1.CustomPronunciationParams.PhoneticEncoding",
            ))
        }
    }
}

/// A collection of pronunciation customizations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomPronunciations {
    /// The pronunciation customizations are applied.
    pub pronunciations: std::vec::Vec<crate::model::CustomPronunciationParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomPronunciations {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pronunciations][crate::model::CustomPronunciations::pronunciations].
    pub fn set_pronunciations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomPronunciationParams>,
    {
        use std::iter::Iterator;
        self.pronunciations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CustomPronunciations {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.CustomPronunciations"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomPronunciations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPronunciations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pronunciations" => Ok(__FieldTag::__pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomPronunciations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPronunciations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pronunciations => {
                            if !fields.insert(__FieldTag::__pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pronunciations",
                                ));
                            }
                            result.pronunciations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomPronunciationParams>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomPronunciations {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pronunciations.is_empty() {
            state.serialize_entry("pronunciations", &self.pronunciations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of turns for multi-speaker synthesis.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MultiSpeakerMarkup {
    /// Required. Speaker turns.
    pub turns: std::vec::Vec<crate::model::multi_speaker_markup::Turn>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MultiSpeakerMarkup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [turns][crate::model::MultiSpeakerMarkup::turns].
    pub fn set_turns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::multi_speaker_markup::Turn>,
    {
        use std::iter::Iterator;
        self.turns = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MultiSpeakerMarkup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.MultiSpeakerMarkup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MultiSpeakerMarkup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __turns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiSpeakerMarkup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "turns" => Ok(__FieldTag::__turns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MultiSpeakerMarkup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiSpeakerMarkup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__turns => {
                            if !fields.insert(__FieldTag::__turns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for turns",
                                ));
                            }
                            result.turns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::multi_speaker_markup::Turn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MultiSpeakerMarkup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.turns.is_empty() {
            state.serialize_entry("turns", &self.turns)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MultiSpeakerMarkup].
pub mod multi_speaker_markup {
    #[allow(unused_imports)]
    use super::*;

    /// A multi-speaker turn.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Turn {
        /// Required. The speaker of the turn, for example, 'O' or 'Q'. Please refer
        /// to documentation for available speakers.
        pub speaker: std::string::String,

        /// Required. The text to speak.
        pub text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Turn {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [speaker][crate::model::multi_speaker_markup::Turn::speaker].
        pub fn set_speaker<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.speaker = v.into();
            self
        }

        /// Sets the value of [text][crate::model::multi_speaker_markup::Turn::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    impl wkt::message::Message for Turn {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.texttospeech.v1.MultiSpeakerMarkup.Turn"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Turn {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __speaker,
                __text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Turn")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "speaker" => Ok(__FieldTag::__speaker),
                                "text" => Ok(__FieldTag::__text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Turn;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Turn")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__speaker => {
                                if !fields.insert(__FieldTag::__speaker) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for speaker",
                                    ));
                                }
                                result.speaker = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Turn {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.speaker.is_empty() {
                state.serialize_entry("speaker", &self.speaker)?;
            }
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Contains text input to be synthesized. Either `text` or `ssml` must be
/// supplied. Supplying both or neither returns
/// [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. The
/// input size is limited to 5000 bytes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesisInput {
    /// Optional. The pronunciation customizations are applied to the input. If
    /// this is set, the input is synthesized using the given pronunciation
    /// customizations.
    ///
    /// The initial support is for en-us, with plans to expand to other locales in
    /// the future. Instant Clone voices aren't supported.
    ///
    /// In order to customize the pronunciation of a phrase, there must be an exact
    /// match of the phrase in the input types. If using SSML, the phrase must not
    /// be inside a phoneme tag.
    pub custom_pronunciations: std::option::Option<crate::model::CustomPronunciations>,

    /// The input source, which is either plain text or SSML.
    pub input_source: std::option::Option<crate::model::synthesis_input::InputSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesisInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [custom_pronunciations][crate::model::SynthesisInput::custom_pronunciations].
    pub fn set_custom_pronunciations<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomPronunciations>,
    {
        self.custom_pronunciations = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_pronunciations][crate::model::SynthesisInput::custom_pronunciations].
    pub fn set_or_clear_custom_pronunciations<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomPronunciations>,
    {
        self.custom_pronunciations = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_source][crate::model::SynthesisInput::input_source].
    ///
    /// Note that all the setters affecting `input_source` are mutually
    /// exclusive.
    pub fn set_input_source<
        T: std::convert::Into<std::option::Option<crate::model::synthesis_input::InputSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_source = v.into();
        self
    }

    /// The value of [input_source][crate::model::SynthesisInput::input_source]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::synthesis_input::InputSource::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::SynthesisInput::input_source]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_source =
            std::option::Option::Some(crate::model::synthesis_input::InputSource::Text(v.into()));
        self
    }

    /// The value of [input_source][crate::model::SynthesisInput::input_source]
    /// if it holds a `Markup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn markup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::synthesis_input::InputSource::Markup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::SynthesisInput::input_source]
    /// to hold a `Markup`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_markup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_source =
            std::option::Option::Some(crate::model::synthesis_input::InputSource::Markup(v.into()));
        self
    }

    /// The value of [input_source][crate::model::SynthesisInput::input_source]
    /// if it holds a `Ssml`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ssml(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::synthesis_input::InputSource::Ssml(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::SynthesisInput::input_source]
    /// to hold a `Ssml`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_ssml<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_source =
            std::option::Option::Some(crate::model::synthesis_input::InputSource::Ssml(v.into()));
        self
    }

    /// The value of [input_source][crate::model::SynthesisInput::input_source]
    /// if it holds a `MultiSpeakerMarkup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_speaker_markup(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MultiSpeakerMarkup>> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::synthesis_input::InputSource::MultiSpeakerMarkup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::SynthesisInput::input_source]
    /// to hold a `MultiSpeakerMarkup`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_multi_speaker_markup<
        T: std::convert::Into<std::boxed::Box<crate::model::MultiSpeakerMarkup>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_source = std::option::Option::Some(
            crate::model::synthesis_input::InputSource::MultiSpeakerMarkup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SynthesisInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesisInput"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesisInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __markup,
            __ssml,
            __multi_speaker_markup,
            __custom_pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesisInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "markup" => Ok(__FieldTag::__markup),
                            "ssml" => Ok(__FieldTag::__ssml),
                            "multiSpeakerMarkup" => Ok(__FieldTag::__multi_speaker_markup),
                            "multi_speaker_markup" => Ok(__FieldTag::__multi_speaker_markup),
                            "customPronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            "custom_pronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesisInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesisInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.text, latest field was text",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__markup => {
                            if !fields.insert(__FieldTag::__markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.markup, latest field was markup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Markup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ssml => {
                            if !fields.insert(__FieldTag::__ssml) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.ssml, latest field was ssml",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Ssml(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_speaker_markup => {
                            if !fields.insert(__FieldTag::__multi_speaker_markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_speaker_markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.multi_speaker_markup, latest field was multiSpeakerMarkup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::MultiSpeakerMarkup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MultiSpeakerMarkup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__custom_pronunciations => {
                            if !fields.insert(__FieldTag::__custom_pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_pronunciations",
                                ));
                            }
                            result.custom_pronunciations = map.next_value::<std::option::Option<crate::model::CustomPronunciations>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesisInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.markup() {
            state.serialize_entry("markup", value)?;
        }
        if let Some(value) = self.ssml() {
            state.serialize_entry("ssml", value)?;
        }
        if let Some(value) = self.multi_speaker_markup() {
            state.serialize_entry("multiSpeakerMarkup", value)?;
        }
        if self.custom_pronunciations.is_some() {
            state.serialize_entry("customPronunciations", &self.custom_pronunciations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SynthesisInput].
pub mod synthesis_input {
    #[allow(unused_imports)]
    use super::*;

    /// The input source, which is either plain text or SSML.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InputSource {
        /// The raw text to be synthesized.
        Text(std::string::String),
        /// Markup for HD voices specifically. This field may not be used with any
        /// other voices.
        Markup(std::string::String),
        /// The SSML document to be synthesized. The SSML document must be valid
        /// and well-formed. Otherwise the RPC will fail and return
        /// [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. For
        /// more information, see
        /// [SSML](https://cloud.google.com/text-to-speech/docs/ssml).
        Ssml(std::string::String),
        /// The multi-speaker input to be synthesized. Only applicable for
        /// multi-speaker synthesis.
        MultiSpeakerMarkup(std::boxed::Box<crate::model::MultiSpeakerMarkup>),
    }
}

/// Description of which voice to use for a synthesis request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VoiceSelectionParams {
    /// Required. The language (and potentially also the region) of the voice
    /// expressed as a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag, e.g. "en-US". This should not include a script tag (e.g. use
    /// "cmn-cn" rather than "cmn-Hant-cn"), because the script will be inferred
    /// from the input provided in the SynthesisInput.  The TTS service
    /// will use this parameter to help choose an appropriate voice.  Note that
    /// the TTS service may choose a voice with a slightly different language code
    /// than the one selected; it may substitute a different region
    /// (e.g. using en-US rather than en-CA if there isn't a Canadian voice
    /// available), or even a different language, e.g. using "nb" (Norwegian
    /// Bokmal) instead of "no" (Norwegian)".
    pub language_code: std::string::String,

    /// The name of the voice. If both the name and the gender are not set,
    /// the service will choose a voice based on the other parameters such as
    /// language_code.
    pub name: std::string::String,

    /// The preferred gender of the voice. If not set, the service will
    /// choose a voice based on the other parameters such as language_code and
    /// name. Note that this is only a preference, not requirement; if a
    /// voice of the appropriate gender is not available, the synthesizer should
    /// substitute a voice with a different gender rather than failing the request.
    pub ssml_gender: crate::model::SsmlVoiceGender,

    /// The configuration for a custom voice. If [CustomVoiceParams.model] is set,
    /// the service will choose the custom voice matching the specified
    /// configuration.
    pub custom_voice: std::option::Option<crate::model::CustomVoiceParams>,

    /// Optional. The configuration for a voice clone. If
    /// [VoiceCloneParams.voice_clone_key] is set, the service chooses the voice
    /// clone matching the specified configuration.
    pub voice_clone: std::option::Option<crate::model::VoiceCloneParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VoiceSelectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::VoiceSelectionParams::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [name][crate::model::VoiceSelectionParams::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssml_gender][crate::model::VoiceSelectionParams::ssml_gender].
    pub fn set_ssml_gender<T: std::convert::Into<crate::model::SsmlVoiceGender>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssml_gender = v.into();
        self
    }

    /// Sets the value of [custom_voice][crate::model::VoiceSelectionParams::custom_voice].
    pub fn set_custom_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomVoiceParams>,
    {
        self.custom_voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_voice][crate::model::VoiceSelectionParams::custom_voice].
    pub fn set_or_clear_custom_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomVoiceParams>,
    {
        self.custom_voice = v.map(|x| x.into());
        self
    }

    /// Sets the value of [voice_clone][crate::model::VoiceSelectionParams::voice_clone].
    pub fn set_voice_clone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceCloneParams>,
    {
        self.voice_clone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice_clone][crate::model::VoiceSelectionParams::voice_clone].
    pub fn set_or_clear_voice_clone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceCloneParams>,
    {
        self.voice_clone = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VoiceSelectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.VoiceSelectionParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VoiceSelectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            __name,
            __ssml_gender,
            __custom_voice,
            __voice_clone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceSelectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            "customVoice" => Ok(__FieldTag::__custom_voice),
                            "custom_voice" => Ok(__FieldTag::__custom_voice),
                            "voiceClone" => Ok(__FieldTag::__voice_clone),
                            "voice_clone" => Ok(__FieldTag::__voice_clone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VoiceSelectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceSelectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_voice => {
                            if !fields.insert(__FieldTag::__custom_voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_voice",
                                ));
                            }
                            result.custom_voice = map
                                .next_value::<std::option::Option<crate::model::CustomVoiceParams>>(
                                )?;
                        }
                        __FieldTag::__voice_clone => {
                            if !fields.insert(__FieldTag::__voice_clone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice_clone",
                                ));
                            }
                            result.voice_clone = map
                                .next_value::<std::option::Option<crate::model::VoiceCloneParams>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VoiceSelectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if self.custom_voice.is_some() {
            state.serialize_entry("customVoice", &self.custom_voice)?;
        }
        if self.voice_clone.is_some() {
            state.serialize_entry("voiceClone", &self.voice_clone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of audio data to be synthesized.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioConfig {
    /// Required. The format of the audio byte stream.
    pub audio_encoding: crate::model::AudioEncoding,

    /// Optional. Input only. Speaking rate/speed, in the range [0.25, 2.0]. 1.0 is
    /// the normal native speed supported by the specific voice. 2.0 is twice as
    /// fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0
    /// speed. Any other values < 0.25 or > 2.0 will return an error.
    pub speaking_rate: f64,

    /// Optional. Input only. Speaking pitch, in the range [-20.0, 20.0]. 20 means
    /// increase 20 semitones from the original pitch. -20 means decrease 20
    /// semitones from the original pitch.
    pub pitch: f64,

    /// Optional. Input only. Volume gain (in dB) of the normal native volume
    /// supported by the specific voice, in the range [-96.0, 16.0]. If unset, or
    /// set to a value of 0.0 (dB), will play at normal native signal amplitude. A
    /// value of -6.0 (dB) will play at approximately half the amplitude of the
    /// normal native signal amplitude. A value of +6.0 (dB) will play at
    /// approximately twice the amplitude of the normal native signal amplitude.
    /// Strongly recommend not to exceed +10 (dB) as there's usually no effective
    /// increase in loudness for any value greater than that.
    pub volume_gain_db: f64,

    /// Optional. The synthesis sample rate (in hertz) for this audio. When this is
    /// specified in SynthesizeSpeechRequest, if this is different from the voice's
    /// natural sample rate, then the synthesizer will honor this request by
    /// converting to the desired sample rate (which might result in worse audio
    /// quality), unless the specified sample rate is not supported for the
    /// encoding chosen, in which case it will fail the request and return
    /// [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    pub sample_rate_hertz: i32,

    /// Optional. Input only. An identifier which selects 'audio effects' profiles
    /// that are applied on (post synthesized) text to speech. Effects are applied
    /// on top of each other in the order they are given. See
    /// [audio
    /// profiles](https://cloud.google.com/text-to-speech/docs/audio-profiles) for
    /// current supported profile ids.
    pub effects_profile_id: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::AudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::AudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [speaking_rate][crate::model::AudioConfig::speaking_rate].
    pub fn set_speaking_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.speaking_rate = v.into();
        self
    }

    /// Sets the value of [pitch][crate::model::AudioConfig::pitch].
    pub fn set_pitch<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pitch = v.into();
        self
    }

    /// Sets the value of [volume_gain_db][crate::model::AudioConfig::volume_gain_db].
    pub fn set_volume_gain_db<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.volume_gain_db = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::AudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [effects_profile_id][crate::model::AudioConfig::effects_profile_id].
    pub fn set_effects_profile_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.effects_profile_id = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.AudioConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __speaking_rate,
            __pitch,
            __volume_gain_db,
            __sample_rate_hertz,
            __effects_profile_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            "pitch" => Ok(__FieldTag::__pitch),
                            "volumeGainDb" => Ok(__FieldTag::__volume_gain_db),
                            "volume_gain_db" => Ok(__FieldTag::__volume_gain_db),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "effectsProfileId" => Ok(__FieldTag::__effects_profile_id),
                            "effects_profile_id" => Ok(__FieldTag::__effects_profile_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pitch => {
                            if !fields.insert(__FieldTag::__pitch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pitch",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_gain_db => {
                            if !fields.insert(__FieldTag::__volume_gain_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_gain_db",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_gain_db =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__effects_profile_id => {
                            if !fields.insert(__FieldTag::__effects_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effects_profile_id",
                                ));
                            }
                            result.effects_profile_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !wkt::internal::is_default(&self.pitch) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitch", &__With(&self.pitch))?;
        }
        if !wkt::internal::is_default(&self.volume_gain_db) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeGainDb", &__With(&self.volume_gain_db))?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.effects_profile_id.is_empty() {
            state.serialize_entry("effectsProfileId", &self.effects_profile_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of the custom voice to be synthesized.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomVoiceParams {
    /// Required. The name of the AutoML model that synthesizes the custom voice.
    pub model: std::string::String,

    /// Optional. Deprecated. The usage of the synthesized audio to be reported.
    #[deprecated]
    pub reported_usage: crate::model::custom_voice_params::ReportedUsage,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomVoiceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::CustomVoiceParams::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [reported_usage][crate::model::CustomVoiceParams::reported_usage].
    #[deprecated]
    pub fn set_reported_usage<
        T: std::convert::Into<crate::model::custom_voice_params::ReportedUsage>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reported_usage = v.into();
        self
    }
}

impl wkt::message::Message for CustomVoiceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.CustomVoiceParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomVoiceParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __reported_usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomVoiceParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "reportedUsage" => Ok(__FieldTag::__reported_usage),
                            "reported_usage" => Ok(__FieldTag::__reported_usage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomVoiceParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomVoiceParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reported_usage => {
                            if !fields.insert(__FieldTag::__reported_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reported_usage",
                                ));
                            }
                            result.reported_usage = map
                                .next_value::<std::option::Option<
                                    crate::model::custom_voice_params::ReportedUsage,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomVoiceParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.reported_usage) {
            state.serialize_entry("reportedUsage", &self.reported_usage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CustomVoiceParams].
pub mod custom_voice_params {
    #[allow(unused_imports)]
    use super::*;

    /// Deprecated. The usage of the synthesized audio. Usage does not affect
    /// billing.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReportedUsage {
        /// Request with reported usage unspecified will be rejected.
        Unspecified,
        /// For scenarios where the synthesized audio is not downloadable and can
        /// only be used once. For example, real-time request in IVR system.
        Realtime,
        /// For scenarios where the synthesized audio is downloadable and can be
        /// reused. For example, the synthesized audio is downloaded, stored in
        /// customer service system and played repeatedly.
        Offline,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReportedUsage::value] or
        /// [ReportedUsage::name].
        UnknownValue(reported_usage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reported_usage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReportedUsage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Realtime => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REPORTED_USAGE_UNSPECIFIED"),
                Self::Realtime => std::option::Option::Some("REALTIME"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReportedUsage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReportedUsage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReportedUsage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Realtime,
                2 => Self::Offline,
                _ => Self::UnknownValue(reported_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReportedUsage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REPORTED_USAGE_UNSPECIFIED" => Self::Unspecified,
                "REALTIME" => Self::Realtime,
                "OFFLINE" => Self::Offline,
                _ => Self::UnknownValue(reported_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReportedUsage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Realtime => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReportedUsage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReportedUsage>::new(
                ".google.cloud.texttospeech.v1.CustomVoiceParams.ReportedUsage",
            ))
        }
    }
}

/// The configuration of Voice Clone feature.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VoiceCloneParams {
    /// Required. Created by GenerateVoiceCloningKey.
    pub voice_cloning_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VoiceCloneParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [voice_cloning_key][crate::model::VoiceCloneParams::voice_cloning_key].
    pub fn set_voice_cloning_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.voice_cloning_key = v.into();
        self
    }
}

impl wkt::message::Message for VoiceCloneParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.VoiceCloneParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VoiceCloneParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voice_cloning_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceCloneParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voiceCloningKey" => Ok(__FieldTag::__voice_cloning_key),
                            "voice_cloning_key" => Ok(__FieldTag::__voice_cloning_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VoiceCloneParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceCloneParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voice_cloning_key => {
                            if !fields.insert(__FieldTag::__voice_cloning_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice_cloning_key",
                                ));
                            }
                            result.voice_cloning_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VoiceCloneParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.voice_cloning_key.is_empty() {
            state.serialize_entry("voiceCloningKey", &self.voice_cloning_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message returned to the client by the `SynthesizeSpeech` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeSpeechResponse {
    /// The audio data bytes encoded as specified in the request, including the
    /// header for encodings that are wrapped in containers (e.g. MP3, OGG_OPUS).
    /// For LINEAR16 audio, we include the WAV header. Note: as
    /// with all bytes fields, protobuffers use a pure binary representation,
    /// whereas JSON representations use base64.
    pub audio_content: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesizeSpeechResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_content][crate::model::SynthesizeSpeechResponse::audio_content].
    pub fn set_audio_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio_content = v.into();
        self
    }
}

impl wkt::message::Message for SynthesizeSpeechResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesizeSpeechResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeSpeechResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioContent" => Ok(__FieldTag::__audio_content),
                            "audio_content" => Ok(__FieldTag::__audio_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeSpeechResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_content => {
                            if !fields.insert(__FieldTag::__audio_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeSpeechResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audio_content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioContent", &__With(&self.audio_content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of the desired output audio data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingAudioConfig {
    /// Required. The format of the audio byte stream.
    /// Streaming supports PCM, ALAW, MULAW and OGG_OPUS. All other encodings
    /// return an error.
    pub audio_encoding: crate::model::AudioEncoding,

    /// Optional. The synthesis sample rate (in hertz) for this audio.
    pub sample_rate_hertz: i32,

    /// Optional. Input only. Speaking rate/speed, in the range [0.25, 2.0]. 1.0 is
    /// the normal native speed supported by the specific voice. 2.0 is twice as
    /// fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0
    /// speed. Any other values < 0.25 or > 2.0 will return an error.
    pub speaking_rate: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingAudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::StreamingAudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::AudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::StreamingAudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [speaking_rate][crate::model::StreamingAudioConfig::speaking_rate].
    pub fn set_speaking_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.speaking_rate = v.into();
        self
    }
}

impl wkt::message::Message for StreamingAudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.StreamingAudioConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __speaking_rate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Provides configuration information for the StreamingSynthesize request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSynthesizeConfig {
    /// Required. The desired voice of the synthesized audio.
    pub voice: std::option::Option<crate::model::VoiceSelectionParams>,

    /// Optional. The configuration of the synthesized audio.
    pub streaming_audio_config: std::option::Option<crate::model::StreamingAudioConfig>,

    /// Optional. The pronunciation customizations are applied to the input. If
    /// this is set, the input is synthesized using the given pronunciation
    /// customizations.
    ///
    /// The initial support is for en-us, with plans to expand to other locales in
    /// the future. Instant Clone voices aren't supported.
    ///
    /// In order to customize the pronunciation of a phrase, there must be an exact
    /// match of the phrase in the input types. If using SSML, the phrase must not
    /// be inside a phoneme tag.
    pub custom_pronunciations: std::option::Option<crate::model::CustomPronunciations>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSynthesizeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [voice][crate::model::StreamingSynthesizeConfig::voice].
    pub fn set_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice][crate::model::StreamingSynthesizeConfig::voice].
    pub fn set_or_clear_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = v.map(|x| x.into());
        self
    }

    /// Sets the value of [streaming_audio_config][crate::model::StreamingSynthesizeConfig::streaming_audio_config].
    pub fn set_streaming_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamingAudioConfig>,
    {
        self.streaming_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [streaming_audio_config][crate::model::StreamingSynthesizeConfig::streaming_audio_config].
    pub fn set_or_clear_streaming_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamingAudioConfig>,
    {
        self.streaming_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_pronunciations][crate::model::StreamingSynthesizeConfig::custom_pronunciations].
    pub fn set_custom_pronunciations<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomPronunciations>,
    {
        self.custom_pronunciations = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_pronunciations][crate::model::StreamingSynthesizeConfig::custom_pronunciations].
    pub fn set_or_clear_custom_pronunciations<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomPronunciations>,
    {
        self.custom_pronunciations = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamingSynthesizeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.StreamingSynthesizeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSynthesizeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voice,
            __streaming_audio_config,
            __custom_pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voice" => Ok(__FieldTag::__voice),
                            "streamingAudioConfig" => Ok(__FieldTag::__streaming_audio_config),
                            "streaming_audio_config" => Ok(__FieldTag::__streaming_audio_config),
                            "customPronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            "custom_pronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSynthesizeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::__streaming_audio_config => {
                            if !fields.insert(__FieldTag::__streaming_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_audio_config",
                                ));
                            }
                            result.streaming_audio_config = map.next_value::<std::option::Option<crate::model::StreamingAudioConfig>>()?
                                ;
                        }
                        __FieldTag::__custom_pronunciations => {
                            if !fields.insert(__FieldTag::__custom_pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_pronunciations",
                                ));
                            }
                            result.custom_pronunciations = map.next_value::<std::option::Option<crate::model::CustomPronunciations>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSynthesizeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if self.streaming_audio_config.is_some() {
            state.serialize_entry("streamingAudioConfig", &self.streaming_audio_config)?;
        }
        if self.custom_pronunciations.is_some() {
            state.serialize_entry("customPronunciations", &self.custom_pronunciations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Input to be synthesized.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSynthesisInput {
    pub input_source: std::option::Option<crate::model::streaming_synthesis_input::InputSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSynthesisInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_source][crate::model::StreamingSynthesisInput::input_source].
    ///
    /// Note that all the setters affecting `input_source` are mutually
    /// exclusive.
    pub fn set_input_source<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_synthesis_input::InputSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_source = v.into();
        self
    }

    /// The value of [input_source][crate::model::StreamingSynthesisInput::input_source]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::streaming_synthesis_input::InputSource::Text(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::StreamingSynthesisInput::input_source]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_source = std::option::Option::Some(
            crate::model::streaming_synthesis_input::InputSource::Text(v.into()),
        );
        self
    }

    /// The value of [input_source][crate::model::StreamingSynthesisInput::input_source]
    /// if it holds a `Markup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn markup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input_source.as_ref().and_then(|v| match v {
            crate::model::streaming_synthesis_input::InputSource::Markup(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input_source][crate::model::StreamingSynthesisInput::input_source]
    /// to hold a `Markup`.
    ///
    /// Note that all the setters affecting `input_source` are
    /// mutually exclusive.
    pub fn set_markup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_source = std::option::Option::Some(
            crate::model::streaming_synthesis_input::InputSource::Markup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StreamingSynthesisInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.StreamingSynthesisInput"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSynthesisInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __markup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesisInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "markup" => Ok(__FieldTag::__markup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSynthesisInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesisInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesisInput.text, latest field was text",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::streaming_synthesis_input::InputSource::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__markup => {
                            if !fields.insert(__FieldTag::__markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesisInput.markup, latest field was markup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::streaming_synthesis_input::InputSource::Markup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSynthesisInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.markup() {
            state.serialize_entry("markup", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingSynthesisInput].
pub mod streaming_synthesis_input {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InputSource {
        /// The raw text to be synthesized. It is recommended that each input
        /// contains complete, terminating sentences, which results in better prosody
        /// in the output audio.
        Text(std::string::String),
        /// Markup for HD voices specifically. This field may not be used with any
        /// other voices.
        Markup(std::string::String),
    }
}

/// Request message for the `StreamingSynthesize` method. Multiple
/// `StreamingSynthesizeRequest` messages are sent in one call.
/// The first message must contain a `streaming_config` that
/// fully specifies the request configuration and must not contain `input`. All
/// subsequent messages must only have `input` set.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSynthesizeRequest {
    /// The request to be sent, either a StreamingSynthesizeConfig or
    /// StreamingSynthesisInput.
    pub streaming_request:
        std::option::Option<crate::model::streaming_synthesize_request::StreamingRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSynthesizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [streaming_request][crate::model::StreamingSynthesizeRequest::streaming_request].
    ///
    /// Note that all the setters affecting `streaming_request` are mutually
    /// exclusive.
    pub fn set_streaming_request<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_synthesize_request::StreamingRequest>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = v.into();
        self
    }

    /// The value of [streaming_request][crate::model::StreamingSynthesizeRequest::streaming_request]
    /// if it holds a `StreamingConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn streaming_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingSynthesizeConfig>> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_synthesize_request::StreamingRequest::StreamingConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [streaming_request][crate::model::StreamingSynthesizeRequest::streaming_request]
    /// to hold a `StreamingConfig`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_streaming_config<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingSynthesizeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_synthesize_request::StreamingRequest::StreamingConfig(v.into()),
        );
        self
    }

    /// The value of [streaming_request][crate::model::StreamingSynthesizeRequest::streaming_request]
    /// if it holds a `Input`, `None` if the field is not set or
    /// holds a different branch.
    pub fn input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingSynthesisInput>> {
        #[allow(unreachable_patterns)]
        self.streaming_request.as_ref().and_then(|v| match v {
            crate::model::streaming_synthesize_request::StreamingRequest::Input(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [streaming_request][crate::model::StreamingSynthesizeRequest::streaming_request]
    /// to hold a `Input`.
    ///
    /// Note that all the setters affecting `streaming_request` are
    /// mutually exclusive.
    pub fn set_input<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingSynthesisInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_request = std::option::Option::Some(
            crate::model::streaming_synthesize_request::StreamingRequest::Input(v.into()),
        );
        self
    }
}

impl wkt::message::Message for StreamingSynthesizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.StreamingSynthesizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSynthesizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __streaming_config,
            __input,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamingConfig" => Ok(__FieldTag::__streaming_config),
                            "streaming_config" => Ok(__FieldTag::__streaming_config),
                            "input" => Ok(__FieldTag::__input),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSynthesizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__streaming_config => {
                            if !fields.insert(__FieldTag::__streaming_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_config",
                                ));
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesizeRequest.streaming_config, latest field was streamingConfig",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_synthesize_request::StreamingRequest::StreamingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingSynthesizeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesizeRequest.input, latest field was input",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_synthesize_request::StreamingRequest::Input(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamingSynthesisInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSynthesizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.streaming_config() {
            state.serialize_entry("streamingConfig", value)?;
        }
        if let Some(value) = self.input() {
            state.serialize_entry("input", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingSynthesizeRequest].
pub mod streaming_synthesize_request {
    #[allow(unused_imports)]
    use super::*;

    /// The request to be sent, either a StreamingSynthesizeConfig or
    /// StreamingSynthesisInput.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StreamingRequest {
        /// StreamingSynthesizeConfig to be used in this streaming attempt. Only
        /// specified in the first message sent in a `StreamingSynthesize` call.
        StreamingConfig(std::boxed::Box<crate::model::StreamingSynthesizeConfig>),
        /// Input to synthesize. Specified in all messages but the first in a
        /// `StreamingSynthesize` call.
        Input(std::boxed::Box<crate::model::StreamingSynthesisInput>),
    }
}

/// `StreamingSynthesizeResponse` is the only message returned to the
/// client by `StreamingSynthesize` method. A series of zero or more
/// `StreamingSynthesizeResponse` messages are streamed back to the client.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSynthesizeResponse {
    /// The audio data bytes encoded as specified in the request. This is
    /// headerless LINEAR16 audio with a sample rate of 24000.
    pub audio_content: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSynthesizeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_content][crate::model::StreamingSynthesizeResponse::audio_content].
    pub fn set_audio_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio_content = v.into();
        self
    }
}

impl wkt::message::Message for StreamingSynthesizeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.StreamingSynthesizeResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSynthesizeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioContent" => Ok(__FieldTag::__audio_content),
                            "audio_content" => Ok(__FieldTag::__audio_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSynthesizeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_content => {
                            if !fields.insert(__FieldTag::__audio_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSynthesizeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.audio_content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioContent", &__With(&self.audio_content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message sent by the client for the
/// `SynthesizeLongAudio` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeLongAudioRequest {
    /// The resource states of the request in the form of
    /// `projects/*/locations/*`.
    pub parent: std::string::String,

    /// Required. The Synthesizer requires either plain text or SSML as input.
    pub input: std::option::Option<crate::model::SynthesisInput>,

    /// Required. The configuration of the synthesized audio.
    pub audio_config: std::option::Option<crate::model::AudioConfig>,

    /// Required. Specifies a Cloud Storage URI for the synthesis results. Must be
    /// specified in the format: `gs://bucket_name/object_name`, and the bucket
    /// must already exist.
    pub output_gcs_uri: std::string::String,

    /// Required. The desired voice of the synthesized audio.
    pub voice: std::option::Option<crate::model::VoiceSelectionParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesizeLongAudioRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SynthesizeLongAudioRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input][crate::model::SynthesizeLongAudioRequest::input].
    pub fn set_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SynthesisInput>,
    {
        self.input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input][crate::model::SynthesizeLongAudioRequest::input].
    pub fn set_or_clear_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SynthesisInput>,
    {
        self.input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio_config][crate::model::SynthesizeLongAudioRequest::audio_config].
    pub fn set_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AudioConfig>,
    {
        self.audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio_config][crate::model::SynthesizeLongAudioRequest::audio_config].
    pub fn set_or_clear_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AudioConfig>,
    {
        self.audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_gcs_uri][crate::model::SynthesizeLongAudioRequest::output_gcs_uri].
    pub fn set_output_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_gcs_uri = v.into();
        self
    }

    /// Sets the value of [voice][crate::model::SynthesizeLongAudioRequest::voice].
    pub fn set_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice][crate::model::SynthesizeLongAudioRequest::voice].
    pub fn set_or_clear_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SynthesizeLongAudioRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesizeLongAudioRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeLongAudioRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input,
            __audio_config,
            __output_gcs_uri,
            __voice,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "input" => Ok(__FieldTag::__input),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "outputGcsUri" => Ok(__FieldTag::__output_gcs_uri),
                            "output_gcs_uri" => Ok(__FieldTag::__output_gcs_uri),
                            "voice" => Ok(__FieldTag::__voice),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeLongAudioRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input = map
                                .next_value::<std::option::Option<crate::model::SynthesisInput>>(
                                )?;
                        }
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            result.audio_config =
                                map.next_value::<std::option::Option<crate::model::AudioConfig>>()?;
                        }
                        __FieldTag::__output_gcs_uri => {
                            if !fields.insert(__FieldTag::__output_gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_gcs_uri",
                                ));
                            }
                            result.output_gcs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeLongAudioRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.input.is_some() {
            state.serialize_entry("input", &self.input)?;
        }
        if self.audio_config.is_some() {
            state.serialize_entry("audioConfig", &self.audio_config)?;
        }
        if !self.output_gcs_uri.is_empty() {
            state.serialize_entry("outputGcsUri", &self.output_gcs_uri)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message returned to the client by the `SynthesizeLongAudio` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeLongAudioResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesizeLongAudioResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SynthesizeLongAudioResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesizeLongAudioResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeLongAudioResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeLongAudioResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeLongAudioResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for response returned by the `SynthesizeLongAudio` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeLongAudioMetadata {
    /// Time when the request was received.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Deprecated. Do not use.
    #[deprecated]
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// The progress of the most recent processing update in percentage, ie. 70.0%.
    pub progress_percentage: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SynthesizeLongAudioMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::SynthesizeLongAudioMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::SynthesizeLongAudioMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::SynthesizeLongAudioMetadata::last_update_time].
    #[deprecated]
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::SynthesizeLongAudioMetadata::last_update_time].
    #[deprecated]
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percentage][crate::model::SynthesizeLongAudioMetadata::progress_percentage].
    pub fn set_progress_percentage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.progress_percentage = v.into();
        self
    }
}

impl wkt::message::Message for SynthesizeLongAudioMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.texttospeech.v1.SynthesizeLongAudioMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeLongAudioMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __last_update_time,
            __progress_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "progressPercentage" => Ok(__FieldTag::__progress_percentage),
                            "progress_percentage" => Ok(__FieldTag::__progress_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeLongAudioMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__progress_percentage => {
                            if !fields.insert(__FieldTag::__progress_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeLongAudioMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !wkt::internal::is_default(&self.progress_percentage) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercentage", &__With(&self.progress_percentage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Gender of the voice as described in
/// [SSML voice element](https://www.w3.org/TR/speech-synthesis11/#edef_voice).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SsmlVoiceGender {
    /// An unspecified gender.
    /// In VoiceSelectionParams, this means that the client doesn't care which
    /// gender the selected voice will have. In the Voice field of
    /// ListVoicesResponse, this may mean that the voice doesn't fit any of the
    /// other categories in this enum, or that the gender of the voice isn't known.
    Unspecified,
    /// A male voice.
    Male,
    /// A female voice.
    Female,
    /// A gender-neutral voice. This voice is not yet supported.
    Neutral,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SsmlVoiceGender::value] or
    /// [SsmlVoiceGender::name].
    UnknownValue(ssml_voice_gender::UnknownValue),
}

#[doc(hidden)]
pub mod ssml_voice_gender {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SsmlVoiceGender {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Male => std::option::Option::Some(1),
            Self::Female => std::option::Option::Some(2),
            Self::Neutral => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SSML_VOICE_GENDER_UNSPECIFIED"),
            Self::Male => std::option::Option::Some("MALE"),
            Self::Female => std::option::Option::Some("FEMALE"),
            Self::Neutral => std::option::Option::Some("NEUTRAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SsmlVoiceGender {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SsmlVoiceGender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SsmlVoiceGender {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Male,
            2 => Self::Female,
            3 => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SsmlVoiceGender {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SSML_VOICE_GENDER_UNSPECIFIED" => Self::Unspecified,
            "MALE" => Self::Male,
            "FEMALE" => Self::Female,
            "NEUTRAL" => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SsmlVoiceGender {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Male => serializer.serialize_i32(1),
            Self::Female => serializer.serialize_i32(2),
            Self::Neutral => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SsmlVoiceGender {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SsmlVoiceGender>::new(
            ".google.cloud.texttospeech.v1.SsmlVoiceGender",
        ))
    }
}

/// Configuration to set up audio encoder. The encoding determines the output
/// audio format that we'd like.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AudioEncoding {
    /// Not specified. Will return result
    /// [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
    Unspecified,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    /// Audio content returned as LINEAR16 also contains a WAV header.
    Linear16,
    /// MP3 audio at 32kbps.
    Mp3,
    /// Opus encoded audio wrapped in an ogg container. The result is a
    /// file which can be played natively on Android, and in browsers (at least
    /// Chrome and Firefox). The quality of the encoding is considerably higher
    /// than MP3 while using approximately the same bitrate.
    OggOpus,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
    /// Audio content returned as MULAW also contains a WAV header.
    Mulaw,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/A-law.
    /// Audio content returned as ALAW also contains a WAV header.
    Alaw,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    /// Note that as opposed to LINEAR16, audio won't be wrapped in a WAV (or
    /// any other) header.
    Pcm,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AudioEncoding::value] or
    /// [AudioEncoding::name].
    UnknownValue(audio_encoding::UnknownValue),
}

#[doc(hidden)]
pub mod audio_encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AudioEncoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear16 => std::option::Option::Some(1),
            Self::Mp3 => std::option::Option::Some(2),
            Self::OggOpus => std::option::Option::Some(3),
            Self::Mulaw => std::option::Option::Some(5),
            Self::Alaw => std::option::Option::Some(6),
            Self::Pcm => std::option::Option::Some(7),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUDIO_ENCODING_UNSPECIFIED"),
            Self::Linear16 => std::option::Option::Some("LINEAR16"),
            Self::Mp3 => std::option::Option::Some("MP3"),
            Self::OggOpus => std::option::Option::Some("OGG_OPUS"),
            Self::Mulaw => std::option::Option::Some("MULAW"),
            Self::Alaw => std::option::Option::Some("ALAW"),
            Self::Pcm => std::option::Option::Some("PCM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AudioEncoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AudioEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AudioEncoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear16,
            2 => Self::Mp3,
            3 => Self::OggOpus,
            5 => Self::Mulaw,
            6 => Self::Alaw,
            7 => Self::Pcm,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AudioEncoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
            "LINEAR16" => Self::Linear16,
            "MP3" => Self::Mp3,
            "OGG_OPUS" => Self::OggOpus,
            "MULAW" => Self::Mulaw,
            "ALAW" => Self::Alaw,
            "PCM" => Self::Pcm,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AudioEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear16 => serializer.serialize_i32(1),
            Self::Mp3 => serializer.serialize_i32(2),
            Self::OggOpus => serializer.serialize_i32(3),
            Self::Mulaw => serializer.serialize_i32(5),
            Self::Alaw => serializer.serialize_i32(6),
            Self::Pcm => serializer.serialize_i32(7),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AudioEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AudioEncoding>::new(
            ".google.cloud.texttospeech.v1.AudioEncoding",
        ))
    }
}
