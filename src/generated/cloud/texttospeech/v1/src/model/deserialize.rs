// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVoicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVoicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVoicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVoicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListVoicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVoicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voices" => Ok(__FieldTag::__voices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListVoicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVoicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voices => {
                            if !fields.insert(__FieldTag::__voices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voices",
                                ));
                            }
                            result.voices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Voice>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Voice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_codes,
            __name,
            __ssml_gender,
            __natural_sample_rate_hertz,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Voice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            "naturalSampleRateHertz" => Ok(__FieldTag::__natural_sample_rate_hertz),
                            "natural_sample_rate_hertz" => {
                                Ok(__FieldTag::__natural_sample_rate_hertz)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Voice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Voice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__natural_sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__natural_sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for natural_sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.natural_sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdvancedVoiceOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __low_latency_journey_synthesis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedVoiceOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lowLatencyJourneySynthesis" => {
                                Ok(__FieldTag::__low_latency_journey_synthesis)
                            }
                            "low_latency_journey_synthesis" => {
                                Ok(__FieldTag::__low_latency_journey_synthesis)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdvancedVoiceOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedVoiceOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__low_latency_journey_synthesis => {
                            if !fields.insert(__FieldTag::__low_latency_journey_synthesis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for low_latency_journey_synthesis",
                                ));
                            }
                            result.low_latency_journey_synthesis =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeSpeechRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input,
            __voice,
            __audio_config,
            __advanced_voice_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "input" => Ok(__FieldTag::__input),
                            "voice" => Ok(__FieldTag::__voice),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "advancedVoiceOptions" => Ok(__FieldTag::__advanced_voice_options),
                            "advanced_voice_options" => Ok(__FieldTag::__advanced_voice_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeSpeechRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input = map
                                .next_value::<std::option::Option<crate::model::SynthesisInput>>(
                                )?;
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            result.audio_config =
                                map.next_value::<std::option::Option<crate::model::AudioConfig>>()?;
                        }
                        __FieldTag::__advanced_voice_options => {
                            if !fields.insert(__FieldTag::__advanced_voice_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_voice_options",
                                ));
                            }
                            result.advanced_voice_options = map.next_value::<std::option::Option<crate::model::AdvancedVoiceOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomPronunciationParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrase,
            __phonetic_encoding,
            __pronunciation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPronunciationParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phrase" => Ok(__FieldTag::__phrase),
                            "phoneticEncoding" => Ok(__FieldTag::__phonetic_encoding),
                            "phonetic_encoding" => Ok(__FieldTag::__phonetic_encoding),
                            "pronunciation" => Ok(__FieldTag::__pronunciation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomPronunciationParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPronunciationParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrase => {
                            if !fields.insert(__FieldTag::__phrase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase",
                                ));
                            }
                            result.phrase =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__phonetic_encoding => {
                            if !fields.insert(__FieldTag::__phonetic_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phonetic_encoding",
                                ));
                            }
                            result.phonetic_encoding = map.next_value::<std::option::Option<
                                crate::model::custom_pronunciation_params::PhoneticEncoding,
                            >>()?;
                        }
                        __FieldTag::__pronunciation => {
                            if !fields.insert(__FieldTag::__pronunciation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pronunciation",
                                ));
                            }
                            result.pronunciation =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomPronunciations {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomPronunciations")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pronunciations" => Ok(__FieldTag::__pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomPronunciations;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomPronunciations")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pronunciations => {
                            if !fields.insert(__FieldTag::__pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pronunciations",
                                ));
                            }
                            result.pronunciations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CustomPronunciationParams>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MultiSpeakerMarkup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __turns,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiSpeakerMarkup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "turns" => Ok(__FieldTag::__turns),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MultiSpeakerMarkup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiSpeakerMarkup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__turns => {
                            if !fields.insert(__FieldTag::__turns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for turns",
                                ));
                            }
                            result.turns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::multi_speaker_markup::Turn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::multi_speaker_markup::Turn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaker,
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Turn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speaker" => Ok(__FieldTag::__speaker),
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::multi_speaker_markup::Turn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Turn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaker => {
                            if !fields.insert(__FieldTag::__speaker) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker",
                                ));
                            }
                            result.speaker = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MultispeakerPrebuiltVoice {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaker_alias,
            __speaker_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultispeakerPrebuiltVoice")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speakerAlias" => Ok(__FieldTag::__speaker_alias),
                            "speaker_alias" => Ok(__FieldTag::__speaker_alias),
                            "speakerId" => Ok(__FieldTag::__speaker_id),
                            "speaker_id" => Ok(__FieldTag::__speaker_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MultispeakerPrebuiltVoice;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultispeakerPrebuiltVoice")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaker_alias => {
                            if !fields.insert(__FieldTag::__speaker_alias) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_alias",
                                ));
                            }
                            result.speaker_alias = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speaker_id => {
                            if !fields.insert(__FieldTag::__speaker_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_id",
                                ));
                            }
                            result.speaker_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MultiSpeakerVoiceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaker_voice_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MultiSpeakerVoiceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speakerVoiceConfigs" => Ok(__FieldTag::__speaker_voice_configs),
                            "speaker_voice_configs" => Ok(__FieldTag::__speaker_voice_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MultiSpeakerVoiceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MultiSpeakerVoiceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaker_voice_configs => {
                            if !fields.insert(__FieldTag::__speaker_voice_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_voice_configs",
                                ));
                            }
                            result.speaker_voice_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MultispeakerPrebuiltVoice>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesisInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __markup,
            __ssml,
            __multi_speaker_markup,
            __prompt,
            __custom_pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesisInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "markup" => Ok(__FieldTag::__markup),
                            "ssml" => Ok(__FieldTag::__ssml),
                            "multiSpeakerMarkup" => Ok(__FieldTag::__multi_speaker_markup),
                            "multi_speaker_markup" => Ok(__FieldTag::__multi_speaker_markup),
                            "prompt" => Ok(__FieldTag::__prompt),
                            "customPronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            "custom_pronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesisInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesisInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.text, latest field was text",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__markup => {
                            if !fields.insert(__FieldTag::__markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.markup, latest field was markup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Markup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ssml => {
                            if !fields.insert(__FieldTag::__ssml) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.ssml, latest field was ssml",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::Ssml(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_speaker_markup => {
                            if !fields.insert(__FieldTag::__multi_speaker_markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_speaker_markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.SynthesisInput.multi_speaker_markup, latest field was multiSpeakerMarkup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::synthesis_input::InputSource::MultiSpeakerMarkup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MultiSpeakerMarkup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__prompt => {
                            if !fields.insert(__FieldTag::__prompt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prompt",
                                ));
                            }
                            result.prompt =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__custom_pronunciations => {
                            if !fields.insert(__FieldTag::__custom_pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_pronunciations",
                                ));
                            }
                            result.custom_pronunciations = map.next_value::<std::option::Option<crate::model::CustomPronunciations>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VoiceSelectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            __name,
            __ssml_gender,
            __custom_voice,
            __voice_clone,
            __model_name,
            __multi_speaker_voice_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceSelectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            "customVoice" => Ok(__FieldTag::__custom_voice),
                            "custom_voice" => Ok(__FieldTag::__custom_voice),
                            "voiceClone" => Ok(__FieldTag::__voice_clone),
                            "voice_clone" => Ok(__FieldTag::__voice_clone),
                            "modelName" => Ok(__FieldTag::__model_name),
                            "model_name" => Ok(__FieldTag::__model_name),
                            "multiSpeakerVoiceConfig" => {
                                Ok(__FieldTag::__multi_speaker_voice_config)
                            }
                            "multi_speaker_voice_config" => {
                                Ok(__FieldTag::__multi_speaker_voice_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VoiceSelectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceSelectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_voice => {
                            if !fields.insert(__FieldTag::__custom_voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_voice",
                                ));
                            }
                            result.custom_voice = map
                                .next_value::<std::option::Option<crate::model::CustomVoiceParams>>(
                                )?;
                        }
                        __FieldTag::__voice_clone => {
                            if !fields.insert(__FieldTag::__voice_clone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice_clone",
                                ));
                            }
                            result.voice_clone = map
                                .next_value::<std::option::Option<crate::model::VoiceCloneParams>>(
                                )?;
                        }
                        __FieldTag::__model_name => {
                            if !fields.insert(__FieldTag::__model_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_name",
                                ));
                            }
                            result.model_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_speaker_voice_config => {
                            if !fields.insert(__FieldTag::__multi_speaker_voice_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_speaker_voice_config",
                                ));
                            }
                            result.multi_speaker_voice_config = map.next_value::<std::option::Option<crate::model::MultiSpeakerVoiceConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __speaking_rate,
            __pitch,
            __volume_gain_db,
            __sample_rate_hertz,
            __effects_profile_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            "pitch" => Ok(__FieldTag::__pitch),
                            "volumeGainDb" => Ok(__FieldTag::__volume_gain_db),
                            "volume_gain_db" => Ok(__FieldTag::__volume_gain_db),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "effectsProfileId" => Ok(__FieldTag::__effects_profile_id),
                            "effects_profile_id" => Ok(__FieldTag::__effects_profile_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pitch => {
                            if !fields.insert(__FieldTag::__pitch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pitch",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_gain_db => {
                            if !fields.insert(__FieldTag::__volume_gain_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_gain_db",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_gain_db =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__effects_profile_id => {
                            if !fields.insert(__FieldTag::__effects_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effects_profile_id",
                                ));
                            }
                            result.effects_profile_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CustomVoiceParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __reported_usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomVoiceParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "reportedUsage" => Ok(__FieldTag::__reported_usage),
                            "reported_usage" => Ok(__FieldTag::__reported_usage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CustomVoiceParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomVoiceParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reported_usage => {
                            if !fields.insert(__FieldTag::__reported_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reported_usage",
                                ));
                            }
                            result.reported_usage = map
                                .next_value::<std::option::Option<
                                    crate::model::custom_voice_params::ReportedUsage,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VoiceCloneParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voice_cloning_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceCloneParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voiceCloningKey" => Ok(__FieldTag::__voice_cloning_key),
                            "voice_cloning_key" => Ok(__FieldTag::__voice_cloning_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VoiceCloneParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceCloneParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voice_cloning_key => {
                            if !fields.insert(__FieldTag::__voice_cloning_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice_cloning_key",
                                ));
                            }
                            result.voice_cloning_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeSpeechResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioContent" => Ok(__FieldTag::__audio_content),
                            "audio_content" => Ok(__FieldTag::__audio_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeSpeechResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_content => {
                            if !fields.insert(__FieldTag::__audio_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __speaking_rate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingSynthesizeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __voice,
            __streaming_audio_config,
            __custom_pronunciations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "voice" => Ok(__FieldTag::__voice),
                            "streamingAudioConfig" => Ok(__FieldTag::__streaming_audio_config),
                            "streaming_audio_config" => Ok(__FieldTag::__streaming_audio_config),
                            "customPronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            "custom_pronunciations" => Ok(__FieldTag::__custom_pronunciations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingSynthesizeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::__streaming_audio_config => {
                            if !fields.insert(__FieldTag::__streaming_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_audio_config",
                                ));
                            }
                            result.streaming_audio_config = map.next_value::<std::option::Option<crate::model::StreamingAudioConfig>>()?
                                ;
                        }
                        __FieldTag::__custom_pronunciations => {
                            if !fields.insert(__FieldTag::__custom_pronunciations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_pronunciations",
                                ));
                            }
                            result.custom_pronunciations = map.next_value::<std::option::Option<crate::model::CustomPronunciations>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingSynthesisInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __markup,
            __multi_speaker_markup,
            __prompt,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesisInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "markup" => Ok(__FieldTag::__markup),
                            "multiSpeakerMarkup" => Ok(__FieldTag::__multi_speaker_markup),
                            "multi_speaker_markup" => Ok(__FieldTag::__multi_speaker_markup),
                            "prompt" => Ok(__FieldTag::__prompt),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingSynthesisInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesisInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesisInput.text, latest field was text",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::streaming_synthesis_input::InputSource::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__markup => {
                            if !fields.insert(__FieldTag::__markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesisInput.markup, latest field was markup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::streaming_synthesis_input::InputSource::Markup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__multi_speaker_markup => {
                            if !fields.insert(__FieldTag::__multi_speaker_markup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_speaker_markup",
                                ));
                            }
                            if result.input_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input_source`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesisInput.multi_speaker_markup, latest field was multiSpeakerMarkup",
                                ));
                            }
                            result.input_source = std::option::Option::Some(
                                crate::model::streaming_synthesis_input::InputSource::MultiSpeakerMarkup(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MultiSpeakerMarkup>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__prompt => {
                            if !fields.insert(__FieldTag::__prompt) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prompt",
                                ));
                            }
                            result.prompt =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingSynthesizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __streaming_config,
            __input,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamingConfig" => Ok(__FieldTag::__streaming_config),
                            "streaming_config" => Ok(__FieldTag::__streaming_config),
                            "input" => Ok(__FieldTag::__input),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingSynthesizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__streaming_config => {
                            if !fields.insert(__FieldTag::__streaming_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_config",
                                ));
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesizeRequest.streaming_config, latest field was streamingConfig",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_synthesize_request::StreamingRequest::StreamingConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingSynthesizeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            if result.streaming_request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `streaming_request`, a oneof with full ID .google.cloud.texttospeech.v1.StreamingSynthesizeRequest.input, latest field was input",
                                ));
                            }
                            result.streaming_request = std::option::Option::Some(
                                crate::model::streaming_synthesize_request::StreamingRequest::Input(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::StreamingSynthesisInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StreamingSynthesizeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSynthesizeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioContent" => Ok(__FieldTag::__audio_content),
                            "audio_content" => Ok(__FieldTag::__audio_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StreamingSynthesizeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSynthesizeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_content => {
                            if !fields.insert(__FieldTag::__audio_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_content =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeLongAudioRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input,
            __audio_config,
            __output_gcs_uri,
            __voice,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "input" => Ok(__FieldTag::__input),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "outputGcsUri" => Ok(__FieldTag::__output_gcs_uri),
                            "output_gcs_uri" => Ok(__FieldTag::__output_gcs_uri),
                            "voice" => Ok(__FieldTag::__voice),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeLongAudioRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input => {
                            if !fields.insert(__FieldTag::__input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input",
                                ));
                            }
                            result.input = map
                                .next_value::<std::option::Option<crate::model::SynthesisInput>>(
                                )?;
                        }
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            result.audio_config =
                                map.next_value::<std::option::Option<crate::model::AudioConfig>>()?;
                        }
                        __FieldTag::__output_gcs_uri => {
                            if !fields.insert(__FieldTag::__output_gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_gcs_uri",
                                ));
                            }
                            result.output_gcs_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeLongAudioResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeLongAudioResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SynthesizeLongAudioMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __last_update_time,
            __progress_percentage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeLongAudioMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "progressPercentage" => Ok(__FieldTag::__progress_percentage),
                            "progress_percentage" => Ok(__FieldTag::__progress_percentage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SynthesizeLongAudioMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeLongAudioMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__progress_percentage => {
                            if !fields.insert(__FieldTag::__progress_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
