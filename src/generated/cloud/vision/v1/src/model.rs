// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A vertex represents a 2D point in the image.
/// NOTE: the vertex coordinates are in the same scale as the original image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Vertex {
    /// X coordinate.
    pub x: i32,

    /// Y coordinate.
    pub y: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Vertex::x].
    pub fn set_x<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Vertex::y].
    pub fn set_y<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for Vertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Vertex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Vertex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Vertex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Vertex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Vertex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Vertex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Vertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Vertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NormalizedVertex {
    /// X coordinate.
    pub x: f32,

    /// Y coordinate.
    pub y: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NormalizedVertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::NormalizedVertex::x].
    pub fn set_x<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::NormalizedVertex::y].
    pub fn set_y<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for NormalizedVertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.NormalizedVertex"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NormalizedVertex {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NormalizedVertex")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NormalizedVertex;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NormalizedVertex")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NormalizedVertex {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NormalizedVertex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NormalizedVertex");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A bounding polygon for the detected image annotation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BoundingPoly {
    /// The bounding polygon vertices.
    pub vertices: std::vec::Vec<crate::model::Vertex>,

    /// The bounding polygon normalized vertices.
    pub normalized_vertices: std::vec::Vec<crate::model::NormalizedVertex>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BoundingPoly {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vertices][crate::model::BoundingPoly::vertices].
    pub fn set_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Vertex>,
    {
        use std::iter::Iterator;
        self.vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalized_vertices][crate::model::BoundingPoly::normalized_vertices].
    pub fn set_normalized_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NormalizedVertex>,
    {
        use std::iter::Iterator;
        self.normalized_vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BoundingPoly {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BoundingPoly"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BoundingPoly {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vertices,
            __normalized_vertices,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoundingPoly")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vertices" => Ok(__FieldTag::__vertices),
                            "normalizedVertices" => Ok(__FieldTag::__normalized_vertices),
                            "normalized_vertices" => Ok(__FieldTag::__normalized_vertices),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BoundingPoly;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoundingPoly")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vertices => {
                            if !fields.insert(__FieldTag::__vertices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertices",
                                ));
                            }
                            result.vertices = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Vertex>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__normalized_vertices => {
                            if !fields.insert(__FieldTag::__normalized_vertices) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for normalized_vertices",
                                ));
                            }
                            result.normalized_vertices =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NormalizedVertex>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BoundingPoly {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vertices.is_empty() {
            state.serialize_entry("vertices", &self.vertices)?;
        }
        if !self.normalized_vertices.is_empty() {
            state.serialize_entry("normalizedVertices", &self.normalized_vertices)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BoundingPoly {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BoundingPoly");
        debug_struct.field("vertices", &self.vertices);
        debug_struct.field("normalized_vertices", &self.normalized_vertices);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A 3D position in the image, used primarily for Face detection landmarks.
/// A valid Position must have both x and y coordinates.
/// The position coordinates are in the same scale as the original image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Position {
    /// X coordinate.
    pub x: f32,

    /// Y coordinate.
    pub y: f32,

    /// Z coordinate (or depth).
    pub z: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Position {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Position::x].
    pub fn set_x<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Position::y].
    pub fn set_y<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [z][crate::model::Position::z].
    pub fn set_z<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.z = v.into();
        self
    }
}

impl wkt::message::Message for Position {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Position"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Position {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __x,
            __y,
            __z,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Position")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            "z" => Ok(__FieldTag::__z),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Position;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Position")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.x = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.y = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__z => {
                            if !fields.insert(__FieldTag::__z) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for z",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.z = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Position {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.x) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("x", &__With(&self.x))?;
        }
        if !wkt::internal::is_default(&self.y) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("y", &__With(&self.y))?;
        }
        if !wkt::internal::is_default(&self.z) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("z", &__With(&self.z))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Position {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Position");
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        debug_struct.field("z", &self.z);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The type of Google Cloud Vision API detection to perform, and the maximum
/// number of results to return for that type. Multiple `Feature` objects can
/// be specified in the `features` list.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Feature {
    /// The feature type.
    pub r#type: crate::model::feature::Type,

    /// Maximum number of results of this type. Does not apply to
    /// `TEXT_DETECTION`, `DOCUMENT_TEXT_DETECTION`, or `CROP_HINTS`.
    pub max_results: i32,

    /// Model to use for the feature.
    /// Supported values: "builtin/stable" (the default if unset) and
    /// "builtin/latest". `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` also
    /// support "builtin/weekly" for the bleeding edge release updated weekly.
    pub model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Feature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Feature::type].
    pub fn set_type<T: std::convert::Into<crate::model::feature::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::Feature::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Feature::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for Feature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Feature"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Feature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __max_results,
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Feature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Feature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Feature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::feature::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Feature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Feature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Feature");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("max_results", &self.max_results);
        debug_struct.field("model", &self.model);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Feature].
pub mod feature {
    #[allow(unused_imports)]
    use super::*;

    /// Type of Google Cloud Vision API feature to be extracted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified feature type.
        Unspecified,
        /// Run face detection.
        FaceDetection,
        /// Run landmark detection.
        LandmarkDetection,
        /// Run logo detection.
        LogoDetection,
        /// Run label detection.
        LabelDetection,
        /// Run text detection / optical character recognition (OCR). Text detection
        /// is optimized for areas of text within a larger image; if the image is
        /// a document, use `DOCUMENT_TEXT_DETECTION` instead.
        TextDetection,
        /// Run dense text document OCR. Takes precedence when both
        /// `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` are present.
        DocumentTextDetection,
        /// Run Safe Search to detect potentially unsafe
        /// or undesirable content.
        SafeSearchDetection,
        /// Compute a set of image properties, such as the
        /// image's dominant colors.
        ImageProperties,
        /// Run crop hints.
        CropHints,
        /// Run web detection.
        WebDetection,
        /// Run Product Search.
        ProductSearch,
        /// Run localizer for object detection.
        ObjectLocalization,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FaceDetection => std::option::Option::Some(1),
                Self::LandmarkDetection => std::option::Option::Some(2),
                Self::LogoDetection => std::option::Option::Some(3),
                Self::LabelDetection => std::option::Option::Some(4),
                Self::TextDetection => std::option::Option::Some(5),
                Self::DocumentTextDetection => std::option::Option::Some(11),
                Self::SafeSearchDetection => std::option::Option::Some(6),
                Self::ImageProperties => std::option::Option::Some(7),
                Self::CropHints => std::option::Option::Some(9),
                Self::WebDetection => std::option::Option::Some(10),
                Self::ProductSearch => std::option::Option::Some(12),
                Self::ObjectLocalization => std::option::Option::Some(19),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::FaceDetection => std::option::Option::Some("FACE_DETECTION"),
                Self::LandmarkDetection => std::option::Option::Some("LANDMARK_DETECTION"),
                Self::LogoDetection => std::option::Option::Some("LOGO_DETECTION"),
                Self::LabelDetection => std::option::Option::Some("LABEL_DETECTION"),
                Self::TextDetection => std::option::Option::Some("TEXT_DETECTION"),
                Self::DocumentTextDetection => std::option::Option::Some("DOCUMENT_TEXT_DETECTION"),
                Self::SafeSearchDetection => std::option::Option::Some("SAFE_SEARCH_DETECTION"),
                Self::ImageProperties => std::option::Option::Some("IMAGE_PROPERTIES"),
                Self::CropHints => std::option::Option::Some("CROP_HINTS"),
                Self::WebDetection => std::option::Option::Some("WEB_DETECTION"),
                Self::ProductSearch => std::option::Option::Some("PRODUCT_SEARCH"),
                Self::ObjectLocalization => std::option::Option::Some("OBJECT_LOCALIZATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FaceDetection,
                2 => Self::LandmarkDetection,
                3 => Self::LogoDetection,
                4 => Self::LabelDetection,
                5 => Self::TextDetection,
                6 => Self::SafeSearchDetection,
                7 => Self::ImageProperties,
                9 => Self::CropHints,
                10 => Self::WebDetection,
                11 => Self::DocumentTextDetection,
                12 => Self::ProductSearch,
                19 => Self::ObjectLocalization,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "FACE_DETECTION" => Self::FaceDetection,
                "LANDMARK_DETECTION" => Self::LandmarkDetection,
                "LOGO_DETECTION" => Self::LogoDetection,
                "LABEL_DETECTION" => Self::LabelDetection,
                "TEXT_DETECTION" => Self::TextDetection,
                "DOCUMENT_TEXT_DETECTION" => Self::DocumentTextDetection,
                "SAFE_SEARCH_DETECTION" => Self::SafeSearchDetection,
                "IMAGE_PROPERTIES" => Self::ImageProperties,
                "CROP_HINTS" => Self::CropHints,
                "WEB_DETECTION" => Self::WebDetection,
                "PRODUCT_SEARCH" => Self::ProductSearch,
                "OBJECT_LOCALIZATION" => Self::ObjectLocalization,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FaceDetection => serializer.serialize_i32(1),
                Self::LandmarkDetection => serializer.serialize_i32(2),
                Self::LogoDetection => serializer.serialize_i32(3),
                Self::LabelDetection => serializer.serialize_i32(4),
                Self::TextDetection => serializer.serialize_i32(5),
                Self::DocumentTextDetection => serializer.serialize_i32(11),
                Self::SafeSearchDetection => serializer.serialize_i32(6),
                Self::ImageProperties => serializer.serialize_i32(7),
                Self::CropHints => serializer.serialize_i32(9),
                Self::WebDetection => serializer.serialize_i32(10),
                Self::ProductSearch => serializer.serialize_i32(12),
                Self::ObjectLocalization => serializer.serialize_i32(19),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vision.v1.Feature.Type",
            ))
        }
    }
}

/// External image source (Google Cloud Storage or web URL image location).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageSource {
    /// **Use `image_uri` instead.**
    ///
    /// The Google Cloud Storage  URI of the form
    /// `gs://bucket_name/object_name`. Object versioning is not supported. See
    /// [Google Cloud Storage Request
    /// URIs](https://cloud.google.com/storage/docs/reference-uris) for more info.
    pub gcs_image_uri: std::string::String,

    /// The URI of the source image. Can be either:
    ///
    /// 1. A Google Cloud Storage URI of the form
    ///    `gs://bucket_name/object_name`. Object versioning is not supported. See
    ///    [Google Cloud Storage Request
    ///    URIs](https://cloud.google.com/storage/docs/reference-uris) for more
    ///    info.
    ///
    /// 1. A publicly-accessible image HTTP/HTTPS URL. When fetching images from
    ///    HTTP/HTTPS URLs, Google cannot guarantee that the request will be
    ///    completed. Your request may fail if the specified host denies the
    ///    request (e.g. due to request throttling or DOS prevention), or if Google
    ///    throttles requests to the site for abuse prevention. You should not
    ///    depend on externally-hosted images for production applications.
    ///
    ///
    /// When both `gcs_image_uri` and `image_uri` are specified, `image_uri` takes
    /// precedence.
    pub image_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_image_uri][crate::model::ImageSource::gcs_image_uri].
    pub fn set_gcs_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_image_uri = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::ImageSource::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }
}

impl wkt::message::Message for ImageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_image_uri,
            __image_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsImageUri" => Ok(__FieldTag::__gcs_image_uri),
                            "gcs_image_uri" => Ok(__FieldTag::__gcs_image_uri),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_image_uri => {
                            if !fields.insert(__FieldTag::__gcs_image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_image_uri",
                                ));
                            }
                            result.gcs_image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_uri",
                                ));
                            }
                            result.image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_image_uri.is_empty() {
            state.serialize_entry("gcsImageUri", &self.gcs_image_uri)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageSource");
        debug_struct.field("gcs_image_uri", &self.gcs_image_uri);
        debug_struct.field("image_uri", &self.image_uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Client image to perform Google Cloud Vision API tasks over.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Image {
    /// Image content, represented as a stream of bytes.
    /// Note: As with all `bytes` fields, protobuffers use a pure binary
    /// representation, whereas JSON representations use base64.
    ///
    /// Currently, this field only works for BatchAnnotateImages requests. It does
    /// not work for AsyncBatchAnnotateImages requests.
    pub content: ::bytes::Bytes,

    /// Google Cloud Storage image location, or publicly-accessible image
    /// URL. If both `content` and `source` are provided for an image, `content`
    /// takes precedence and is used to perform the image annotation request.
    pub source: std::option::Option<crate::model::ImageSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Image {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::Image::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Image::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageSource>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::Image::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageSource>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Image {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Image"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Image {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Image")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "source" => Ok(__FieldTag::__source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Image;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Image")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::ImageSource>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Image");
        debug_struct.field("content", &self.content);
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A face annotation object contains the results of face detection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FaceAnnotation {
    /// The bounding polygon around the face. The coordinates of the bounding box
    /// are in the original image's scale.
    /// The bounding box is computed to "frame" the face in accordance with human
    /// expectations. It is based on the landmarker results.
    /// Note that one or more x and/or y coordinates may not be generated in the
    /// `BoundingPoly` (the polygon will be unbounded) if only a partial face
    /// appears in the image to be annotated.
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The `fd_bounding_poly` bounding polygon is tighter than the
    /// `boundingPoly`, and encloses only the skin part of the face. Typically, it
    /// is used to eliminate the face from any image analysis that detects the
    /// "amount of skin" visible in an image. It is not based on the
    /// landmarker results, only on the initial face detection, hence
    /// the \<code\>fd\</code\> (face detection) prefix.
    pub fd_bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// Detected face landmarks.
    pub landmarks: std::vec::Vec<crate::model::face_annotation::Landmark>,

    /// Roll angle, which indicates the amount of clockwise/anti-clockwise rotation
    /// of the face relative to the image vertical about the axis perpendicular to
    /// the face. Range [-180,180].
    pub roll_angle: f32,

    /// Yaw angle, which indicates the leftward/rightward angle that the face is
    /// pointing relative to the vertical plane perpendicular to the image. Range
    /// [-180,180].
    pub pan_angle: f32,

    /// Pitch angle, which indicates the upwards/downwards angle that the face is
    /// pointing relative to the image's horizontal plane. Range [-180,180].
    pub tilt_angle: f32,

    /// Detection confidence. Range [0, 1].
    pub detection_confidence: f32,

    /// Face landmarking confidence. Range [0, 1].
    pub landmarking_confidence: f32,

    /// Joy likelihood.
    pub joy_likelihood: crate::model::Likelihood,

    /// Sorrow likelihood.
    pub sorrow_likelihood: crate::model::Likelihood,

    /// Anger likelihood.
    pub anger_likelihood: crate::model::Likelihood,

    /// Surprise likelihood.
    pub surprise_likelihood: crate::model::Likelihood,

    /// Under-exposed likelihood.
    pub under_exposed_likelihood: crate::model::Likelihood,

    /// Blurred likelihood.
    pub blurred_likelihood: crate::model::Likelihood,

    /// Headwear likelihood.
    pub headwear_likelihood: crate::model::Likelihood,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FaceAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::FaceAnnotation::bounding_poly].
    pub fn set_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_poly][crate::model::FaceAnnotation::bounding_poly].
    pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fd_bounding_poly][crate::model::FaceAnnotation::fd_bounding_poly].
    pub fn set_fd_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.fd_bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fd_bounding_poly][crate::model::FaceAnnotation::fd_bounding_poly].
    pub fn set_or_clear_fd_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.fd_bounding_poly = v.map(|x| x.into());
        self
    }

    /// Sets the value of [landmarks][crate::model::FaceAnnotation::landmarks].
    pub fn set_landmarks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::face_annotation::Landmark>,
    {
        use std::iter::Iterator;
        self.landmarks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [roll_angle][crate::model::FaceAnnotation::roll_angle].
    pub fn set_roll_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.roll_angle = v.into();
        self
    }

    /// Sets the value of [pan_angle][crate::model::FaceAnnotation::pan_angle].
    pub fn set_pan_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.pan_angle = v.into();
        self
    }

    /// Sets the value of [tilt_angle][crate::model::FaceAnnotation::tilt_angle].
    pub fn set_tilt_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.tilt_angle = v.into();
        self
    }

    /// Sets the value of [detection_confidence][crate::model::FaceAnnotation::detection_confidence].
    pub fn set_detection_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.detection_confidence = v.into();
        self
    }

    /// Sets the value of [landmarking_confidence][crate::model::FaceAnnotation::landmarking_confidence].
    pub fn set_landmarking_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.landmarking_confidence = v.into();
        self
    }

    /// Sets the value of [joy_likelihood][crate::model::FaceAnnotation::joy_likelihood].
    pub fn set_joy_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.joy_likelihood = v.into();
        self
    }

    /// Sets the value of [sorrow_likelihood][crate::model::FaceAnnotation::sorrow_likelihood].
    pub fn set_sorrow_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.sorrow_likelihood = v.into();
        self
    }

    /// Sets the value of [anger_likelihood][crate::model::FaceAnnotation::anger_likelihood].
    pub fn set_anger_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.anger_likelihood = v.into();
        self
    }

    /// Sets the value of [surprise_likelihood][crate::model::FaceAnnotation::surprise_likelihood].
    pub fn set_surprise_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.surprise_likelihood = v.into();
        self
    }

    /// Sets the value of [under_exposed_likelihood][crate::model::FaceAnnotation::under_exposed_likelihood].
    pub fn set_under_exposed_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.under_exposed_likelihood = v.into();
        self
    }

    /// Sets the value of [blurred_likelihood][crate::model::FaceAnnotation::blurred_likelihood].
    pub fn set_blurred_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.blurred_likelihood = v.into();
        self
    }

    /// Sets the value of [headwear_likelihood][crate::model::FaceAnnotation::headwear_likelihood].
    pub fn set_headwear_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.headwear_likelihood = v.into();
        self
    }
}

impl wkt::message::Message for FaceAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.FaceAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FaceAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bounding_poly,
            __fd_bounding_poly,
            __landmarks,
            __roll_angle,
            __pan_angle,
            __tilt_angle,
            __detection_confidence,
            __landmarking_confidence,
            __joy_likelihood,
            __sorrow_likelihood,
            __anger_likelihood,
            __surprise_likelihood,
            __under_exposed_likelihood,
            __blurred_likelihood,
            __headwear_likelihood,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FaceAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                            "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                            "fdBoundingPoly" => Ok(__FieldTag::__fd_bounding_poly),
                            "fd_bounding_poly" => Ok(__FieldTag::__fd_bounding_poly),
                            "landmarks" => Ok(__FieldTag::__landmarks),
                            "rollAngle" => Ok(__FieldTag::__roll_angle),
                            "roll_angle" => Ok(__FieldTag::__roll_angle),
                            "panAngle" => Ok(__FieldTag::__pan_angle),
                            "pan_angle" => Ok(__FieldTag::__pan_angle),
                            "tiltAngle" => Ok(__FieldTag::__tilt_angle),
                            "tilt_angle" => Ok(__FieldTag::__tilt_angle),
                            "detectionConfidence" => Ok(__FieldTag::__detection_confidence),
                            "detection_confidence" => Ok(__FieldTag::__detection_confidence),
                            "landmarkingConfidence" => Ok(__FieldTag::__landmarking_confidence),
                            "landmarking_confidence" => Ok(__FieldTag::__landmarking_confidence),
                            "joyLikelihood" => Ok(__FieldTag::__joy_likelihood),
                            "joy_likelihood" => Ok(__FieldTag::__joy_likelihood),
                            "sorrowLikelihood" => Ok(__FieldTag::__sorrow_likelihood),
                            "sorrow_likelihood" => Ok(__FieldTag::__sorrow_likelihood),
                            "angerLikelihood" => Ok(__FieldTag::__anger_likelihood),
                            "anger_likelihood" => Ok(__FieldTag::__anger_likelihood),
                            "surpriseLikelihood" => Ok(__FieldTag::__surprise_likelihood),
                            "surprise_likelihood" => Ok(__FieldTag::__surprise_likelihood),
                            "underExposedLikelihood" => Ok(__FieldTag::__under_exposed_likelihood),
                            "under_exposed_likelihood" => {
                                Ok(__FieldTag::__under_exposed_likelihood)
                            }
                            "blurredLikelihood" => Ok(__FieldTag::__blurred_likelihood),
                            "blurred_likelihood" => Ok(__FieldTag::__blurred_likelihood),
                            "headwearLikelihood" => Ok(__FieldTag::__headwear_likelihood),
                            "headwear_likelihood" => Ok(__FieldTag::__headwear_likelihood),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FaceAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FaceAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bounding_poly => {
                            if !fields.insert(__FieldTag::__bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_poly",
                                ));
                            }
                            result.bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__fd_bounding_poly => {
                            if !fields.insert(__FieldTag::__fd_bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fd_bounding_poly",
                                ));
                            }
                            result.fd_bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__landmarks => {
                            if !fields.insert(__FieldTag::__landmarks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for landmarks",
                                ));
                            }
                            result.landmarks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::face_annotation::Landmark>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__roll_angle => {
                            if !fields.insert(__FieldTag::__roll_angle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roll_angle",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.roll_angle = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pan_angle => {
                            if !fields.insert(__FieldTag::__pan_angle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pan_angle",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pan_angle = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tilt_angle => {
                            if !fields.insert(__FieldTag::__tilt_angle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tilt_angle",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tilt_angle = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__detection_confidence => {
                            if !fields.insert(__FieldTag::__detection_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detection_confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.detection_confidence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__landmarking_confidence => {
                            if !fields.insert(__FieldTag::__landmarking_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for landmarking_confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.landmarking_confidence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__joy_likelihood => {
                            if !fields.insert(__FieldTag::__joy_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for joy_likelihood",
                                ));
                            }
                            result.joy_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sorrow_likelihood => {
                            if !fields.insert(__FieldTag::__sorrow_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sorrow_likelihood",
                                ));
                            }
                            result.sorrow_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__anger_likelihood => {
                            if !fields.insert(__FieldTag::__anger_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anger_likelihood",
                                ));
                            }
                            result.anger_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__surprise_likelihood => {
                            if !fields.insert(__FieldTag::__surprise_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for surprise_likelihood",
                                ));
                            }
                            result.surprise_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__under_exposed_likelihood => {
                            if !fields.insert(__FieldTag::__under_exposed_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for under_exposed_likelihood",
                                ));
                            }
                            result.under_exposed_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__blurred_likelihood => {
                            if !fields.insert(__FieldTag::__blurred_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurred_likelihood",
                                ));
                            }
                            result.blurred_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__headwear_likelihood => {
                            if !fields.insert(__FieldTag::__headwear_likelihood) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for headwear_likelihood",
                                ));
                            }
                            result.headwear_likelihood = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FaceAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bounding_poly.is_some() {
            state.serialize_entry("boundingPoly", &self.bounding_poly)?;
        }
        if self.fd_bounding_poly.is_some() {
            state.serialize_entry("fdBoundingPoly", &self.fd_bounding_poly)?;
        }
        if !self.landmarks.is_empty() {
            state.serialize_entry("landmarks", &self.landmarks)?;
        }
        if !wkt::internal::is_default(&self.roll_angle) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rollAngle", &__With(&self.roll_angle))?;
        }
        if !wkt::internal::is_default(&self.pan_angle) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("panAngle", &__With(&self.pan_angle))?;
        }
        if !wkt::internal::is_default(&self.tilt_angle) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tiltAngle", &__With(&self.tilt_angle))?;
        }
        if !wkt::internal::is_default(&self.detection_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("detectionConfidence", &__With(&self.detection_confidence))?;
        }
        if !wkt::internal::is_default(&self.landmarking_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "landmarkingConfidence",
                &__With(&self.landmarking_confidence),
            )?;
        }
        if !wkt::internal::is_default(&self.joy_likelihood) {
            state.serialize_entry("joyLikelihood", &self.joy_likelihood)?;
        }
        if !wkt::internal::is_default(&self.sorrow_likelihood) {
            state.serialize_entry("sorrowLikelihood", &self.sorrow_likelihood)?;
        }
        if !wkt::internal::is_default(&self.anger_likelihood) {
            state.serialize_entry("angerLikelihood", &self.anger_likelihood)?;
        }
        if !wkt::internal::is_default(&self.surprise_likelihood) {
            state.serialize_entry("surpriseLikelihood", &self.surprise_likelihood)?;
        }
        if !wkt::internal::is_default(&self.under_exposed_likelihood) {
            state.serialize_entry("underExposedLikelihood", &self.under_exposed_likelihood)?;
        }
        if !wkt::internal::is_default(&self.blurred_likelihood) {
            state.serialize_entry("blurredLikelihood", &self.blurred_likelihood)?;
        }
        if !wkt::internal::is_default(&self.headwear_likelihood) {
            state.serialize_entry("headwearLikelihood", &self.headwear_likelihood)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FaceAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FaceAnnotation");
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("fd_bounding_poly", &self.fd_bounding_poly);
        debug_struct.field("landmarks", &self.landmarks);
        debug_struct.field("roll_angle", &self.roll_angle);
        debug_struct.field("pan_angle", &self.pan_angle);
        debug_struct.field("tilt_angle", &self.tilt_angle);
        debug_struct.field("detection_confidence", &self.detection_confidence);
        debug_struct.field("landmarking_confidence", &self.landmarking_confidence);
        debug_struct.field("joy_likelihood", &self.joy_likelihood);
        debug_struct.field("sorrow_likelihood", &self.sorrow_likelihood);
        debug_struct.field("anger_likelihood", &self.anger_likelihood);
        debug_struct.field("surprise_likelihood", &self.surprise_likelihood);
        debug_struct.field("under_exposed_likelihood", &self.under_exposed_likelihood);
        debug_struct.field("blurred_likelihood", &self.blurred_likelihood);
        debug_struct.field("headwear_likelihood", &self.headwear_likelihood);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FaceAnnotation].
pub mod face_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// A face-specific landmark (for example, a face feature).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Landmark {
        /// Face landmark type.
        pub r#type: crate::model::face_annotation::landmark::Type,

        /// Face landmark position.
        pub position: std::option::Option<crate::model::Position>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Landmark {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::face_annotation::Landmark::type].
        pub fn set_type<T: std::convert::Into<crate::model::face_annotation::landmark::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [position][crate::model::face_annotation::Landmark::position].
        pub fn set_position<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Position>,
        {
            self.position = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [position][crate::model::face_annotation::Landmark::position].
        pub fn set_or_clear_position<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Position>,
        {
            self.position = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Landmark {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.FaceAnnotation.Landmark"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Landmark {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __position,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Landmark")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "position" => Ok(__FieldTag::__position),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Landmark;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Landmark")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::face_annotation::landmark::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__position => {
                                if !fields.insert(__FieldTag::__position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for position",
                                    ));
                                }
                                result.position = map
                                    .next_value::<std::option::Option<crate::model::Position>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Landmark {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if self.position.is_some() {
                state.serialize_entry("position", &self.position)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Landmark {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Landmark");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("position", &self.position);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Landmark].
    pub mod landmark {
        #[allow(unused_imports)]
        use super::*;

        /// Face landmark (feature) type.
        /// Left and right are defined from the vantage of the viewer of the image
        /// without considering mirror projections typical of photos. So, `LEFT_EYE`,
        /// typically, is the person's right eye.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unknown face landmark detected. Should not be filled.
            UnknownLandmark,
            /// Left eye.
            LeftEye,
            /// Right eye.
            RightEye,
            /// Left of left eyebrow.
            LeftOfLeftEyebrow,
            /// Right of left eyebrow.
            RightOfLeftEyebrow,
            /// Left of right eyebrow.
            LeftOfRightEyebrow,
            /// Right of right eyebrow.
            RightOfRightEyebrow,
            /// Midpoint between eyes.
            MidpointBetweenEyes,
            /// Nose tip.
            NoseTip,
            /// Upper lip.
            UpperLip,
            /// Lower lip.
            LowerLip,
            /// Mouth left.
            MouthLeft,
            /// Mouth right.
            MouthRight,
            /// Mouth center.
            MouthCenter,
            /// Nose, bottom right.
            NoseBottomRight,
            /// Nose, bottom left.
            NoseBottomLeft,
            /// Nose, bottom center.
            NoseBottomCenter,
            /// Left eye, top boundary.
            LeftEyeTopBoundary,
            /// Left eye, right corner.
            LeftEyeRightCorner,
            /// Left eye, bottom boundary.
            LeftEyeBottomBoundary,
            /// Left eye, left corner.
            LeftEyeLeftCorner,
            /// Right eye, top boundary.
            RightEyeTopBoundary,
            /// Right eye, right corner.
            RightEyeRightCorner,
            /// Right eye, bottom boundary.
            RightEyeBottomBoundary,
            /// Right eye, left corner.
            RightEyeLeftCorner,
            /// Left eyebrow, upper midpoint.
            LeftEyebrowUpperMidpoint,
            /// Right eyebrow, upper midpoint.
            RightEyebrowUpperMidpoint,
            /// Left ear tragion.
            LeftEarTragion,
            /// Right ear tragion.
            RightEarTragion,
            /// Left eye pupil.
            LeftEyePupil,
            /// Right eye pupil.
            RightEyePupil,
            /// Forehead glabella.
            ForeheadGlabella,
            /// Chin gnathion.
            ChinGnathion,
            /// Chin left gonion.
            ChinLeftGonion,
            /// Chin right gonion.
            ChinRightGonion,
            /// Left cheek center.
            LeftCheekCenter,
            /// Right cheek center.
            RightCheekCenter,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::UnknownLandmark => std::option::Option::Some(0),
                    Self::LeftEye => std::option::Option::Some(1),
                    Self::RightEye => std::option::Option::Some(2),
                    Self::LeftOfLeftEyebrow => std::option::Option::Some(3),
                    Self::RightOfLeftEyebrow => std::option::Option::Some(4),
                    Self::LeftOfRightEyebrow => std::option::Option::Some(5),
                    Self::RightOfRightEyebrow => std::option::Option::Some(6),
                    Self::MidpointBetweenEyes => std::option::Option::Some(7),
                    Self::NoseTip => std::option::Option::Some(8),
                    Self::UpperLip => std::option::Option::Some(9),
                    Self::LowerLip => std::option::Option::Some(10),
                    Self::MouthLeft => std::option::Option::Some(11),
                    Self::MouthRight => std::option::Option::Some(12),
                    Self::MouthCenter => std::option::Option::Some(13),
                    Self::NoseBottomRight => std::option::Option::Some(14),
                    Self::NoseBottomLeft => std::option::Option::Some(15),
                    Self::NoseBottomCenter => std::option::Option::Some(16),
                    Self::LeftEyeTopBoundary => std::option::Option::Some(17),
                    Self::LeftEyeRightCorner => std::option::Option::Some(18),
                    Self::LeftEyeBottomBoundary => std::option::Option::Some(19),
                    Self::LeftEyeLeftCorner => std::option::Option::Some(20),
                    Self::RightEyeTopBoundary => std::option::Option::Some(21),
                    Self::RightEyeRightCorner => std::option::Option::Some(22),
                    Self::RightEyeBottomBoundary => std::option::Option::Some(23),
                    Self::RightEyeLeftCorner => std::option::Option::Some(24),
                    Self::LeftEyebrowUpperMidpoint => std::option::Option::Some(25),
                    Self::RightEyebrowUpperMidpoint => std::option::Option::Some(26),
                    Self::LeftEarTragion => std::option::Option::Some(27),
                    Self::RightEarTragion => std::option::Option::Some(28),
                    Self::LeftEyePupil => std::option::Option::Some(29),
                    Self::RightEyePupil => std::option::Option::Some(30),
                    Self::ForeheadGlabella => std::option::Option::Some(31),
                    Self::ChinGnathion => std::option::Option::Some(32),
                    Self::ChinLeftGonion => std::option::Option::Some(33),
                    Self::ChinRightGonion => std::option::Option::Some(34),
                    Self::LeftCheekCenter => std::option::Option::Some(35),
                    Self::RightCheekCenter => std::option::Option::Some(36),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::UnknownLandmark => std::option::Option::Some("UNKNOWN_LANDMARK"),
                    Self::LeftEye => std::option::Option::Some("LEFT_EYE"),
                    Self::RightEye => std::option::Option::Some("RIGHT_EYE"),
                    Self::LeftOfLeftEyebrow => std::option::Option::Some("LEFT_OF_LEFT_EYEBROW"),
                    Self::RightOfLeftEyebrow => std::option::Option::Some("RIGHT_OF_LEFT_EYEBROW"),
                    Self::LeftOfRightEyebrow => std::option::Option::Some("LEFT_OF_RIGHT_EYEBROW"),
                    Self::RightOfRightEyebrow => {
                        std::option::Option::Some("RIGHT_OF_RIGHT_EYEBROW")
                    }
                    Self::MidpointBetweenEyes => std::option::Option::Some("MIDPOINT_BETWEEN_EYES"),
                    Self::NoseTip => std::option::Option::Some("NOSE_TIP"),
                    Self::UpperLip => std::option::Option::Some("UPPER_LIP"),
                    Self::LowerLip => std::option::Option::Some("LOWER_LIP"),
                    Self::MouthLeft => std::option::Option::Some("MOUTH_LEFT"),
                    Self::MouthRight => std::option::Option::Some("MOUTH_RIGHT"),
                    Self::MouthCenter => std::option::Option::Some("MOUTH_CENTER"),
                    Self::NoseBottomRight => std::option::Option::Some("NOSE_BOTTOM_RIGHT"),
                    Self::NoseBottomLeft => std::option::Option::Some("NOSE_BOTTOM_LEFT"),
                    Self::NoseBottomCenter => std::option::Option::Some("NOSE_BOTTOM_CENTER"),
                    Self::LeftEyeTopBoundary => std::option::Option::Some("LEFT_EYE_TOP_BOUNDARY"),
                    Self::LeftEyeRightCorner => std::option::Option::Some("LEFT_EYE_RIGHT_CORNER"),
                    Self::LeftEyeBottomBoundary => {
                        std::option::Option::Some("LEFT_EYE_BOTTOM_BOUNDARY")
                    }
                    Self::LeftEyeLeftCorner => std::option::Option::Some("LEFT_EYE_LEFT_CORNER"),
                    Self::RightEyeTopBoundary => {
                        std::option::Option::Some("RIGHT_EYE_TOP_BOUNDARY")
                    }
                    Self::RightEyeRightCorner => {
                        std::option::Option::Some("RIGHT_EYE_RIGHT_CORNER")
                    }
                    Self::RightEyeBottomBoundary => {
                        std::option::Option::Some("RIGHT_EYE_BOTTOM_BOUNDARY")
                    }
                    Self::RightEyeLeftCorner => std::option::Option::Some("RIGHT_EYE_LEFT_CORNER"),
                    Self::LeftEyebrowUpperMidpoint => {
                        std::option::Option::Some("LEFT_EYEBROW_UPPER_MIDPOINT")
                    }
                    Self::RightEyebrowUpperMidpoint => {
                        std::option::Option::Some("RIGHT_EYEBROW_UPPER_MIDPOINT")
                    }
                    Self::LeftEarTragion => std::option::Option::Some("LEFT_EAR_TRAGION"),
                    Self::RightEarTragion => std::option::Option::Some("RIGHT_EAR_TRAGION"),
                    Self::LeftEyePupil => std::option::Option::Some("LEFT_EYE_PUPIL"),
                    Self::RightEyePupil => std::option::Option::Some("RIGHT_EYE_PUPIL"),
                    Self::ForeheadGlabella => std::option::Option::Some("FOREHEAD_GLABELLA"),
                    Self::ChinGnathion => std::option::Option::Some("CHIN_GNATHION"),
                    Self::ChinLeftGonion => std::option::Option::Some("CHIN_LEFT_GONION"),
                    Self::ChinRightGonion => std::option::Option::Some("CHIN_RIGHT_GONION"),
                    Self::LeftCheekCenter => std::option::Option::Some("LEFT_CHEEK_CENTER"),
                    Self::RightCheekCenter => std::option::Option::Some("RIGHT_CHEEK_CENTER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::UnknownLandmark,
                    1 => Self::LeftEye,
                    2 => Self::RightEye,
                    3 => Self::LeftOfLeftEyebrow,
                    4 => Self::RightOfLeftEyebrow,
                    5 => Self::LeftOfRightEyebrow,
                    6 => Self::RightOfRightEyebrow,
                    7 => Self::MidpointBetweenEyes,
                    8 => Self::NoseTip,
                    9 => Self::UpperLip,
                    10 => Self::LowerLip,
                    11 => Self::MouthLeft,
                    12 => Self::MouthRight,
                    13 => Self::MouthCenter,
                    14 => Self::NoseBottomRight,
                    15 => Self::NoseBottomLeft,
                    16 => Self::NoseBottomCenter,
                    17 => Self::LeftEyeTopBoundary,
                    18 => Self::LeftEyeRightCorner,
                    19 => Self::LeftEyeBottomBoundary,
                    20 => Self::LeftEyeLeftCorner,
                    21 => Self::RightEyeTopBoundary,
                    22 => Self::RightEyeRightCorner,
                    23 => Self::RightEyeBottomBoundary,
                    24 => Self::RightEyeLeftCorner,
                    25 => Self::LeftEyebrowUpperMidpoint,
                    26 => Self::RightEyebrowUpperMidpoint,
                    27 => Self::LeftEarTragion,
                    28 => Self::RightEarTragion,
                    29 => Self::LeftEyePupil,
                    30 => Self::RightEyePupil,
                    31 => Self::ForeheadGlabella,
                    32 => Self::ChinGnathion,
                    33 => Self::ChinLeftGonion,
                    34 => Self::ChinRightGonion,
                    35 => Self::LeftCheekCenter,
                    36 => Self::RightCheekCenter,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN_LANDMARK" => Self::UnknownLandmark,
                    "LEFT_EYE" => Self::LeftEye,
                    "RIGHT_EYE" => Self::RightEye,
                    "LEFT_OF_LEFT_EYEBROW" => Self::LeftOfLeftEyebrow,
                    "RIGHT_OF_LEFT_EYEBROW" => Self::RightOfLeftEyebrow,
                    "LEFT_OF_RIGHT_EYEBROW" => Self::LeftOfRightEyebrow,
                    "RIGHT_OF_RIGHT_EYEBROW" => Self::RightOfRightEyebrow,
                    "MIDPOINT_BETWEEN_EYES" => Self::MidpointBetweenEyes,
                    "NOSE_TIP" => Self::NoseTip,
                    "UPPER_LIP" => Self::UpperLip,
                    "LOWER_LIP" => Self::LowerLip,
                    "MOUTH_LEFT" => Self::MouthLeft,
                    "MOUTH_RIGHT" => Self::MouthRight,
                    "MOUTH_CENTER" => Self::MouthCenter,
                    "NOSE_BOTTOM_RIGHT" => Self::NoseBottomRight,
                    "NOSE_BOTTOM_LEFT" => Self::NoseBottomLeft,
                    "NOSE_BOTTOM_CENTER" => Self::NoseBottomCenter,
                    "LEFT_EYE_TOP_BOUNDARY" => Self::LeftEyeTopBoundary,
                    "LEFT_EYE_RIGHT_CORNER" => Self::LeftEyeRightCorner,
                    "LEFT_EYE_BOTTOM_BOUNDARY" => Self::LeftEyeBottomBoundary,
                    "LEFT_EYE_LEFT_CORNER" => Self::LeftEyeLeftCorner,
                    "RIGHT_EYE_TOP_BOUNDARY" => Self::RightEyeTopBoundary,
                    "RIGHT_EYE_RIGHT_CORNER" => Self::RightEyeRightCorner,
                    "RIGHT_EYE_BOTTOM_BOUNDARY" => Self::RightEyeBottomBoundary,
                    "RIGHT_EYE_LEFT_CORNER" => Self::RightEyeLeftCorner,
                    "LEFT_EYEBROW_UPPER_MIDPOINT" => Self::LeftEyebrowUpperMidpoint,
                    "RIGHT_EYEBROW_UPPER_MIDPOINT" => Self::RightEyebrowUpperMidpoint,
                    "LEFT_EAR_TRAGION" => Self::LeftEarTragion,
                    "RIGHT_EAR_TRAGION" => Self::RightEarTragion,
                    "LEFT_EYE_PUPIL" => Self::LeftEyePupil,
                    "RIGHT_EYE_PUPIL" => Self::RightEyePupil,
                    "FOREHEAD_GLABELLA" => Self::ForeheadGlabella,
                    "CHIN_GNATHION" => Self::ChinGnathion,
                    "CHIN_LEFT_GONION" => Self::ChinLeftGonion,
                    "CHIN_RIGHT_GONION" => Self::ChinRightGonion,
                    "LEFT_CHEEK_CENTER" => Self::LeftCheekCenter,
                    "RIGHT_CHEEK_CENTER" => Self::RightCheekCenter,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::UnknownLandmark => serializer.serialize_i32(0),
                    Self::LeftEye => serializer.serialize_i32(1),
                    Self::RightEye => serializer.serialize_i32(2),
                    Self::LeftOfLeftEyebrow => serializer.serialize_i32(3),
                    Self::RightOfLeftEyebrow => serializer.serialize_i32(4),
                    Self::LeftOfRightEyebrow => serializer.serialize_i32(5),
                    Self::RightOfRightEyebrow => serializer.serialize_i32(6),
                    Self::MidpointBetweenEyes => serializer.serialize_i32(7),
                    Self::NoseTip => serializer.serialize_i32(8),
                    Self::UpperLip => serializer.serialize_i32(9),
                    Self::LowerLip => serializer.serialize_i32(10),
                    Self::MouthLeft => serializer.serialize_i32(11),
                    Self::MouthRight => serializer.serialize_i32(12),
                    Self::MouthCenter => serializer.serialize_i32(13),
                    Self::NoseBottomRight => serializer.serialize_i32(14),
                    Self::NoseBottomLeft => serializer.serialize_i32(15),
                    Self::NoseBottomCenter => serializer.serialize_i32(16),
                    Self::LeftEyeTopBoundary => serializer.serialize_i32(17),
                    Self::LeftEyeRightCorner => serializer.serialize_i32(18),
                    Self::LeftEyeBottomBoundary => serializer.serialize_i32(19),
                    Self::LeftEyeLeftCorner => serializer.serialize_i32(20),
                    Self::RightEyeTopBoundary => serializer.serialize_i32(21),
                    Self::RightEyeRightCorner => serializer.serialize_i32(22),
                    Self::RightEyeBottomBoundary => serializer.serialize_i32(23),
                    Self::RightEyeLeftCorner => serializer.serialize_i32(24),
                    Self::LeftEyebrowUpperMidpoint => serializer.serialize_i32(25),
                    Self::RightEyebrowUpperMidpoint => serializer.serialize_i32(26),
                    Self::LeftEarTragion => serializer.serialize_i32(27),
                    Self::RightEarTragion => serializer.serialize_i32(28),
                    Self::LeftEyePupil => serializer.serialize_i32(29),
                    Self::RightEyePupil => serializer.serialize_i32(30),
                    Self::ForeheadGlabella => serializer.serialize_i32(31),
                    Self::ChinGnathion => serializer.serialize_i32(32),
                    Self::ChinLeftGonion => serializer.serialize_i32(33),
                    Self::ChinRightGonion => serializer.serialize_i32(34),
                    Self::LeftCheekCenter => serializer.serialize_i32(35),
                    Self::RightCheekCenter => serializer.serialize_i32(36),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.vision.v1.FaceAnnotation.Landmark.Type",
                ))
            }
        }
    }
}

/// Detected entity location information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationInfo {
    /// lat/long location coordinates.
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_lng][crate::model::LocationInfo::lat_lng].
    pub fn set_lat_lng<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lat_lng][crate::model::LocationInfo::lat_lng].
    pub fn set_or_clear_lat_lng<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.lat_lng = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LocationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LocationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lat_lng,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latLng" => Ok(__FieldTag::__lat_lng),
                            "lat_lng" => Ok(__FieldTag::__lat_lng),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lat_lng => {
                            if !fields.insert(__FieldTag::__lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lat_lng",
                                ));
                            }
                            result.lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lat_lng.is_some() {
            state.serialize_entry("latLng", &self.lat_lng)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationInfo");
        debug_struct.field("lat_lng", &self.lat_lng);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `Property` consists of a user-supplied name/value pair.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Property {
    /// Name of the property.
    pub name: std::string::String,

    /// Value of the property.
    pub value: std::string::String,

    /// Value of numeric properties.
    pub uint64_value: u64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Property {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Property::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Property::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [uint64_value][crate::model::Property::uint64_value].
    pub fn set_uint64_value<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.uint64_value = v.into();
        self
    }
}

impl wkt::message::Message for Property {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Property"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Property {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            __uint64_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Property")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            "uint64Value" => Ok(__FieldTag::__uint64_value),
                            "uint64_value" => Ok(__FieldTag::__uint64_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Property;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Property")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uint64_value => {
                            if !fields.insert(__FieldTag::__uint64_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uint64_value",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.uint64_value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Property {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.uint64_value) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("uint64Value", &__With(&self.uint64_value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Property {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Property");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        debug_struct.field("uint64_value", &self.uint64_value);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set of detected entity features.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityAnnotation {
    /// Opaque entity ID. Some IDs may be available in
    /// [Google Knowledge Graph Search
    /// API](https://developers.google.com/knowledge-graph/).
    pub mid: std::string::String,

    /// The language code for the locale in which the entity textual
    /// `description` is expressed.
    pub locale: std::string::String,

    /// Entity textual description, expressed in its `locale` language.
    pub description: std::string::String,

    /// Overall score of the result. Range [0, 1].
    pub score: f32,

    /// **Deprecated. Use `score` instead.**
    /// The accuracy of the entity detection in an image.
    /// For example, for an image in which the "Eiffel Tower" entity is detected,
    /// this field represents the confidence that there is a tower in the query
    /// image. Range [0, 1].
    #[deprecated]
    pub confidence: f32,

    /// The relevancy of the ICA (Image Content Annotation) label to the
    /// image. For example, the relevancy of "tower" is likely higher to an image
    /// containing the detected "Eiffel Tower" than to an image containing a
    /// detected distant towering building, even though the confidence that
    /// there is a tower in each image may be the same. Range [0, 1].
    pub topicality: f32,

    /// Image region to which this entity belongs. Not produced
    /// for `LABEL_DETECTION` features.
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The location information for the detected entity. Multiple
    /// `LocationInfo` elements can be present because one location may
    /// indicate the location of the scene in the image, and another location
    /// may indicate the location of the place where the image was taken.
    /// Location information is usually present for landmarks.
    pub locations: std::vec::Vec<crate::model::LocationInfo>,

    /// Some entities may have optional user-supplied `Property` (name/value)
    /// fields, such a score or string that qualifies the entity.
    pub properties: std::vec::Vec<crate::model::Property>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mid][crate::model::EntityAnnotation::mid].
    pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mid = v.into();
        self
    }

    /// Sets the value of [locale][crate::model::EntityAnnotation::locale].
    pub fn set_locale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.locale = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntityAnnotation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [score][crate::model::EntityAnnotation::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::EntityAnnotation::confidence].
    #[deprecated]
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [topicality][crate::model::EntityAnnotation::topicality].
    pub fn set_topicality<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.topicality = v.into();
        self
    }

    /// Sets the value of [bounding_poly][crate::model::EntityAnnotation::bounding_poly].
    pub fn set_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_poly][crate::model::EntityAnnotation::bounding_poly].
    pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = v.map(|x| x.into());
        self
    }

    /// Sets the value of [locations][crate::model::EntityAnnotation::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocationInfo>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::EntityAnnotation::properties].
    pub fn set_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Property>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.EntityAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mid,
            __locale,
            __description,
            __score,
            __confidence,
            __topicality,
            __bounding_poly,
            __locations,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mid" => Ok(__FieldTag::__mid),
                            "locale" => Ok(__FieldTag::__locale),
                            "description" => Ok(__FieldTag::__description),
                            "score" => Ok(__FieldTag::__score),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "topicality" => Ok(__FieldTag::__topicality),
                            "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                            "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                            "locations" => Ok(__FieldTag::__locations),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mid => {
                            if !fields.insert(__FieldTag::__mid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mid",
                                ));
                            }
                            result.mid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locale => {
                            if !fields.insert(__FieldTag::__locale) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locale",
                                ));
                            }
                            result.locale = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__topicality => {
                            if !fields.insert(__FieldTag::__topicality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topicality",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.topicality = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bounding_poly => {
                            if !fields.insert(__FieldTag::__bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_poly",
                                ));
                            }
                            result.bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LocationInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Property>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EntityAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mid.is_empty() {
            state.serialize_entry("mid", &self.mid)?;
        }
        if !self.locale.is_empty() {
            state.serialize_entry("locale", &self.locale)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !wkt::internal::is_default(&self.topicality) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("topicality", &__With(&self.topicality))?;
        }
        if self.bounding_poly.is_some() {
            state.serialize_entry("boundingPoly", &self.bounding_poly)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EntityAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EntityAnnotation");
        debug_struct.field("mid", &self.mid);
        debug_struct.field("locale", &self.locale);
        debug_struct.field("description", &self.description);
        debug_struct.field("score", &self.score);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("topicality", &self.topicality);
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("properties", &self.properties);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set of detected objects with bounding boxes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalizedObjectAnnotation {
    /// Object ID that should align with EntityAnnotation mid.
    pub mid: std::string::String,

    /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
    /// information, see
    /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
    pub language_code: std::string::String,

    /// Object name, expressed in its `language_code` language.
    pub name: std::string::String,

    /// Score of the result. Range [0, 1].
    pub score: f32,

    /// Image region to which this object belongs. This must be populated.
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalizedObjectAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mid][crate::model::LocalizedObjectAnnotation::mid].
    pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mid = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::LocalizedObjectAnnotation::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [name][crate::model::LocalizedObjectAnnotation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [score][crate::model::LocalizedObjectAnnotation::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [bounding_poly][crate::model::LocalizedObjectAnnotation::bounding_poly].
    pub fn set_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_poly][crate::model::LocalizedObjectAnnotation::bounding_poly].
    pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LocalizedObjectAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LocalizedObjectAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocalizedObjectAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mid,
            __language_code,
            __name,
            __score,
            __bounding_poly,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocalizedObjectAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mid" => Ok(__FieldTag::__mid),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "name" => Ok(__FieldTag::__name),
                            "score" => Ok(__FieldTag::__score),
                            "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                            "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocalizedObjectAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocalizedObjectAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mid => {
                            if !fields.insert(__FieldTag::__mid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mid",
                                ));
                            }
                            result.mid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bounding_poly => {
                            if !fields.insert(__FieldTag::__bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_poly",
                                ));
                            }
                            result.bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocalizedObjectAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mid.is_empty() {
            state.serialize_entry("mid", &self.mid)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if self.bounding_poly.is_some() {
            state.serialize_entry("boundingPoly", &self.bounding_poly)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocalizedObjectAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocalizedObjectAnnotation");
        debug_struct.field("mid", &self.mid);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("name", &self.name);
        debug_struct.field("score", &self.score);
        debug_struct.field("bounding_poly", &self.bounding_poly);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set of features pertaining to the image, computed by computer vision
/// methods over safe-search verticals (for example, adult, spoof, medical,
/// violence).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SafeSearchAnnotation {
    /// Represents the adult content likelihood for the image. Adult content may
    /// contain elements such as nudity, pornographic images or cartoons, or
    /// sexual activities.
    pub adult: crate::model::Likelihood,

    /// Spoof likelihood. The likelihood that an modification
    /// was made to the image's canonical version to make it appear
    /// funny or offensive.
    pub spoof: crate::model::Likelihood,

    /// Likelihood that this is a medical image.
    pub medical: crate::model::Likelihood,

    /// Likelihood that this image contains violent content. Violent content may
    /// include death, serious harm, or injury to individuals or groups of
    /// individuals.
    pub violence: crate::model::Likelihood,

    /// Likelihood that the request image contains racy content. Racy content may
    /// include (but is not limited to) skimpy or sheer clothing, strategically
    /// covered nudity, lewd or provocative poses, or close-ups of sensitive
    /// body areas.
    pub racy: crate::model::Likelihood,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SafeSearchAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adult][crate::model::SafeSearchAnnotation::adult].
    pub fn set_adult<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.adult = v.into();
        self
    }

    /// Sets the value of [spoof][crate::model::SafeSearchAnnotation::spoof].
    pub fn set_spoof<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.spoof = v.into();
        self
    }

    /// Sets the value of [medical][crate::model::SafeSearchAnnotation::medical].
    pub fn set_medical<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.medical = v.into();
        self
    }

    /// Sets the value of [violence][crate::model::SafeSearchAnnotation::violence].
    pub fn set_violence<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.violence = v.into();
        self
    }

    /// Sets the value of [racy][crate::model::SafeSearchAnnotation::racy].
    pub fn set_racy<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.racy = v.into();
        self
    }
}

impl wkt::message::Message for SafeSearchAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.SafeSearchAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SafeSearchAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adult,
            __spoof,
            __medical,
            __violence,
            __racy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SafeSearchAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adult" => Ok(__FieldTag::__adult),
                            "spoof" => Ok(__FieldTag::__spoof),
                            "medical" => Ok(__FieldTag::__medical),
                            "violence" => Ok(__FieldTag::__violence),
                            "racy" => Ok(__FieldTag::__racy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SafeSearchAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SafeSearchAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adult => {
                            if !fields.insert(__FieldTag::__adult) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adult",
                                ));
                            }
                            result.adult = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spoof => {
                            if !fields.insert(__FieldTag::__spoof) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spoof",
                                ));
                            }
                            result.spoof = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__medical => {
                            if !fields.insert(__FieldTag::__medical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for medical",
                                ));
                            }
                            result.medical = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__violence => {
                            if !fields.insert(__FieldTag::__violence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for violence",
                                ));
                            }
                            result.violence = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__racy => {
                            if !fields.insert(__FieldTag::__racy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for racy",
                                ));
                            }
                            result.racy = map
                                .next_value::<std::option::Option<crate::model::Likelihood>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SafeSearchAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.adult) {
            state.serialize_entry("adult", &self.adult)?;
        }
        if !wkt::internal::is_default(&self.spoof) {
            state.serialize_entry("spoof", &self.spoof)?;
        }
        if !wkt::internal::is_default(&self.medical) {
            state.serialize_entry("medical", &self.medical)?;
        }
        if !wkt::internal::is_default(&self.violence) {
            state.serialize_entry("violence", &self.violence)?;
        }
        if !wkt::internal::is_default(&self.racy) {
            state.serialize_entry("racy", &self.racy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SafeSearchAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SafeSearchAnnotation");
        debug_struct.field("adult", &self.adult);
        debug_struct.field("spoof", &self.spoof);
        debug_struct.field("medical", &self.medical);
        debug_struct.field("violence", &self.violence);
        debug_struct.field("racy", &self.racy);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Rectangle determined by min and max `LatLng` pairs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LatLongRect {
    /// Min lat/long pair.
    pub min_lat_lng: std::option::Option<gtype::model::LatLng>,

    /// Max lat/long pair.
    pub max_lat_lng: std::option::Option<gtype::model::LatLng>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LatLongRect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_lat_lng][crate::model::LatLongRect::min_lat_lng].
    pub fn set_min_lat_lng<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.min_lat_lng = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_lat_lng][crate::model::LatLongRect::min_lat_lng].
    pub fn set_or_clear_min_lat_lng<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.min_lat_lng = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_lat_lng][crate::model::LatLongRect::max_lat_lng].
    pub fn set_max_lat_lng<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.max_lat_lng = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_lat_lng][crate::model::LatLongRect::max_lat_lng].
    pub fn set_or_clear_max_lat_lng<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.max_lat_lng = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LatLongRect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LatLongRect"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LatLongRect {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_lat_lng,
            __max_lat_lng,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LatLongRect")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minLatLng" => Ok(__FieldTag::__min_lat_lng),
                            "min_lat_lng" => Ok(__FieldTag::__min_lat_lng),
                            "maxLatLng" => Ok(__FieldTag::__max_lat_lng),
                            "max_lat_lng" => Ok(__FieldTag::__max_lat_lng),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LatLongRect;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LatLongRect")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_lat_lng => {
                            if !fields.insert(__FieldTag::__min_lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_lat_lng",
                                ));
                            }
                            result.min_lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__max_lat_lng => {
                            if !fields.insert(__FieldTag::__max_lat_lng) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_lat_lng",
                                ));
                            }
                            result.max_lat_lng =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LatLongRect {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.min_lat_lng.is_some() {
            state.serialize_entry("minLatLng", &self.min_lat_lng)?;
        }
        if self.max_lat_lng.is_some() {
            state.serialize_entry("maxLatLng", &self.max_lat_lng)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LatLongRect {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LatLongRect");
        debug_struct.field("min_lat_lng", &self.min_lat_lng);
        debug_struct.field("max_lat_lng", &self.max_lat_lng);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Color information consists of RGB channels, score, and the fraction of
/// the image that the color occupies in the image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ColorInfo {
    /// RGB components of the color.
    pub color: std::option::Option<gtype::model::Color>,

    /// Image-specific score for this color. Value in range [0, 1].
    pub score: f32,

    /// The fraction of pixels the color occupies in the image.
    /// Value in range [0, 1].
    pub pixel_fraction: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [color][crate::model::ColorInfo::color].
    pub fn set_color<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Color>,
    {
        self.color = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [color][crate::model::ColorInfo::color].
    pub fn set_or_clear_color<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Color>,
    {
        self.color = v.map(|x| x.into());
        self
    }

    /// Sets the value of [score][crate::model::ColorInfo::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [pixel_fraction][crate::model::ColorInfo::pixel_fraction].
    pub fn set_pixel_fraction<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.pixel_fraction = v.into();
        self
    }
}

impl wkt::message::Message for ColorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ColorInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColorInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __color,
            __score,
            __pixel_fraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColorInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "color" => Ok(__FieldTag::__color),
                            "score" => Ok(__FieldTag::__score),
                            "pixelFraction" => Ok(__FieldTag::__pixel_fraction),
                            "pixel_fraction" => Ok(__FieldTag::__pixel_fraction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColorInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColorInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__color => {
                            if !fields.insert(__FieldTag::__color) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color",
                                ));
                            }
                            result.color =
                                map.next_value::<std::option::Option<gtype::model::Color>>()?;
                        }
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pixel_fraction => {
                            if !fields.insert(__FieldTag::__pixel_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pixel_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pixel_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.color.is_some() {
            state.serialize_entry("color", &self.color)?;
        }
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.pixel_fraction) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pixelFraction", &__With(&self.pixel_fraction))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ColorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColorInfo");
        debug_struct.field("color", &self.color);
        debug_struct.field("score", &self.score);
        debug_struct.field("pixel_fraction", &self.pixel_fraction);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set of dominant colors and their corresponding scores.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DominantColorsAnnotation {
    /// RGB color values with their score and pixel fraction.
    pub colors: std::vec::Vec<crate::model::ColorInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DominantColorsAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [colors][crate::model::DominantColorsAnnotation::colors].
    pub fn set_colors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColorInfo>,
    {
        use std::iter::Iterator;
        self.colors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DominantColorsAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DominantColorsAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DominantColorsAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __colors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DominantColorsAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "colors" => Ok(__FieldTag::__colors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DominantColorsAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DominantColorsAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__colors => {
                            if !fields.insert(__FieldTag::__colors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colors",
                                ));
                            }
                            result.colors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ColorInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DominantColorsAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.colors.is_empty() {
            state.serialize_entry("colors", &self.colors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DominantColorsAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DominantColorsAnnotation");
        debug_struct.field("colors", &self.colors);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Stores image properties, such as dominant colors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageProperties {
    /// If present, dominant colors completed successfully.
    pub dominant_colors: std::option::Option<crate::model::DominantColorsAnnotation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dominant_colors][crate::model::ImageProperties::dominant_colors].
    pub fn set_dominant_colors<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DominantColorsAnnotation>,
    {
        self.dominant_colors = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dominant_colors][crate::model::ImageProperties::dominant_colors].
    pub fn set_or_clear_dominant_colors<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DominantColorsAnnotation>,
    {
        self.dominant_colors = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImageProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageProperties"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageProperties {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dominant_colors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageProperties")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dominantColors" => Ok(__FieldTag::__dominant_colors),
                            "dominant_colors" => Ok(__FieldTag::__dominant_colors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageProperties;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageProperties")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dominant_colors => {
                            if !fields.insert(__FieldTag::__dominant_colors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dominant_colors",
                                ));
                            }
                            result.dominant_colors = map.next_value::<std::option::Option<crate::model::DominantColorsAnnotation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageProperties {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dominant_colors.is_some() {
            state.serialize_entry("dominantColors", &self.dominant_colors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageProperties");
        debug_struct.field("dominant_colors", &self.dominant_colors);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Single crop hint that is used to generate a new crop when serving an image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CropHint {
    /// The bounding polygon for the crop region. The coordinates of the bounding
    /// box are in the original image's scale.
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// Confidence of this being a salient region.  Range [0, 1].
    pub confidence: f32,

    /// Fraction of importance of this salient region with respect to the original
    /// image.
    pub importance_fraction: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::CropHint::bounding_poly].
    pub fn set_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_poly][crate::model::CropHint::bounding_poly].
    pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidence][crate::model::CropHint::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [importance_fraction][crate::model::CropHint::importance_fraction].
    pub fn set_importance_fraction<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.importance_fraction = v.into();
        self
    }
}

impl wkt::message::Message for CropHint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CropHint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bounding_poly,
            __confidence,
            __importance_fraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CropHint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                            "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "importanceFraction" => Ok(__FieldTag::__importance_fraction),
                            "importance_fraction" => Ok(__FieldTag::__importance_fraction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CropHint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CropHint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bounding_poly => {
                            if !fields.insert(__FieldTag::__bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_poly",
                                ));
                            }
                            result.bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__importance_fraction => {
                            if !fields.insert(__FieldTag::__importance_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for importance_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.importance_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CropHint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bounding_poly.is_some() {
            state.serialize_entry("boundingPoly", &self.bounding_poly)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !wkt::internal::is_default(&self.importance_fraction) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("importanceFraction", &__With(&self.importance_fraction))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CropHint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CropHint");
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("confidence", &self.confidence);
        debug_struct.field("importance_fraction", &self.importance_fraction);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Set of crop hints that are used to generate new crops when serving images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CropHintsAnnotation {
    /// Crop hint results.
    pub crop_hints: std::vec::Vec<crate::model::CropHint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHintsAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crop_hints][crate::model::CropHintsAnnotation::crop_hints].
    pub fn set_crop_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CropHint>,
    {
        use std::iter::Iterator;
        self.crop_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CropHintsAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHintsAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CropHintsAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __crop_hints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CropHintsAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cropHints" => Ok(__FieldTag::__crop_hints),
                            "crop_hints" => Ok(__FieldTag::__crop_hints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CropHintsAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CropHintsAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__crop_hints => {
                            if !fields.insert(__FieldTag::__crop_hints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crop_hints",
                                ));
                            }
                            result.crop_hints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CropHint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CropHintsAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.crop_hints.is_empty() {
            state.serialize_entry("cropHints", &self.crop_hints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CropHintsAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CropHintsAnnotation");
        debug_struct.field("crop_hints", &self.crop_hints);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters for crop hints annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CropHintsParams {
    /// Aspect ratios in floats, representing the ratio of the width to the height
    /// of the image. For example, if the desired aspect ratio is 4/3, the
    /// corresponding float value should be 1.33333.  If not specified, the
    /// best possible crop is returned. The number of provided aspect ratios is
    /// limited to a maximum of 16; any aspect ratios provided after the 16th are
    /// ignored.
    pub aspect_ratios: std::vec::Vec<f32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHintsParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_ratios][crate::model::CropHintsParams::aspect_ratios].
    pub fn set_aspect_ratios<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.aspect_ratios = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CropHintsParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHintsParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CropHintsParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aspect_ratios,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CropHintsParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aspectRatios" => Ok(__FieldTag::__aspect_ratios),
                            "aspect_ratios" => Ok(__FieldTag::__aspect_ratios),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CropHintsParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CropHintsParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aspect_ratios => {
                            if !fields.insert(__FieldTag::__aspect_ratios) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aspect_ratios",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.aspect_ratios =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CropHintsParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.aspect_ratios.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("aspectRatios", &__With(&self.aspect_ratios))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CropHintsParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CropHintsParams");
        debug_struct.field("aspect_ratios", &self.aspect_ratios);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters for web detection request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebDetectionParams {
    /// This field has no effect on results.
    #[deprecated]
    pub include_geo_results: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebDetectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_geo_results][crate::model::WebDetectionParams::include_geo_results].
    #[deprecated]
    pub fn set_include_geo_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_geo_results = v.into();
        self
    }
}

impl wkt::message::Message for WebDetectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.WebDetectionParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebDetectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __include_geo_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebDetectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includeGeoResults" => Ok(__FieldTag::__include_geo_results),
                            "include_geo_results" => Ok(__FieldTag::__include_geo_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebDetectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebDetectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__include_geo_results => {
                            if !fields.insert(__FieldTag::__include_geo_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_geo_results",
                                ));
                            }
                            result.include_geo_results = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebDetectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.include_geo_results) {
            state.serialize_entry("includeGeoResults", &self.include_geo_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WebDetectionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebDetectionParams");
        debug_struct.field("include_geo_results", &self.include_geo_results);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters for text detections. This is used to control TEXT_DETECTION and
/// DOCUMENT_TEXT_DETECTION features.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TextDetectionParams {
    /// By default, Cloud Vision API only includes confidence score for
    /// DOCUMENT_TEXT_DETECTION result. Set the flag to true to include confidence
    /// score for TEXT_DETECTION as well.
    pub enable_text_detection_confidence_score: bool,

    /// A list of advanced OCR options to further fine-tune OCR behavior.
    /// Current valid values are:
    ///
    /// - `legacy_layout`: a heuristics layout detection algorithm, which serves as
    ///   an alternative to the current ML-based layout detection algorithm.
    ///   Customers can choose the best suitable layout algorithm based on their
    ///   situation.
    pub advanced_ocr_options: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextDetectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_text_detection_confidence_score][crate::model::TextDetectionParams::enable_text_detection_confidence_score].
    pub fn set_enable_text_detection_confidence_score<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_text_detection_confidence_score = v.into();
        self
    }

    /// Sets the value of [advanced_ocr_options][crate::model::TextDetectionParams::advanced_ocr_options].
    pub fn set_advanced_ocr_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.advanced_ocr_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TextDetectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.TextDetectionParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextDetectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_text_detection_confidence_score,
            __advanced_ocr_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextDetectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableTextDetectionConfidenceScore" => {
                                Ok(__FieldTag::__enable_text_detection_confidence_score)
                            }
                            "enable_text_detection_confidence_score" => {
                                Ok(__FieldTag::__enable_text_detection_confidence_score)
                            }
                            "advancedOcrOptions" => Ok(__FieldTag::__advanced_ocr_options),
                            "advanced_ocr_options" => Ok(__FieldTag::__advanced_ocr_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextDetectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextDetectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_text_detection_confidence_score => {
                            if !fields.insert(__FieldTag::__enable_text_detection_confidence_score)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_text_detection_confidence_score",
                                ));
                            }
                            result.enable_text_detection_confidence_score = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advanced_ocr_options => {
                            if !fields.insert(__FieldTag::__advanced_ocr_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_ocr_options",
                                ));
                            }
                            result.advanced_ocr_options = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TextDetectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_text_detection_confidence_score) {
            state.serialize_entry(
                "enableTextDetectionConfidenceScore",
                &self.enable_text_detection_confidence_score,
            )?;
        }
        if !self.advanced_ocr_options.is_empty() {
            state.serialize_entry("advancedOcrOptions", &self.advanced_ocr_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TextDetectionParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextDetectionParams");
        debug_struct.field(
            "enable_text_detection_confidence_score",
            &self.enable_text_detection_confidence_score,
        );
        debug_struct.field("advanced_ocr_options", &self.advanced_ocr_options);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Image context and/or feature-specific parameters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageContext {
    /// Not used.
    pub lat_long_rect: std::option::Option<crate::model::LatLongRect>,

    /// List of languages to use for TEXT_DETECTION. In most cases, an empty value
    /// yields the best results since it enables automatic language detection. For
    /// languages based on the Latin alphabet, setting `language_hints` is not
    /// needed. In rare cases, when the language of the text in the image is known,
    /// setting a hint will help get better results (although it will be a
    /// significant hindrance if the hint is wrong). Text detection returns an
    /// error if one or more of the specified languages is not one of the
    /// [supported languages](https://cloud.google.com/vision/docs/languages).
    pub language_hints: std::vec::Vec<std::string::String>,

    /// Parameters for crop hints annotation request.
    pub crop_hints_params: std::option::Option<crate::model::CropHintsParams>,

    /// Parameters for product search.
    pub product_search_params: std::option::Option<crate::model::ProductSearchParams>,

    /// Parameters for web detection.
    pub web_detection_params: std::option::Option<crate::model::WebDetectionParams>,

    /// Parameters for text detection and document text detection.
    pub text_detection_params: std::option::Option<crate::model::TextDetectionParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_long_rect][crate::model::ImageContext::lat_long_rect].
    pub fn set_lat_long_rect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LatLongRect>,
    {
        self.lat_long_rect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lat_long_rect][crate::model::ImageContext::lat_long_rect].
    pub fn set_or_clear_lat_long_rect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LatLongRect>,
    {
        self.lat_long_rect = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_hints][crate::model::ImageContext::language_hints].
    pub fn set_language_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [crop_hints_params][crate::model::ImageContext::crop_hints_params].
    pub fn set_crop_hints_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CropHintsParams>,
    {
        self.crop_hints_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crop_hints_params][crate::model::ImageContext::crop_hints_params].
    pub fn set_or_clear_crop_hints_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CropHintsParams>,
    {
        self.crop_hints_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_search_params][crate::model::ImageContext::product_search_params].
    pub fn set_product_search_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductSearchParams>,
    {
        self.product_search_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product_search_params][crate::model::ImageContext::product_search_params].
    pub fn set_or_clear_product_search_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductSearchParams>,
    {
        self.product_search_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_detection_params][crate::model::ImageContext::web_detection_params].
    pub fn set_web_detection_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebDetectionParams>,
    {
        self.web_detection_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [web_detection_params][crate::model::ImageContext::web_detection_params].
    pub fn set_or_clear_web_detection_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WebDetectionParams>,
    {
        self.web_detection_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [text_detection_params][crate::model::ImageContext::text_detection_params].
    pub fn set_text_detection_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextDetectionParams>,
    {
        self.text_detection_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text_detection_params][crate::model::ImageContext::text_detection_params].
    pub fn set_or_clear_text_detection_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextDetectionParams>,
    {
        self.text_detection_params = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImageContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __lat_long_rect,
            __language_hints,
            __crop_hints_params,
            __product_search_params,
            __web_detection_params,
            __text_detection_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "latLongRect" => Ok(__FieldTag::__lat_long_rect),
                            "lat_long_rect" => Ok(__FieldTag::__lat_long_rect),
                            "languageHints" => Ok(__FieldTag::__language_hints),
                            "language_hints" => Ok(__FieldTag::__language_hints),
                            "cropHintsParams" => Ok(__FieldTag::__crop_hints_params),
                            "crop_hints_params" => Ok(__FieldTag::__crop_hints_params),
                            "productSearchParams" => Ok(__FieldTag::__product_search_params),
                            "product_search_params" => Ok(__FieldTag::__product_search_params),
                            "webDetectionParams" => Ok(__FieldTag::__web_detection_params),
                            "web_detection_params" => Ok(__FieldTag::__web_detection_params),
                            "textDetectionParams" => Ok(__FieldTag::__text_detection_params),
                            "text_detection_params" => Ok(__FieldTag::__text_detection_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__lat_long_rect => {
                            if !fields.insert(__FieldTag::__lat_long_rect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lat_long_rect",
                                ));
                            }
                            result.lat_long_rect =
                                map.next_value::<std::option::Option<crate::model::LatLongRect>>()?;
                        }
                        __FieldTag::__language_hints => {
                            if !fields.insert(__FieldTag::__language_hints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_hints",
                                ));
                            }
                            result.language_hints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__crop_hints_params => {
                            if !fields.insert(__FieldTag::__crop_hints_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crop_hints_params",
                                ));
                            }
                            result.crop_hints_params = map
                                .next_value::<std::option::Option<crate::model::CropHintsParams>>(
                                )?;
                        }
                        __FieldTag::__product_search_params => {
                            if !fields.insert(__FieldTag::__product_search_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_search_params",
                                ));
                            }
                            result.product_search_params = map.next_value::<std::option::Option<crate::model::ProductSearchParams>>()?
                                ;
                        }
                        __FieldTag::__web_detection_params => {
                            if !fields.insert(__FieldTag::__web_detection_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_detection_params",
                                ));
                            }
                            result.web_detection_params = map.next_value::<std::option::Option<crate::model::WebDetectionParams>>()?
                                ;
                        }
                        __FieldTag::__text_detection_params => {
                            if !fields.insert(__FieldTag::__text_detection_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_detection_params",
                                ));
                            }
                            result.text_detection_params = map.next_value::<std::option::Option<crate::model::TextDetectionParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.lat_long_rect.is_some() {
            state.serialize_entry("latLongRect", &self.lat_long_rect)?;
        }
        if !self.language_hints.is_empty() {
            state.serialize_entry("languageHints", &self.language_hints)?;
        }
        if self.crop_hints_params.is_some() {
            state.serialize_entry("cropHintsParams", &self.crop_hints_params)?;
        }
        if self.product_search_params.is_some() {
            state.serialize_entry("productSearchParams", &self.product_search_params)?;
        }
        if self.web_detection_params.is_some() {
            state.serialize_entry("webDetectionParams", &self.web_detection_params)?;
        }
        if self.text_detection_params.is_some() {
            state.serialize_entry("textDetectionParams", &self.text_detection_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageContext");
        debug_struct.field("lat_long_rect", &self.lat_long_rect);
        debug_struct.field("language_hints", &self.language_hints);
        debug_struct.field("crop_hints_params", &self.crop_hints_params);
        debug_struct.field("product_search_params", &self.product_search_params);
        debug_struct.field("web_detection_params", &self.web_detection_params);
        debug_struct.field("text_detection_params", &self.text_detection_params);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for performing Google Cloud Vision API tasks over a user-provided
/// image, with user-requested features, and with context information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateImageRequest {
    /// The image to be processed.
    pub image: std::option::Option<crate::model::Image>,

    /// Requested features.
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image.
    pub image_context: std::option::Option<crate::model::ImageContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::AnnotateImageRequest::image].
    pub fn set_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Image>,
    {
        self.image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image][crate::model::AnnotateImageRequest::image].
    pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Image>,
    {
        self.image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [features][crate::model::AnnotateImageRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_context][crate::model::AnnotateImageRequest::image_context].
    pub fn set_image_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_context][crate::model::AnnotateImageRequest::image_context].
    pub fn set_or_clear_image_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotateImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateImageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateImageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image,
            __features,
            __image_context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateImageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "image" => Ok(__FieldTag::__image),
                            "features" => Ok(__FieldTag::__features),
                            "imageContext" => Ok(__FieldTag::__image_context),
                            "image_context" => Ok(__FieldTag::__image_context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateImageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateImageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            result.image =
                                map.next_value::<std::option::Option<crate::model::Image>>()?;
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Feature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__image_context => {
                            if !fields.insert(__FieldTag::__image_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_context",
                                ));
                            }
                            result.image_context = map
                                .next_value::<std::option::Option<crate::model::ImageContext>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateImageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.image.is_some() {
            state.serialize_entry("image", &self.image)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if self.image_context.is_some() {
            state.serialize_entry("imageContext", &self.image_context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateImageRequest");
        debug_struct.field("image", &self.image);
        debug_struct.field("features", &self.features);
        debug_struct.field("image_context", &self.image_context);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// If an image was produced from a file (e.g. a PDF), this message gives
/// information about the source of that image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageAnnotationContext {
    /// The URI of the file used to produce the image.
    pub uri: std::string::String,

    /// If the file was a PDF or TIFF, this field gives the page number within
    /// the file used to produce the image.
    pub page_number: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageAnnotationContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ImageAnnotationContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [page_number][crate::model::ImageAnnotationContext::page_number].
    pub fn set_page_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_number = v.into();
        self
    }
}

impl wkt::message::Message for ImageAnnotationContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageAnnotationContext"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageAnnotationContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __page_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageAnnotationContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "pageNumber" => Ok(__FieldTag::__page_number),
                            "page_number" => Ok(__FieldTag::__page_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageAnnotationContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageAnnotationContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_number => {
                            if !fields.insert(__FieldTag::__page_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_number = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageAnnotationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.page_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageNumber", &__With(&self.page_number))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageAnnotationContext {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageAnnotationContext");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("page_number", &self.page_number);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to an image annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateImageResponse {
    /// If present, face detection has completed successfully.
    pub face_annotations: std::vec::Vec<crate::model::FaceAnnotation>,

    /// If present, landmark detection has completed successfully.
    pub landmark_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, logo detection has completed successfully.
    pub logo_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, label detection has completed successfully.
    pub label_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, localized object detection has completed successfully.
    /// This will be sorted descending by confidence score.
    pub localized_object_annotations: std::vec::Vec<crate::model::LocalizedObjectAnnotation>,

    /// If present, text (OCR) detection has completed successfully.
    pub text_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, text (OCR) detection or document (OCR) text detection has
    /// completed successfully.
    /// This annotation provides the structural hierarchy for the OCR detected
    /// text.
    pub full_text_annotation: std::option::Option<crate::model::TextAnnotation>,

    /// If present, safe-search annotation has completed successfully.
    pub safe_search_annotation: std::option::Option<crate::model::SafeSearchAnnotation>,

    /// If present, image properties were extracted successfully.
    pub image_properties_annotation: std::option::Option<crate::model::ImageProperties>,

    /// If present, crop hints have completed successfully.
    pub crop_hints_annotation: std::option::Option<crate::model::CropHintsAnnotation>,

    /// If present, web detection has completed successfully.
    pub web_detection: std::option::Option<crate::model::WebDetection>,

    /// If present, product search has completed successfully.
    pub product_search_results: std::option::Option<crate::model::ProductSearchResults>,

    /// If set, represents the error message for the operation.
    /// Note that filled-in image annotations are guaranteed to be
    /// correct, even when `error` is set.
    pub error: std::option::Option<rpc::model::Status>,

    /// If present, contextual information is needed to understand where this image
    /// comes from.
    pub context: std::option::Option<crate::model::ImageAnnotationContext>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateImageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [face_annotations][crate::model::AnnotateImageResponse::face_annotations].
    pub fn set_face_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FaceAnnotation>,
    {
        use std::iter::Iterator;
        self.face_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [landmark_annotations][crate::model::AnnotateImageResponse::landmark_annotations].
    pub fn set_landmark_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.landmark_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logo_annotations][crate::model::AnnotateImageResponse::logo_annotations].
    pub fn set_logo_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.logo_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [label_annotations][crate::model::AnnotateImageResponse::label_annotations].
    pub fn set_label_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.label_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [localized_object_annotations][crate::model::AnnotateImageResponse::localized_object_annotations].
    pub fn set_localized_object_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocalizedObjectAnnotation>,
    {
        use std::iter::Iterator;
        self.localized_object_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [text_annotations][crate::model::AnnotateImageResponse::text_annotations].
    pub fn set_text_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.text_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [full_text_annotation][crate::model::AnnotateImageResponse::full_text_annotation].
    pub fn set_full_text_annotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextAnnotation>,
    {
        self.full_text_annotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [full_text_annotation][crate::model::AnnotateImageResponse::full_text_annotation].
    pub fn set_or_clear_full_text_annotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextAnnotation>,
    {
        self.full_text_annotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [safe_search_annotation][crate::model::AnnotateImageResponse::safe_search_annotation].
    pub fn set_safe_search_annotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SafeSearchAnnotation>,
    {
        self.safe_search_annotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [safe_search_annotation][crate::model::AnnotateImageResponse::safe_search_annotation].
    pub fn set_or_clear_safe_search_annotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SafeSearchAnnotation>,
    {
        self.safe_search_annotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_properties_annotation][crate::model::AnnotateImageResponse::image_properties_annotation].
    pub fn set_image_properties_annotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageProperties>,
    {
        self.image_properties_annotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_properties_annotation][crate::model::AnnotateImageResponse::image_properties_annotation].
    pub fn set_or_clear_image_properties_annotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageProperties>,
    {
        self.image_properties_annotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crop_hints_annotation][crate::model::AnnotateImageResponse::crop_hints_annotation].
    pub fn set_crop_hints_annotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CropHintsAnnotation>,
    {
        self.crop_hints_annotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crop_hints_annotation][crate::model::AnnotateImageResponse::crop_hints_annotation].
    pub fn set_or_clear_crop_hints_annotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CropHintsAnnotation>,
    {
        self.crop_hints_annotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [web_detection][crate::model::AnnotateImageResponse::web_detection].
    pub fn set_web_detection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WebDetection>,
    {
        self.web_detection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [web_detection][crate::model::AnnotateImageResponse::web_detection].
    pub fn set_or_clear_web_detection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WebDetection>,
    {
        self.web_detection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_search_results][crate::model::AnnotateImageResponse::product_search_results].
    pub fn set_product_search_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductSearchResults>,
    {
        self.product_search_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product_search_results][crate::model::AnnotateImageResponse::product_search_results].
    pub fn set_or_clear_product_search_results<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductSearchResults>,
    {
        self.product_search_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::AnnotateImageResponse::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AnnotateImageResponse::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [context][crate::model::AnnotateImageResponse::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageAnnotationContext>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::AnnotateImageResponse::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageAnnotationContext>,
    {
        self.context = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotateImageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateImageResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateImageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __face_annotations,
            __landmark_annotations,
            __logo_annotations,
            __label_annotations,
            __localized_object_annotations,
            __text_annotations,
            __full_text_annotation,
            __safe_search_annotation,
            __image_properties_annotation,
            __crop_hints_annotation,
            __web_detection,
            __product_search_results,
            __error,
            __context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateImageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "faceAnnotations" => Ok(__FieldTag::__face_annotations),
                            "face_annotations" => Ok(__FieldTag::__face_annotations),
                            "landmarkAnnotations" => Ok(__FieldTag::__landmark_annotations),
                            "landmark_annotations" => Ok(__FieldTag::__landmark_annotations),
                            "logoAnnotations" => Ok(__FieldTag::__logo_annotations),
                            "logo_annotations" => Ok(__FieldTag::__logo_annotations),
                            "labelAnnotations" => Ok(__FieldTag::__label_annotations),
                            "label_annotations" => Ok(__FieldTag::__label_annotations),
                            "localizedObjectAnnotations" => {
                                Ok(__FieldTag::__localized_object_annotations)
                            }
                            "localized_object_annotations" => {
                                Ok(__FieldTag::__localized_object_annotations)
                            }
                            "textAnnotations" => Ok(__FieldTag::__text_annotations),
                            "text_annotations" => Ok(__FieldTag::__text_annotations),
                            "fullTextAnnotation" => Ok(__FieldTag::__full_text_annotation),
                            "full_text_annotation" => Ok(__FieldTag::__full_text_annotation),
                            "safeSearchAnnotation" => Ok(__FieldTag::__safe_search_annotation),
                            "safe_search_annotation" => Ok(__FieldTag::__safe_search_annotation),
                            "imagePropertiesAnnotation" => {
                                Ok(__FieldTag::__image_properties_annotation)
                            }
                            "image_properties_annotation" => {
                                Ok(__FieldTag::__image_properties_annotation)
                            }
                            "cropHintsAnnotation" => Ok(__FieldTag::__crop_hints_annotation),
                            "crop_hints_annotation" => Ok(__FieldTag::__crop_hints_annotation),
                            "webDetection" => Ok(__FieldTag::__web_detection),
                            "web_detection" => Ok(__FieldTag::__web_detection),
                            "productSearchResults" => Ok(__FieldTag::__product_search_results),
                            "product_search_results" => Ok(__FieldTag::__product_search_results),
                            "error" => Ok(__FieldTag::__error),
                            "context" => Ok(__FieldTag::__context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateImageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateImageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__face_annotations => {
                            if !fields.insert(__FieldTag::__face_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for face_annotations",
                                ));
                            }
                            result.face_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FaceAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__landmark_annotations => {
                            if !fields.insert(__FieldTag::__landmark_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for landmark_annotations",
                                ));
                            }
                            result.landmark_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EntityAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logo_annotations => {
                            if !fields.insert(__FieldTag::__logo_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logo_annotations",
                                ));
                            }
                            result.logo_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EntityAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_annotations => {
                            if !fields.insert(__FieldTag::__label_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_annotations",
                                ));
                            }
                            result.label_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EntityAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__localized_object_annotations => {
                            if !fields.insert(__FieldTag::__localized_object_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for localized_object_annotations",
                                ));
                            }
                            result.localized_object_annotations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LocalizedObjectAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_annotations => {
                            if !fields.insert(__FieldTag::__text_annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_annotations",
                                ));
                            }
                            result.text_annotations =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::EntityAnnotation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_text_annotation => {
                            if !fields.insert(__FieldTag::__full_text_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_text_annotation",
                                ));
                            }
                            result.full_text_annotation = map
                                .next_value::<std::option::Option<crate::model::TextAnnotation>>(
                                )?;
                        }
                        __FieldTag::__safe_search_annotation => {
                            if !fields.insert(__FieldTag::__safe_search_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for safe_search_annotation",
                                ));
                            }
                            result.safe_search_annotation = map.next_value::<std::option::Option<crate::model::SafeSearchAnnotation>>()?
                                ;
                        }
                        __FieldTag::__image_properties_annotation => {
                            if !fields.insert(__FieldTag::__image_properties_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_properties_annotation",
                                ));
                            }
                            result.image_properties_annotation = map
                                .next_value::<std::option::Option<crate::model::ImageProperties>>(
                                )?;
                        }
                        __FieldTag::__crop_hints_annotation => {
                            if !fields.insert(__FieldTag::__crop_hints_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crop_hints_annotation",
                                ));
                            }
                            result.crop_hints_annotation = map.next_value::<std::option::Option<crate::model::CropHintsAnnotation>>()?
                                ;
                        }
                        __FieldTag::__web_detection => {
                            if !fields.insert(__FieldTag::__web_detection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_detection",
                                ));
                            }
                            result.web_detection = map
                                .next_value::<std::option::Option<crate::model::WebDetection>>()?;
                        }
                        __FieldTag::__product_search_results => {
                            if !fields.insert(__FieldTag::__product_search_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_search_results",
                                ));
                            }
                            result.product_search_results = map.next_value::<std::option::Option<crate::model::ProductSearchResults>>()?
                                ;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context = map.next_value::<std::option::Option<crate::model::ImageAnnotationContext>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateImageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.face_annotations.is_empty() {
            state.serialize_entry("faceAnnotations", &self.face_annotations)?;
        }
        if !self.landmark_annotations.is_empty() {
            state.serialize_entry("landmarkAnnotations", &self.landmark_annotations)?;
        }
        if !self.logo_annotations.is_empty() {
            state.serialize_entry("logoAnnotations", &self.logo_annotations)?;
        }
        if !self.label_annotations.is_empty() {
            state.serialize_entry("labelAnnotations", &self.label_annotations)?;
        }
        if !self.localized_object_annotations.is_empty() {
            state.serialize_entry(
                "localizedObjectAnnotations",
                &self.localized_object_annotations,
            )?;
        }
        if !self.text_annotations.is_empty() {
            state.serialize_entry("textAnnotations", &self.text_annotations)?;
        }
        if self.full_text_annotation.is_some() {
            state.serialize_entry("fullTextAnnotation", &self.full_text_annotation)?;
        }
        if self.safe_search_annotation.is_some() {
            state.serialize_entry("safeSearchAnnotation", &self.safe_search_annotation)?;
        }
        if self.image_properties_annotation.is_some() {
            state.serialize_entry(
                "imagePropertiesAnnotation",
                &self.image_properties_annotation,
            )?;
        }
        if self.crop_hints_annotation.is_some() {
            state.serialize_entry("cropHintsAnnotation", &self.crop_hints_annotation)?;
        }
        if self.web_detection.is_some() {
            state.serialize_entry("webDetection", &self.web_detection)?;
        }
        if self.product_search_results.is_some() {
            state.serialize_entry("productSearchResults", &self.product_search_results)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateImageResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateImageResponse");
        debug_struct.field("face_annotations", &self.face_annotations);
        debug_struct.field("landmark_annotations", &self.landmark_annotations);
        debug_struct.field("logo_annotations", &self.logo_annotations);
        debug_struct.field("label_annotations", &self.label_annotations);
        debug_struct.field(
            "localized_object_annotations",
            &self.localized_object_annotations,
        );
        debug_struct.field("text_annotations", &self.text_annotations);
        debug_struct.field("full_text_annotation", &self.full_text_annotation);
        debug_struct.field("safe_search_annotation", &self.safe_search_annotation);
        debug_struct.field(
            "image_properties_annotation",
            &self.image_properties_annotation,
        );
        debug_struct.field("crop_hints_annotation", &self.crop_hints_annotation);
        debug_struct.field("web_detection", &self.web_detection);
        debug_struct.field("product_search_results", &self.product_search_results);
        debug_struct.field("error", &self.error);
        debug_struct.field("context", &self.context);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Multiple image annotation requests are batched into a single service call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchAnnotateImagesRequest {
    /// Required. Individual image annotation requests for this batch.
    pub requests: std::vec::Vec<crate::model::AnnotateImageRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requests][crate::model::BatchAnnotateImagesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent][crate::model::BatchAnnotateImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BatchAnnotateImagesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateImagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchAnnotateImagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requests,
            __parent,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchAnnotateImagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requests" => Ok(__FieldTag::__requests),
                            "parent" => Ok(__FieldTag::__parent),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchAnnotateImagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchAnnotateImagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateImageRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchAnnotateImagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchAnnotateImagesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchAnnotateImagesRequest");
        debug_struct.field("requests", &self.requests);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("labels", &self.labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to a batch image annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchAnnotateImagesResponse {
    /// Individual responses to image annotation requests within the batch.
    pub responses: std::vec::Vec<crate::model::AnnotateImageResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchAnnotateImagesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateImagesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchAnnotateImagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchAnnotateImagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchAnnotateImagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchAnnotateImagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateImageResponse>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchAnnotateImagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchAnnotateImagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchAnnotateImagesResponse");
        debug_struct.field("responses", &self.responses);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A request to annotate one single file, e.g. a PDF, TIFF or GIF file.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateFileRequest {
    /// Required. Information about the input file.
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Required. Requested features.
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image(s) in the file.
    pub image_context: std::option::Option<crate::model::ImageContext>,

    /// Pages of the file to perform image annotation.
    ///
    /// Pages starts from 1, we assume the first page of the file is page 1.
    /// At most 5 pages are supported per request. Pages can be negative.
    ///
    /// Page 1 means the first page.
    /// Page 2 means the second page.
    /// Page -1 means the last page.
    /// Page -2 means the second to the last page.
    ///
    /// If the file is GIF instead of PDF or TIFF, page refers to GIF frames.
    ///
    /// If this field is empty, by default the service performs image annotation
    /// for the first 5 pages of the file.
    pub pages: std::vec::Vec<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AnnotateFileRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::AnnotateFileRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [features][crate::model::AnnotateFileRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_context][crate::model::AnnotateFileRequest::image_context].
    pub fn set_image_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_context][crate::model::AnnotateFileRequest::image_context].
    pub fn set_or_clear_image_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pages][crate::model::AnnotateFileRequest::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_config,
            __features,
            __image_context,
            __pages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "features" => Ok(__FieldTag::__features),
                            "imageContext" => Ok(__FieldTag::__image_context),
                            "image_context" => Ok(__FieldTag::__image_context),
                            "pages" => Ok(__FieldTag::__pages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Feature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__image_context => {
                            if !fields.insert(__FieldTag::__image_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_context",
                                ));
                            }
                            result.image_context = map
                                .next_value::<std::option::Option<crate::model::ImageContext>>()?;
                        }
                        __FieldTag::__pages => {
                            if !fields.insert(__FieldTag::__pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pages",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if self.image_context.is_some() {
            state.serialize_entry("imageContext", &self.image_context)?;
        }
        if !self.pages.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pages", &__With(&self.pages))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateFileRequest");
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("features", &self.features);
        debug_struct.field("image_context", &self.image_context);
        debug_struct.field("pages", &self.pages);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to a single file annotation request. A file may contain one or more
/// images, which individually have their own responses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotateFileResponse {
    /// Information about the file for which this response is generated.
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Individual responses to images found within the file. This field will be
    /// empty if the `error` field is set.
    pub responses: std::vec::Vec<crate::model::AnnotateImageResponse>,

    /// This field gives the total number of pages in the file.
    pub total_pages: i32,

    /// If set, represents the error message for the failed request. The
    /// `responses` field will not be set in this case.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AnnotateFileResponse::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::AnnotateFileResponse::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [responses][crate::model::AnnotateFileResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_pages][crate::model::AnnotateFileResponse::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AnnotateFileResponse::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AnnotateFileResponse::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AnnotateFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotateFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_config,
            __responses,
            __total_pages,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotateFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "responses" => Ok(__FieldTag::__responses),
                            "totalPages" => Ok(__FieldTag::__total_pages),
                            "total_pages" => Ok(__FieldTag::__total_pages),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotateFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotateFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateImageResponse>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_pages => {
                            if !fields.insert(__FieldTag::__total_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_pages",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnnotateFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !wkt::internal::is_default(&self.total_pages) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalPages", &__With(&self.total_pages))?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnnotateFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnnotateFileResponse");
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("responses", &self.responses);
        debug_struct.field("total_pages", &self.total_pages);
        debug_struct.field("error", &self.error);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A list of requests to annotate files using the BatchAnnotateFiles API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchAnnotateFilesRequest {
    /// Required. The list of file annotation requests. Right now we support only
    /// one AnnotateFileRequest in BatchAnnotateFilesRequest.
    pub requests: std::vec::Vec<crate::model::AnnotateFileRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requests][crate::model::BatchAnnotateFilesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateFileRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent][crate::model::BatchAnnotateFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BatchAnnotateFilesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateFilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchAnnotateFilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requests,
            __parent,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchAnnotateFilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requests" => Ok(__FieldTag::__requests),
                            "parent" => Ok(__FieldTag::__parent),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchAnnotateFilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchAnnotateFilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateFileRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchAnnotateFilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchAnnotateFilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchAnnotateFilesRequest");
        debug_struct.field("requests", &self.requests);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("labels", &self.labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A list of file annotation responses.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchAnnotateFilesResponse {
    /// The list of file annotation responses, each response corresponding to each
    /// AnnotateFileRequest in BatchAnnotateFilesRequest.
    pub responses: std::vec::Vec<crate::model::AnnotateFileResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchAnnotateFilesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateFileResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateFilesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchAnnotateFilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchAnnotateFilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchAnnotateFilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchAnnotateFilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateFileResponse>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchAnnotateFilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchAnnotateFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchAnnotateFilesResponse");
        debug_struct.field("responses", &self.responses);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An offline file annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncAnnotateFileRequest {
    /// Required. Information about the input file.
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Required. Requested features.
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image(s) in the file.
    pub image_context: std::option::Option<crate::model::ImageContext>,

    /// Required. The desired output location and metadata (e.g. format).
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncAnnotateFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AsyncAnnotateFileRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::AsyncAnnotateFileRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [features][crate::model::AsyncAnnotateFileRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_context][crate::model::AsyncAnnotateFileRequest::image_context].
    pub fn set_image_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_context][crate::model::AsyncAnnotateFileRequest::image_context].
    pub fn set_or_clear_image_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageContext>,
    {
        self.image_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_config][crate::model::AsyncAnnotateFileRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::AsyncAnnotateFileRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AsyncAnnotateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncAnnotateFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncAnnotateFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_config,
            __features,
            __image_context,
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncAnnotateFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "features" => Ok(__FieldTag::__features),
                            "imageContext" => Ok(__FieldTag::__image_context),
                            "image_context" => Ok(__FieldTag::__image_context),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncAnnotateFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncAnnotateFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Feature>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__image_context => {
                            if !fields.insert(__FieldTag::__image_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_context",
                                ));
                            }
                            result.image_context = map
                                .next_value::<std::option::Option<crate::model::ImageContext>>()?;
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncAnnotateFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if self.image_context.is_some() {
            state.serialize_entry("imageContext", &self.image_context)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncAnnotateFileRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncAnnotateFileRequest");
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("features", &self.features);
        debug_struct.field("image_context", &self.image_context);
        debug_struct.field("output_config", &self.output_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The response for a single offline file annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncAnnotateFileResponse {
    /// The output location and metadata from AsyncAnnotateFileRequest.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncAnnotateFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_config][crate::model::AsyncAnnotateFileResponse::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::AsyncAnnotateFileResponse::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AsyncAnnotateFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncAnnotateFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncAnnotateFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncAnnotateFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncAnnotateFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncAnnotateFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncAnnotateFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncAnnotateFileResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncAnnotateFileResponse");
        debug_struct.field("output_config", &self.output_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for async image annotation for a list of images.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncBatchAnnotateImagesRequest {
    /// Required. Individual image annotation requests for this batch.
    pub requests: std::vec::Vec<crate::model::AnnotateImageRequest>,

    /// Required. The desired output location and metadata (e.g. format).
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requests][crate::model::AsyncBatchAnnotateImagesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_config][crate::model::AsyncBatchAnnotateImagesRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::AsyncBatchAnnotateImagesRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent][crate::model::AsyncBatchAnnotateImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AsyncBatchAnnotateImagesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateImagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncBatchAnnotateImagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requests,
            __output_config,
            __parent,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncBatchAnnotateImagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requests" => Ok(__FieldTag::__requests),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "parent" => Ok(__FieldTag::__parent),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncBatchAnnotateImagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncBatchAnnotateImagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotateImageRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncBatchAnnotateImagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncBatchAnnotateImagesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncBatchAnnotateImagesRequest");
        debug_struct.field("requests", &self.requests);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("labels", &self.labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to an async batch image annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncBatchAnnotateImagesResponse {
    /// The output location and metadata from AsyncBatchAnnotateImagesRequest.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_config][crate::model::AsyncBatchAnnotateImagesResponse::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::AsyncBatchAnnotateImagesResponse::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateImagesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncBatchAnnotateImagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncBatchAnnotateImagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncBatchAnnotateImagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncBatchAnnotateImagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncBatchAnnotateImagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncBatchAnnotateImagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncBatchAnnotateImagesResponse");
        debug_struct.field("output_config", &self.output_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Multiple async file annotation requests are batched into a single service
/// call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncBatchAnnotateFilesRequest {
    /// Required. Individual async file annotation requests for this batch.
    pub requests: std::vec::Vec<crate::model::AsyncAnnotateFileRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [requests][crate::model::AsyncBatchAnnotateFilesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AsyncAnnotateFileRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parent][crate::model::AsyncBatchAnnotateFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AsyncBatchAnnotateFilesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateFilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncBatchAnnotateFilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requests,
            __parent,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncBatchAnnotateFilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requests" => Ok(__FieldTag::__requests),
                            "parent" => Ok(__FieldTag::__parent),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncBatchAnnotateFilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncBatchAnnotateFilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AsyncAnnotateFileRequest>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncBatchAnnotateFilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncBatchAnnotateFilesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncBatchAnnotateFilesRequest");
        debug_struct.field("requests", &self.requests);
        debug_struct.field("parent", &self.parent);
        debug_struct.field("labels", &self.labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to an async batch file annotation request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AsyncBatchAnnotateFilesResponse {
    /// The list of file annotation responses, one for each request in
    /// AsyncBatchAnnotateFilesRequest.
    pub responses: std::vec::Vec<crate::model::AsyncAnnotateFileResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::AsyncBatchAnnotateFilesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AsyncAnnotateFileResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateFilesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AsyncBatchAnnotateFilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AsyncBatchAnnotateFilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AsyncBatchAnnotateFilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AsyncBatchAnnotateFilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AsyncAnnotateFileResponse>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AsyncBatchAnnotateFilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AsyncBatchAnnotateFilesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AsyncBatchAnnotateFilesResponse");
        debug_struct.field("responses", &self.responses);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The desired input location and metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InputConfig {
    /// The Google Cloud Storage location to read the input from.
    pub gcs_source: std::option::Option<crate::model::GcsSource>,

    /// File content, represented as a stream of bytes.
    /// Note: As with all `bytes` fields, protobuffers use a pure binary
    /// representation, whereas JSON representations use base64.
    ///
    /// Currently, this field only works for BatchAnnotateFiles requests. It does
    /// not work for AsyncBatchAnnotateFiles requests.
    pub content: ::bytes::Bytes,

    /// The type of the file. Currently only "application/pdf", "image/tiff" and
    /// "image/gif" are supported. Wildcards are not supported.
    pub mime_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::InputConfig::gcs_source].
    pub fn set_gcs_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcsSource>,
    {
        self.gcs_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcs_source][crate::model::InputConfig::gcs_source].
    pub fn set_or_clear_gcs_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcsSource>,
    {
        self.gcs_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content][crate::model::InputConfig::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::InputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.InputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __content,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "content" => Ok(__FieldTag::__content),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            result.gcs_source =
                                map.next_value::<std::option::Option<crate::model::GcsSource>>()?;
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gcs_source.is_some() {
            state.serialize_entry("gcsSource", &self.gcs_source)?;
        }
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InputConfig");
        debug_struct.field("gcs_source", &self.gcs_source);
        debug_struct.field("content", &self.content);
        debug_struct.field("mime_type", &self.mime_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The desired output location and metadata.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputConfig {
    /// The Google Cloud Storage location to write the output(s) to.
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,

    /// The max number of response protos to put into each output JSON file on
    /// Google Cloud Storage.
    /// The valid range is [1, 100]. If not specified, the default value is 20.
    ///
    /// For example, for one pdf file with 100 pages, 100 response protos will
    /// be generated. If `batch_size` = 20, then 5 json files each
    /// containing 20 response protos will be written under the prefix
    /// `gcs_destination`.`uri`.
    ///
    /// Currently, batch_size only applies to GcsDestination, with potential future
    /// support for other output configurations.
    pub batch_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::OutputConfig::gcs_destination].
    pub fn set_gcs_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.gcs_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcs_destination][crate::model::OutputConfig::gcs_destination].
    pub fn set_or_clear_gcs_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.gcs_destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [batch_size][crate::model::OutputConfig::batch_size].
    pub fn set_batch_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.batch_size = v.into();
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.OutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __batch_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "batchSize" => Ok(__FieldTag::__batch_size),
                            "batch_size" => Ok(__FieldTag::__batch_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            result.gcs_destination = map
                                .next_value::<std::option::Option<crate::model::GcsDestination>>(
                                )?;
                        }
                        __FieldTag::__batch_size => {
                            if !fields.insert(__FieldTag::__batch_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.batch_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gcs_destination.is_some() {
            state.serialize_entry("gcsDestination", &self.gcs_destination)?;
        }
        if !wkt::internal::is_default(&self.batch_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("batchSize", &__With(&self.batch_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputConfig");
        debug_struct.field("gcs_destination", &self.gcs_destination);
        debug_struct.field("batch_size", &self.batch_size);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Google Cloud Storage location where the input will be read from.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsSource {
    /// Google Cloud Storage URI for the input file. This must only be a
    /// Google Cloud Storage object. Wildcards are not currently supported.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GcsSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsSource");
        debug_struct.field("uri", &self.uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Google Cloud Storage location where the output will be written to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Google Cloud Storage URI prefix where the results will be stored. Results
    /// will be in JSON format and preceded by its corresponding input URI prefix.
    /// This field can either represent a gcs file prefix or gcs directory. In
    /// either case, the uri should be unique because in order to get all of the
    /// output files, you will need to do a wildcard gcs search on the uri prefix
    /// you provide.
    ///
    /// Examples:
    ///
    /// * File Prefix: gs://bucket-name/here/filenameprefix   The output files
    ///   will be created in gs://bucket-name/here/ and the names of the
    ///   output files will begin with "filenameprefix".
    ///
    /// * Directory Prefix: gs://bucket-name/some/location/   The output files
    ///   will be created in gs://bucket-name/some/location/ and the names of the
    ///   output files could be anything because there was no filename prefix
    ///   specified.
    ///
    ///
    /// If multiple outputs, each response is still AnnotateFileResponse, each of
    /// which contains some subset of the full list of AnnotateImageResponse.
    /// Multiple outputs can happen if, for example, the output JSON is too large
    /// and overflows into multiple sharded files.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GcsDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsDestination");
        debug_struct.field("uri", &self.uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains metadata for the BatchAnnotateImages operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Current state of the batch operation.
    pub state: crate::model::operation_metadata::State,

    /// The time when the batch request was received.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation result was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::OperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::operation_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Batch operation states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is received.
        Created,
        /// Request is actively being processed.
        Running,
        /// The batch processing is done.
        Done,
        /// The batch processing was cancelled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Created => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Created,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATED" => Self::Created,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Created => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vision.v1.OperationMetadata.State",
            ))
        }
    }
}

/// Parameters for a product search request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductSearchParams {
    /// The bounding polygon around the area of interest in the image.
    /// If it is not specified, system discretion will be applied.
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The resource name of a [ProductSet][google.cloud.vision.v1.ProductSet] to
    /// be searched for similar images.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`.
    ///
    /// [google.cloud.vision.v1.ProductSet]: crate::model::ProductSet
    pub product_set: std::string::String,

    /// The list of product categories to search in. Currently, we only consider
    /// the first category, and either "homegoods-v2", "apparel-v2", "toys-v2",
    /// "packagedgoods-v1", or "general-v1" should be specified. The legacy
    /// categories "homegoods", "apparel", and "toys" are still supported but will
    /// be deprecated. For new products, please use "homegoods-v2", "apparel-v2",
    /// or "toys-v2" for better product search accuracy. It is recommended to
    /// migrate existing products to these categories as well.
    pub product_categories: std::vec::Vec<std::string::String>,

    /// The filtering expression. This can be used to restrict search results based
    /// on Product labels. We currently support an AND of OR of key-value
    /// expressions, where each expression within an OR must have the same key. An
    /// '=' should be used to connect the key and value.
    ///
    /// For example, "(color = red OR color = blue) AND brand = Google" is
    /// acceptable, but "(color = red OR brand = Google)" is not acceptable.
    /// "color: red" is not acceptable because it uses a ':' instead of an '='.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSearchParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::ProductSearchParams::bounding_poly].
    pub fn set_bounding_poly<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_poly][crate::model::ProductSearchParams::bounding_poly].
    pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_poly = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_set][crate::model::ProductSearchParams::product_set].
    pub fn set_product_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set = v.into();
        self
    }

    /// Sets the value of [product_categories][crate::model::ProductSearchParams::product_categories].
    pub fn set_product_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.product_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::ProductSearchParams::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ProductSearchParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSearchParams"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductSearchParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bounding_poly,
            __product_set,
            __product_categories,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductSearchParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                            "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                            "productSet" => Ok(__FieldTag::__product_set),
                            "product_set" => Ok(__FieldTag::__product_set),
                            "productCategories" => Ok(__FieldTag::__product_categories),
                            "product_categories" => Ok(__FieldTag::__product_categories),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductSearchParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductSearchParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bounding_poly => {
                            if !fields.insert(__FieldTag::__bounding_poly) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_poly",
                                ));
                            }
                            result.bounding_poly = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__product_set => {
                            if !fields.insert(__FieldTag::__product_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set",
                                ));
                            }
                            result.product_set = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_categories => {
                            if !fields.insert(__FieldTag::__product_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_categories",
                                ));
                            }
                            result.product_categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductSearchParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bounding_poly.is_some() {
            state.serialize_entry("boundingPoly", &self.bounding_poly)?;
        }
        if !self.product_set.is_empty() {
            state.serialize_entry("productSet", &self.product_set)?;
        }
        if !self.product_categories.is_empty() {
            state.serialize_entry("productCategories", &self.product_categories)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductSearchParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductSearchParams");
        debug_struct.field("bounding_poly", &self.bounding_poly);
        debug_struct.field("product_set", &self.product_set);
        debug_struct.field("product_categories", &self.product_categories);
        debug_struct.field("filter", &self.filter);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Results for a product search request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductSearchResults {
    /// Timestamp of the index which provided these results. Products added to the
    /// product set and products removed from the product set after this time are
    /// not reflected in the current results.
    pub index_time: std::option::Option<wkt::Timestamp>,

    /// List of results, one for each product match.
    pub results: std::vec::Vec<crate::model::product_search_results::Result>,

    /// List of results grouped by products detected in the query image. Each entry
    /// corresponds to one bounding polygon in the query image, and contains the
    /// matching products specific to that region. There may be duplicate product
    /// matches in the union of all the per-product results.
    pub product_grouped_results: std::vec::Vec<crate::model::product_search_results::GroupedResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSearchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_time][crate::model::ProductSearchResults::index_time].
    pub fn set_index_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_time][crate::model::ProductSearchResults::index_time].
    pub fn set_or_clear_index_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [results][crate::model::ProductSearchResults::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product_search_results::Result>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [product_grouped_results][crate::model::ProductSearchResults::product_grouped_results].
    pub fn set_product_grouped_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product_search_results::GroupedResult>,
    {
        use std::iter::Iterator;
        self.product_grouped_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProductSearchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductSearchResults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __index_time,
            __results,
            __product_grouped_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductSearchResults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "indexTime" => Ok(__FieldTag::__index_time),
                            "index_time" => Ok(__FieldTag::__index_time),
                            "results" => Ok(__FieldTag::__results),
                            "productGroupedResults" => Ok(__FieldTag::__product_grouped_results),
                            "product_grouped_results" => Ok(__FieldTag::__product_grouped_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductSearchResults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductSearchResults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__index_time => {
                            if !fields.insert(__FieldTag::__index_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_time",
                                ));
                            }
                            result.index_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::product_search_results::Result>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_grouped_results => {
                            if !fields.insert(__FieldTag::__product_grouped_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_grouped_results",
                                ));
                            }
                            result.product_grouped_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::product_search_results::GroupedResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductSearchResults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.index_time.is_some() {
            state.serialize_entry("indexTime", &self.index_time)?;
        }
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.product_grouped_results.is_empty() {
            state.serialize_entry("productGroupedResults", &self.product_grouped_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductSearchResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductSearchResults");
        debug_struct.field("index_time", &self.index_time);
        debug_struct.field("results", &self.results);
        debug_struct.field("product_grouped_results", &self.product_grouped_results);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProductSearchResults].
pub mod product_search_results {
    #[allow(unused_imports)]
    use super::*;

    /// Information about a product.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Result {
        /// The Product.
        pub product: std::option::Option<crate::model::Product>,

        /// A confidence level on the match, ranging from 0 (no confidence) to
        /// 1 (full confidence).
        pub score: f32,

        /// The resource name of the image from the product that is the closest match
        /// to the query.
        pub image: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [product][crate::model::product_search_results::Result::product].
        pub fn set_product<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Product>,
        {
            self.product = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [product][crate::model::product_search_results::Result::product].
        pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Product>,
        {
            self.product = v.map(|x| x.into());
            self
        }

        /// Sets the value of [score][crate::model::product_search_results::Result::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [image][crate::model::product_search_results::Result::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }
    }

    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.Result"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __product,
                __score,
                __image,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Result")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "product" => Ok(__FieldTag::__product),
                                "score" => Ok(__FieldTag::__score),
                                "image" => Ok(__FieldTag::__image),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Result;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Result")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__product => {
                                if !fields.insert(__FieldTag::__product) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for product",
                                    ));
                                }
                                result.product =
                                    map.next_value::<std::option::Option<crate::model::Product>>()?;
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__image => {
                                if !fields.insert(__FieldTag::__image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image",
                                    ));
                                }
                                result.image = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.product.is_some() {
                state.serialize_entry("product", &self.product)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self.image.is_empty() {
                state.serialize_entry("image", &self.image)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Result");
            debug_struct.field("product", &self.product);
            debug_struct.field("score", &self.score);
            debug_struct.field("image", &self.image);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Prediction for what the object in the bounding box is.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ObjectAnnotation {
        /// Object ID that should align with EntityAnnotation mid.
        pub mid: std::string::String,

        /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
        /// information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        pub language_code: std::string::String,

        /// Object name, expressed in its `language_code` language.
        pub name: std::string::String,

        /// Score of the result. Range [0, 1].
        pub score: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ObjectAnnotation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mid][crate::model::product_search_results::ObjectAnnotation::mid].
        pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mid = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::product_search_results::ObjectAnnotation::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [name][crate::model::product_search_results::ObjectAnnotation::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [score][crate::model::product_search_results::ObjectAnnotation::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }
    }

    impl wkt::message::Message for ObjectAnnotation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.ObjectAnnotation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ObjectAnnotation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mid,
                __language_code,
                __name,
                __score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ObjectAnnotation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mid" => Ok(__FieldTag::__mid),
                                "languageCode" => Ok(__FieldTag::__language_code),
                                "language_code" => Ok(__FieldTag::__language_code),
                                "name" => Ok(__FieldTag::__name),
                                "score" => Ok(__FieldTag::__score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ObjectAnnotation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ObjectAnnotation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mid => {
                                if !fields.insert(__FieldTag::__mid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mid",
                                    ));
                                }
                                result.mid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__language_code => {
                                if !fields.insert(__FieldTag::__language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_code",
                                    ));
                                }
                                result.language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ObjectAnnotation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.mid.is_empty() {
                state.serialize_entry("mid", &self.mid)?;
            }
            if !self.language_code.is_empty() {
                state.serialize_entry("languageCode", &self.language_code)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ObjectAnnotation {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ObjectAnnotation");
            debug_struct.field("mid", &self.mid);
            debug_struct.field("language_code", &self.language_code);
            debug_struct.field("name", &self.name);
            debug_struct.field("score", &self.score);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Information about the products similar to a single product in a query
    /// image.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupedResult {
        /// The bounding polygon around the product detected in the query image.
        pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

        /// List of results, one for each product match.
        pub results: std::vec::Vec<crate::model::product_search_results::Result>,

        /// List of generic predictions for the object in the bounding box.
        pub object_annotations:
            std::vec::Vec<crate::model::product_search_results::ObjectAnnotation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupedResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bounding_poly][crate::model::product_search_results::GroupedResult::bounding_poly].
        pub fn set_bounding_poly<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BoundingPoly>,
        {
            self.bounding_poly = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [bounding_poly][crate::model::product_search_results::GroupedResult::bounding_poly].
        pub fn set_or_clear_bounding_poly<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BoundingPoly>,
        {
            self.bounding_poly = v.map(|x| x.into());
            self
        }

        /// Sets the value of [results][crate::model::product_search_results::GroupedResult::results].
        pub fn set_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::product_search_results::Result>,
        {
            use std::iter::Iterator;
            self.results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [object_annotations][crate::model::product_search_results::GroupedResult::object_annotations].
        pub fn set_object_annotations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::product_search_results::ObjectAnnotation>,
        {
            use std::iter::Iterator;
            self.object_annotations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroupedResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.GroupedResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupedResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bounding_poly,
                __results,
                __object_annotations,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupedResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "boundingPoly" => Ok(__FieldTag::__bounding_poly),
                                "bounding_poly" => Ok(__FieldTag::__bounding_poly),
                                "results" => Ok(__FieldTag::__results),
                                "objectAnnotations" => Ok(__FieldTag::__object_annotations),
                                "object_annotations" => Ok(__FieldTag::__object_annotations),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupedResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupedResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bounding_poly => {
                                if !fields.insert(__FieldTag::__bounding_poly) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bounding_poly",
                                    ));
                                }
                                result.bounding_poly = map
                                    .next_value::<std::option::Option<crate::model::BoundingPoly>>(
                                    )?;
                            }
                            __FieldTag::__results => {
                                if !fields.insert(__FieldTag::__results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for results",
                                    ));
                                }
                                result.results = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::product_search_results::Result>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__object_annotations => {
                                if !fields.insert(__FieldTag::__object_annotations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for object_annotations",
                                    ));
                                }
                                result.object_annotations = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::product_search_results::ObjectAnnotation,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupedResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.bounding_poly.is_some() {
                state.serialize_entry("boundingPoly", &self.bounding_poly)?;
            }
            if !self.results.is_empty() {
                state.serialize_entry("results", &self.results)?;
            }
            if !self.object_annotations.is_empty() {
                state.serialize_entry("objectAnnotations", &self.object_annotations)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GroupedResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GroupedResult");
            debug_struct.field("bounding_poly", &self.bounding_poly);
            debug_struct.field("results", &self.results);
            debug_struct.field("object_annotations", &self.object_annotations);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A Product contains ReferenceImages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Product {
    /// The resource name of the product.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    ///
    /// This field is ignored when creating a product.
    pub name: std::string::String,

    /// The user-provided name for this Product. Must not be empty. Must be at most
    /// 4096 characters long.
    pub display_name: std::string::String,

    /// User-provided metadata to be stored with this product. Must be at most 4096
    /// characters long.
    pub description: std::string::String,

    /// Immutable. The category for the product identified by the reference image.
    /// This should be one of "homegoods-v2", "apparel-v2", "toys-v2",
    /// "packagedgoods-v1" or "general-v1". The legacy categories "homegoods",
    /// "apparel", and "toys" are still supported, but these should not be used for
    /// new products.
    pub product_category: std::string::String,

    /// Key-value pairs that can be attached to a product. At query time,
    /// constraints can be specified based on the product_labels.
    ///
    /// Note that integer values can be provided as strings, e.g. "1199". Only
    /// strings with integer values can match a range-based restriction which is
    /// to be supported soon.
    ///
    /// Multiple values can be assigned to the same key. One product may have up to
    /// 500 product_labels.
    ///
    /// Notice that the total number of distinct product_labels over all products
    /// in one ProductSet cannot exceed 1M, otherwise the product search pipeline
    /// will refuse to work for that ProductSet.
    pub product_labels: std::vec::Vec<crate::model::product::KeyValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Product {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Product::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Product::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Product::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [product_category][crate::model::Product::product_category].
    pub fn set_product_category<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.product_category = v.into();
        self
    }

    /// Sets the value of [product_labels][crate::model::Product::product_labels].
    pub fn set_product_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product::KeyValue>,
    {
        use std::iter::Iterator;
        self.product_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Product {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Product"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Product {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __product_category,
            __product_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Product")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "productCategory" => Ok(__FieldTag::__product_category),
                            "product_category" => Ok(__FieldTag::__product_category),
                            "productLabels" => Ok(__FieldTag::__product_labels),
                            "product_labels" => Ok(__FieldTag::__product_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Product;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Product")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_category => {
                            if !fields.insert(__FieldTag::__product_category) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_category",
                                ));
                            }
                            result.product_category = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_labels => {
                            if !fields.insert(__FieldTag::__product_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_labels",
                                ));
                            }
                            result.product_labels =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::product::KeyValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Product {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.product_category.is_empty() {
            state.serialize_entry("productCategory", &self.product_category)?;
        }
        if !self.product_labels.is_empty() {
            state.serialize_entry("productLabels", &self.product_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Product {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Product");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("product_category", &self.product_category);
        debug_struct.field("product_labels", &self.product_labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Product].
pub mod product {
    #[allow(unused_imports)]
    use super::*;

    /// A product label represented as a key-value pair.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KeyValue {
        /// The key of the label attached to the product. Cannot be empty and cannot
        /// exceed 128 bytes.
        pub key: std::string::String,

        /// The value of the label attached to the product. Cannot be empty and
        /// cannot exceed 128 bytes.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::product::KeyValue::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::product::KeyValue::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for KeyValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.Product.KeyValue"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KeyValue {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KeyValue")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KeyValue;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KeyValue")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KeyValue {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for KeyValue {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("KeyValue");
            debug_struct.field("key", &self.key);
            debug_struct.field("value", &self.value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A ProductSet contains Products. A ProductSet can contain a maximum of 1
/// million reference images. If the limit is exceeded, periodic indexing will
/// fail.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductSet {
    /// The resource name of the ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`.
    ///
    /// This field is ignored when creating a ProductSet.
    pub name: std::string::String,

    /// The user-provided name for this ProductSet. Must not be empty. Must be at
    /// most 4096 characters long.
    pub display_name: std::string::String,

    /// Output only. The time at which this ProductSet was last indexed. Query
    /// results will reflect all updates before this time. If this ProductSet has
    /// never been indexed, this timestamp is the default value
    /// "1970-01-01T00:00:00Z".
    ///
    /// This field is ignored when creating a ProductSet.
    pub index_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If there was an error with indexing the product set, the field
    /// is populated.
    ///
    /// This field is ignored when creating a ProductSet.
    pub index_error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProductSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ProductSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [index_time][crate::model::ProductSet::index_time].
    pub fn set_index_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_time][crate::model::ProductSet::index_time].
    pub fn set_or_clear_index_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.index_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [index_error][crate::model::ProductSet::index_error].
    pub fn set_index_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.index_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index_error][crate::model::ProductSet::index_error].
    pub fn set_or_clear_index_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.index_error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProductSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __index_time,
            __index_error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "indexTime" => Ok(__FieldTag::__index_time),
                            "index_time" => Ok(__FieldTag::__index_time),
                            "indexError" => Ok(__FieldTag::__index_error),
                            "index_error" => Ok(__FieldTag::__index_error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__index_time => {
                            if !fields.insert(__FieldTag::__index_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_time",
                                ));
                            }
                            result.index_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__index_error => {
                            if !fields.insert(__FieldTag::__index_error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for index_error",
                                ));
                            }
                            result.index_error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.index_time.is_some() {
            state.serialize_entry("indexTime", &self.index_time)?;
        }
        if self.index_error.is_some() {
            state.serialize_entry("indexError", &self.index_error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductSet");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("index_time", &self.index_time);
        debug_struct.field("index_error", &self.index_error);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A `ReferenceImage` represents a product image and its associated metadata,
/// such as bounding boxes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReferenceImage {
    /// The resource name of the reference image.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
    ///
    /// This field is ignored when creating a reference image.
    pub name: std::string::String,

    /// Required. The Google Cloud Storage URI of the reference image.
    ///
    /// The URI must start with `gs://`.
    pub uri: std::string::String,

    /// Optional. Bounding polygons around the areas of interest in the reference
    /// image. If this field is empty, the system will try to detect regions of
    /// interest. At most 10 bounding polygons will be used.
    ///
    /// The provided shape is converted into a non-rotated rectangle. Once
    /// converted, the small edge of the rectangle must be greater than or equal
    /// to 300 pixels. The aspect ratio must be 1:4 or less (i.e. 1:3 is ok; 1:5
    /// is not).
    pub bounding_polys: std::vec::Vec<crate::model::BoundingPoly>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReferenceImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReferenceImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ReferenceImage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [bounding_polys][crate::model::ReferenceImage::bounding_polys].
    pub fn set_bounding_polys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoundingPoly>,
    {
        use std::iter::Iterator;
        self.bounding_polys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReferenceImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ReferenceImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReferenceImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uri,
            __bounding_polys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReferenceImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uri" => Ok(__FieldTag::__uri),
                            "boundingPolys" => Ok(__FieldTag::__bounding_polys),
                            "bounding_polys" => Ok(__FieldTag::__bounding_polys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReferenceImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReferenceImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bounding_polys => {
                            if !fields.insert(__FieldTag::__bounding_polys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_polys",
                                ));
                            }
                            result.bounding_polys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BoundingPoly>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReferenceImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.bounding_polys.is_empty() {
            state.serialize_entry("boundingPolys", &self.bounding_polys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReferenceImage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReferenceImage");
        debug_struct.field("name", &self.name);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("bounding_polys", &self.bounding_polys);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `CreateProduct` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProductRequest {
    /// Required. The project in which the Product should be created.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID`.
    pub parent: std::string::String,

    /// Required. The product to create.
    pub product: std::option::Option<crate::model::Product>,

    /// A user-supplied resource id for this Product. If set, the server will
    /// attempt to use this value as the resource id. If it is already in use, an
    /// error is returned with code ALREADY_EXISTS. Must be at most 128 characters
    /// long. It cannot contain the character `/`.
    pub product_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProductRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [product][crate::model::CreateProductRequest::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::CreateProductRequest::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_id][crate::model::CreateProductRequest::product_id].
    pub fn set_product_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __product,
            __product_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "product" => Ok(__FieldTag::__product),
                            "productId" => Ok(__FieldTag::__product_id),
                            "product_id" => Ok(__FieldTag::__product_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__product_id => {
                            if !fields.insert(__FieldTag::__product_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_id",
                                ));
                            }
                            result.product_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.product_id.is_empty() {
            state.serialize_entry("productId", &self.product_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateProductRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("product", &self.product);
        debug_struct.field("product_id", &self.product_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `ListProducts` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsRequest {
    /// Required. The project OR ProductSet from which Products should be listed.
    ///
    /// Format:
    /// `projects/PROJECT_ID/locations/LOC_ID`
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the `ListProducts` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsResponse {
    /// List of products.
    pub products: std::vec::Vec<crate::model::Product>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [products][crate::model::ListProductsResponse::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProductsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductsResponse {
    type PageItem = crate::model::Product;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.products
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __products,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "products" => Ok(__FieldTag::__products),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__products => {
                            if !fields.insert(__FieldTag::__products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for products",
                                ));
                            }
                            result.products = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Product>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.products.is_empty() {
            state.serialize_entry("products", &self.products)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsResponse");
        debug_struct.field("products", &self.products);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `GetProduct` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProductRequest {
    /// Required. Resource name of the Product to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProductRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `UpdateProduct` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProductRequest {
    /// Required. The Product resource which replaces the one on the server.
    /// product.name is immutable.
    pub product: std::option::Option<crate::model::Product>,

    /// The [FieldMask][google.protobuf.FieldMask] that specifies which fields
    /// to update.
    /// If update_mask isn't specified, all mutable fields are to be updated.
    /// Valid mask paths include `product_labels`, `display_name`, and
    /// `description`.
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::UpdateProductRequest::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::UpdateProductRequest::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProductRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProductRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.UpdateProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateProductRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `DeleteProduct` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProductRequest {
    /// Required. Resource name of product to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProductRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `CreateProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProductSetRequest {
    /// Required. The project in which the ProductSet should be created.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    pub parent: std::string::String,

    /// Required. The ProductSet to create.
    pub product_set: std::option::Option<crate::model::ProductSet>,

    /// A user-supplied resource id for this ProductSet. If set, the server will
    /// attempt to use this value as the resource id. If it is already in use, an
    /// error is returned with code ALREADY_EXISTS. Must be at most 128 characters
    /// long. It cannot contain the character `/`.
    pub product_set_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProductSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [product_set][crate::model::CreateProductSetRequest::product_set].
    pub fn set_product_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductSet>,
    {
        self.product_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product_set][crate::model::CreateProductSetRequest::product_set].
    pub fn set_or_clear_product_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductSet>,
    {
        self.product_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_set_id][crate::model::CreateProductSetRequest::product_set_id].
    pub fn set_product_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __product_set,
            __product_set_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "productSet" => Ok(__FieldTag::__product_set),
                            "product_set" => Ok(__FieldTag::__product_set),
                            "productSetId" => Ok(__FieldTag::__product_set_id),
                            "product_set_id" => Ok(__FieldTag::__product_set_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_set => {
                            if !fields.insert(__FieldTag::__product_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set",
                                ));
                            }
                            result.product_set =
                                map.next_value::<std::option::Option<crate::model::ProductSet>>()?;
                        }
                        __FieldTag::__product_set_id => {
                            if !fields.insert(__FieldTag::__product_set_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set_id",
                                ));
                            }
                            result.product_set_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.product_set.is_some() {
            state.serialize_entry("productSet", &self.product_set)?;
        }
        if !self.product_set_id.is_empty() {
            state.serialize_entry("productSetId", &self.product_set_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateProductSetRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("product_set", &self.product_set);
        debug_struct.field("product_set_id", &self.product_set_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `ListProductSets` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductSetsRequest {
    /// Required. The project from which ProductSets should be listed.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProductSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductSetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductSetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductSetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the `ListProductSets` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductSetsResponse {
    /// List of ProductSets.
    pub product_sets: std::vec::Vec<crate::model::ProductSet>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_sets][crate::model::ListProductSetsResponse::product_sets].
    pub fn set_product_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProductSet>,
    {
        use std::iter::Iterator;
        self.product_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProductSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductSetsResponse {
    type PageItem = crate::model::ProductSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.product_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_sets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductSetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productSets" => Ok(__FieldTag::__product_sets),
                            "product_sets" => Ok(__FieldTag::__product_sets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_sets => {
                            if !fields.insert(__FieldTag::__product_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_sets",
                                ));
                            }
                            result.product_sets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ProductSet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product_sets.is_empty() {
            state.serialize_entry("productSets", &self.product_sets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductSetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductSetsResponse");
        debug_struct.field("product_sets", &self.product_sets);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `GetProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProductSetRequest {
    /// Required. Resource name of the ProductSet to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProductSetRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `UpdateProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProductSetRequest {
    /// Required. The ProductSet resource which replaces the one on the server.
    pub product_set: std::option::Option<crate::model::ProductSet>,

    /// The [FieldMask][google.protobuf.FieldMask] that specifies which fields to
    /// update.
    /// If update_mask isn't specified, all mutable fields are to be updated.
    /// Valid mask path is `display_name`.
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_set][crate::model::UpdateProductSetRequest::product_set].
    pub fn set_product_set<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductSet>,
    {
        self.product_set = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product_set][crate::model::UpdateProductSetRequest::product_set].
    pub fn set_or_clear_product_set<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductSet>,
    {
        self.product_set = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProductSetRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProductSetRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.UpdateProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_set,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productSet" => Ok(__FieldTag::__product_set),
                            "product_set" => Ok(__FieldTag::__product_set),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_set => {
                            if !fields.insert(__FieldTag::__product_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set",
                                ));
                            }
                            result.product_set =
                                map.next_value::<std::option::Option<crate::model::ProductSet>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.product_set.is_some() {
            state.serialize_entry("productSet", &self.product_set)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateProductSetRequest");
        debug_struct.field("product_set", &self.product_set);
        debug_struct.field("update_mask", &self.update_mask);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `DeleteProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProductSetRequest {
    /// Required. Resource name of the ProductSet to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProductSetRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `CreateReferenceImage` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReferenceImageRequest {
    /// Required. Resource name of the product in which to create the reference
    /// image.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    pub parent: std::string::String,

    /// Required. The reference image to create.
    /// If an image ID is specified, it is ignored.
    pub reference_image: std::option::Option<crate::model::ReferenceImage>,

    /// A user-supplied resource id for the ReferenceImage to be added. If set,
    /// the server will attempt to use this value as the resource id. If it is
    /// already in use, an error is returned with code ALREADY_EXISTS. Must be at
    /// most 128 characters long. It cannot contain the character `/`.
    pub reference_image_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReferenceImageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reference_image][crate::model::CreateReferenceImageRequest::reference_image].
    pub fn set_reference_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReferenceImage>,
    {
        self.reference_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference_image][crate::model::CreateReferenceImageRequest::reference_image].
    pub fn set_or_clear_reference_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReferenceImage>,
    {
        self.reference_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reference_image_id][crate::model::CreateReferenceImageRequest::reference_image_id].
    pub fn set_reference_image_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference_image_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateReferenceImageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReferenceImageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __reference_image,
            __reference_image_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReferenceImageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "referenceImage" => Ok(__FieldTag::__reference_image),
                            "reference_image" => Ok(__FieldTag::__reference_image),
                            "referenceImageId" => Ok(__FieldTag::__reference_image_id),
                            "reference_image_id" => Ok(__FieldTag::__reference_image_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReferenceImageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReferenceImageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reference_image => {
                            if !fields.insert(__FieldTag::__reference_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_image",
                                ));
                            }
                            result.reference_image = map
                                .next_value::<std::option::Option<crate::model::ReferenceImage>>(
                                )?;
                        }
                        __FieldTag::__reference_image_id => {
                            if !fields.insert(__FieldTag::__reference_image_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_image_id",
                                ));
                            }
                            result.reference_image_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReferenceImageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.reference_image.is_some() {
            state.serialize_entry("referenceImage", &self.reference_image)?;
        }
        if !self.reference_image_id.is_empty() {
            state.serialize_entry("referenceImageId", &self.reference_image_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateReferenceImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateReferenceImageRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("reference_image", &self.reference_image);
        debug_struct.field("reference_image_id", &self.reference_image_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `ListReferenceImages` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReferenceImagesRequest {
    /// Required. Resource name of the product containing the reference images.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    pub page_size: i32,

    /// A token identifying a page of results to be returned. This is the value
    /// of `nextPageToken` returned in a previous reference image list request.
    ///
    /// Defaults to the first page if not specified.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferenceImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReferenceImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReferenceImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReferenceImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReferenceImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListReferenceImagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReferenceImagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReferenceImagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReferenceImagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReferenceImagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReferenceImagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReferenceImagesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReferenceImagesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the `ListReferenceImages` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReferenceImagesResponse {
    /// The list of reference images.
    pub reference_images: std::vec::Vec<crate::model::ReferenceImage>,

    /// The maximum number of items to return. Default 10, maximum 100.
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferenceImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reference_images][crate::model::ListReferenceImagesResponse::reference_images].
    pub fn set_reference_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReferenceImage>,
    {
        use std::iter::Iterator;
        self.reference_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReferenceImagesResponse::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReferenceImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReferenceImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListReferenceImagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReferenceImagesResponse {
    type PageItem = crate::model::ReferenceImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reference_images
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReferenceImagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reference_images,
            __page_size,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReferenceImagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referenceImages" => Ok(__FieldTag::__reference_images),
                            "reference_images" => Ok(__FieldTag::__reference_images),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReferenceImagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReferenceImagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reference_images => {
                            if !fields.insert(__FieldTag::__reference_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_images",
                                ));
                            }
                            result.reference_images =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReferenceImage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReferenceImagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reference_images.is_empty() {
            state.serialize_entry("referenceImages", &self.reference_images)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReferenceImagesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReferenceImagesResponse");
        debug_struct.field("reference_images", &self.reference_images);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `GetReferenceImage` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReferenceImageRequest {
    /// Required. The resource name of the ReferenceImage to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReferenceImageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetReferenceImageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReferenceImageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReferenceImageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReferenceImageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReferenceImageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReferenceImageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReferenceImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReferenceImageRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `DeleteReferenceImage` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReferenceImageRequest {
    /// Required. The resource name of the reference image to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReferenceImageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteReferenceImageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReferenceImageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReferenceImageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReferenceImageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReferenceImageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReferenceImageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteReferenceImageRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteReferenceImageRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `AddProductToProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddProductToProductSetRequest {
    /// Required. The resource name for the ProductSet to modify.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    pub name: std::string::String,

    /// Required. The resource name for the Product to be added to this ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    pub product: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddProductToProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AddProductToProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [product][crate::model::AddProductToProductSetRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }
}

impl wkt::message::Message for AddProductToProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AddProductToProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddProductToProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __product,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddProductToProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "product" => Ok(__FieldTag::__product),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddProductToProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddProductToProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddProductToProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddProductToProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddProductToProductSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("product", &self.product);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `RemoveProductFromProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveProductFromProductSetRequest {
    /// Required. The resource name for the ProductSet to modify.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    pub name: std::string::String,

    /// Required. The resource name for the Product to be removed from this
    /// ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    pub product: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveProductFromProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveProductFromProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [product][crate::model::RemoveProductFromProductSetRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }
}

impl wkt::message::Message for RemoveProductFromProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.RemoveProductFromProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveProductFromProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __product,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveProductFromProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "product" => Ok(__FieldTag::__product),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveProductFromProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveProductFromProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveProductFromProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveProductFromProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveProductFromProductSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("product", &self.product);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `ListProductsInProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsInProductSetRequest {
    /// Required. The ProductSet resource for which to retrieve Products.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    pub name: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsInProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListProductsInProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductsInProductSetRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductsInProductSetRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsInProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsInProductSetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsInProductSetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsInProductSetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsInProductSetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsInProductSetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsInProductSetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsInProductSetRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsInProductSetRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the `ListProductsInProductSet` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsInProductSetResponse {
    /// The list of Products.
    pub products: std::vec::Vec<crate::model::Product>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsInProductSetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [products][crate::model::ListProductsInProductSetResponse::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProductsInProductSetResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsInProductSetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsInProductSetResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductsInProductSetResponse {
    type PageItem = crate::model::Product;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.products
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsInProductSetResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __products,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsInProductSetResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "products" => Ok(__FieldTag::__products),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsInProductSetResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsInProductSetResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__products => {
                            if !fields.insert(__FieldTag::__products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for products",
                                ));
                            }
                            result.products = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Product>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsInProductSetResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.products.is_empty() {
            state.serialize_entry("products", &self.products)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsInProductSetResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsInProductSetResponse");
        debug_struct.field("products", &self.products);
        debug_struct.field("next_page_token", &self.next_page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The Google Cloud Storage location for a csv file which preserves a list of
/// ImportProductSetRequests in each line.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductSetsGcsSource {
    /// The Google Cloud Storage URI of the input csv file.
    ///
    /// The URI must start with `gs://`.
    ///
    /// The format of the input csv file should be one image per line.
    /// In each line, there are 8 columns.
    ///
    /// 1. image-uri
    /// 1. image-id
    /// 1. product-set-id
    /// 1. product-id
    /// 1. product-category
    /// 1. product-display-name
    /// 1. labels
    /// 1. bounding-poly
    ///
    /// The `image-uri`, `product-set-id`, `product-id`, and `product-category`
    /// columns are required. All other columns are optional.
    ///
    /// If the `ProductSet` or `Product` specified by the `product-set-id` and
    /// `product-id` values does not exist, then the system will create a new
    /// `ProductSet` or `Product` for the image. In this case, the
    /// `product-display-name` column refers to
    /// [display_name][google.cloud.vision.v1.Product.display_name], the
    /// `product-category` column refers to
    /// [product_category][google.cloud.vision.v1.Product.product_category], and
    /// the `labels` column refers to
    /// [product_labels][google.cloud.vision.v1.Product.product_labels].
    ///
    /// The `image-id` column is optional but must be unique if provided. If it is
    /// empty, the system will automatically assign a unique id to the image.
    ///
    /// The `product-display-name` column is optional. If it is empty, the system
    /// sets the [display_name][google.cloud.vision.v1.Product.display_name] field
    /// for the product to a space (" "). You can update the `display_name` later
    /// by using the API.
    ///
    /// If a `Product` with the specified `product-id` already exists, then the
    /// system ignores the `product-display-name`, `product-category`, and `labels`
    /// columns.
    ///
    /// The `labels` column (optional) is a line containing a list of
    /// comma-separated key-value pairs, in the following format:
    ///
    /// ```norust
    /// "key_1=value_1,key_2=value_2,...,key_n=value_n"
    /// ```
    ///
    /// The `bounding-poly` column (optional) identifies one region of
    /// interest from the image in the same manner as `CreateReferenceImage`. If
    /// you do not specify the `bounding-poly` column, then the system will try to
    /// detect regions of interest automatically.
    ///
    /// At most one `bounding-poly` column is allowed per line. If the image
    /// contains multiple regions of interest, add a line to the CSV file that
    /// includes the same product information, and the `bounding-poly` values for
    /// each region of interest.
    ///
    /// The `bounding-poly` column must contain an even number of comma-separated
    /// numbers, in the format "p1_x,p1_y,p2_x,p2_y,...,pn_x,pn_y". Use
    /// non-negative integers for absolute bounding polygons, and float values
    /// in [0, 1] for normalized bounding polygons.
    ///
    /// The system will resize the image if the image resolution is too
    /// large to process (larger than 20MP).
    ///
    /// [google.cloud.vision.v1.Product.display_name]: crate::model::Product::display_name
    /// [google.cloud.vision.v1.Product.product_category]: crate::model::Product::product_category
    /// [google.cloud.vision.v1.Product.product_labels]: crate::model::Product::product_labels
    pub csv_file_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsGcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [csv_file_uri][crate::model::ImportProductSetsGcsSource::csv_file_uri].
    pub fn set_csv_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.csv_file_uri = v.into();
        self
    }
}

impl wkt::message::Message for ImportProductSetsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsGcsSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductSetsGcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __csv_file_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductSetsGcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "csvFileUri" => Ok(__FieldTag::__csv_file_uri),
                            "csv_file_uri" => Ok(__FieldTag::__csv_file_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductSetsGcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductSetsGcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__csv_file_uri => {
                            if !fields.insert(__FieldTag::__csv_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for csv_file_uri",
                                ));
                            }
                            result.csv_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductSetsGcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.csv_file_uri.is_empty() {
            state.serialize_entry("csvFileUri", &self.csv_file_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductSetsGcsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductSetsGcsSource");
        debug_struct.field("csv_file_uri", &self.csv_file_uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The input content for the `ImportProductSets` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductSetsInputConfig {
    /// The source of the input.
    pub source: std::option::Option<crate::model::import_product_sets_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ImportProductSetsInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_product_sets_input_config::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportProductSetsInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportProductSetsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_product_sets_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportProductSetsInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportProductSetsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_product_sets_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportProductSetsInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductSetsInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductSetsInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductSetsInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductSetsInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.vision.v1.ImportProductSetsInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_product_sets_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ImportProductSetsGcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductSetsInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductSetsInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductSetsInputConfig");
        debug_struct.field("source", &self.source);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportProductSetsInputConfig].
pub mod import_product_sets_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The Google Cloud Storage location for a csv file which preserves a list
        /// of ImportProductSetRequests in each line.
        GcsSource(std::boxed::Box<crate::model::ImportProductSetsGcsSource>),
    }
}

/// Request message for the `ImportProductSets` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductSetsRequest {
    /// Required. The project in which the ProductSets should be imported.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    pub parent: std::string::String,

    /// Required. The input content for the list of requests.
    pub input_config: std::option::Option<crate::model::ImportProductSetsInputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportProductSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportProductSetsRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportProductSetsInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportProductSetsRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportProductSetsInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportProductSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductSetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductSetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductSetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductSetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::ImportProductSetsInputConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductSetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductSetsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductSetsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("input_config", &self.input_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for the `ImportProductSets` method.
///
/// This message is returned by the
/// [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation]
/// method in the returned
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductSetsResponse {
    /// The list of reference_images that are imported successfully.
    pub reference_images: std::vec::Vec<crate::model::ReferenceImage>,

    /// The rpc status for each ImportProductSet request, including both successes
    /// and errors.
    ///
    /// The number of statuses here matches the number of lines in the csv file,
    /// and statuses[i] stores the success or failure status of processing the i-th
    /// line of the csv, starting from line 0.
    pub statuses: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reference_images][crate::model::ImportProductSetsResponse::reference_images].
    pub fn set_reference_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReferenceImage>,
    {
        use std::iter::Iterator;
        self.reference_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [statuses][crate::model::ImportProductSetsResponse::statuses].
    pub fn set_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportProductSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductSetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reference_images,
            __statuses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductSetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "referenceImages" => Ok(__FieldTag::__reference_images),
                            "reference_images" => Ok(__FieldTag::__reference_images),
                            "statuses" => Ok(__FieldTag::__statuses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductSetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductSetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reference_images => {
                            if !fields.insert(__FieldTag::__reference_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_images",
                                ));
                            }
                            result.reference_images =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReferenceImage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__statuses => {
                            if !fields.insert(__FieldTag::__statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for statuses",
                                ));
                            }
                            result.statuses = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductSetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reference_images.is_empty() {
            state.serialize_entry("referenceImages", &self.reference_images)?;
        }
        if !self.statuses.is_empty() {
            state.serialize_entry("statuses", &self.statuses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductSetsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductSetsResponse");
        debug_struct.field("reference_images", &self.reference_images);
        debug_struct.field("statuses", &self.statuses);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for the batch operations such as the current state.
///
/// This is included in the `metadata` field of the `Operation` returned by the
/// `GetOperation` call of the `google::longrunning::Operations` service.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchOperationMetadata {
    /// The current state of the batch operation.
    pub state: crate::model::batch_operation_metadata::State,

    /// The time when the batch request was submitted to the server.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the batch request is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchOperationMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::BatchOperationMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BatchOperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BatchOperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __submit_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::batch_operation_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchOperationMetadata");
        debug_struct.field("state", &self.state);
        debug_struct.field("submit_time", &self.submit_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BatchOperationMetadata].
pub mod batch_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the batch request can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is actively being processed.
        Processing,
        /// The request is done and at least one item has been successfully
        /// processed.
        Successful,
        /// The request is done and no item has been successfully processed.
        Failed,
        /// The request is done after the longrunning.Operations.CancelOperation has
        /// been called by the user.  Any records that were processed before the
        /// cancel command are output as specified in the request.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Processing => std::option::Option::Some(1),
                Self::Successful => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Processing => std::option::Option::Some("PROCESSING"),
                Self::Successful => std::option::Option::Some("SUCCESSFUL"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Processing,
                2 => Self::Successful,
                3 => Self::Failed,
                4 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROCESSING" => Self::Processing,
                "SUCCESSFUL" => Self::Successful,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Processing => serializer.serialize_i32(1),
                Self::Successful => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vision.v1.BatchOperationMetadata.State",
            ))
        }
    }
}

/// Config to control which ProductSet contains the Products to be deleted.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductSetPurgeConfig {
    /// The ProductSet that contains the Products to delete. If a Product is a
    /// member of product_set_id in addition to other ProductSets, the Product will
    /// still be deleted.
    pub product_set_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSetPurgeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_set_id][crate::model::ProductSetPurgeConfig::product_set_id].
    pub fn set_product_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set_id = v.into();
        self
    }
}

impl wkt::message::Message for ProductSetPurgeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSetPurgeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductSetPurgeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_set_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductSetPurgeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productSetId" => Ok(__FieldTag::__product_set_id),
                            "product_set_id" => Ok(__FieldTag::__product_set_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductSetPurgeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductSetPurgeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_set_id => {
                            if !fields.insert(__FieldTag::__product_set_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set_id",
                                ));
                            }
                            result.product_set_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductSetPurgeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product_set_id.is_empty() {
            state.serialize_entry("productSetId", &self.product_set_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductSetPurgeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductSetPurgeConfig");
        debug_struct.field("product_set_id", &self.product_set_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for the `PurgeProducts` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeProductsRequest {
    /// Required. The project and location in which the Products should be deleted.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    pub parent: std::string::String,

    /// The default value is false. Override this value to true to actually perform
    /// the purge.
    pub force: bool,

    /// The Products to delete.
    pub target: std::option::Option<crate::model::purge_products_request::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeProductsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::purge_products_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::PurgeProductsRequest::target]
    /// if it holds a `ProductSetPurgeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn product_set_purge_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProductSetPurgeConfig>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::purge_products_request::Target::ProductSetPurgeConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target]
    /// to hold a `ProductSetPurgeConfig`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_product_set_purge_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ProductSetPurgeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::purge_products_request::Target::ProductSetPurgeConfig(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::PurgeProductsRequest::target]
    /// if it holds a `DeleteOrphanProducts`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_orphan_products(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::purge_products_request::Target::DeleteOrphanProducts(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target]
    /// to hold a `DeleteOrphanProducts`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_delete_orphan_products<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::purge_products_request::Target::DeleteOrphanProducts(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PurgeProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.PurgeProductsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeProductsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_set_purge_config,
            __delete_orphan_products,
            __parent,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeProductsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productSetPurgeConfig" => Ok(__FieldTag::__product_set_purge_config),
                            "product_set_purge_config" => {
                                Ok(__FieldTag::__product_set_purge_config)
                            }
                            "deleteOrphanProducts" => Ok(__FieldTag::__delete_orphan_products),
                            "delete_orphan_products" => Ok(__FieldTag::__delete_orphan_products),
                            "parent" => Ok(__FieldTag::__parent),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeProductsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeProductsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_set_purge_config => {
                            if !fields.insert(__FieldTag::__product_set_purge_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_set_purge_config",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.vision.v1.PurgeProductsRequest.product_set_purge_config, latest field was productSetPurgeConfig",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::purge_products_request::Target::ProductSetPurgeConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProductSetPurgeConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_orphan_products => {
                            if !fields.insert(__FieldTag::__delete_orphan_products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_orphan_products",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.vision.v1.PurgeProductsRequest.delete_orphan_products, latest field was deleteOrphanProducts",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::purge_products_request::Target::DeleteOrphanProducts(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeProductsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.product_set_purge_config() {
            state.serialize_entry("productSetPurgeConfig", value)?;
        }
        if let Some(value) = self.delete_orphan_products() {
            state.serialize_entry("deleteOrphanProducts", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeProductsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeProductsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("force", &self.force);
        debug_struct.field("target", &self.target);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PurgeProductsRequest].
pub mod purge_products_request {
    #[allow(unused_imports)]
    use super::*;

    /// The Products to delete.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Specify which ProductSet contains the Products to be deleted.
        ProductSetPurgeConfig(std::boxed::Box<crate::model::ProductSetPurgeConfig>),
        /// If delete_orphan_products is true, all Products that are not in any
        /// ProductSet will be deleted.
        DeleteOrphanProducts(bool),
    }
}

/// TextAnnotation contains a structured representation of OCR extracted text.
/// The hierarchy of an OCR extracted text structure is like this:
/// TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
/// Each structural component, starting from Page, may further have their own
/// properties. Properties describe detected languages, breaks etc.. Please refer
/// to the
/// [TextAnnotation.TextProperty][google.cloud.vision.v1.TextAnnotation.TextProperty]
/// message definition below for more detail.
///
/// [google.cloud.vision.v1.TextAnnotation.TextProperty]: crate::model::text_annotation::TextProperty
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TextAnnotation {
    /// List of pages detected by OCR.
    pub pages: std::vec::Vec<crate::model::Page>,

    /// UTF-8 text detected on the pages.
    pub text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pages][crate::model::TextAnnotation::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Page>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [text][crate::model::TextAnnotation::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

impl wkt::message::Message for TextAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.TextAnnotation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pages,
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pages" => Ok(__FieldTag::__pages),
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pages => {
                            if !fields.insert(__FieldTag::__pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pages",
                                ));
                            }
                            result.pages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Page>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TextAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pages.is_empty() {
            state.serialize_entry("pages", &self.pages)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TextAnnotation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TextAnnotation");
        debug_struct.field("pages", &self.pages);
        debug_struct.field("text", &self.text);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TextAnnotation].
pub mod text_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Detected language for a structural component.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DetectedLanguage {
        /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
        /// information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        pub language_code: std::string::String,

        /// Confidence of detected language. Range [0, 1].
        pub confidence: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectedLanguage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [language_code][crate::model::text_annotation::DetectedLanguage::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [confidence][crate::model::text_annotation::DetectedLanguage::confidence].
        pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence = v.into();
            self
        }
    }

    impl wkt::message::Message for DetectedLanguage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.DetectedLanguage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DetectedLanguage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __language_code,
                __confidence,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DetectedLanguage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "languageCode" => Ok(__FieldTag::__language_code),
                                "language_code" => Ok(__FieldTag::__language_code),
                                "confidence" => Ok(__FieldTag::__confidence),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DetectedLanguage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DetectedLanguage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__language_code => {
                                if !fields.insert(__FieldTag::__language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_code",
                                    ));
                                }
                                result.language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__confidence => {
                                if !fields.insert(__FieldTag::__confidence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.confidence =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DetectedLanguage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.language_code.is_empty() {
                state.serialize_entry("languageCode", &self.language_code)?;
            }
            if !wkt::internal::is_default(&self.confidence) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("confidence", &__With(&self.confidence))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DetectedLanguage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DetectedLanguage");
            debug_struct.field("language_code", &self.language_code);
            debug_struct.field("confidence", &self.confidence);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Detected start or end of a structural component.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DetectedBreak {
        /// Detected break type.
        pub r#type: crate::model::text_annotation::detected_break::BreakType,

        /// True if break prepends the element.
        pub is_prefix: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectedBreak {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::text_annotation::DetectedBreak::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::text_annotation::detected_break::BreakType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [is_prefix][crate::model::text_annotation::DetectedBreak::is_prefix].
        pub fn set_is_prefix<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for DetectedBreak {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.DetectedBreak"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DetectedBreak {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __is_prefix,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DetectedBreak")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "isPrefix" => Ok(__FieldTag::__is_prefix),
                                "is_prefix" => Ok(__FieldTag::__is_prefix),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DetectedBreak;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DetectedBreak")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::text_annotation::detected_break::BreakType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__is_prefix => {
                                if !fields.insert(__FieldTag::__is_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_prefix",
                                    ));
                                }
                                result.is_prefix = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DetectedBreak {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.is_prefix) {
                state.serialize_entry("isPrefix", &self.is_prefix)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DetectedBreak {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DetectedBreak");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("is_prefix", &self.is_prefix);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [DetectedBreak].
    pub mod detected_break {
        #[allow(unused_imports)]
        use super::*;

        /// Enum to denote the type of break found. New line, space etc.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BreakType {
            /// Unknown break label type.
            Unknown,
            /// Regular space.
            Space,
            /// Sure space (very wide).
            SureSpace,
            /// Line-wrapping break.
            EolSureSpace,
            /// End-line hyphen that is not present in text; does not co-occur with
            /// `SPACE`, `LEADER_SPACE`, or `LINE_BREAK`.
            Hyphen,
            /// Line break that ends a paragraph.
            LineBreak,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BreakType::value] or
            /// [BreakType::name].
            UnknownValue(break_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod break_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl BreakType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::Space => std::option::Option::Some(1),
                    Self::SureSpace => std::option::Option::Some(2),
                    Self::EolSureSpace => std::option::Option::Some(3),
                    Self::Hyphen => std::option::Option::Some(4),
                    Self::LineBreak => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Space => std::option::Option::Some("SPACE"),
                    Self::SureSpace => std::option::Option::Some("SURE_SPACE"),
                    Self::EolSureSpace => std::option::Option::Some("EOL_SURE_SPACE"),
                    Self::Hyphen => std::option::Option::Some("HYPHEN"),
                    Self::LineBreak => std::option::Option::Some("LINE_BREAK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for BreakType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for BreakType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for BreakType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::Space,
                    2 => Self::SureSpace,
                    3 => Self::EolSureSpace,
                    4 => Self::Hyphen,
                    5 => Self::LineBreak,
                    _ => Self::UnknownValue(break_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for BreakType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "SPACE" => Self::Space,
                    "SURE_SPACE" => Self::SureSpace,
                    "EOL_SURE_SPACE" => Self::EolSureSpace,
                    "HYPHEN" => Self::Hyphen,
                    "LINE_BREAK" => Self::LineBreak,
                    _ => Self::UnknownValue(break_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for BreakType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::Space => serializer.serialize_i32(1),
                    Self::SureSpace => serializer.serialize_i32(2),
                    Self::EolSureSpace => serializer.serialize_i32(3),
                    Self::Hyphen => serializer.serialize_i32(4),
                    Self::LineBreak => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for BreakType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BreakType>::new(
                    ".google.cloud.vision.v1.TextAnnotation.DetectedBreak.BreakType",
                ))
            }
        }
    }

    /// Additional information detected on the structural component.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TextProperty {
        /// A list of detected languages together with confidence.
        pub detected_languages: std::vec::Vec<crate::model::text_annotation::DetectedLanguage>,

        /// Detected start or end of a text segment.
        pub detected_break: std::option::Option<crate::model::text_annotation::DetectedBreak>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextProperty {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [detected_languages][crate::model::text_annotation::TextProperty::detected_languages].
        pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::text_annotation::DetectedLanguage>,
        {
            use std::iter::Iterator;
            self.detected_languages = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [detected_break][crate::model::text_annotation::TextProperty::detected_break].
        pub fn set_detected_break<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::text_annotation::DetectedBreak>,
        {
            self.detected_break = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [detected_break][crate::model::text_annotation::TextProperty::detected_break].
        pub fn set_or_clear_detected_break<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::text_annotation::DetectedBreak>,
        {
            self.detected_break = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TextProperty {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.TextProperty"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TextProperty {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __detected_languages,
                __detected_break,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TextProperty")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "detectedLanguages" => Ok(__FieldTag::__detected_languages),
                                "detected_languages" => Ok(__FieldTag::__detected_languages),
                                "detectedBreak" => Ok(__FieldTag::__detected_break),
                                "detected_break" => Ok(__FieldTag::__detected_break),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TextProperty;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TextProperty")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__detected_languages => {
                                if !fields.insert(__FieldTag::__detected_languages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detected_languages",
                                    ));
                                }
                                result.detected_languages = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::text_annotation::DetectedLanguage,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__detected_break => {
                                if !fields.insert(__FieldTag::__detected_break) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for detected_break",
                                    ));
                                }
                                result.detected_break = map.next_value::<std::option::Option<
                                    crate::model::text_annotation::DetectedBreak,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TextProperty {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.detected_languages.is_empty() {
                state.serialize_entry("detectedLanguages", &self.detected_languages)?;
            }
            if self.detected_break.is_some() {
                state.serialize_entry("detectedBreak", &self.detected_break)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TextProperty {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TextProperty");
            debug_struct.field("detected_languages", &self.detected_languages);
            debug_struct.field("detected_break", &self.detected_break);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Detected page from OCR.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Page {
    /// Additional information detected on the page.
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// Page width. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    pub width: i32,

    /// Page height. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    pub height: i32,

    /// List of blocks of text, images etc on this page.
    pub blocks: std::vec::Vec<crate::model::Block>,

    /// Confidence of the OCR results on the page. Range [0, 1].
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Page {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Page::property].
    pub fn set_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [property][crate::model::Page::property].
    pub fn set_or_clear_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = v.map(|x| x.into());
        self
    }

    /// Sets the value of [width][crate::model::Page::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }

    /// Sets the value of [height][crate::model::Page::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }

    /// Sets the value of [blocks][crate::model::Page::blocks].
    pub fn set_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Block>,
    {
        use std::iter::Iterator;
        self.blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::Page::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Page {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Page"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Page {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __property,
            __width,
            __height,
            __blocks,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Page")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "property" => Ok(__FieldTag::__property),
                            "width" => Ok(__FieldTag::__width),
                            "height" => Ok(__FieldTag::__height),
                            "blocks" => Ok(__FieldTag::__blocks),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Page;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Page")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__property => {
                            if !fields.insert(__FieldTag::__property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for property",
                                ));
                            }
                            result.property =
                                map.next_value::<std::option::Option<
                                    crate::model::text_annotation::TextProperty,
                                >>()?;
                        }
                        __FieldTag::__width => {
                            if !fields.insert(__FieldTag::__width) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__height => {
                            if !fields.insert(__FieldTag::__height) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__blocks => {
                            if !fields.insert(__FieldTag::__blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blocks",
                                ));
                            }
                            result.blocks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Block>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Page {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.property.is_some() {
            state.serialize_entry("property", &self.property)?;
        }
        if !wkt::internal::is_default(&self.width) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("width", &__With(&self.width))?;
        }
        if !wkt::internal::is_default(&self.height) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("height", &__With(&self.height))?;
        }
        if !self.blocks.is_empty() {
            state.serialize_entry("blocks", &self.blocks)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Page");
        debug_struct.field("property", &self.property);
        debug_struct.field("width", &self.width);
        debug_struct.field("height", &self.height);
        debug_struct.field("blocks", &self.blocks);
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Logical element on the page.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Block {
    /// Additional information detected for the block.
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the block.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///
    ///   and the vertex order will still be (0, 1, 2, 3).
    ///
    ///
    /// ```norust
    ///   0----1
    ///   |    |
    ///   3----2
    /// ```
    ///
    /// ```norust
    ///   2----3
    ///   |    |
    ///   1----0
    /// ```
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of paragraphs in this block (if this blocks is of type text).
    pub paragraphs: std::vec::Vec<crate::model::Paragraph>,

    /// Detected block type (text, image etc) for this block.
    pub block_type: crate::model::block::BlockType,

    /// Confidence of the OCR results on the block. Range [0, 1].
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Block {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Block::property].
    pub fn set_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [property][crate::model::Block::property].
    pub fn set_or_clear_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bounding_box][crate::model::Block::bounding_box].
    pub fn set_bounding_box<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_box][crate::model::Block::bounding_box].
    pub fn set_or_clear_bounding_box<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = v.map(|x| x.into());
        self
    }

    /// Sets the value of [paragraphs][crate::model::Block::paragraphs].
    pub fn set_paragraphs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Paragraph>,
    {
        use std::iter::Iterator;
        self.paragraphs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [block_type][crate::model::Block::block_type].
    pub fn set_block_type<T: std::convert::Into<crate::model::block::BlockType>>(
        mut self,
        v: T,
    ) -> Self {
        self.block_type = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Block::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Block {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Block"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Block {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __property,
            __bounding_box,
            __paragraphs,
            __block_type,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Block")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "property" => Ok(__FieldTag::__property),
                            "boundingBox" => Ok(__FieldTag::__bounding_box),
                            "bounding_box" => Ok(__FieldTag::__bounding_box),
                            "paragraphs" => Ok(__FieldTag::__paragraphs),
                            "blockType" => Ok(__FieldTag::__block_type),
                            "block_type" => Ok(__FieldTag::__block_type),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Block;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Block")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__property => {
                            if !fields.insert(__FieldTag::__property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for property",
                                ));
                            }
                            result.property =
                                map.next_value::<std::option::Option<
                                    crate::model::text_annotation::TextProperty,
                                >>()?;
                        }
                        __FieldTag::__bounding_box => {
                            if !fields.insert(__FieldTag::__bounding_box) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_box",
                                ));
                            }
                            result.bounding_box = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__paragraphs => {
                            if !fields.insert(__FieldTag::__paragraphs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paragraphs",
                                ));
                            }
                            result.paragraphs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Paragraph>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__block_type => {
                            if !fields.insert(__FieldTag::__block_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for block_type",
                                ));
                            }
                            result.block_type = map
                                .next_value::<std::option::Option<crate::model::block::BlockType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Block {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.property.is_some() {
            state.serialize_entry("property", &self.property)?;
        }
        if self.bounding_box.is_some() {
            state.serialize_entry("boundingBox", &self.bounding_box)?;
        }
        if !self.paragraphs.is_empty() {
            state.serialize_entry("paragraphs", &self.paragraphs)?;
        }
        if !wkt::internal::is_default(&self.block_type) {
            state.serialize_entry("blockType", &self.block_type)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Block");
        debug_struct.field("property", &self.property);
        debug_struct.field("bounding_box", &self.bounding_box);
        debug_struct.field("paragraphs", &self.paragraphs);
        debug_struct.field("block_type", &self.block_type);
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Block].
pub mod block {
    #[allow(unused_imports)]
    use super::*;

    /// Type of a block (text, image etc) as identified by OCR.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BlockType {
        /// Unknown block type.
        Unknown,
        /// Regular text block.
        Text,
        /// Table block.
        Table,
        /// Image block.
        Picture,
        /// Horizontal/vertical line box.
        Ruler,
        /// Barcode block.
        Barcode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BlockType::value] or
        /// [BlockType::name].
        UnknownValue(block_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod block_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BlockType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Text => std::option::Option::Some(1),
                Self::Table => std::option::Option::Some(2),
                Self::Picture => std::option::Option::Some(3),
                Self::Ruler => std::option::Option::Some(4),
                Self::Barcode => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Picture => std::option::Option::Some("PICTURE"),
                Self::Ruler => std::option::Option::Some("RULER"),
                Self::Barcode => std::option::Option::Some("BARCODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BlockType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BlockType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BlockType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Text,
                2 => Self::Table,
                3 => Self::Picture,
                4 => Self::Ruler,
                5 => Self::Barcode,
                _ => Self::UnknownValue(block_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BlockType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "TEXT" => Self::Text,
                "TABLE" => Self::Table,
                "PICTURE" => Self::Picture,
                "RULER" => Self::Ruler,
                "BARCODE" => Self::Barcode,
                _ => Self::UnknownValue(block_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BlockType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Text => serializer.serialize_i32(1),
                Self::Table => serializer.serialize_i32(2),
                Self::Picture => serializer.serialize_i32(3),
                Self::Ruler => serializer.serialize_i32(4),
                Self::Barcode => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BlockType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BlockType>::new(
                ".google.cloud.vision.v1.Block.BlockType",
            ))
        }
    }
}

/// Structural unit of text representing a number of words in certain order.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Paragraph {
    /// Additional information detected for the paragraph.
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the paragraph.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of all words in this paragraph.
    pub words: std::vec::Vec<crate::model::Word>,

    /// Confidence of the OCR results for the paragraph. Range [0, 1].
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Paragraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Paragraph::property].
    pub fn set_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [property][crate::model::Paragraph::property].
    pub fn set_or_clear_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bounding_box][crate::model::Paragraph::bounding_box].
    pub fn set_bounding_box<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_box][crate::model::Paragraph::bounding_box].
    pub fn set_or_clear_bounding_box<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = v.map(|x| x.into());
        self
    }

    /// Sets the value of [words][crate::model::Paragraph::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Word>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::Paragraph::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Paragraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Paragraph"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Paragraph {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __property,
            __bounding_box,
            __words,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Paragraph")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "property" => Ok(__FieldTag::__property),
                            "boundingBox" => Ok(__FieldTag::__bounding_box),
                            "bounding_box" => Ok(__FieldTag::__bounding_box),
                            "words" => Ok(__FieldTag::__words),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Paragraph;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Paragraph")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__property => {
                            if !fields.insert(__FieldTag::__property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for property",
                                ));
                            }
                            result.property =
                                map.next_value::<std::option::Option<
                                    crate::model::text_annotation::TextProperty,
                                >>()?;
                        }
                        __FieldTag::__bounding_box => {
                            if !fields.insert(__FieldTag::__bounding_box) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_box",
                                ));
                            }
                            result.bounding_box = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__words => {
                            if !fields.insert(__FieldTag::__words) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for words",
                                ));
                            }
                            result.words = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Word>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Paragraph {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.property.is_some() {
            state.serialize_entry("property", &self.property)?;
        }
        if self.bounding_box.is_some() {
            state.serialize_entry("boundingBox", &self.bounding_box)?;
        }
        if !self.words.is_empty() {
            state.serialize_entry("words", &self.words)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Paragraph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Paragraph");
        debug_struct.field("property", &self.property);
        debug_struct.field("bounding_box", &self.bounding_box);
        debug_struct.field("words", &self.words);
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A word representation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Word {
    /// Additional information detected for the word.
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the word.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of symbols in the word.
    /// The order of the symbols follows the natural reading order.
    pub symbols: std::vec::Vec<crate::model::Symbol>,

    /// Confidence of the OCR results for the word. Range [0, 1].
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Word {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Word::property].
    pub fn set_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [property][crate::model::Word::property].
    pub fn set_or_clear_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bounding_box][crate::model::Word::bounding_box].
    pub fn set_bounding_box<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_box][crate::model::Word::bounding_box].
    pub fn set_or_clear_bounding_box<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = v.map(|x| x.into());
        self
    }

    /// Sets the value of [symbols][crate::model::Word::symbols].
    pub fn set_symbols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Symbol>,
    {
        use std::iter::Iterator;
        self.symbols = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::Word::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Word {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Word"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Word {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __property,
            __bounding_box,
            __symbols,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Word")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "property" => Ok(__FieldTag::__property),
                            "boundingBox" => Ok(__FieldTag::__bounding_box),
                            "bounding_box" => Ok(__FieldTag::__bounding_box),
                            "symbols" => Ok(__FieldTag::__symbols),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Word;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Word")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__property => {
                            if !fields.insert(__FieldTag::__property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for property",
                                ));
                            }
                            result.property =
                                map.next_value::<std::option::Option<
                                    crate::model::text_annotation::TextProperty,
                                >>()?;
                        }
                        __FieldTag::__bounding_box => {
                            if !fields.insert(__FieldTag::__bounding_box) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_box",
                                ));
                            }
                            result.bounding_box = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__symbols => {
                            if !fields.insert(__FieldTag::__symbols) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for symbols",
                                ));
                            }
                            result.symbols = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Symbol>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Word {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.property.is_some() {
            state.serialize_entry("property", &self.property)?;
        }
        if self.bounding_box.is_some() {
            state.serialize_entry("boundingBox", &self.bounding_box)?;
        }
        if !self.symbols.is_empty() {
            state.serialize_entry("symbols", &self.symbols)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Word {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Word");
        debug_struct.field("property", &self.property);
        debug_struct.field("bounding_box", &self.bounding_box);
        debug_struct.field("symbols", &self.symbols);
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A single symbol representation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Symbol {
    /// Additional information detected for the symbol.
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the symbol.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// The actual UTF-8 representation of the symbol.
    pub text: std::string::String,

    /// Confidence of the OCR results for the symbol. Range [0, 1].
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Symbol {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Symbol::property].
    pub fn set_property<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [property][crate::model::Symbol::property].
    pub fn set_or_clear_property<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::text_annotation::TextProperty>,
    {
        self.property = v.map(|x| x.into());
        self
    }

    /// Sets the value of [bounding_box][crate::model::Symbol::bounding_box].
    pub fn set_bounding_box<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bounding_box][crate::model::Symbol::bounding_box].
    pub fn set_or_clear_bounding_box<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BoundingPoly>,
    {
        self.bounding_box = v.map(|x| x.into());
        self
    }

    /// Sets the value of [text][crate::model::Symbol::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Symbol::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Symbol {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Symbol"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Symbol {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __property,
            __bounding_box,
            __text,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Symbol")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "property" => Ok(__FieldTag::__property),
                            "boundingBox" => Ok(__FieldTag::__bounding_box),
                            "bounding_box" => Ok(__FieldTag::__bounding_box),
                            "text" => Ok(__FieldTag::__text),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Symbol;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Symbol")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__property => {
                            if !fields.insert(__FieldTag::__property) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for property",
                                ));
                            }
                            result.property =
                                map.next_value::<std::option::Option<
                                    crate::model::text_annotation::TextProperty,
                                >>()?;
                        }
                        __FieldTag::__bounding_box => {
                            if !fields.insert(__FieldTag::__bounding_box) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bounding_box",
                                ));
                            }
                            result.bounding_box = map
                                .next_value::<std::option::Option<crate::model::BoundingPoly>>()?;
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Symbol {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.property.is_some() {
            state.serialize_entry("property", &self.property)?;
        }
        if self.bounding_box.is_some() {
            state.serialize_entry("boundingBox", &self.bounding_box)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Symbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Symbol");
        debug_struct.field("property", &self.property);
        debug_struct.field("bounding_box", &self.bounding_box);
        debug_struct.field("text", &self.text);
        debug_struct.field("confidence", &self.confidence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Relevant information for the image from the Internet.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WebDetection {
    /// Deduced entities from similar images on the Internet.
    pub web_entities: std::vec::Vec<crate::model::web_detection::WebEntity>,

    /// Fully matching images from the Internet.
    /// Can include resized copies of the query image.
    pub full_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// Partial matching images from the Internet.
    /// Those images are similar enough to share some key-point features. For
    /// example an original image will likely have partial matching for its crops.
    pub partial_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// Web pages containing the matching images from the Internet.
    pub pages_with_matching_images: std::vec::Vec<crate::model::web_detection::WebPage>,

    /// The visually similar image results.
    pub visually_similar_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// The service's best guess as to the topic of the request image.
    /// Inferred from similar images on the open web.
    pub best_guess_labels: std::vec::Vec<crate::model::web_detection::WebLabel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebDetection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [web_entities][crate::model::WebDetection::web_entities].
    pub fn set_web_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebEntity>,
    {
        use std::iter::Iterator;
        self.web_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [full_matching_images][crate::model::WebDetection::full_matching_images].
    pub fn set_full_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.full_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_matching_images][crate::model::WebDetection::partial_matching_images].
    pub fn set_partial_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.partial_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pages_with_matching_images][crate::model::WebDetection::pages_with_matching_images].
    pub fn set_pages_with_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebPage>,
    {
        use std::iter::Iterator;
        self.pages_with_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [visually_similar_images][crate::model::WebDetection::visually_similar_images].
    pub fn set_visually_similar_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.visually_similar_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [best_guess_labels][crate::model::WebDetection::best_guess_labels].
    pub fn set_best_guess_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebLabel>,
    {
        use std::iter::Iterator;
        self.best_guess_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WebDetection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.WebDetection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebDetection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __web_entities,
            __full_matching_images,
            __partial_matching_images,
            __pages_with_matching_images,
            __visually_similar_images,
            __best_guess_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebDetection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "webEntities" => Ok(__FieldTag::__web_entities),
                            "web_entities" => Ok(__FieldTag::__web_entities),
                            "fullMatchingImages" => Ok(__FieldTag::__full_matching_images),
                            "full_matching_images" => Ok(__FieldTag::__full_matching_images),
                            "partialMatchingImages" => Ok(__FieldTag::__partial_matching_images),
                            "partial_matching_images" => Ok(__FieldTag::__partial_matching_images),
                            "pagesWithMatchingImages" => {
                                Ok(__FieldTag::__pages_with_matching_images)
                            }
                            "pages_with_matching_images" => {
                                Ok(__FieldTag::__pages_with_matching_images)
                            }
                            "visuallySimilarImages" => Ok(__FieldTag::__visually_similar_images),
                            "visually_similar_images" => Ok(__FieldTag::__visually_similar_images),
                            "bestGuessLabels" => Ok(__FieldTag::__best_guess_labels),
                            "best_guess_labels" => Ok(__FieldTag::__best_guess_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebDetection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebDetection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__web_entities => {
                            if !fields.insert(__FieldTag::__web_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for web_entities",
                                ));
                            }
                            result.web_entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebEntity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__full_matching_images => {
                            if !fields.insert(__FieldTag::__full_matching_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for full_matching_images",
                                ));
                            }
                            result.full_matching_images = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebImage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_matching_images => {
                            if !fields.insert(__FieldTag::__partial_matching_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_matching_images",
                                ));
                            }
                            result.partial_matching_images = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebImage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pages_with_matching_images => {
                            if !fields.insert(__FieldTag::__pages_with_matching_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pages_with_matching_images",
                                ));
                            }
                            result.pages_with_matching_images = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebPage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visually_similar_images => {
                            if !fields.insert(__FieldTag::__visually_similar_images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visually_similar_images",
                                ));
                            }
                            result.visually_similar_images = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebImage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__best_guess_labels => {
                            if !fields.insert(__FieldTag::__best_guess_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for best_guess_labels",
                                ));
                            }
                            result.best_guess_labels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::web_detection::WebLabel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WebDetection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.web_entities.is_empty() {
            state.serialize_entry("webEntities", &self.web_entities)?;
        }
        if !self.full_matching_images.is_empty() {
            state.serialize_entry("fullMatchingImages", &self.full_matching_images)?;
        }
        if !self.partial_matching_images.is_empty() {
            state.serialize_entry("partialMatchingImages", &self.partial_matching_images)?;
        }
        if !self.pages_with_matching_images.is_empty() {
            state.serialize_entry("pagesWithMatchingImages", &self.pages_with_matching_images)?;
        }
        if !self.visually_similar_images.is_empty() {
            state.serialize_entry("visuallySimilarImages", &self.visually_similar_images)?;
        }
        if !self.best_guess_labels.is_empty() {
            state.serialize_entry("bestGuessLabels", &self.best_guess_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WebDetection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WebDetection");
        debug_struct.field("web_entities", &self.web_entities);
        debug_struct.field("full_matching_images", &self.full_matching_images);
        debug_struct.field("partial_matching_images", &self.partial_matching_images);
        debug_struct.field(
            "pages_with_matching_images",
            &self.pages_with_matching_images,
        );
        debug_struct.field("visually_similar_images", &self.visually_similar_images);
        debug_struct.field("best_guess_labels", &self.best_guess_labels);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WebDetection].
pub mod web_detection {
    #[allow(unused_imports)]
    use super::*;

    /// Entity deduced from similar images on the Internet.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebEntity {
        /// Opaque entity ID.
        pub entity_id: std::string::String,

        /// Overall relevancy score for the entity.
        /// Not normalized and not comparable across different image queries.
        pub score: f32,

        /// Canonical description of the entity, in English.
        pub description: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::web_detection::WebEntity::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebEntity::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [description][crate::model::web_detection::WebEntity::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for WebEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebEntity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebEntity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __entity_id,
                __score,
                __description,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebEntity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "entityId" => Ok(__FieldTag::__entity_id),
                                "entity_id" => Ok(__FieldTag::__entity_id),
                                "score" => Ok(__FieldTag::__score),
                                "description" => Ok(__FieldTag::__description),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebEntity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebEntity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__entity_id => {
                                if !fields.insert(__FieldTag::__entity_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_id",
                                    ));
                                }
                                result.entity_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WebEntity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.entity_id.is_empty() {
                state.serialize_entry("entityId", &self.entity_id)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WebEntity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WebEntity");
            debug_struct.field("entity_id", &self.entity_id);
            debug_struct.field("score", &self.score);
            debug_struct.field("description", &self.description);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata for online images.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebImage {
        /// The result image URL.
        pub url: std::string::String,

        /// (Deprecated) Overall relevancy score for the image.
        pub score: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebImage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::web_detection::WebImage::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebImage::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }
    }

    impl wkt::message::Message for WebImage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebImage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebImage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __url,
                __score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebImage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "url" => Ok(__FieldTag::__url),
                                "score" => Ok(__FieldTag::__score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebImage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebImage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__url => {
                                if !fields.insert(__FieldTag::__url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for url",
                                    ));
                                }
                                result.url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WebImage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.url.is_empty() {
                state.serialize_entry("url", &self.url)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WebImage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WebImage");
            debug_struct.field("url", &self.url);
            debug_struct.field("score", &self.score);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Metadata for web pages.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebPage {
        /// The result web page URL.
        pub url: std::string::String,

        /// (Deprecated) Overall relevancy score for the web page.
        pub score: f32,

        /// Title for the web page, may contain HTML markups.
        pub page_title: std::string::String,

        /// Fully matching images on the page.
        /// Can include resized copies of the query image.
        pub full_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

        /// Partial matching images on the page.
        /// Those images are similar enough to share some key-point features. For
        /// example an original image will likely have partial matching for its
        /// crops.
        pub partial_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebPage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::web_detection::WebPage::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebPage::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [page_title][crate::model::web_detection::WebPage::page_title].
        pub fn set_page_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.page_title = v.into();
            self
        }

        /// Sets the value of [full_matching_images][crate::model::web_detection::WebPage::full_matching_images].
        pub fn set_full_matching_images<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::web_detection::WebImage>,
        {
            use std::iter::Iterator;
            self.full_matching_images = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [partial_matching_images][crate::model::web_detection::WebPage::partial_matching_images].
        pub fn set_partial_matching_images<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::web_detection::WebImage>,
        {
            use std::iter::Iterator;
            self.partial_matching_images = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WebPage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebPage"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebPage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __url,
                __score,
                __page_title,
                __full_matching_images,
                __partial_matching_images,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebPage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "url" => Ok(__FieldTag::__url),
                                "score" => Ok(__FieldTag::__score),
                                "pageTitle" => Ok(__FieldTag::__page_title),
                                "page_title" => Ok(__FieldTag::__page_title),
                                "fullMatchingImages" => Ok(__FieldTag::__full_matching_images),
                                "full_matching_images" => Ok(__FieldTag::__full_matching_images),
                                "partialMatchingImages" => {
                                    Ok(__FieldTag::__partial_matching_images)
                                }
                                "partial_matching_images" => {
                                    Ok(__FieldTag::__partial_matching_images)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebPage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebPage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__url => {
                                if !fields.insert(__FieldTag::__url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for url",
                                    ));
                                }
                                result.url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__page_title => {
                                if !fields.insert(__FieldTag::__page_title) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for page_title",
                                    ));
                                }
                                result.page_title = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__full_matching_images => {
                                if !fields.insert(__FieldTag::__full_matching_images) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_matching_images",
                                    ));
                                }
                                result.full_matching_images = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::web_detection::WebImage>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__partial_matching_images => {
                                if !fields.insert(__FieldTag::__partial_matching_images) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partial_matching_images",
                                    ));
                                }
                                result.partial_matching_images = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::web_detection::WebImage>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WebPage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.url.is_empty() {
                state.serialize_entry("url", &self.url)?;
            }
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !self.page_title.is_empty() {
                state.serialize_entry("pageTitle", &self.page_title)?;
            }
            if !self.full_matching_images.is_empty() {
                state.serialize_entry("fullMatchingImages", &self.full_matching_images)?;
            }
            if !self.partial_matching_images.is_empty() {
                state.serialize_entry("partialMatchingImages", &self.partial_matching_images)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WebPage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WebPage");
            debug_struct.field("url", &self.url);
            debug_struct.field("score", &self.score);
            debug_struct.field("page_title", &self.page_title);
            debug_struct.field("full_matching_images", &self.full_matching_images);
            debug_struct.field("partial_matching_images", &self.partial_matching_images);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Label to provide extra metadata for the web detection.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebLabel {
        /// Label for extra metadata.
        pub label: std::string::String,

        /// The BCP-47 language code for `label`, such as "en-US" or "sr-Latn".
        /// For more information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        pub language_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebLabel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [label][crate::model::web_detection::WebLabel::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::web_detection::WebLabel::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }
    }

    impl wkt::message::Message for WebLabel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebLabel"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebLabel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __label,
                __language_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebLabel")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "label" => Ok(__FieldTag::__label),
                                "languageCode" => Ok(__FieldTag::__language_code),
                                "language_code" => Ok(__FieldTag::__language_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebLabel;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebLabel")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__label => {
                                if !fields.insert(__FieldTag::__label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for label",
                                    ));
                                }
                                result.label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__language_code => {
                                if !fields.insert(__FieldTag::__language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_code",
                                    ));
                                }
                                result.language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WebLabel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.label.is_empty() {
                state.serialize_entry("label", &self.label)?;
            }
            if !self.language_code.is_empty() {
                state.serialize_entry("languageCode", &self.language_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for WebLabel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("WebLabel");
            debug_struct.field("label", &self.label);
            debug_struct.field("language_code", &self.language_code);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A bucketized representation of likelihood, which is intended to give clients
/// highly stable results across model upgrades.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Likelihood {
    /// Unknown likelihood.
    Unknown,
    /// It is very unlikely.
    VeryUnlikely,
    /// It is unlikely.
    Unlikely,
    /// It is possible.
    Possible,
    /// It is likely.
    Likely,
    /// It is very likely.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Likelihood::value] or
    /// [Likelihood::name].
    UnknownValue(likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Likelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unknown => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unknown => std::option::Option::Some("UNKNOWN"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Likelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Likelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Likelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unknown,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Likelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNKNOWN" => Self::Unknown,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Likelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unknown => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Likelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Likelihood>::new(
            ".google.cloud.vision.v1.Likelihood",
        ))
    }
}
