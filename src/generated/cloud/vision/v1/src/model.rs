// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A vertex represents a 2D point in the image.
/// NOTE: the vertex coordinates are in the same scale as the original image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Vertex {
    /// X coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub x: i32,

    /// Y coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub y: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Vertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Vertex::x].
    pub fn set_x<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Vertex::y].
    pub fn set_y<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for Vertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Vertex"
    }
}

/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NormalizedVertex {
    /// X coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub x: f32,

    /// Y coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub y: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NormalizedVertex {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::NormalizedVertex::x].
    pub fn set_x<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::NormalizedVertex::y].
    pub fn set_y<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }
}

impl wkt::message::Message for NormalizedVertex {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.NormalizedVertex"
    }
}

/// A bounding polygon for the detected image annotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BoundingPoly {
    /// The bounding polygon vertices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vertices: std::vec::Vec<crate::model::Vertex>,

    /// The bounding polygon normalized vertices.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub normalized_vertices: std::vec::Vec<crate::model::NormalizedVertex>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BoundingPoly {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vertices][crate::model::BoundingPoly::vertices].
    pub fn set_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Vertex>,
    {
        use std::iter::Iterator;
        self.vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [normalized_vertices][crate::model::BoundingPoly::normalized_vertices].
    pub fn set_normalized_vertices<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NormalizedVertex>,
    {
        use std::iter::Iterator;
        self.normalized_vertices = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BoundingPoly {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BoundingPoly"
    }
}

/// A 3D position in the image, used primarily for Face detection landmarks.
/// A valid Position must have both x and y coordinates.
/// The position coordinates are in the same scale as the original image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Position {
    /// X coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub x: f32,

    /// Y coordinate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub y: f32,

    /// Z coordinate (or depth).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub z: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Position {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [x][crate::model::Position::x].
    pub fn set_x<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Position::y].
    pub fn set_y<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [z][crate::model::Position::z].
    pub fn set_z<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.z = v.into();
        self
    }
}

impl wkt::message::Message for Position {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Position"
    }
}

/// The type of Google Cloud Vision API detection to perform, and the maximum
/// number of results to return for that type. Multiple `Feature` objects can
/// be specified in the `features` list.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Feature {
    /// The feature type.
    #[serde(rename = "type")]
    pub r#type: crate::model::feature::Type,

    /// Maximum number of results of this type. Does not apply to
    /// `TEXT_DETECTION`, `DOCUMENT_TEXT_DETECTION`, or `CROP_HINTS`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_results: i32,

    /// Model to use for the feature.
    /// Supported values: "builtin/stable" (the default if unset) and
    /// "builtin/latest". `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` also
    /// support "builtin/weekly" for the bleeding edge release updated weekly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Feature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Feature::type].
    pub fn set_type<T: std::convert::Into<crate::model::feature::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::Feature::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Feature::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for Feature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Feature"
    }
}

/// Defines additional types related to [Feature].
pub mod feature {
    #[allow(unused_imports)]
    use super::*;

    /// Type of Google Cloud Vision API feature to be extracted.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified feature type.
        Unspecified,
        /// Run face detection.
        FaceDetection,
        /// Run landmark detection.
        LandmarkDetection,
        /// Run logo detection.
        LogoDetection,
        /// Run label detection.
        LabelDetection,
        /// Run text detection / optical character recognition (OCR). Text detection
        /// is optimized for areas of text within a larger image; if the image is
        /// a document, use `DOCUMENT_TEXT_DETECTION` instead.
        TextDetection,
        /// Run dense text document OCR. Takes precedence when both
        /// `DOCUMENT_TEXT_DETECTION` and `TEXT_DETECTION` are present.
        DocumentTextDetection,
        /// Run Safe Search to detect potentially unsafe
        /// or undesirable content.
        SafeSearchDetection,
        /// Compute a set of image properties, such as the
        /// image's dominant colors.
        ImageProperties,
        /// Run crop hints.
        CropHints,
        /// Run web detection.
        WebDetection,
        /// Run Product Search.
        ProductSearch,
        /// Run localizer for object detection.
        ObjectLocalization,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::FaceDetection => std::option::Option::Some(1),
                Self::LandmarkDetection => std::option::Option::Some(2),
                Self::LogoDetection => std::option::Option::Some(3),
                Self::LabelDetection => std::option::Option::Some(4),
                Self::TextDetection => std::option::Option::Some(5),
                Self::DocumentTextDetection => std::option::Option::Some(11),
                Self::SafeSearchDetection => std::option::Option::Some(6),
                Self::ImageProperties => std::option::Option::Some(7),
                Self::CropHints => std::option::Option::Some(9),
                Self::WebDetection => std::option::Option::Some(10),
                Self::ProductSearch => std::option::Option::Some(12),
                Self::ObjectLocalization => std::option::Option::Some(19),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::FaceDetection => std::option::Option::Some("FACE_DETECTION"),
                Self::LandmarkDetection => std::option::Option::Some("LANDMARK_DETECTION"),
                Self::LogoDetection => std::option::Option::Some("LOGO_DETECTION"),
                Self::LabelDetection => std::option::Option::Some("LABEL_DETECTION"),
                Self::TextDetection => std::option::Option::Some("TEXT_DETECTION"),
                Self::DocumentTextDetection => std::option::Option::Some("DOCUMENT_TEXT_DETECTION"),
                Self::SafeSearchDetection => std::option::Option::Some("SAFE_SEARCH_DETECTION"),
                Self::ImageProperties => std::option::Option::Some("IMAGE_PROPERTIES"),
                Self::CropHints => std::option::Option::Some("CROP_HINTS"),
                Self::WebDetection => std::option::Option::Some("WEB_DETECTION"),
                Self::ProductSearch => std::option::Option::Some("PRODUCT_SEARCH"),
                Self::ObjectLocalization => std::option::Option::Some("OBJECT_LOCALIZATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::FaceDetection,
                2 => Self::LandmarkDetection,
                3 => Self::LogoDetection,
                4 => Self::LabelDetection,
                5 => Self::TextDetection,
                6 => Self::SafeSearchDetection,
                7 => Self::ImageProperties,
                9 => Self::CropHints,
                10 => Self::WebDetection,
                11 => Self::DocumentTextDetection,
                12 => Self::ProductSearch,
                19 => Self::ObjectLocalization,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "FACE_DETECTION" => Self::FaceDetection,
                "LANDMARK_DETECTION" => Self::LandmarkDetection,
                "LOGO_DETECTION" => Self::LogoDetection,
                "LABEL_DETECTION" => Self::LabelDetection,
                "TEXT_DETECTION" => Self::TextDetection,
                "DOCUMENT_TEXT_DETECTION" => Self::DocumentTextDetection,
                "SAFE_SEARCH_DETECTION" => Self::SafeSearchDetection,
                "IMAGE_PROPERTIES" => Self::ImageProperties,
                "CROP_HINTS" => Self::CropHints,
                "WEB_DETECTION" => Self::WebDetection,
                "PRODUCT_SEARCH" => Self::ProductSearch,
                "OBJECT_LOCALIZATION" => Self::ObjectLocalization,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::FaceDetection => serializer.serialize_i32(1),
                Self::LandmarkDetection => serializer.serialize_i32(2),
                Self::LogoDetection => serializer.serialize_i32(3),
                Self::LabelDetection => serializer.serialize_i32(4),
                Self::TextDetection => serializer.serialize_i32(5),
                Self::DocumentTextDetection => serializer.serialize_i32(11),
                Self::SafeSearchDetection => serializer.serialize_i32(6),
                Self::ImageProperties => serializer.serialize_i32(7),
                Self::CropHints => serializer.serialize_i32(9),
                Self::WebDetection => serializer.serialize_i32(10),
                Self::ProductSearch => serializer.serialize_i32(12),
                Self::ObjectLocalization => serializer.serialize_i32(19),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vision.v1.Feature.Type",
            ))
        }
    }
}

/// External image source (Google Cloud Storage or web URL image location).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageSource {
    /// **Use `image_uri` instead.**
    ///
    /// The Google Cloud Storage  URI of the form
    /// `gs://bucket_name/object_name`. Object versioning is not supported. See
    /// [Google Cloud Storage Request
    /// URIs](https://cloud.google.com/storage/docs/reference-uris) for more info.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_image_uri: std::string::String,

    /// The URI of the source image. Can be either:
    ///
    /// . A Google Cloud Storage URI of the form
    ///   `gs://bucket_name/object_name`. Object versioning is not supported. See
    ///   [Google Cloud Storage Request
    ///   URIs](https://cloud.google.com/storage/docs/reference-uris) for more
    ///   info.
    ///
    /// . A publicly-accessible image HTTP/HTTPS URL. When fetching images from
    ///   HTTP/HTTPS URLs, Google cannot guarantee that the request will be
    ///   completed. Your request may fail if the specified host denies the
    ///   request (e.g. due to request throttling or DOS prevention), or if Google
    ///   throttles requests to the site for abuse prevention. You should not
    ///   depend on externally-hosted images for production applications.
    ///
    ///
    /// When both `gcs_image_uri` and `image_uri` are specified, `image_uri` takes
    /// precedence.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_image_uri][crate::model::ImageSource::gcs_image_uri].
    pub fn set_gcs_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_image_uri = v.into();
        self
    }

    /// Sets the value of [image_uri][crate::model::ImageSource::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }
}

impl wkt::message::Message for ImageSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageSource"
    }
}

/// Client image to perform Google Cloud Vision API tasks over.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Image {
    /// Image content, represented as a stream of bytes.
    /// Note: As with all `bytes` fields, protobuffers use a pure binary
    /// representation, whereas JSON representations use base64.
    ///
    /// Currently, this field only works for BatchAnnotateImages requests. It does
    /// not work for AsyncBatchAnnotateImages requests.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub content: ::bytes::Bytes,

    /// Google Cloud Storage image location, or publicly-accessible image
    /// URL. If both `content` and `source` are provided for an image, `content`
    /// takes precedence and is used to perform the image annotation request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::ImageSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Image {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::Image::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Image::source].
    pub fn set_source<T: std::convert::Into<std::option::Option<crate::model::ImageSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for Image {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Image"
    }
}

/// A face annotation object contains the results of face detection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FaceAnnotation {
    /// The bounding polygon around the face. The coordinates of the bounding box
    /// are in the original image's scale.
    /// The bounding box is computed to "frame" the face in accordance with human
    /// expectations. It is based on the landmarker results.
    /// Note that one or more x and/or y coordinates may not be generated in the
    /// `BoundingPoly` (the polygon will be unbounded) if only a partial face
    /// appears in the image to be annotated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The `fd_bounding_poly` bounding polygon is tighter than the
    /// `boundingPoly`, and encloses only the skin part of the face. Typically, it
    /// is used to eliminate the face from any image analysis that detects the
    /// "amount of skin" visible in an image. It is not based on the
    /// landmarker results, only on the initial face detection, hence
    /// the \<code\>fd\</code\> (face detection) prefix.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fd_bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// Detected face landmarks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub landmarks: std::vec::Vec<crate::model::face_annotation::Landmark>,

    /// Roll angle, which indicates the amount of clockwise/anti-clockwise rotation
    /// of the face relative to the image vertical about the axis perpendicular to
    /// the face. Range [-180,180].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub roll_angle: f32,

    /// Yaw angle, which indicates the leftward/rightward angle that the face is
    /// pointing relative to the vertical plane perpendicular to the image. Range
    /// [-180,180].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub pan_angle: f32,

    /// Pitch angle, which indicates the upwards/downwards angle that the face is
    /// pointing relative to the image's horizontal plane. Range [-180,180].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub tilt_angle: f32,

    /// Detection confidence. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub detection_confidence: f32,

    /// Face landmarking confidence. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub landmarking_confidence: f32,

    /// Joy likelihood.
    pub joy_likelihood: crate::model::Likelihood,

    /// Sorrow likelihood.
    pub sorrow_likelihood: crate::model::Likelihood,

    /// Anger likelihood.
    pub anger_likelihood: crate::model::Likelihood,

    /// Surprise likelihood.
    pub surprise_likelihood: crate::model::Likelihood,

    /// Under-exposed likelihood.
    pub under_exposed_likelihood: crate::model::Likelihood,

    /// Blurred likelihood.
    pub blurred_likelihood: crate::model::Likelihood,

    /// Headwear likelihood.
    pub headwear_likelihood: crate::model::Likelihood,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FaceAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::FaceAnnotation::bounding_poly].
    pub fn set_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_poly = v.into();
        self
    }

    /// Sets the value of [fd_bounding_poly][crate::model::FaceAnnotation::fd_bounding_poly].
    pub fn set_fd_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.fd_bounding_poly = v.into();
        self
    }

    /// Sets the value of [roll_angle][crate::model::FaceAnnotation::roll_angle].
    pub fn set_roll_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.roll_angle = v.into();
        self
    }

    /// Sets the value of [pan_angle][crate::model::FaceAnnotation::pan_angle].
    pub fn set_pan_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.pan_angle = v.into();
        self
    }

    /// Sets the value of [tilt_angle][crate::model::FaceAnnotation::tilt_angle].
    pub fn set_tilt_angle<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.tilt_angle = v.into();
        self
    }

    /// Sets the value of [detection_confidence][crate::model::FaceAnnotation::detection_confidence].
    pub fn set_detection_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.detection_confidence = v.into();
        self
    }

    /// Sets the value of [landmarking_confidence][crate::model::FaceAnnotation::landmarking_confidence].
    pub fn set_landmarking_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.landmarking_confidence = v.into();
        self
    }

    /// Sets the value of [joy_likelihood][crate::model::FaceAnnotation::joy_likelihood].
    pub fn set_joy_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.joy_likelihood = v.into();
        self
    }

    /// Sets the value of [sorrow_likelihood][crate::model::FaceAnnotation::sorrow_likelihood].
    pub fn set_sorrow_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.sorrow_likelihood = v.into();
        self
    }

    /// Sets the value of [anger_likelihood][crate::model::FaceAnnotation::anger_likelihood].
    pub fn set_anger_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.anger_likelihood = v.into();
        self
    }

    /// Sets the value of [surprise_likelihood][crate::model::FaceAnnotation::surprise_likelihood].
    pub fn set_surprise_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.surprise_likelihood = v.into();
        self
    }

    /// Sets the value of [under_exposed_likelihood][crate::model::FaceAnnotation::under_exposed_likelihood].
    pub fn set_under_exposed_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.under_exposed_likelihood = v.into();
        self
    }

    /// Sets the value of [blurred_likelihood][crate::model::FaceAnnotation::blurred_likelihood].
    pub fn set_blurred_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.blurred_likelihood = v.into();
        self
    }

    /// Sets the value of [headwear_likelihood][crate::model::FaceAnnotation::headwear_likelihood].
    pub fn set_headwear_likelihood<T: std::convert::Into<crate::model::Likelihood>>(
        mut self,
        v: T,
    ) -> Self {
        self.headwear_likelihood = v.into();
        self
    }

    /// Sets the value of [landmarks][crate::model::FaceAnnotation::landmarks].
    pub fn set_landmarks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::face_annotation::Landmark>,
    {
        use std::iter::Iterator;
        self.landmarks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FaceAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.FaceAnnotation"
    }
}

/// Defines additional types related to [FaceAnnotation].
pub mod face_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// A face-specific landmark (for example, a face feature).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Landmark {
        /// Face landmark type.
        #[serde(rename = "type")]
        pub r#type: crate::model::face_annotation::landmark::Type,

        /// Face landmark position.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub position: std::option::Option<crate::model::Position>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Landmark {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::face_annotation::Landmark::type].
        pub fn set_type<T: std::convert::Into<crate::model::face_annotation::landmark::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [position][crate::model::face_annotation::Landmark::position].
        pub fn set_position<T: std::convert::Into<std::option::Option<crate::model::Position>>>(
            mut self,
            v: T,
        ) -> Self {
            self.position = v.into();
            self
        }
    }

    impl wkt::message::Message for Landmark {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.FaceAnnotation.Landmark"
        }
    }

    /// Defines additional types related to [Landmark].
    pub mod landmark {
        #[allow(unused_imports)]
        use super::*;

        /// Face landmark (feature) type.
        /// Left and right are defined from the vantage of the viewer of the image
        /// without considering mirror projections typical of photos. So, `LEFT_EYE`,
        /// typically, is the person's right eye.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unknown face landmark detected. Should not be filled.
            UnknownLandmark,
            /// Left eye.
            LeftEye,
            /// Right eye.
            RightEye,
            /// Left of left eyebrow.
            LeftOfLeftEyebrow,
            /// Right of left eyebrow.
            RightOfLeftEyebrow,
            /// Left of right eyebrow.
            LeftOfRightEyebrow,
            /// Right of right eyebrow.
            RightOfRightEyebrow,
            /// Midpoint between eyes.
            MidpointBetweenEyes,
            /// Nose tip.
            NoseTip,
            /// Upper lip.
            UpperLip,
            /// Lower lip.
            LowerLip,
            /// Mouth left.
            MouthLeft,
            /// Mouth right.
            MouthRight,
            /// Mouth center.
            MouthCenter,
            /// Nose, bottom right.
            NoseBottomRight,
            /// Nose, bottom left.
            NoseBottomLeft,
            /// Nose, bottom center.
            NoseBottomCenter,
            /// Left eye, top boundary.
            LeftEyeTopBoundary,
            /// Left eye, right corner.
            LeftEyeRightCorner,
            /// Left eye, bottom boundary.
            LeftEyeBottomBoundary,
            /// Left eye, left corner.
            LeftEyeLeftCorner,
            /// Right eye, top boundary.
            RightEyeTopBoundary,
            /// Right eye, right corner.
            RightEyeRightCorner,
            /// Right eye, bottom boundary.
            RightEyeBottomBoundary,
            /// Right eye, left corner.
            RightEyeLeftCorner,
            /// Left eyebrow, upper midpoint.
            LeftEyebrowUpperMidpoint,
            /// Right eyebrow, upper midpoint.
            RightEyebrowUpperMidpoint,
            /// Left ear tragion.
            LeftEarTragion,
            /// Right ear tragion.
            RightEarTragion,
            /// Left eye pupil.
            LeftEyePupil,
            /// Right eye pupil.
            RightEyePupil,
            /// Forehead glabella.
            ForeheadGlabella,
            /// Chin gnathion.
            ChinGnathion,
            /// Chin left gonion.
            ChinLeftGonion,
            /// Chin right gonion.
            ChinRightGonion,
            /// Left cheek center.
            LeftCheekCenter,
            /// Right cheek center.
            RightCheekCenter,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::UnknownLandmark => std::option::Option::Some(0),
                    Self::LeftEye => std::option::Option::Some(1),
                    Self::RightEye => std::option::Option::Some(2),
                    Self::LeftOfLeftEyebrow => std::option::Option::Some(3),
                    Self::RightOfLeftEyebrow => std::option::Option::Some(4),
                    Self::LeftOfRightEyebrow => std::option::Option::Some(5),
                    Self::RightOfRightEyebrow => std::option::Option::Some(6),
                    Self::MidpointBetweenEyes => std::option::Option::Some(7),
                    Self::NoseTip => std::option::Option::Some(8),
                    Self::UpperLip => std::option::Option::Some(9),
                    Self::LowerLip => std::option::Option::Some(10),
                    Self::MouthLeft => std::option::Option::Some(11),
                    Self::MouthRight => std::option::Option::Some(12),
                    Self::MouthCenter => std::option::Option::Some(13),
                    Self::NoseBottomRight => std::option::Option::Some(14),
                    Self::NoseBottomLeft => std::option::Option::Some(15),
                    Self::NoseBottomCenter => std::option::Option::Some(16),
                    Self::LeftEyeTopBoundary => std::option::Option::Some(17),
                    Self::LeftEyeRightCorner => std::option::Option::Some(18),
                    Self::LeftEyeBottomBoundary => std::option::Option::Some(19),
                    Self::LeftEyeLeftCorner => std::option::Option::Some(20),
                    Self::RightEyeTopBoundary => std::option::Option::Some(21),
                    Self::RightEyeRightCorner => std::option::Option::Some(22),
                    Self::RightEyeBottomBoundary => std::option::Option::Some(23),
                    Self::RightEyeLeftCorner => std::option::Option::Some(24),
                    Self::LeftEyebrowUpperMidpoint => std::option::Option::Some(25),
                    Self::RightEyebrowUpperMidpoint => std::option::Option::Some(26),
                    Self::LeftEarTragion => std::option::Option::Some(27),
                    Self::RightEarTragion => std::option::Option::Some(28),
                    Self::LeftEyePupil => std::option::Option::Some(29),
                    Self::RightEyePupil => std::option::Option::Some(30),
                    Self::ForeheadGlabella => std::option::Option::Some(31),
                    Self::ChinGnathion => std::option::Option::Some(32),
                    Self::ChinLeftGonion => std::option::Option::Some(33),
                    Self::ChinRightGonion => std::option::Option::Some(34),
                    Self::LeftCheekCenter => std::option::Option::Some(35),
                    Self::RightCheekCenter => std::option::Option::Some(36),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::UnknownLandmark => std::option::Option::Some("UNKNOWN_LANDMARK"),
                    Self::LeftEye => std::option::Option::Some("LEFT_EYE"),
                    Self::RightEye => std::option::Option::Some("RIGHT_EYE"),
                    Self::LeftOfLeftEyebrow => std::option::Option::Some("LEFT_OF_LEFT_EYEBROW"),
                    Self::RightOfLeftEyebrow => std::option::Option::Some("RIGHT_OF_LEFT_EYEBROW"),
                    Self::LeftOfRightEyebrow => std::option::Option::Some("LEFT_OF_RIGHT_EYEBROW"),
                    Self::RightOfRightEyebrow => {
                        std::option::Option::Some("RIGHT_OF_RIGHT_EYEBROW")
                    }
                    Self::MidpointBetweenEyes => std::option::Option::Some("MIDPOINT_BETWEEN_EYES"),
                    Self::NoseTip => std::option::Option::Some("NOSE_TIP"),
                    Self::UpperLip => std::option::Option::Some("UPPER_LIP"),
                    Self::LowerLip => std::option::Option::Some("LOWER_LIP"),
                    Self::MouthLeft => std::option::Option::Some("MOUTH_LEFT"),
                    Self::MouthRight => std::option::Option::Some("MOUTH_RIGHT"),
                    Self::MouthCenter => std::option::Option::Some("MOUTH_CENTER"),
                    Self::NoseBottomRight => std::option::Option::Some("NOSE_BOTTOM_RIGHT"),
                    Self::NoseBottomLeft => std::option::Option::Some("NOSE_BOTTOM_LEFT"),
                    Self::NoseBottomCenter => std::option::Option::Some("NOSE_BOTTOM_CENTER"),
                    Self::LeftEyeTopBoundary => std::option::Option::Some("LEFT_EYE_TOP_BOUNDARY"),
                    Self::LeftEyeRightCorner => std::option::Option::Some("LEFT_EYE_RIGHT_CORNER"),
                    Self::LeftEyeBottomBoundary => {
                        std::option::Option::Some("LEFT_EYE_BOTTOM_BOUNDARY")
                    }
                    Self::LeftEyeLeftCorner => std::option::Option::Some("LEFT_EYE_LEFT_CORNER"),
                    Self::RightEyeTopBoundary => {
                        std::option::Option::Some("RIGHT_EYE_TOP_BOUNDARY")
                    }
                    Self::RightEyeRightCorner => {
                        std::option::Option::Some("RIGHT_EYE_RIGHT_CORNER")
                    }
                    Self::RightEyeBottomBoundary => {
                        std::option::Option::Some("RIGHT_EYE_BOTTOM_BOUNDARY")
                    }
                    Self::RightEyeLeftCorner => std::option::Option::Some("RIGHT_EYE_LEFT_CORNER"),
                    Self::LeftEyebrowUpperMidpoint => {
                        std::option::Option::Some("LEFT_EYEBROW_UPPER_MIDPOINT")
                    }
                    Self::RightEyebrowUpperMidpoint => {
                        std::option::Option::Some("RIGHT_EYEBROW_UPPER_MIDPOINT")
                    }
                    Self::LeftEarTragion => std::option::Option::Some("LEFT_EAR_TRAGION"),
                    Self::RightEarTragion => std::option::Option::Some("RIGHT_EAR_TRAGION"),
                    Self::LeftEyePupil => std::option::Option::Some("LEFT_EYE_PUPIL"),
                    Self::RightEyePupil => std::option::Option::Some("RIGHT_EYE_PUPIL"),
                    Self::ForeheadGlabella => std::option::Option::Some("FOREHEAD_GLABELLA"),
                    Self::ChinGnathion => std::option::Option::Some("CHIN_GNATHION"),
                    Self::ChinLeftGonion => std::option::Option::Some("CHIN_LEFT_GONION"),
                    Self::ChinRightGonion => std::option::Option::Some("CHIN_RIGHT_GONION"),
                    Self::LeftCheekCenter => std::option::Option::Some("LEFT_CHEEK_CENTER"),
                    Self::RightCheekCenter => std::option::Option::Some("RIGHT_CHEEK_CENTER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::UnknownLandmark,
                    1 => Self::LeftEye,
                    2 => Self::RightEye,
                    3 => Self::LeftOfLeftEyebrow,
                    4 => Self::RightOfLeftEyebrow,
                    5 => Self::LeftOfRightEyebrow,
                    6 => Self::RightOfRightEyebrow,
                    7 => Self::MidpointBetweenEyes,
                    8 => Self::NoseTip,
                    9 => Self::UpperLip,
                    10 => Self::LowerLip,
                    11 => Self::MouthLeft,
                    12 => Self::MouthRight,
                    13 => Self::MouthCenter,
                    14 => Self::NoseBottomRight,
                    15 => Self::NoseBottomLeft,
                    16 => Self::NoseBottomCenter,
                    17 => Self::LeftEyeTopBoundary,
                    18 => Self::LeftEyeRightCorner,
                    19 => Self::LeftEyeBottomBoundary,
                    20 => Self::LeftEyeLeftCorner,
                    21 => Self::RightEyeTopBoundary,
                    22 => Self::RightEyeRightCorner,
                    23 => Self::RightEyeBottomBoundary,
                    24 => Self::RightEyeLeftCorner,
                    25 => Self::LeftEyebrowUpperMidpoint,
                    26 => Self::RightEyebrowUpperMidpoint,
                    27 => Self::LeftEarTragion,
                    28 => Self::RightEarTragion,
                    29 => Self::LeftEyePupil,
                    30 => Self::RightEyePupil,
                    31 => Self::ForeheadGlabella,
                    32 => Self::ChinGnathion,
                    33 => Self::ChinLeftGonion,
                    34 => Self::ChinRightGonion,
                    35 => Self::LeftCheekCenter,
                    36 => Self::RightCheekCenter,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN_LANDMARK" => Self::UnknownLandmark,
                    "LEFT_EYE" => Self::LeftEye,
                    "RIGHT_EYE" => Self::RightEye,
                    "LEFT_OF_LEFT_EYEBROW" => Self::LeftOfLeftEyebrow,
                    "RIGHT_OF_LEFT_EYEBROW" => Self::RightOfLeftEyebrow,
                    "LEFT_OF_RIGHT_EYEBROW" => Self::LeftOfRightEyebrow,
                    "RIGHT_OF_RIGHT_EYEBROW" => Self::RightOfRightEyebrow,
                    "MIDPOINT_BETWEEN_EYES" => Self::MidpointBetweenEyes,
                    "NOSE_TIP" => Self::NoseTip,
                    "UPPER_LIP" => Self::UpperLip,
                    "LOWER_LIP" => Self::LowerLip,
                    "MOUTH_LEFT" => Self::MouthLeft,
                    "MOUTH_RIGHT" => Self::MouthRight,
                    "MOUTH_CENTER" => Self::MouthCenter,
                    "NOSE_BOTTOM_RIGHT" => Self::NoseBottomRight,
                    "NOSE_BOTTOM_LEFT" => Self::NoseBottomLeft,
                    "NOSE_BOTTOM_CENTER" => Self::NoseBottomCenter,
                    "LEFT_EYE_TOP_BOUNDARY" => Self::LeftEyeTopBoundary,
                    "LEFT_EYE_RIGHT_CORNER" => Self::LeftEyeRightCorner,
                    "LEFT_EYE_BOTTOM_BOUNDARY" => Self::LeftEyeBottomBoundary,
                    "LEFT_EYE_LEFT_CORNER" => Self::LeftEyeLeftCorner,
                    "RIGHT_EYE_TOP_BOUNDARY" => Self::RightEyeTopBoundary,
                    "RIGHT_EYE_RIGHT_CORNER" => Self::RightEyeRightCorner,
                    "RIGHT_EYE_BOTTOM_BOUNDARY" => Self::RightEyeBottomBoundary,
                    "RIGHT_EYE_LEFT_CORNER" => Self::RightEyeLeftCorner,
                    "LEFT_EYEBROW_UPPER_MIDPOINT" => Self::LeftEyebrowUpperMidpoint,
                    "RIGHT_EYEBROW_UPPER_MIDPOINT" => Self::RightEyebrowUpperMidpoint,
                    "LEFT_EAR_TRAGION" => Self::LeftEarTragion,
                    "RIGHT_EAR_TRAGION" => Self::RightEarTragion,
                    "LEFT_EYE_PUPIL" => Self::LeftEyePupil,
                    "RIGHT_EYE_PUPIL" => Self::RightEyePupil,
                    "FOREHEAD_GLABELLA" => Self::ForeheadGlabella,
                    "CHIN_GNATHION" => Self::ChinGnathion,
                    "CHIN_LEFT_GONION" => Self::ChinLeftGonion,
                    "CHIN_RIGHT_GONION" => Self::ChinRightGonion,
                    "LEFT_CHEEK_CENTER" => Self::LeftCheekCenter,
                    "RIGHT_CHEEK_CENTER" => Self::RightCheekCenter,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::UnknownLandmark => serializer.serialize_i32(0),
                    Self::LeftEye => serializer.serialize_i32(1),
                    Self::RightEye => serializer.serialize_i32(2),
                    Self::LeftOfLeftEyebrow => serializer.serialize_i32(3),
                    Self::RightOfLeftEyebrow => serializer.serialize_i32(4),
                    Self::LeftOfRightEyebrow => serializer.serialize_i32(5),
                    Self::RightOfRightEyebrow => serializer.serialize_i32(6),
                    Self::MidpointBetweenEyes => serializer.serialize_i32(7),
                    Self::NoseTip => serializer.serialize_i32(8),
                    Self::UpperLip => serializer.serialize_i32(9),
                    Self::LowerLip => serializer.serialize_i32(10),
                    Self::MouthLeft => serializer.serialize_i32(11),
                    Self::MouthRight => serializer.serialize_i32(12),
                    Self::MouthCenter => serializer.serialize_i32(13),
                    Self::NoseBottomRight => serializer.serialize_i32(14),
                    Self::NoseBottomLeft => serializer.serialize_i32(15),
                    Self::NoseBottomCenter => serializer.serialize_i32(16),
                    Self::LeftEyeTopBoundary => serializer.serialize_i32(17),
                    Self::LeftEyeRightCorner => serializer.serialize_i32(18),
                    Self::LeftEyeBottomBoundary => serializer.serialize_i32(19),
                    Self::LeftEyeLeftCorner => serializer.serialize_i32(20),
                    Self::RightEyeTopBoundary => serializer.serialize_i32(21),
                    Self::RightEyeRightCorner => serializer.serialize_i32(22),
                    Self::RightEyeBottomBoundary => serializer.serialize_i32(23),
                    Self::RightEyeLeftCorner => serializer.serialize_i32(24),
                    Self::LeftEyebrowUpperMidpoint => serializer.serialize_i32(25),
                    Self::RightEyebrowUpperMidpoint => serializer.serialize_i32(26),
                    Self::LeftEarTragion => serializer.serialize_i32(27),
                    Self::RightEarTragion => serializer.serialize_i32(28),
                    Self::LeftEyePupil => serializer.serialize_i32(29),
                    Self::RightEyePupil => serializer.serialize_i32(30),
                    Self::ForeheadGlabella => serializer.serialize_i32(31),
                    Self::ChinGnathion => serializer.serialize_i32(32),
                    Self::ChinLeftGonion => serializer.serialize_i32(33),
                    Self::ChinRightGonion => serializer.serialize_i32(34),
                    Self::LeftCheekCenter => serializer.serialize_i32(35),
                    Self::RightCheekCenter => serializer.serialize_i32(36),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.vision.v1.FaceAnnotation.Landmark.Type",
                ))
            }
        }
    }
}

/// Detected entity location information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationInfo {
    /// lat/long location coordinates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lat_lng: std::option::Option<gtype::model::LatLng>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_lng][crate::model::LocationInfo::lat_lng].
    pub fn set_lat_lng<T: std::convert::Into<std::option::Option<gtype::model::LatLng>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lat_lng = v.into();
        self
    }
}

impl wkt::message::Message for LocationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LocationInfo"
    }
}

/// A `Property` consists of a user-supplied name/value pair.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Property {
    /// Name of the property.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Value of the property.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub value: std::string::String,

    /// Value of numeric properties.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub uint64_value: u64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Property {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Property::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::Property::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [uint64_value][crate::model::Property::uint64_value].
    pub fn set_uint64_value<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.uint64_value = v.into();
        self
    }
}

impl wkt::message::Message for Property {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Property"
    }
}

/// Set of detected entity features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntityAnnotation {
    /// Opaque entity ID. Some IDs may be available in
    /// [Google Knowledge Graph Search
    /// API](https://developers.google.com/knowledge-graph/).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mid: std::string::String,

    /// The language code for the locale in which the entity textual
    /// `description` is expressed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub locale: std::string::String,

    /// Entity textual description, expressed in its `locale` language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Overall score of the result. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f32,

    /// **Deprecated. Use `score` instead.**
    /// The accuracy of the entity detection in an image.
    /// For example, for an image in which the "Eiffel Tower" entity is detected,
    /// this field represents the confidence that there is a tower in the query
    /// image. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub confidence: f32,

    /// The relevancy of the ICA (Image Content Annotation) label to the
    /// image. For example, the relevancy of "tower" is likely higher to an image
    /// containing the detected "Eiffel Tower" than to an image containing a
    /// detected distant towering building, even though the confidence that
    /// there is a tower in each image may be the same. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub topicality: f32,

    /// Image region to which this entity belongs. Not produced
    /// for `LABEL_DETECTION` features.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The location information for the detected entity. Multiple
    /// `LocationInfo` elements can be present because one location may
    /// indicate the location of the scene in the image, and another location
    /// may indicate the location of the place where the image was taken.
    /// Location information is usually present for landmarks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<crate::model::LocationInfo>,

    /// Some entities may have optional user-supplied `Property` (name/value)
    /// fields, such a score or string that qualifies the entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub properties: std::vec::Vec<crate::model::Property>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntityAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mid][crate::model::EntityAnnotation::mid].
    pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mid = v.into();
        self
    }

    /// Sets the value of [locale][crate::model::EntityAnnotation::locale].
    pub fn set_locale<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.locale = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntityAnnotation::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [score][crate::model::EntityAnnotation::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::EntityAnnotation::confidence].
    #[deprecated]
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [topicality][crate::model::EntityAnnotation::topicality].
    pub fn set_topicality<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.topicality = v.into();
        self
    }

    /// Sets the value of [bounding_poly][crate::model::EntityAnnotation::bounding_poly].
    pub fn set_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_poly = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::EntityAnnotation::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocationInfo>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::EntityAnnotation::properties].
    pub fn set_properties<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Property>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EntityAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.EntityAnnotation"
    }
}

/// Set of detected objects with bounding boxes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocalizedObjectAnnotation {
    /// Object ID that should align with EntityAnnotation mid.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mid: std::string::String,

    /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
    /// information, see
    /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub language_code: std::string::String,

    /// Object name, expressed in its `language_code` language.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Score of the result. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f32,

    /// Image region to which this object belongs. This must be populated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalizedObjectAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mid][crate::model::LocalizedObjectAnnotation::mid].
    pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mid = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::LocalizedObjectAnnotation::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [name][crate::model::LocalizedObjectAnnotation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [score][crate::model::LocalizedObjectAnnotation::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [bounding_poly][crate::model::LocalizedObjectAnnotation::bounding_poly].
    pub fn set_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_poly = v.into();
        self
    }
}

impl wkt::message::Message for LocalizedObjectAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LocalizedObjectAnnotation"
    }
}

/// Set of features pertaining to the image, computed by computer vision
/// methods over safe-search verticals (for example, adult, spoof, medical,
/// violence).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SafeSearchAnnotation {
    /// Represents the adult content likelihood for the image. Adult content may
    /// contain elements such as nudity, pornographic images or cartoons, or
    /// sexual activities.
    pub adult: crate::model::Likelihood,

    /// Spoof likelihood. The likelihood that an modification
    /// was made to the image's canonical version to make it appear
    /// funny or offensive.
    pub spoof: crate::model::Likelihood,

    /// Likelihood that this is a medical image.
    pub medical: crate::model::Likelihood,

    /// Likelihood that this image contains violent content. Violent content may
    /// include death, serious harm, or injury to individuals or groups of
    /// individuals.
    pub violence: crate::model::Likelihood,

    /// Likelihood that the request image contains racy content. Racy content may
    /// include (but is not limited to) skimpy or sheer clothing, strategically
    /// covered nudity, lewd or provocative poses, or close-ups of sensitive
    /// body areas.
    pub racy: crate::model::Likelihood,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SafeSearchAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adult][crate::model::SafeSearchAnnotation::adult].
    pub fn set_adult<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.adult = v.into();
        self
    }

    /// Sets the value of [spoof][crate::model::SafeSearchAnnotation::spoof].
    pub fn set_spoof<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.spoof = v.into();
        self
    }

    /// Sets the value of [medical][crate::model::SafeSearchAnnotation::medical].
    pub fn set_medical<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.medical = v.into();
        self
    }

    /// Sets the value of [violence][crate::model::SafeSearchAnnotation::violence].
    pub fn set_violence<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.violence = v.into();
        self
    }

    /// Sets the value of [racy][crate::model::SafeSearchAnnotation::racy].
    pub fn set_racy<T: std::convert::Into<crate::model::Likelihood>>(mut self, v: T) -> Self {
        self.racy = v.into();
        self
    }
}

impl wkt::message::Message for SafeSearchAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.SafeSearchAnnotation"
    }
}

/// Rectangle determined by min and max `LatLng` pairs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LatLongRect {
    /// Min lat/long pair.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub min_lat_lng: std::option::Option<gtype::model::LatLng>,

    /// Max lat/long pair.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_lat_lng: std::option::Option<gtype::model::LatLng>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LatLongRect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_lat_lng][crate::model::LatLongRect::min_lat_lng].
    pub fn set_min_lat_lng<T: std::convert::Into<std::option::Option<gtype::model::LatLng>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_lat_lng = v.into();
        self
    }

    /// Sets the value of [max_lat_lng][crate::model::LatLongRect::max_lat_lng].
    pub fn set_max_lat_lng<T: std::convert::Into<std::option::Option<gtype::model::LatLng>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_lat_lng = v.into();
        self
    }
}

impl wkt::message::Message for LatLongRect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.LatLongRect"
    }
}

/// Color information consists of RGB channels, score, and the fraction of
/// the image that the color occupies in the image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColorInfo {
    /// RGB components of the color.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub color: std::option::Option<gtype::model::Color>,

    /// Image-specific score for this color. Value in range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub score: f32,

    /// The fraction of pixels the color occupies in the image.
    /// Value in range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub pixel_fraction: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [color][crate::model::ColorInfo::color].
    pub fn set_color<T: std::convert::Into<std::option::Option<gtype::model::Color>>>(
        mut self,
        v: T,
    ) -> Self {
        self.color = v.into();
        self
    }

    /// Sets the value of [score][crate::model::ColorInfo::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [pixel_fraction][crate::model::ColorInfo::pixel_fraction].
    pub fn set_pixel_fraction<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.pixel_fraction = v.into();
        self
    }
}

impl wkt::message::Message for ColorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ColorInfo"
    }
}

/// Set of dominant colors and their corresponding scores.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DominantColorsAnnotation {
    /// RGB color values with their score and pixel fraction.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub colors: std::vec::Vec<crate::model::ColorInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DominantColorsAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [colors][crate::model::DominantColorsAnnotation::colors].
    pub fn set_colors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ColorInfo>,
    {
        use std::iter::Iterator;
        self.colors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DominantColorsAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DominantColorsAnnotation"
    }
}

/// Stores image properties, such as dominant colors.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageProperties {
    /// If present, dominant colors completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dominant_colors: std::option::Option<crate::model::DominantColorsAnnotation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dominant_colors][crate::model::ImageProperties::dominant_colors].
    pub fn set_dominant_colors<
        T: std::convert::Into<std::option::Option<crate::model::DominantColorsAnnotation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dominant_colors = v.into();
        self
    }
}

impl wkt::message::Message for ImageProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageProperties"
    }
}

/// Single crop hint that is used to generate a new crop when serving an image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CropHint {
    /// The bounding polygon for the crop region. The coordinates of the bounding
    /// box are in the original image's scale.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// Confidence of this being a salient region.  Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    /// Fraction of importance of this salient region with respect to the original
    /// image.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub importance_fraction: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::CropHint::bounding_poly].
    pub fn set_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_poly = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::CropHint::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [importance_fraction][crate::model::CropHint::importance_fraction].
    pub fn set_importance_fraction<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.importance_fraction = v.into();
        self
    }
}

impl wkt::message::Message for CropHint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHint"
    }
}

/// Set of crop hints that are used to generate new crops when serving images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CropHintsAnnotation {
    /// Crop hint results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub crop_hints: std::vec::Vec<crate::model::CropHint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHintsAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [crop_hints][crate::model::CropHintsAnnotation::crop_hints].
    pub fn set_crop_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CropHint>,
    {
        use std::iter::Iterator;
        self.crop_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CropHintsAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHintsAnnotation"
    }
}

/// Parameters for crop hints annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CropHintsParams {
    /// Aspect ratios in floats, representing the ratio of the width to the height
    /// of the image. For example, if the desired aspect ratio is 4/3, the
    /// corresponding float value should be 1.33333.  If not specified, the
    /// best possible crop is returned. The number of provided aspect ratios is
    /// limited to a maximum of 16; any aspect ratios provided after the 16th are
    /// ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_ratios: std::vec::Vec<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CropHintsParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_ratios][crate::model::CropHintsParams::aspect_ratios].
    pub fn set_aspect_ratios<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f32>,
    {
        use std::iter::Iterator;
        self.aspect_ratios = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CropHintsParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CropHintsParams"
    }
}

/// Parameters for web detection request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebDetectionParams {
    /// This field has no effect on results.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[deprecated]
    pub include_geo_results: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebDetectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [include_geo_results][crate::model::WebDetectionParams::include_geo_results].
    #[deprecated]
    pub fn set_include_geo_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_geo_results = v.into();
        self
    }
}

impl wkt::message::Message for WebDetectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.WebDetectionParams"
    }
}

/// Parameters for text detections. This is used to control TEXT_DETECTION and
/// DOCUMENT_TEXT_DETECTION features.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextDetectionParams {
    /// By default, Cloud Vision API only includes confidence score for
    /// DOCUMENT_TEXT_DETECTION result. Set the flag to true to include confidence
    /// score for TEXT_DETECTION as well.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_text_detection_confidence_score: bool,

    /// A list of advanced OCR options to further fine-tune OCR behavior.
    /// Current valid values are:
    ///
    /// - `legacy_layout`: a heuristics layout detection algorithm, which serves as
    ///   an alternative to the current ML-based layout detection algorithm.
    ///   Customers can choose the best suitable layout algorithm based on their
    ///   situation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub advanced_ocr_options: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextDetectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_text_detection_confidence_score][crate::model::TextDetectionParams::enable_text_detection_confidence_score].
    pub fn set_enable_text_detection_confidence_score<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_text_detection_confidence_score = v.into();
        self
    }

    /// Sets the value of [advanced_ocr_options][crate::model::TextDetectionParams::advanced_ocr_options].
    pub fn set_advanced_ocr_options<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.advanced_ocr_options = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TextDetectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.TextDetectionParams"
    }
}

/// Image context and/or feature-specific parameters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageContext {
    /// Not used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lat_long_rect: std::option::Option<crate::model::LatLongRect>,

    /// List of languages to use for TEXT_DETECTION. In most cases, an empty value
    /// yields the best results since it enables automatic language detection. For
    /// languages based on the Latin alphabet, setting `language_hints` is not
    /// needed. In rare cases, when the language of the text in the image is known,
    /// setting a hint will help get better results (although it will be a
    /// significant hindrance if the hint is wrong). Text detection returns an
    /// error if one or more of the specified languages is not one of the
    /// [supported languages](https://cloud.google.com/vision/docs/languages).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub language_hints: std::vec::Vec<std::string::String>,

    /// Parameters for crop hints annotation request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crop_hints_params: std::option::Option<crate::model::CropHintsParams>,

    /// Parameters for product search.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product_search_params: std::option::Option<crate::model::ProductSearchParams>,

    /// Parameters for web detection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub web_detection_params: std::option::Option<crate::model::WebDetectionParams>,

    /// Parameters for text detection and document text detection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub text_detection_params: std::option::Option<crate::model::TextDetectionParams>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lat_long_rect][crate::model::ImageContext::lat_long_rect].
    pub fn set_lat_long_rect<
        T: std::convert::Into<std::option::Option<crate::model::LatLongRect>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lat_long_rect = v.into();
        self
    }

    /// Sets the value of [crop_hints_params][crate::model::ImageContext::crop_hints_params].
    pub fn set_crop_hints_params<
        T: std::convert::Into<std::option::Option<crate::model::CropHintsParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crop_hints_params = v.into();
        self
    }

    /// Sets the value of [product_search_params][crate::model::ImageContext::product_search_params].
    pub fn set_product_search_params<
        T: std::convert::Into<std::option::Option<crate::model::ProductSearchParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.product_search_params = v.into();
        self
    }

    /// Sets the value of [web_detection_params][crate::model::ImageContext::web_detection_params].
    pub fn set_web_detection_params<
        T: std::convert::Into<std::option::Option<crate::model::WebDetectionParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_detection_params = v.into();
        self
    }

    /// Sets the value of [text_detection_params][crate::model::ImageContext::text_detection_params].
    pub fn set_text_detection_params<
        T: std::convert::Into<std::option::Option<crate::model::TextDetectionParams>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.text_detection_params = v.into();
        self
    }

    /// Sets the value of [language_hints][crate::model::ImageContext::language_hints].
    pub fn set_language_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImageContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageContext"
    }
}

/// Request for performing Google Cloud Vision API tasks over a user-provided
/// image, with user-requested features, and with context information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateImageRequest {
    /// The image to be processed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image: std::option::Option<crate::model::Image>,

    /// Requested features.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_context: std::option::Option<crate::model::ImageContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image][crate::model::AnnotateImageRequest::image].
    pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::Image>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = v.into();
        self
    }

    /// Sets the value of [image_context][crate::model::AnnotateImageRequest::image_context].
    pub fn set_image_context<
        T: std::convert::Into<std::option::Option<crate::model::ImageContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_context = v.into();
        self
    }

    /// Sets the value of [features][crate::model::AnnotateImageRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateImageRequest"
    }
}

/// If an image was produced from a file (e.g. a PDF), this message gives
/// information about the source of that image.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImageAnnotationContext {
    /// The URI of the file used to produce the image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// If the file was a PDF or TIFF, this field gives the page number within
    /// the file used to produce the image.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_number: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageAnnotationContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::ImageAnnotationContext::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [page_number][crate::model::ImageAnnotationContext::page_number].
    pub fn set_page_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_number = v.into();
        self
    }
}

impl wkt::message::Message for ImageAnnotationContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImageAnnotationContext"
    }
}

/// Response to an image annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateImageResponse {
    /// If present, face detection has completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub face_annotations: std::vec::Vec<crate::model::FaceAnnotation>,

    /// If present, landmark detection has completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub landmark_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, logo detection has completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub logo_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, label detection has completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub label_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, localized object detection has completed successfully.
    /// This will be sorted descending by confidence score.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub localized_object_annotations: std::vec::Vec<crate::model::LocalizedObjectAnnotation>,

    /// If present, text (OCR) detection has completed successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub text_annotations: std::vec::Vec<crate::model::EntityAnnotation>,

    /// If present, text (OCR) detection or document (OCR) text detection has
    /// completed successfully.
    /// This annotation provides the structural hierarchy for the OCR detected
    /// text.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub full_text_annotation: std::option::Option<crate::model::TextAnnotation>,

    /// If present, safe-search annotation has completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub safe_search_annotation: std::option::Option<crate::model::SafeSearchAnnotation>,

    /// If present, image properties were extracted successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_properties_annotation: std::option::Option<crate::model::ImageProperties>,

    /// If present, crop hints have completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crop_hints_annotation: std::option::Option<crate::model::CropHintsAnnotation>,

    /// If present, web detection has completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub web_detection: std::option::Option<crate::model::WebDetection>,

    /// If present, product search has completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product_search_results: std::option::Option<crate::model::ProductSearchResults>,

    /// If set, represents the error message for the operation.
    /// Note that filled-in image annotations are guaranteed to be
    /// correct, even when `error` is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// If present, contextual information is needed to understand where this image
    /// comes from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub context: std::option::Option<crate::model::ImageAnnotationContext>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateImageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [full_text_annotation][crate::model::AnnotateImageResponse::full_text_annotation].
    pub fn set_full_text_annotation<
        T: std::convert::Into<std::option::Option<crate::model::TextAnnotation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.full_text_annotation = v.into();
        self
    }

    /// Sets the value of [safe_search_annotation][crate::model::AnnotateImageResponse::safe_search_annotation].
    pub fn set_safe_search_annotation<
        T: std::convert::Into<std::option::Option<crate::model::SafeSearchAnnotation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.safe_search_annotation = v.into();
        self
    }

    /// Sets the value of [image_properties_annotation][crate::model::AnnotateImageResponse::image_properties_annotation].
    pub fn set_image_properties_annotation<
        T: std::convert::Into<std::option::Option<crate::model::ImageProperties>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_properties_annotation = v.into();
        self
    }

    /// Sets the value of [crop_hints_annotation][crate::model::AnnotateImageResponse::crop_hints_annotation].
    pub fn set_crop_hints_annotation<
        T: std::convert::Into<std::option::Option<crate::model::CropHintsAnnotation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.crop_hints_annotation = v.into();
        self
    }

    /// Sets the value of [web_detection][crate::model::AnnotateImageResponse::web_detection].
    pub fn set_web_detection<
        T: std::convert::Into<std::option::Option<crate::model::WebDetection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.web_detection = v.into();
        self
    }

    /// Sets the value of [product_search_results][crate::model::AnnotateImageResponse::product_search_results].
    pub fn set_product_search_results<
        T: std::convert::Into<std::option::Option<crate::model::ProductSearchResults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.product_search_results = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AnnotateImageResponse::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [context][crate::model::AnnotateImageResponse::context].
    pub fn set_context<
        T: std::convert::Into<std::option::Option<crate::model::ImageAnnotationContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// Sets the value of [face_annotations][crate::model::AnnotateImageResponse::face_annotations].
    pub fn set_face_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FaceAnnotation>,
    {
        use std::iter::Iterator;
        self.face_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [landmark_annotations][crate::model::AnnotateImageResponse::landmark_annotations].
    pub fn set_landmark_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.landmark_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logo_annotations][crate::model::AnnotateImageResponse::logo_annotations].
    pub fn set_logo_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.logo_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [label_annotations][crate::model::AnnotateImageResponse::label_annotations].
    pub fn set_label_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.label_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [localized_object_annotations][crate::model::AnnotateImageResponse::localized_object_annotations].
    pub fn set_localized_object_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocalizedObjectAnnotation>,
    {
        use std::iter::Iterator;
        self.localized_object_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [text_annotations][crate::model::AnnotateImageResponse::text_annotations].
    pub fn set_text_annotations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityAnnotation>,
    {
        use std::iter::Iterator;
        self.text_annotations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateImageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateImageResponse"
    }
}

/// Multiple image annotation requests are batched into a single service call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchAnnotateImagesRequest {
    /// Required. Individual image annotation requests for this batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::AnnotateImageRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchAnnotateImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchAnnotateImagesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchAnnotateImagesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateImagesRequest"
    }
}

/// Response to a batch image annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchAnnotateImagesResponse {
    /// Individual responses to image annotation requests within the batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::AnnotateImageResponse>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchAnnotateImagesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateImagesResponse"
    }
}

/// A request to annotate one single file, e.g. a PDF, TIFF or GIF file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateFileRequest {
    /// Required. Information about the input file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Required. Requested features.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image(s) in the file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_context: std::option::Option<crate::model::ImageContext>,

    /// Pages of the file to perform image annotation.
    ///
    /// Pages starts from 1, we assume the first page of the file is page 1.
    /// At most 5 pages are supported per request. Pages can be negative.
    ///
    /// Page 1 means the first page.
    /// Page 2 means the second page.
    /// Page -1 means the last page.
    /// Page -2 means the second to the last page.
    ///
    /// If the file is GIF instead of PDF or TIFF, page refers to GIF frames.
    ///
    /// If this field is empty, by default the service performs image annotation
    /// for the first 5 pages of the file.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pages: std::vec::Vec<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AnnotateFileRequest::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::InputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [image_context][crate::model::AnnotateFileRequest::image_context].
    pub fn set_image_context<
        T: std::convert::Into<std::option::Option<crate::model::ImageContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_context = v.into();
        self
    }

    /// Sets the value of [features][crate::model::AnnotateFileRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pages][crate::model::AnnotateFileRequest::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateFileRequest"
    }
}

/// Response to a single file annotation request. A file may contain one or more
/// images, which individually have their own responses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AnnotateFileResponse {
    /// Information about the file for which this response is generated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Individual responses to images found within the file. This field will be
    /// empty if the `error` field is set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::AnnotateImageResponse>,

    /// This field gives the total number of pages in the file.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_pages: i32,

    /// If set, represents the error message for the failed request. The
    /// `responses` field will not be set in this case.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnnotateFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AnnotateFileResponse::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::InputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [total_pages][crate::model::AnnotateFileResponse::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AnnotateFileResponse::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::AnnotateFileResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AnnotateFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AnnotateFileResponse"
    }
}

/// A list of requests to annotate files using the BatchAnnotateFiles API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchAnnotateFilesRequest {
    /// Required. The list of file annotation requests. Right now we support only
    /// one AnnotateFileRequest in BatchAnnotateFilesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::AnnotateFileRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchAnnotateFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchAnnotateFilesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateFileRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchAnnotateFilesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateFilesRequest"
    }
}

/// A list of file annotation responses.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchAnnotateFilesResponse {
    /// The list of file annotation responses, each response corresponding to each
    /// AnnotateFileRequest in BatchAnnotateFilesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::AnnotateFileResponse>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchAnnotateFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchAnnotateFilesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateFileResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchAnnotateFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchAnnotateFilesResponse"
    }
}

/// An offline file annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncAnnotateFileRequest {
    /// Required. Information about the input file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Required. Requested features.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub features: std::vec::Vec<crate::model::Feature>,

    /// Additional context that may accompany the image(s) in the file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub image_context: std::option::Option<crate::model::ImageContext>,

    /// Required. The desired output location and metadata (e.g. format).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncAnnotateFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_config][crate::model::AsyncAnnotateFileRequest::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::InputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }

    /// Sets the value of [image_context][crate::model::AsyncAnnotateFileRequest::image_context].
    pub fn set_image_context<
        T: std::convert::Into<std::option::Option<crate::model::ImageContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image_context = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::AsyncAnnotateFileRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [features][crate::model::AsyncAnnotateFileRequest::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AsyncAnnotateFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncAnnotateFileRequest"
    }
}

/// The response for a single offline file annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncAnnotateFileResponse {
    /// The output location and metadata from AsyncAnnotateFileRequest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncAnnotateFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_config][crate::model::AsyncAnnotateFileResponse::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }
}

impl wkt::message::Message for AsyncAnnotateFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncAnnotateFileResponse"
    }
}

/// Request for async image annotation for a list of images.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncBatchAnnotateImagesRequest {
    /// Required. Individual image annotation requests for this batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::AnnotateImageRequest>,

    /// Required. The desired output location and metadata (e.g. format).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_config][crate::model::AsyncBatchAnnotateImagesRequest::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::AsyncBatchAnnotateImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::AsyncBatchAnnotateImagesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotateImageRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AsyncBatchAnnotateImagesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateImagesRequest"
    }
}

/// Response to an async batch image annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncBatchAnnotateImagesResponse {
    /// The output location and metadata from AsyncBatchAnnotateImagesRequest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_config][crate::model::AsyncBatchAnnotateImagesResponse::output_config].
    pub fn set_output_config<
        T: std::convert::Into<std::option::Option<crate::model::OutputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.output_config = v.into();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateImagesResponse"
    }
}

/// Multiple async file annotation requests are batched into a single service
/// call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncBatchAnnotateFilesRequest {
    /// Required. Individual async file annotation requests for this batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::AsyncAnnotateFileRequest>,

    /// Optional. Target project and location to make a call.
    ///
    /// Format: `projects/{project-id}/locations/{location-id}`.
    ///
    /// If no parent is specified, a region will be chosen automatically.
    ///
    /// Supported location-ids:
    /// `us`: USA country only,
    /// `asia`: East asia areas, like Japan, Taiwan,
    /// `eu`: The European Union.
    ///
    /// Example: `projects/project-A/locations/eu`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AsyncBatchAnnotateFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::AsyncBatchAnnotateFilesRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AsyncAnnotateFileRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::AsyncBatchAnnotateFilesRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateFilesRequest"
    }
}

/// Response to an async batch file annotation request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AsyncBatchAnnotateFilesResponse {
    /// The list of file annotation responses, one for each request in
    /// AsyncBatchAnnotateFilesRequest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::AsyncAnnotateFileResponse>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AsyncBatchAnnotateFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::AsyncBatchAnnotateFilesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AsyncAnnotateFileResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AsyncBatchAnnotateFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AsyncBatchAnnotateFilesResponse"
    }
}

/// The desired input location and metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InputConfig {
    /// The Google Cloud Storage location to read the input from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_source: std::option::Option<crate::model::GcsSource>,

    /// File content, represented as a stream of bytes.
    /// Note: As with all `bytes` fields, protobuffers use a pure binary
    /// representation, whereas JSON representations use base64.
    ///
    /// Currently, this field only works for BatchAnnotateFiles requests. It does
    /// not work for AsyncBatchAnnotateFiles requests.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub content: ::bytes::Bytes,

    /// The type of the file. Currently only "application/pdf", "image/tiff" and
    /// "image/gif" are supported. Wildcards are not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_source][crate::model::InputConfig::gcs_source].
    pub fn set_gcs_source<T: std::convert::Into<std::option::Option<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_source = v.into();
        self
    }

    /// Sets the value of [content][crate::model::InputConfig::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::InputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }
}

impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.InputConfig"
    }
}

/// The desired output location and metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OutputConfig {
    /// The Google Cloud Storage location to write the output(s) to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gcs_destination: std::option::Option<crate::model::GcsDestination>,

    /// The max number of response protos to put into each output JSON file on
    /// Google Cloud Storage.
    /// The valid range is [1, 100]. If not specified, the default value is 20.
    ///
    /// For example, for one pdf file with 100 pages, 100 response protos will
    /// be generated. If `batch_size` = 20, then 5 json files each
    /// containing 20 response protos will be written under the prefix
    /// `gcs_destination`.`uri`.
    ///
    /// Currently, batch_size only applies to GcsDestination, with potential future
    /// support for other output configurations.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub batch_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_destination][crate::model::OutputConfig::gcs_destination].
    pub fn set_gcs_destination<
        T: std::convert::Into<std::option::Option<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gcs_destination = v.into();
        self
    }

    /// Sets the value of [batch_size][crate::model::OutputConfig::batch_size].
    pub fn set_batch_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.batch_size = v.into();
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.OutputConfig"
    }
}

/// The Google Cloud Storage location where the input will be read from.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsSource {
    /// Google Cloud Storage URI for the input file. This must only be a
    /// Google Cloud Storage object. Wildcards are not currently supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsSource::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GcsSource"
    }
}

/// The Google Cloud Storage location where the output will be written to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcsDestination {
    /// Google Cloud Storage URI prefix where the results will be stored. Results
    /// will be in JSON format and preceded by its corresponding input URI prefix.
    /// This field can either represent a gcs file prefix or gcs directory. In
    /// either case, the uri should be unique because in order to get all of the
    /// output files, you will need to do a wildcard gcs search on the uri prefix
    /// you provide.
    ///
    /// Examples:
    ///
    /// * File Prefix: gs://bucket-name/here/filenameprefix   The output files
    ///   will be created in gs://bucket-name/here/ and the names of the
    ///   output files will begin with "filenameprefix".
    ///
    /// * Directory Prefix: gs://bucket-name/some/location/   The output files
    ///   will be created in gs://bucket-name/some/location/ and the names of the
    ///   output files could be anything because there was no filename prefix
    ///   specified.
    ///
    ///
    /// If multiple outputs, each response is still AnnotateFileResponse, each of
    /// which contains some subset of the full list of AnnotateImageResponse.
    /// Multiple outputs can happen if, for example, the output JSON is too large
    /// and overflows into multiple sharded files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GcsDestination"
    }
}

/// Contains metadata for the BatchAnnotateImages operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Current state of the batch operation.
    pub state: crate::model::operation_metadata::State,

    /// The time when the batch request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation result was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::OperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::OperationMetadata::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Batch operation states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is received.
        Created,
        /// Request is actively being processed.
        Running,
        /// The batch processing is done.
        Done,
        /// The batch processing was cancelled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Created => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Created,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATED" => Self::Created,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Created => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vision.v1.OperationMetadata.State",
            ))
        }
    }
}

/// Parameters for a product search request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProductSearchParams {
    /// The bounding polygon around the area of interest in the image.
    /// If it is not specified, system discretion will be applied.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

    /// The resource name of a [ProductSet][google.cloud.vision.v1.ProductSet] to
    /// be searched for similar images.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`.
    ///
    /// [google.cloud.vision.v1.ProductSet]: crate::model::ProductSet
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_set: std::string::String,

    /// The list of product categories to search in. Currently, we only consider
    /// the first category, and either "homegoods-v2", "apparel-v2", "toys-v2",
    /// "packagedgoods-v1", or "general-v1" should be specified. The legacy
    /// categories "homegoods", "apparel", and "toys" are still supported but will
    /// be deprecated. For new products, please use "homegoods-v2", "apparel-v2",
    /// or "toys-v2" for better product search accuracy. It is recommended to
    /// migrate existing products to these categories as well.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub product_categories: std::vec::Vec<std::string::String>,

    /// The filtering expression. This can be used to restrict search results based
    /// on Product labels. We currently support an AND of OR of key-value
    /// expressions, where each expression within an OR must have the same key. An
    /// '=' should be used to connect the key and value.
    ///
    /// For example, "(color = red OR color = blue) AND brand = Google" is
    /// acceptable, but "(color = red OR brand = Google)" is not acceptable.
    /// "color: red" is not acceptable because it uses a ':' instead of an '='.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSearchParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bounding_poly][crate::model::ProductSearchParams::bounding_poly].
    pub fn set_bounding_poly<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_poly = v.into();
        self
    }

    /// Sets the value of [product_set][crate::model::ProductSearchParams::product_set].
    pub fn set_product_set<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ProductSearchParams::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [product_categories][crate::model::ProductSearchParams::product_categories].
    pub fn set_product_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.product_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProductSearchParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSearchParams"
    }
}

/// Results for a product search request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProductSearchResults {
    /// Timestamp of the index which provided these results. Products added to the
    /// product set and products removed from the product set after this time are
    /// not reflected in the current results.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_time: std::option::Option<wkt::Timestamp>,

    /// List of results, one for each product match.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::product_search_results::Result>,

    /// List of results grouped by products detected in the query image. Each entry
    /// corresponds to one bounding polygon in the query image, and contains the
    /// matching products specific to that region. There may be duplicate product
    /// matches in the union of all the per-product results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub product_grouped_results: std::vec::Vec<crate::model::product_search_results::GroupedResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSearchResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [index_time][crate::model::ProductSearchResults::index_time].
    pub fn set_index_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_time = v.into();
        self
    }

    /// Sets the value of [results][crate::model::ProductSearchResults::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product_search_results::Result>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [product_grouped_results][crate::model::ProductSearchResults::product_grouped_results].
    pub fn set_product_grouped_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product_search_results::GroupedResult>,
    {
        use std::iter::Iterator;
        self.product_grouped_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProductSearchResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults"
    }
}

/// Defines additional types related to [ProductSearchResults].
pub mod product_search_results {
    #[allow(unused_imports)]
    use super::*;

    /// Information about a product.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Result {
        /// The Product.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub product: std::option::Option<crate::model::Product>,

        /// A confidence level on the match, ranging from 0 (no confidence) to
        /// 1 (full confidence).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub score: f32,

        /// The resource name of the image from the product that is the closest match
        /// to the query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub image: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [product][crate::model::product_search_results::Result::product].
        pub fn set_product<T: std::convert::Into<std::option::Option<crate::model::Product>>>(
            mut self,
            v: T,
        ) -> Self {
            self.product = v.into();
            self
        }

        /// Sets the value of [score][crate::model::product_search_results::Result::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [image][crate::model::product_search_results::Result::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }
    }

    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.Result"
        }
    }

    /// Prediction for what the object in the bounding box is.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ObjectAnnotation {
        /// Object ID that should align with EntityAnnotation mid.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mid: std::string::String,

        /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
        /// information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub language_code: std::string::String,

        /// Object name, expressed in its `language_code` language.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Score of the result. Range [0, 1].
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub score: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ObjectAnnotation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mid][crate::model::product_search_results::ObjectAnnotation::mid].
        pub fn set_mid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mid = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::product_search_results::ObjectAnnotation::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [name][crate::model::product_search_results::ObjectAnnotation::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [score][crate::model::product_search_results::ObjectAnnotation::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }
    }

    impl wkt::message::Message for ObjectAnnotation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.ObjectAnnotation"
        }
    }

    /// Information about the products similar to a single product in a query
    /// image.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GroupedResult {
        /// The bounding polygon around the product detected in the query image.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bounding_poly: std::option::Option<crate::model::BoundingPoly>,

        /// List of results, one for each product match.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub results: std::vec::Vec<crate::model::product_search_results::Result>,

        /// List of generic predictions for the object in the bounding box.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub object_annotations:
            std::vec::Vec<crate::model::product_search_results::ObjectAnnotation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupedResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bounding_poly][crate::model::product_search_results::GroupedResult::bounding_poly].
        pub fn set_bounding_poly<
            T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bounding_poly = v.into();
            self
        }

        /// Sets the value of [results][crate::model::product_search_results::GroupedResult::results].
        pub fn set_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::product_search_results::Result>,
        {
            use std::iter::Iterator;
            self.results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [object_annotations][crate::model::product_search_results::GroupedResult::object_annotations].
        pub fn set_object_annotations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::product_search_results::ObjectAnnotation>,
        {
            use std::iter::Iterator;
            self.object_annotations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GroupedResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.ProductSearchResults.GroupedResult"
        }
    }
}

/// A Product contains ReferenceImages.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Product {
    /// The resource name of the product.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    ///
    /// This field is ignored when creating a product.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The user-provided name for this Product. Must not be empty. Must be at most
    /// 4096 characters long.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// User-provided metadata to be stored with this product. Must be at most 4096
    /// characters long.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Immutable. The category for the product identified by the reference image.
    /// This should be one of "homegoods-v2", "apparel-v2", "toys-v2",
    /// "packagedgoods-v1" or "general-v1". The legacy categories "homegoods",
    /// "apparel", and "toys" are still supported, but these should not be used for
    /// new products.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_category: std::string::String,

    /// Key-value pairs that can be attached to a product. At query time,
    /// constraints can be specified based on the product_labels.
    ///
    /// Note that integer values can be provided as strings, e.g. "1199". Only
    /// strings with integer values can match a range-based restriction which is
    /// to be supported soon.
    ///
    /// Multiple values can be assigned to the same key. One product may have up to
    /// 500 product_labels.
    ///
    /// Notice that the total number of distinct product_labels over all products
    /// in one ProductSet cannot exceed 1M, otherwise the product search pipeline
    /// will refuse to work for that ProductSet.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub product_labels: std::vec::Vec<crate::model::product::KeyValue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Product {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Product::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Product::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Product::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [product_category][crate::model::Product::product_category].
    pub fn set_product_category<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.product_category = v.into();
        self
    }

    /// Sets the value of [product_labels][crate::model::Product::product_labels].
    pub fn set_product_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::product::KeyValue>,
    {
        use std::iter::Iterator;
        self.product_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Product {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Product"
    }
}

/// Defines additional types related to [Product].
pub mod product {
    #[allow(unused_imports)]
    use super::*;

    /// A product label represented as a key-value pair.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct KeyValue {
        /// The key of the label attached to the product. Cannot be empty and cannot
        /// exceed 128 bytes.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// The value of the label attached to the product. Cannot be empty and
        /// cannot exceed 128 bytes.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyValue {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::product::KeyValue::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::product::KeyValue::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for KeyValue {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.Product.KeyValue"
        }
    }
}

/// A ProductSet contains Products. A ProductSet can contain a maximum of 1
/// million reference images. If the limit is exceeded, periodic indexing will
/// fail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProductSet {
    /// The resource name of the ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`.
    ///
    /// This field is ignored when creating a ProductSet.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The user-provided name for this ProductSet. Must not be empty. Must be at
    /// most 4096 characters long.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. The time at which this ProductSet was last indexed. Query
    /// results will reflect all updates before this time. If this ProductSet has
    /// never been indexed, this timestamp is the default value
    /// "1970-01-01T00:00:00Z".
    ///
    /// This field is ignored when creating a ProductSet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_time: std::option::Option<wkt::Timestamp>,

    /// Output only. If there was an error with indexing the product set, the field
    /// is populated.
    ///
    /// This field is ignored when creating a ProductSet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub index_error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProductSet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ProductSet::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [index_time][crate::model::ProductSet::index_time].
    pub fn set_index_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_time = v.into();
        self
    }

    /// Sets the value of [index_error][crate::model::ProductSet::index_error].
    pub fn set_index_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.index_error = v.into();
        self
    }
}

impl wkt::message::Message for ProductSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSet"
    }
}

/// A `ReferenceImage` represents a product image and its associated metadata,
/// such as bounding boxes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReferenceImage {
    /// The resource name of the reference image.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
    ///
    /// This field is ignored when creating a reference image.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The Google Cloud Storage URI of the reference image.
    ///
    /// The URI must start with `gs://`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Optional. Bounding polygons around the areas of interest in the reference
    /// image. If this field is empty, the system will try to detect regions of
    /// interest. At most 10 bounding polygons will be used.
    ///
    /// The provided shape is converted into a non-rotated rectangle. Once
    /// converted, the small edge of the rectangle must be greater than or equal
    /// to 300 pixels. The aspect ratio must be 1:4 or less (i.e. 1:3 is ok; 1:5
    /// is not).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bounding_polys: std::vec::Vec<crate::model::BoundingPoly>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReferenceImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReferenceImage::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ReferenceImage::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [bounding_polys][crate::model::ReferenceImage::bounding_polys].
    pub fn set_bounding_polys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoundingPoly>,
    {
        use std::iter::Iterator;
        self.bounding_polys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReferenceImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ReferenceImage"
    }
}

/// Request message for the `CreateProduct` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateProductRequest {
    /// Required. The project in which the Product should be created.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The product to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product: std::option::Option<crate::model::Product>,

    /// A user-supplied resource id for this Product. If set, the server will
    /// attempt to use this value as the resource id. If it is already in use, an
    /// error is returned with code ALREADY_EXISTS. Must be at most 128 characters
    /// long. It cannot contain the character `/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProductRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [product][crate::model::CreateProductRequest::product].
    pub fn set_product<T: std::convert::Into<std::option::Option<crate::model::Product>>>(
        mut self,
        v: T,
    ) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [product_id][crate::model::CreateProductRequest::product_id].
    pub fn set_product_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateProductRequest"
    }
}

/// Request message for the `ListProducts` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductsRequest {
    /// Required. The project OR ProductSet from which Products should be listed.
    ///
    /// Format:
    /// `projects/PROJECT_ID/locations/LOC_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsRequest"
    }
}

/// Response message for the `ListProducts` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductsResponse {
    /// List of products.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub products: std::vec::Vec<crate::model::Product>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProductsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [products][crate::model::ListProductsResponse::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProductsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductsResponse {
    type PageItem = crate::model::Product;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.products
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the `GetProduct` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProductRequest {
    /// Required. Resource name of the Product to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetProductRequest"
    }
}

/// Request message for the `UpdateProduct` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProductRequest {
    /// Required. The Product resource which replaces the one on the server.
    /// product.name is immutable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product: std::option::Option<crate::model::Product>,

    /// The [FieldMask][google.protobuf.FieldMask] that specifies which fields
    /// to update.
    /// If update_mask isn't specified, all mutable fields are to be updated.
    /// Valid mask paths include `product_labels`, `display_name`, and
    /// `description`.
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::UpdateProductRequest::product].
    pub fn set_product<T: std::convert::Into<std::option::Option<crate::model::Product>>>(
        mut self,
        v: T,
    ) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProductRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.UpdateProductRequest"
    }
}

/// Request message for the `DeleteProduct` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteProductRequest {
    /// Required. Resource name of product to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteProductRequest"
    }
}

/// Request message for the `CreateProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateProductSetRequest {
    /// Required. The project in which the ProductSet should be created.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ProductSet to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product_set: std::option::Option<crate::model::ProductSet>,

    /// A user-supplied resource id for this ProductSet. If set, the server will
    /// attempt to use this value as the resource id. If it is already in use, an
    /// error is returned with code ALREADY_EXISTS. Must be at most 128 characters
    /// long. It cannot contain the character `/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_set_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProductSetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [product_set][crate::model::CreateProductSetRequest::product_set].
    pub fn set_product_set<T: std::convert::Into<std::option::Option<crate::model::ProductSet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.product_set = v.into();
        self
    }

    /// Sets the value of [product_set_id][crate::model::CreateProductSetRequest::product_set_id].
    pub fn set_product_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateProductSetRequest"
    }
}

/// Request message for the `ListProductSets` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductSetsRequest {
    /// Required. The project from which ProductSets should be listed.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProductSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductSetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductSetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductSetsRequest"
    }
}

/// Response message for the `ListProductSets` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductSetsResponse {
    /// List of ProductSets.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub product_sets: std::vec::Vec<crate::model::ProductSet>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProductSetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [product_sets][crate::model::ListProductSetsResponse::product_sets].
    pub fn set_product_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProductSet>,
    {
        use std::iter::Iterator;
        self.product_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProductSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductSetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductSetsResponse {
    type PageItem = crate::model::ProductSet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.product_sets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the `GetProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetProductSetRequest {
    /// Required. Resource name of the ProductSet to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetProductSetRequest"
    }
}

/// Request message for the `UpdateProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateProductSetRequest {
    /// Required. The ProductSet resource which replaces the one on the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub product_set: std::option::Option<crate::model::ProductSet>,

    /// The [FieldMask][google.protobuf.FieldMask] that specifies which fields to
    /// update.
    /// If update_mask isn't specified, all mutable fields are to be updated.
    /// Valid mask path is `display_name`.
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_set][crate::model::UpdateProductSetRequest::product_set].
    pub fn set_product_set<T: std::convert::Into<std::option::Option<crate::model::ProductSet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.product_set = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProductSetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.UpdateProductSetRequest"
    }
}

/// Request message for the `DeleteProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteProductSetRequest {
    /// Required. Resource name of the ProductSet to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteProductSetRequest"
    }
}

/// Request message for the `CreateReferenceImage` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateReferenceImageRequest {
    /// Required. Resource name of the product in which to create the reference
    /// image.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The reference image to create.
    /// If an image ID is specified, it is ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference_image: std::option::Option<crate::model::ReferenceImage>,

    /// A user-supplied resource id for the ReferenceImage to be added. If set,
    /// the server will attempt to use this value as the resource id. If it is
    /// already in use, an error is returned with code ALREADY_EXISTS. Must be at
    /// most 128 characters long. It cannot contain the character `/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reference_image_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReferenceImageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [reference_image][crate::model::CreateReferenceImageRequest::reference_image].
    pub fn set_reference_image<
        T: std::convert::Into<std::option::Option<crate::model::ReferenceImage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reference_image = v.into();
        self
    }

    /// Sets the value of [reference_image_id][crate::model::CreateReferenceImageRequest::reference_image_id].
    pub fn set_reference_image_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference_image_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.CreateReferenceImageRequest"
    }
}

/// Request message for the `ListReferenceImages` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReferenceImagesRequest {
    /// Required. Resource name of the product containing the reference images.
    ///
    /// Format is
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// A token identifying a page of results to be returned. This is the value
    /// of `nextPageToken` returned in a previous reference image list request.
    ///
    /// Defaults to the first page if not specified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferenceImagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReferenceImagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReferenceImagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReferenceImagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReferenceImagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListReferenceImagesRequest"
    }
}

/// Response message for the `ListReferenceImages` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReferenceImagesResponse {
    /// The list of reference images.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reference_images: std::vec::Vec<crate::model::ReferenceImage>,

    /// The maximum number of items to return. Default 10, maximum 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReferenceImagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListReferenceImagesResponse::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReferenceImagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [reference_images][crate::model::ListReferenceImagesResponse::reference_images].
    pub fn set_reference_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReferenceImage>,
    {
        use std::iter::Iterator;
        self.reference_images = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReferenceImagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListReferenceImagesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReferenceImagesResponse {
    type PageItem = crate::model::ReferenceImage;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.reference_images
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for the `GetReferenceImage` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReferenceImageRequest {
    /// Required. The resource name of the ReferenceImage to get.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReferenceImageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.GetReferenceImageRequest"
    }
}

/// Request message for the `DeleteReferenceImage` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteReferenceImageRequest {
    /// Required. The resource name of the reference image to delete.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID/referenceImages/IMAGE_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReferenceImageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReferenceImageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReferenceImageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.DeleteReferenceImageRequest"
    }
}

/// Request message for the `AddProductToProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddProductToProductSetRequest {
    /// Required. The resource name for the ProductSet to modify.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The resource name for the Product to be added to this ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddProductToProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AddProductToProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [product][crate::model::AddProductToProductSetRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }
}

impl wkt::message::Message for AddProductToProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.AddProductToProductSetRequest"
    }
}

/// Request message for the `RemoveProductFromProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveProductFromProductSetRequest {
    /// Required. The resource name for the ProductSet to modify.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The resource name for the Product to be removed from this
    /// ProductSet.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/products/PRODUCT_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveProductFromProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RemoveProductFromProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [product][crate::model::RemoveProductFromProductSetRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }
}

impl wkt::message::Message for RemoveProductFromProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.RemoveProductFromProductSetRequest"
    }
}

/// Request message for the `ListProductsInProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductsInProductSetRequest {
    /// Required. The ProductSet resource for which to retrieve Products.
    ///
    /// Format is:
    /// `projects/PROJECT_ID/locations/LOC_ID/productSets/PRODUCT_SET_ID`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The maximum number of items to return. Default 10, maximum 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// The next_page_token returned from a previous List request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsInProductSetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ListProductsInProductSetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductsInProductSetRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductsInProductSetRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsInProductSetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsInProductSetRequest"
    }
}

/// Response message for the `ListProductsInProductSet` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListProductsInProductSetResponse {
    /// The list of Products.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub products: std::vec::Vec<crate::model::Product>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsInProductSetResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListProductsInProductSetResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [products][crate::model::ListProductsInProductSetResponse::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListProductsInProductSetResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ListProductsInProductSetResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductsInProductSetResponse {
    type PageItem = crate::model::Product;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.products
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The Google Cloud Storage location for a csv file which preserves a list of
/// ImportProductSetRequests in each line.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportProductSetsGcsSource {
    /// The Google Cloud Storage URI of the input csv file.
    ///
    /// The URI must start with `gs://`.
    ///
    /// The format of the input csv file should be one image per line.
    /// In each line, there are 8 columns.
    ///
    /// . image-uri
    /// . image-id
    /// . product-set-id
    /// . product-id
    /// . product-category
    /// . product-display-name
    /// . labels
    /// . bounding-poly
    ///
    /// The `image-uri`, `product-set-id`, `product-id`, and `product-category`
    /// columns are required. All other columns are optional.
    ///
    /// If the `ProductSet` or `Product` specified by the `product-set-id` and
    /// `product-id` values does not exist, then the system will create a new
    /// `ProductSet` or `Product` for the image. In this case, the
    /// `product-display-name` column refers to
    /// [display_name][google.cloud.vision.v1.Product.display_name], the
    /// `product-category` column refers to
    /// [product_category][google.cloud.vision.v1.Product.product_category], and
    /// the `labels` column refers to
    /// [product_labels][google.cloud.vision.v1.Product.product_labels].
    ///
    /// The `image-id` column is optional but must be unique if provided. If it is
    /// empty, the system will automatically assign a unique id to the image.
    ///
    /// The `product-display-name` column is optional. If it is empty, the system
    /// sets the [display_name][google.cloud.vision.v1.Product.display_name] field
    /// for the product to a space (" "). You can update the `display_name` later
    /// by using the API.
    ///
    /// If a `Product` with the specified `product-id` already exists, then the
    /// system ignores the `product-display-name`, `product-category`, and `labels`
    /// columns.
    ///
    /// The `labels` column (optional) is a line containing a list of
    /// comma-separated key-value pairs, in the following format:
    ///
    /// ```norust
    /// "key_1=value_1,key_2=value_2,...,key_n=value_n"
    /// ```
    ///
    /// The `bounding-poly` column (optional) identifies one region of
    /// interest from the image in the same manner as `CreateReferenceImage`. If
    /// you do not specify the `bounding-poly` column, then the system will try to
    /// detect regions of interest automatically.
    ///
    /// At most one `bounding-poly` column is allowed per line. If the image
    /// contains multiple regions of interest, add a line to the CSV file that
    /// includes the same product information, and the `bounding-poly` values for
    /// each region of interest.
    ///
    /// The `bounding-poly` column must contain an even number of comma-separated
    /// numbers, in the format "p1_x,p1_y,p2_x,p2_y,...,pn_x,pn_y". Use
    /// non-negative integers for absolute bounding polygons, and float values
    /// in [0, 1] for normalized bounding polygons.
    ///
    /// The system will resize the image if the image resolution is too
    /// large to process (larger than 20MP).
    ///
    /// [google.cloud.vision.v1.Product.display_name]: crate::model::Product::display_name
    /// [google.cloud.vision.v1.Product.product_category]: crate::model::Product::product_category
    /// [google.cloud.vision.v1.Product.product_labels]: crate::model::Product::product_labels
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub csv_file_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsGcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [csv_file_uri][crate::model::ImportProductSetsGcsSource::csv_file_uri].
    pub fn set_csv_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.csv_file_uri = v.into();
        self
    }
}

impl wkt::message::Message for ImportProductSetsGcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsGcsSource"
    }
}

/// The input content for the `ImportProductSets` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportProductSetsInputConfig {
    /// The source of the input.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::import_product_sets_input_config::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ImportProductSetsInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_product_sets_input_config::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportProductSetsInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImportProductSetsGcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_product_sets_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportProductSetsInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ImportProductSetsGcsSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_product_sets_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportProductSetsInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsInputConfig"
    }
}

/// Defines additional types related to [ImportProductSetsInputConfig].
pub mod import_product_sets_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// The Google Cloud Storage location for a csv file which preserves a list
        /// of ImportProductSetRequests in each line.
        GcsSource(std::boxed::Box<crate::model::ImportProductSetsGcsSource>),
    }
}

/// Request message for the `ImportProductSets` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportProductSetsRequest {
    /// Required. The project in which the ProductSets should be imported.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The input content for the list of requests.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub input_config: std::option::Option<crate::model::ImportProductSetsInputConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportProductSetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportProductSetsRequest::input_config].
    pub fn set_input_config<
        T: std::convert::Into<std::option::Option<crate::model::ImportProductSetsInputConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input_config = v.into();
        self
    }
}

impl wkt::message::Message for ImportProductSetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsRequest"
    }
}

/// Response message for the `ImportProductSets` method.
///
/// This message is returned by the
/// [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation]
/// method in the returned
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportProductSetsResponse {
    /// The list of reference_images that are imported successfully.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub reference_images: std::vec::Vec<crate::model::ReferenceImage>,

    /// The rpc status for each ImportProductSet request, including both successes
    /// and errors.
    ///
    /// The number of statuses here matches the number of lines in the csv file,
    /// and statuses[i] stores the success or failure status of processing the i-th
    /// line of the csv, starting from line 0.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub statuses: std::vec::Vec<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductSetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reference_images][crate::model::ImportProductSetsResponse::reference_images].
    pub fn set_reference_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReferenceImage>,
    {
        use std::iter::Iterator;
        self.reference_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [statuses][crate::model::ImportProductSetsResponse::statuses].
    pub fn set_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportProductSetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ImportProductSetsResponse"
    }
}

/// Metadata for the batch operations such as the current state.
///
/// This is included in the `metadata` field of the `Operation` returned by the
/// `GetOperation` call of the `google::longrunning::Operations` service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchOperationMetadata {
    /// The current state of the batch operation.
    pub state: crate::model::batch_operation_metadata::State,

    /// The time when the batch request was submitted to the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the batch request is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchOperationMetadata::submit_time].
    pub fn set_submit_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.submit_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BatchOperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for BatchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.BatchOperationMetadata"
    }
}

/// Defines additional types related to [BatchOperationMetadata].
pub mod batch_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the batch request can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is actively being processed.
        Processing,
        /// The request is done and at least one item has been successfully
        /// processed.
        Successful,
        /// The request is done and no item has been successfully processed.
        Failed,
        /// The request is done after the longrunning.Operations.CancelOperation has
        /// been called by the user.  Any records that were processed before the
        /// cancel command are output as specified in the request.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Processing => std::option::Option::Some(1),
                Self::Successful => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Processing => std::option::Option::Some("PROCESSING"),
                Self::Successful => std::option::Option::Some("SUCCESSFUL"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Processing,
                2 => Self::Successful,
                3 => Self::Failed,
                4 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PROCESSING" => Self::Processing,
                "SUCCESSFUL" => Self::Successful,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Processing => serializer.serialize_i32(1),
                Self::Successful => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vision.v1.BatchOperationMetadata.State",
            ))
        }
    }
}

/// Config to control which ProductSet contains the Products to be deleted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ProductSetPurgeConfig {
    /// The ProductSet that contains the Products to delete. If a Product is a
    /// member of product_set_id in addition to other ProductSets, the Product will
    /// still be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub product_set_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductSetPurgeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product_set_id][crate::model::ProductSetPurgeConfig::product_set_id].
    pub fn set_product_set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_set_id = v.into();
        self
    }
}

impl wkt::message::Message for ProductSetPurgeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.ProductSetPurgeConfig"
    }
}

/// Request message for the `PurgeProducts` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PurgeProductsRequest {
    /// Required. The project and location in which the Products should be deleted.
    ///
    /// Format is `projects/PROJECT_ID/locations/LOC_ID`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The default value is false. Override this value to true to actually perform
    /// the purge.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    /// The Products to delete.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::purge_products_request::Target>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeProductsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::purge_products_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::PurgeProductsRequest::target]
    /// if it holds a `ProductSetPurgeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn product_set_purge_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProductSetPurgeConfig>> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::purge_products_request::Target::ProductSetPurgeConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [target][crate::model::PurgeProductsRequest::target]
    /// if it holds a `DeleteOrphanProducts`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_orphan_products(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::purge_products_request::Target::DeleteOrphanProducts(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target]
    /// to hold a `ProductSetPurgeConfig`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_product_set_purge_config<
        T: std::convert::Into<std::boxed::Box<crate::model::ProductSetPurgeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = std::option::Option::Some(
            crate::model::purge_products_request::Target::ProductSetPurgeConfig(v.into()),
        );
        self
    }

    /// Sets the value of [target][crate::model::PurgeProductsRequest::target]
    /// to hold a `DeleteOrphanProducts`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_delete_orphan_products<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::purge_products_request::Target::DeleteOrphanProducts(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PurgeProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.PurgeProductsRequest"
    }
}

/// Defines additional types related to [PurgeProductsRequest].
pub mod purge_products_request {
    #[allow(unused_imports)]
    use super::*;

    /// The Products to delete.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// Specify which ProductSet contains the Products to be deleted.
        ProductSetPurgeConfig(std::boxed::Box<crate::model::ProductSetPurgeConfig>),
        /// If delete_orphan_products is true, all Products that are not in any
        /// ProductSet will be deleted.
        DeleteOrphanProducts(bool),
    }
}

/// TextAnnotation contains a structured representation of OCR extracted text.
/// The hierarchy of an OCR extracted text structure is like this:
/// TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
/// Each structural component, starting from Page, may further have their own
/// properties. Properties describe detected languages, breaks etc.. Please refer
/// to the
/// [TextAnnotation.TextProperty][google.cloud.vision.v1.TextAnnotation.TextProperty]
/// message definition below for more detail.
///
/// [google.cloud.vision.v1.TextAnnotation.TextProperty]: crate::model::text_annotation::TextProperty
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TextAnnotation {
    /// List of pages detected by OCR.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pages: std::vec::Vec<crate::model::Page>,

    /// UTF-8 text detected on the pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TextAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::TextAnnotation::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [pages][crate::model::TextAnnotation::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Page>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TextAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.TextAnnotation"
    }
}

/// Defines additional types related to [TextAnnotation].
pub mod text_annotation {
    #[allow(unused_imports)]
    use super::*;

    /// Detected language for a structural component.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DetectedLanguage {
        /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
        /// information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub language_code: std::string::String,

        /// Confidence of detected language. Range [0, 1].
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub confidence: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectedLanguage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [language_code][crate::model::text_annotation::DetectedLanguage::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [confidence][crate::model::text_annotation::DetectedLanguage::confidence].
        pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence = v.into();
            self
        }
    }

    impl wkt::message::Message for DetectedLanguage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.DetectedLanguage"
        }
    }

    /// Detected start or end of a structural component.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DetectedBreak {
        /// Detected break type.
        #[serde(rename = "type")]
        pub r#type: crate::model::text_annotation::detected_break::BreakType,

        /// True if break prepends the element.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub is_prefix: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DetectedBreak {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::text_annotation::DetectedBreak::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::text_annotation::detected_break::BreakType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [is_prefix][crate::model::text_annotation::DetectedBreak::is_prefix].
        pub fn set_is_prefix<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for DetectedBreak {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.DetectedBreak"
        }
    }

    /// Defines additional types related to [DetectedBreak].
    pub mod detected_break {
        #[allow(unused_imports)]
        use super::*;

        /// Enum to denote the type of break found. New line, space etc.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BreakType {
            /// Unknown break label type.
            Unknown,
            /// Regular space.
            Space,
            /// Sure space (very wide).
            SureSpace,
            /// Line-wrapping break.
            EolSureSpace,
            /// End-line hyphen that is not present in text; does not co-occur with
            /// `SPACE`, `LEADER_SPACE`, or `LINE_BREAK`.
            Hyphen,
            /// Line break that ends a paragraph.
            LineBreak,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BreakType::value] or
            /// [BreakType::name].
            UnknownValue(break_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod break_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl BreakType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::Space => std::option::Option::Some(1),
                    Self::SureSpace => std::option::Option::Some(2),
                    Self::EolSureSpace => std::option::Option::Some(3),
                    Self::Hyphen => std::option::Option::Some(4),
                    Self::LineBreak => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::Space => std::option::Option::Some("SPACE"),
                    Self::SureSpace => std::option::Option::Some("SURE_SPACE"),
                    Self::EolSureSpace => std::option::Option::Some("EOL_SURE_SPACE"),
                    Self::Hyphen => std::option::Option::Some("HYPHEN"),
                    Self::LineBreak => std::option::Option::Some("LINE_BREAK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for BreakType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for BreakType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for BreakType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::Space,
                    2 => Self::SureSpace,
                    3 => Self::EolSureSpace,
                    4 => Self::Hyphen,
                    5 => Self::LineBreak,
                    _ => Self::UnknownValue(break_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for BreakType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "SPACE" => Self::Space,
                    "SURE_SPACE" => Self::SureSpace,
                    "EOL_SURE_SPACE" => Self::EolSureSpace,
                    "HYPHEN" => Self::Hyphen,
                    "LINE_BREAK" => Self::LineBreak,
                    _ => Self::UnknownValue(break_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for BreakType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::Space => serializer.serialize_i32(1),
                    Self::SureSpace => serializer.serialize_i32(2),
                    Self::EolSureSpace => serializer.serialize_i32(3),
                    Self::Hyphen => serializer.serialize_i32(4),
                    Self::LineBreak => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for BreakType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BreakType>::new(
                    ".google.cloud.vision.v1.TextAnnotation.DetectedBreak.BreakType",
                ))
            }
        }
    }

    /// Additional information detected on the structural component.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TextProperty {
        /// A list of detected languages together with confidence.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub detected_languages: std::vec::Vec<crate::model::text_annotation::DetectedLanguage>,

        /// Detected start or end of a text segment.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub detected_break: std::option::Option<crate::model::text_annotation::DetectedBreak>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TextProperty {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [detected_break][crate::model::text_annotation::TextProperty::detected_break].
        pub fn set_detected_break<
            T: std::convert::Into<std::option::Option<crate::model::text_annotation::DetectedBreak>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detected_break = v.into();
            self
        }

        /// Sets the value of [detected_languages][crate::model::text_annotation::TextProperty::detected_languages].
        pub fn set_detected_languages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::text_annotation::DetectedLanguage>,
        {
            use std::iter::Iterator;
            self.detected_languages = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TextProperty {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.TextAnnotation.TextProperty"
        }
    }
}

/// Detected page from OCR.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Page {
    /// Additional information detected on the page.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// Page width. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub width: i32,

    /// Page height. For PDFs the unit is points. For images (including
    /// TIFFs) the unit is pixels.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub height: i32,

    /// List of blocks of text, images etc on this page.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blocks: std::vec::Vec<crate::model::Block>,

    /// Confidence of the OCR results on the page. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Page {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Page::property].
    pub fn set_property<
        T: std::convert::Into<std::option::Option<crate::model::text_annotation::TextProperty>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.property = v.into();
        self
    }

    /// Sets the value of [width][crate::model::Page::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }

    /// Sets the value of [height][crate::model::Page::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Page::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [blocks][crate::model::Page::blocks].
    pub fn set_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Block>,
    {
        use std::iter::Iterator;
        self.blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Page {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Page"
    }
}

/// Logical element on the page.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Block {
    /// Additional information detected for the block.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the block.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///
    /// * and the vertex order will still be (0, 1, 2, 3).
    ///
    ///
    /// ```norust
    ///   0----1
    ///   |    |
    ///   3----2
    /// ```
    ///
    /// ```norust
    ///   2----3
    ///   |    |
    ///   1----0
    /// ```
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of paragraphs in this block (if this blocks is of type text).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub paragraphs: std::vec::Vec<crate::model::Paragraph>,

    /// Detected block type (text, image etc) for this block.
    pub block_type: crate::model::block::BlockType,

    /// Confidence of the OCR results on the block. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Block {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Block::property].
    pub fn set_property<
        T: std::convert::Into<std::option::Option<crate::model::text_annotation::TextProperty>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.property = v.into();
        self
    }

    /// Sets the value of [bounding_box][crate::model::Block::bounding_box].
    pub fn set_bounding_box<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_box = v.into();
        self
    }

    /// Sets the value of [block_type][crate::model::Block::block_type].
    pub fn set_block_type<T: std::convert::Into<crate::model::block::BlockType>>(
        mut self,
        v: T,
    ) -> Self {
        self.block_type = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Block::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [paragraphs][crate::model::Block::paragraphs].
    pub fn set_paragraphs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Paragraph>,
    {
        use std::iter::Iterator;
        self.paragraphs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Block {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Block"
    }
}

/// Defines additional types related to [Block].
pub mod block {
    #[allow(unused_imports)]
    use super::*;

    /// Type of a block (text, image etc) as identified by OCR.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BlockType {
        /// Unknown block type.
        Unknown,
        /// Regular text block.
        Text,
        /// Table block.
        Table,
        /// Image block.
        Picture,
        /// Horizontal/vertical line box.
        Ruler,
        /// Barcode block.
        Barcode,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BlockType::value] or
        /// [BlockType::name].
        UnknownValue(block_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod block_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BlockType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Text => std::option::Option::Some(1),
                Self::Table => std::option::Option::Some(2),
                Self::Picture => std::option::Option::Some(3),
                Self::Ruler => std::option::Option::Some(4),
                Self::Barcode => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Picture => std::option::Option::Some("PICTURE"),
                Self::Ruler => std::option::Option::Some("RULER"),
                Self::Barcode => std::option::Option::Some("BARCODE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BlockType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BlockType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BlockType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Text,
                2 => Self::Table,
                3 => Self::Picture,
                4 => Self::Ruler,
                5 => Self::Barcode,
                _ => Self::UnknownValue(block_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BlockType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "TEXT" => Self::Text,
                "TABLE" => Self::Table,
                "PICTURE" => Self::Picture,
                "RULER" => Self::Ruler,
                "BARCODE" => Self::Barcode,
                _ => Self::UnknownValue(block_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BlockType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Text => serializer.serialize_i32(1),
                Self::Table => serializer.serialize_i32(2),
                Self::Picture => serializer.serialize_i32(3),
                Self::Ruler => serializer.serialize_i32(4),
                Self::Barcode => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BlockType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BlockType>::new(
                ".google.cloud.vision.v1.Block.BlockType",
            ))
        }
    }
}

/// Structural unit of text representing a number of words in certain order.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Paragraph {
    /// Additional information detected for the paragraph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the paragraph.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of all words in this paragraph.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub words: std::vec::Vec<crate::model::Word>,

    /// Confidence of the OCR results for the paragraph. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Paragraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Paragraph::property].
    pub fn set_property<
        T: std::convert::Into<std::option::Option<crate::model::text_annotation::TextProperty>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.property = v.into();
        self
    }

    /// Sets the value of [bounding_box][crate::model::Paragraph::bounding_box].
    pub fn set_bounding_box<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_box = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Paragraph::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [words][crate::model::Paragraph::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Word>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Paragraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Paragraph"
    }
}

/// A word representation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Word {
    /// Additional information detected for the word.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the word.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// List of symbols in the word.
    /// The order of the symbols follows the natural reading order.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub symbols: std::vec::Vec<crate::model::Symbol>,

    /// Confidence of the OCR results for the word. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Word {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Word::property].
    pub fn set_property<
        T: std::convert::Into<std::option::Option<crate::model::text_annotation::TextProperty>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.property = v.into();
        self
    }

    /// Sets the value of [bounding_box][crate::model::Word::bounding_box].
    pub fn set_bounding_box<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_box = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Word::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [symbols][crate::model::Word::symbols].
    pub fn set_symbols<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Symbol>,
    {
        use std::iter::Iterator;
        self.symbols = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Word {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Word"
    }
}

/// A single symbol representation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Symbol {
    /// Additional information detected for the symbol.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub property: std::option::Option<crate::model::text_annotation::TextProperty>,

    /// The bounding box for the symbol.
    /// The vertices are in the order of top-left, top-right, bottom-right,
    /// bottom-left. When a rotation of the bounding box is detected the rotation
    /// is represented as around the top-left corner as defined when the text is
    /// read in the 'natural' orientation.
    /// For example:
    ///
    /// * when the text is horizontal it might look like:
    ///   0----1
    ///   |    |
    ///   3----2
    /// * when it's rotated 180 degrees around the top-left corner it becomes:
    ///   2----3
    ///   |    |
    ///   1----0
    ///   and the vertex order will still be (0, 1, 2, 3).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bounding_box: std::option::Option<crate::model::BoundingPoly>,

    /// The actual UTF-8 representation of the symbol.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub text: std::string::String,

    /// Confidence of the OCR results for the symbol. Range [0, 1].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub confidence: f32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Symbol {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [property][crate::model::Symbol::property].
    pub fn set_property<
        T: std::convert::Into<std::option::Option<crate::model::text_annotation::TextProperty>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.property = v.into();
        self
    }

    /// Sets the value of [bounding_box][crate::model::Symbol::bounding_box].
    pub fn set_bounding_box<
        T: std::convert::Into<std::option::Option<crate::model::BoundingPoly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bounding_box = v.into();
        self
    }

    /// Sets the value of [text][crate::model::Symbol::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Symbol::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for Symbol {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.Symbol"
    }
}

/// Relevant information for the image from the Internet.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WebDetection {
    /// Deduced entities from similar images on the Internet.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub web_entities: std::vec::Vec<crate::model::web_detection::WebEntity>,

    /// Fully matching images from the Internet.
    /// Can include resized copies of the query image.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub full_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// Partial matching images from the Internet.
    /// Those images are similar enough to share some key-point features. For
    /// example an original image will likely have partial matching for its crops.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partial_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// Web pages containing the matching images from the Internet.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub pages_with_matching_images: std::vec::Vec<crate::model::web_detection::WebPage>,

    /// The visually similar image results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub visually_similar_images: std::vec::Vec<crate::model::web_detection::WebImage>,

    /// The service's best guess as to the topic of the request image.
    /// Inferred from similar images on the open web.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub best_guess_labels: std::vec::Vec<crate::model::web_detection::WebLabel>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WebDetection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [web_entities][crate::model::WebDetection::web_entities].
    pub fn set_web_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebEntity>,
    {
        use std::iter::Iterator;
        self.web_entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [full_matching_images][crate::model::WebDetection::full_matching_images].
    pub fn set_full_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.full_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_matching_images][crate::model::WebDetection::partial_matching_images].
    pub fn set_partial_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.partial_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pages_with_matching_images][crate::model::WebDetection::pages_with_matching_images].
    pub fn set_pages_with_matching_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebPage>,
    {
        use std::iter::Iterator;
        self.pages_with_matching_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [visually_similar_images][crate::model::WebDetection::visually_similar_images].
    pub fn set_visually_similar_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebImage>,
    {
        use std::iter::Iterator;
        self.visually_similar_images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [best_guess_labels][crate::model::WebDetection::best_guess_labels].
    pub fn set_best_guess_labels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::web_detection::WebLabel>,
    {
        use std::iter::Iterator;
        self.best_guess_labels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WebDetection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vision.v1.WebDetection"
    }
}

/// Defines additional types related to [WebDetection].
pub mod web_detection {
    #[allow(unused_imports)]
    use super::*;

    /// Entity deduced from similar images on the Internet.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WebEntity {
        /// Opaque entity ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity_id: std::string::String,

        /// Overall relevancy score for the entity.
        /// Not normalized and not comparable across different image queries.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub score: f32,

        /// Canonical description of the entity, in English.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebEntity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_id][crate::model::web_detection::WebEntity::entity_id].
        pub fn set_entity_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_id = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebEntity::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [description][crate::model::web_detection::WebEntity::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for WebEntity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebEntity"
        }
    }

    /// Metadata for online images.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WebImage {
        /// The result image URL.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub url: std::string::String,

        /// (Deprecated) Overall relevancy score for the image.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub score: f32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebImage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::web_detection::WebImage::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebImage::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }
    }

    impl wkt::message::Message for WebImage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebImage"
        }
    }

    /// Metadata for web pages.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WebPage {
        /// The result web page URL.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub url: std::string::String,

        /// (Deprecated) Overall relevancy score for the web page.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub score: f32,

        /// Title for the web page, may contain HTML markups.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub page_title: std::string::String,

        /// Fully matching images on the page.
        /// Can include resized copies of the query image.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub full_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

        /// Partial matching images on the page.
        /// Those images are similar enough to share some key-point features. For
        /// example an original image will likely have partial matching for its
        /// crops.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub partial_matching_images: std::vec::Vec<crate::model::web_detection::WebImage>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebPage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::web_detection::WebPage::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [score][crate::model::web_detection::WebPage::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [page_title][crate::model::web_detection::WebPage::page_title].
        pub fn set_page_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.page_title = v.into();
            self
        }

        /// Sets the value of [full_matching_images][crate::model::web_detection::WebPage::full_matching_images].
        pub fn set_full_matching_images<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::web_detection::WebImage>,
        {
            use std::iter::Iterator;
            self.full_matching_images = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [partial_matching_images][crate::model::web_detection::WebPage::partial_matching_images].
        pub fn set_partial_matching_images<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::web_detection::WebImage>,
        {
            use std::iter::Iterator;
            self.partial_matching_images = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for WebPage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebPage"
        }
    }

    /// Label to provide extra metadata for the web detection.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct WebLabel {
        /// Label for extra metadata.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub label: std::string::String,

        /// The BCP-47 language code for `label`, such as "en-US" or "sr-Latn".
        /// For more information, see
        /// <http://www.unicode.org/reports/tr35/#Unicode_locale_identifier>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub language_code: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WebLabel {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [label][crate::model::web_detection::WebLabel::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::web_detection::WebLabel::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }
    }

    impl wkt::message::Message for WebLabel {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vision.v1.WebDetection.WebLabel"
        }
    }
}

/// A bucketized representation of likelihood, which is intended to give clients
/// highly stable results across model upgrades.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Likelihood {
    /// Unknown likelihood.
    Unknown,
    /// It is very unlikely.
    VeryUnlikely,
    /// It is unlikely.
    Unlikely,
    /// It is possible.
    Possible,
    /// It is likely.
    Likely,
    /// It is very likely.
    VeryLikely,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Likelihood::value] or
    /// [Likelihood::name].
    UnknownValue(likelihood::UnknownValue),
}

#[doc(hidden)]
pub mod likelihood {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Likelihood {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unknown => std::option::Option::Some(0),
            Self::VeryUnlikely => std::option::Option::Some(1),
            Self::Unlikely => std::option::Option::Some(2),
            Self::Possible => std::option::Option::Some(3),
            Self::Likely => std::option::Option::Some(4),
            Self::VeryLikely => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unknown => std::option::Option::Some("UNKNOWN"),
            Self::VeryUnlikely => std::option::Option::Some("VERY_UNLIKELY"),
            Self::Unlikely => std::option::Option::Some("UNLIKELY"),
            Self::Possible => std::option::Option::Some("POSSIBLE"),
            Self::Likely => std::option::Option::Some("LIKELY"),
            Self::VeryLikely => std::option::Option::Some("VERY_LIKELY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Likelihood {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Likelihood {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Likelihood {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unknown,
            1 => Self::VeryUnlikely,
            2 => Self::Unlikely,
            3 => Self::Possible,
            4 => Self::Likely,
            5 => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Likelihood {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNKNOWN" => Self::Unknown,
            "VERY_UNLIKELY" => Self::VeryUnlikely,
            "UNLIKELY" => Self::Unlikely,
            "POSSIBLE" => Self::Possible,
            "LIKELY" => Self::Likely,
            "VERY_LIKELY" => Self::VeryLikely,
            _ => Self::UnknownValue(likelihood::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Likelihood {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unknown => serializer.serialize_i32(0),
            Self::VeryUnlikely => serializer.serialize_i32(1),
            Self::Unlikely => serializer.serialize_i32(2),
            Self::Possible => serializer.serialize_i32(3),
            Self::Likely => serializer.serialize_i32(4),
            Self::VeryLikely => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Likelihood {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Likelihood>::new(
            ".google.cloud.vision.v1.Likelihood",
        ))
    }
}
