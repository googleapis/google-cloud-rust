// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;
use std::sync::Arc;

/// Implements a client for the Cloud Vision API.
///
/// # Service Description
///
/// Service that performs Google Cloud Vision API detection tasks over client
/// images, such as face, landmark, logo, label, and text detection. The
/// ImageAnnotator service returns detected entities from the images.
///
/// # Configuration
///
/// `ImageAnnotator` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ImageAnnotator` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ImageAnnotator` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ImageAnnotator {
    inner: Arc<dyn crate::stubs::dynamic::ImageAnnotator>,
}

impl ImageAnnotator {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ImageAnnotator + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ImageAnnotator>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ImageAnnotator> {
        crate::transport::ImageAnnotator::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ImageAnnotator> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ImageAnnotator::new)
    }

    /// Run image detection and annotation for a batch of images.
    pub fn batch_annotate_images(&self) -> crate::builders::image_annotator::BatchAnnotateImages {
        crate::builders::image_annotator::BatchAnnotateImages::new(self.inner.clone())
    }

    /// Service that performs image detection and annotation for a batch of files.
    /// Now only "application/pdf", "image/tiff" and "image/gif" are supported.
    ///
    /// This service will extract at most 5 (customers can specify which 5 in
    /// AnnotateFileRequest.pages) frames (gif) or pages (pdf or tiff) from each
    /// file provided and perform detection and annotation for each image
    /// extracted.
    pub fn batch_annotate_files(&self) -> crate::builders::image_annotator::BatchAnnotateFiles {
        crate::builders::image_annotator::BatchAnnotateFiles::new(self.inner.clone())
    }

    /// Run asynchronous image detection and annotation for a list of images.
    ///
    /// Progress and results can be retrieved through the
    /// `google.longrunning.Operations` interface.
    /// `Operation.metadata` contains `OperationMetadata` (metadata).
    /// `Operation.response` contains `AsyncBatchAnnotateImagesResponse` (results).
    ///
    /// This service will write image annotation outputs to json files in customer
    /// GCS bucket, each json file containing BatchAnnotateImagesResponse proto.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AsyncBatchAnnotateImagesResponse, model::OperationMetadata>
    /// ) -> Result<model::AsyncBatchAnnotateImagesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AsyncBatchAnnotateImagesResponse, model::OperationMetadata>
    /// ) -> Result<model::AsyncBatchAnnotateImagesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::AsyncBatchAnnotateImagesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::OperationMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::image_annotator::AsyncBatchAnnotateImages::send
    /// [poller()]: crate::builders::image_annotator::AsyncBatchAnnotateImages::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn async_batch_annotate_images(
        &self,
    ) -> crate::builders::image_annotator::AsyncBatchAnnotateImages {
        crate::builders::image_annotator::AsyncBatchAnnotateImages::new(self.inner.clone())
    }

    /// Run asynchronous image detection and annotation for a list of generic
    /// files, such as PDF files, which may contain multiple pages and multiple
    /// images per page. Progress and results can be retrieved through the
    /// `google.longrunning.Operations` interface.
    /// `Operation.metadata` contains `OperationMetadata` (metadata).
    /// `Operation.response` contains `AsyncBatchAnnotateFilesResponse` (results).
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AsyncBatchAnnotateFilesResponse, model::OperationMetadata>
    /// ) -> Result<model::AsyncBatchAnnotateFilesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AsyncBatchAnnotateFilesResponse, model::OperationMetadata>
    /// ) -> Result<model::AsyncBatchAnnotateFilesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::AsyncBatchAnnotateFilesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::OperationMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::image_annotator::AsyncBatchAnnotateFiles::send
    /// [poller()]: crate::builders::image_annotator::AsyncBatchAnnotateFiles::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn async_batch_annotate_files(
        &self,
    ) -> crate::builders::image_annotator::AsyncBatchAnnotateFiles {
        crate::builders::image_annotator::AsyncBatchAnnotateFiles::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::image_annotator::GetOperation {
        crate::builders::image_annotator::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Cloud Vision API.
///
/// # Service Description
///
/// Manages Products and ProductSets of reference images for use in product
/// search. It uses the following resource model:
///
/// - The API has a collection of [ProductSet][google.cloud.vision.v1.ProductSet]
///   resources, named `projects/*/locations/*/productSets/*`, which acts as a way
///   to put different products into groups to limit identification.
///
/// In parallel,
///
/// - The API has a collection of [Product][google.cloud.vision.v1.Product]
///   resources, named
///   `projects/*/locations/*/products/*`
///
/// - Each [Product][google.cloud.vision.v1.Product] has a collection of
///   [ReferenceImage][google.cloud.vision.v1.ReferenceImage] resources, named
///   `projects/*/locations/*/products/*/referenceImages/*`
///
///
/// [google.cloud.vision.v1.Product]: crate::model::Product
/// [google.cloud.vision.v1.ProductSet]: crate::model::ProductSet
/// [google.cloud.vision.v1.ReferenceImage]: crate::model::ReferenceImage
///
/// # Configuration
///
/// `ProductSearch` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ProductSearch` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ProductSearch` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ProductSearch {
    inner: Arc<dyn crate::stubs::dynamic::ProductSearch>,
}

impl ProductSearch {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ProductSearch + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ProductSearch>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ProductSearch> {
        crate::transport::ProductSearch::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ProductSearch> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ProductSearch::new)
    }

    /// Creates and returns a new ProductSet resource.
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if display_name is missing, or is longer than
    ///   4096 characters.
    pub fn create_product_set(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::CreateProductSet {
        crate::builders::product_search::CreateProductSet::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Lists ProductSets in an unspecified order.
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if page_size is greater than 100, or less
    ///   than 1.
    pub fn list_product_sets(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::ListProductSets {
        crate::builders::product_search::ListProductSets::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets information associated with a ProductSet.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the ProductSet does not exist.
    pub fn get_product_set(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::GetProductSet {
        crate::builders::product_search::GetProductSet::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Makes changes to a ProductSet resource.
    /// Only display_name can be updated currently.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the ProductSet does not exist.
    /// * Returns INVALID_ARGUMENT if display_name is present in update_mask but
    ///   missing from the request or longer than 4096 characters.
    pub fn update_product_set(
        &self,
        product_set: impl Into<crate::model::ProductSet>,
    ) -> crate::builders::product_search::UpdateProductSet {
        crate::builders::product_search::UpdateProductSet::new(self.inner.clone())
            .set_product_set(product_set.into())
    }

    /// Permanently deletes a ProductSet. Products and ReferenceImages in the
    /// ProductSet are not deleted.
    ///
    /// The actual image files are not deleted from Google Cloud Storage.
    pub fn delete_product_set(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::DeleteProductSet {
        crate::builders::product_search::DeleteProductSet::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates and returns a new product resource.
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if display_name is missing or longer than 4096
    ///   characters.
    /// * Returns INVALID_ARGUMENT if description is longer than 4096 characters.
    /// * Returns INVALID_ARGUMENT if product_category is missing or invalid.
    pub fn create_product(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::CreateProduct {
        crate::builders::product_search::CreateProduct::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Lists products in an unspecified order.
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
    pub fn list_products(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::ListProducts {
        crate::builders::product_search::ListProducts::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets information associated with a Product.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the Product does not exist.
    pub fn get_product(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::GetProduct {
        crate::builders::product_search::GetProduct::new(self.inner.clone()).set_name(name.into())
    }

    /// Makes changes to a Product resource.
    /// Only the `display_name`, `description`, and `labels` fields can be updated
    /// right now.
    ///
    /// If labels are updated, the change will not be reflected in queries until
    /// the next index time.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the Product does not exist.
    /// * Returns INVALID_ARGUMENT if display_name is present in update_mask but is
    ///   missing from the request or longer than 4096 characters.
    /// * Returns INVALID_ARGUMENT if description is present in update_mask but is
    ///   longer than 4096 characters.
    /// * Returns INVALID_ARGUMENT if product_category is present in update_mask.
    pub fn update_product(
        &self,
        product: impl Into<crate::model::Product>,
    ) -> crate::builders::product_search::UpdateProduct {
        crate::builders::product_search::UpdateProduct::new(self.inner.clone())
            .set_product(product.into())
    }

    /// Permanently deletes a product and its reference images.
    ///
    /// Metadata of the product and all its images will be deleted right away, but
    /// search queries against ProductSets containing the product may still work
    /// until all related caches are refreshed.
    pub fn delete_product(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::DeleteProduct {
        crate::builders::product_search::DeleteProduct::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Creates and returns a new ReferenceImage resource.
    ///
    /// The `bounding_poly` field is optional. If `bounding_poly` is not specified,
    /// the system will try to detect regions of interest in the image that are
    /// compatible with the product_category on the parent product. If it is
    /// specified, detection is ALWAYS skipped. The system converts polygons into
    /// non-rotated rectangles.
    ///
    /// Note that the pipeline will resize the image if the image resolution is too
    /// large to process (above 50MP).
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if the image_uri is missing or longer than 4096
    ///   characters.
    /// * Returns INVALID_ARGUMENT if the product does not exist.
    /// * Returns INVALID_ARGUMENT if bounding_poly is not provided, and nothing
    ///   compatible with the parent product's product_category is detected.
    /// * Returns INVALID_ARGUMENT if bounding_poly contains more than 10 polygons.
    pub fn create_reference_image(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::CreateReferenceImage {
        crate::builders::product_search::CreateReferenceImage::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Permanently deletes a reference image.
    ///
    /// The image metadata will be deleted right away, but search queries
    /// against ProductSets containing the image may still work until all related
    /// caches are refreshed.
    ///
    /// The actual image files are not deleted from Google Cloud Storage.
    pub fn delete_reference_image(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::DeleteReferenceImage {
        crate::builders::product_search::DeleteReferenceImage::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Lists reference images.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the parent product does not exist.
    /// * Returns INVALID_ARGUMENT if the page_size is greater than 100, or less
    ///   than 1.
    pub fn list_reference_images(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::ListReferenceImages {
        crate::builders::product_search::ListReferenceImages::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets information associated with a ReferenceImage.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the specified image does not exist.
    pub fn get_reference_image(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::GetReferenceImage {
        crate::builders::product_search::GetReferenceImage::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Adds a Product to the specified ProductSet. If the Product is already
    /// present, no change is made.
    ///
    /// One Product can be added to at most 100 ProductSets.
    ///
    /// Possible errors:
    ///
    /// * Returns NOT_FOUND if the Product or the ProductSet doesn't exist.
    pub fn add_product_to_product_set(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::AddProductToProductSet {
        crate::builders::product_search::AddProductToProductSet::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Removes a Product from the specified ProductSet.
    pub fn remove_product_from_product_set(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::RemoveProductFromProductSet {
        crate::builders::product_search::RemoveProductFromProductSet::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Lists the Products in a ProductSet, in an unspecified order. If the
    /// ProductSet does not exist, the products field of the response will be
    /// empty.
    ///
    /// Possible errors:
    ///
    /// * Returns INVALID_ARGUMENT if page_size is greater than 100 or less than 1.
    pub fn list_products_in_product_set(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::ListProductsInProductSet {
        crate::builders::product_search::ListProductsInProductSet::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Asynchronous API that imports a list of reference images to specified
    /// product sets based on a list of image information.
    ///
    /// The [google.longrunning.Operation][google.longrunning.Operation] API can be
    /// used to keep track of the progress and results of the request.
    /// `Operation.metadata` contains `BatchOperationMetadata`. (progress)
    /// `Operation.response` contains `ImportProductSetsResponse`. (results)
    ///
    /// The input source of this method is a csv file on Google Cloud Storage.
    /// For the format of the csv file please see
    /// [ImportProductSetsGcsSource.csv_file_uri][google.cloud.vision.v1.ImportProductSetsGcsSource.csv_file_uri].
    ///
    /// [google.cloud.vision.v1.ImportProductSetsGcsSource.csv_file_uri]: crate::model::ImportProductSetsGcsSource::csv_file_uri
    /// [google.longrunning.Operation]: longrunning::model::Operation
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportProductSetsResponse, model::BatchOperationMetadata>
    /// ) -> Result<model::ImportProductSetsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportProductSetsResponse, model::BatchOperationMetadata>
    /// ) -> Result<model::ImportProductSetsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::ImportProductSetsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::BatchOperationMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_search::ImportProductSets::send
    /// [poller()]: crate::builders::product_search::ImportProductSets::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn import_product_sets(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::ImportProductSets {
        crate::builders::product_search::ImportProductSets::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Asynchronous API to delete all Products in a ProductSet or all Products
    /// that are in no ProductSet.
    ///
    /// If a Product is a member of the specified ProductSet in addition to other
    /// ProductSets, the Product will still be deleted.
    ///
    /// It is recommended to not delete the specified ProductSet until after this
    /// operation has completed. It is also recommended to not add any of the
    /// Products involved in the batch delete to a new ProductSet while this
    /// operation is running because those Products may still end up deleted.
    ///
    /// It's not possible to undo the PurgeProducts operation. Therefore, it is
    /// recommended to keep the csv files used in ImportProductSets (if that was
    /// how you originally built the Product Set) before starting PurgeProducts, in
    /// case you need to re-import the data after deletion.
    ///
    /// If the plan is to purge all of the Products from a ProductSet and then
    /// re-use the empty ProductSet to re-import new Products into the empty
    /// ProductSet, you must wait until the PurgeProducts operation has finished
    /// for that ProductSet.
    ///
    /// The [google.longrunning.Operation][google.longrunning.Operation] API can be
    /// used to keep track of the progress and results of the request.
    /// `Operation.metadata` contains `BatchOperationMetadata`. (progress)
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::BatchOperationMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_vision_v1::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<wkt::Empty, model::BatchOperationMetadata>
    /// ) -> Result<wkt::Empty> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [wkt::Empty] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::BatchOperationMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_search::PurgeProducts::send
    /// [poller()]: crate::builders::product_search::PurgeProducts::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn purge_products(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_search::PurgeProducts {
        crate::builders::product_search::PurgeProducts::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_search::GetOperation {
        crate::builders::product_search::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}
