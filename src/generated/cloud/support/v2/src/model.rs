// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An Actor represents an entity that performed an action. For example, an actor
/// could be a user who posted a comment on a support case, a user who
/// uploaded an attachment, or a service account that created a support case.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Actor {
    /// The name to display for the actor. If not provided, it is inferred from
    /// credentials supplied during case creation. When an email is provided, a
    /// display name must also be provided. This will be obfuscated if the user
    /// is a Google Support agent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// The email address of the actor. If not provided, it is inferred from the
    /// credentials supplied during case creation. When a name is provided, an
    /// email must also be provided. If the user is a Google Support agent, this is
    /// obfuscated.
    ///
    /// This field is deprecated. Use `username` instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    #[deprecated]
    pub email: std::string::String,

    /// Output only. Whether the actor is a Google support actor.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub google_support: bool,

    /// Output only. The username of the actor. It may look like an email or other
    /// format provided by the identity provider. If not provided, it is inferred
    /// from the credentials supplied. When a name is provided, a username must
    /// also be provided. If the user is a Google Support agent, this will not be
    /// set.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Actor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::Actor::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [email][crate::model::Actor::email].
    #[deprecated]
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [google_support][crate::model::Actor::google_support].
    pub fn set_google_support<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.google_support = v.into();
        self
    }

    /// Sets the value of [username][crate::model::Actor::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for Actor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.Actor"
    }
}

/// An Attachment contains metadata about a file that was uploaded to a
/// case - it is NOT a file itself. That being said, the name of an Attachment
/// object can be used to download its accompanying file through the
/// `media.download` endpoint.
///
/// While attachments can be uploaded in the console at the
/// same time as a comment, they're associated on a "case" level, not a
/// "comment" level.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Attachment {
    /// Output only. Identifier. The resource name of the attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. The time at which the attachment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The user who uploaded the attachment. Note, the name and email
    /// will be obfuscated if the attachment was uploaded by Google support.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creator: std::option::Option<crate::model::Actor>,

    /// The filename of the attachment (e.g. `"graph.jpg"`).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filename: std::string::String,

    /// Output only. The MIME type of the attachment (e.g. text/plain).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub mime_type: std::string::String,

    /// Output only. The size of the attachment in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub size_bytes: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Attachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Attachment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Attachment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Attachment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Attachment::creator].
    pub fn set_creator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creator][crate::model::Attachment::creator].
    pub fn set_or_clear_creator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filename][crate::model::Attachment::filename].
    pub fn set_filename<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filename = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::Attachment::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Attachment::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }
}

impl wkt::message::Message for Attachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.Attachment"
    }
}

/// The request message for the ListAttachments endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachmentsRequest {
    /// Required. The name of the case for which attachments should be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of attachments fetched with each request.
    ///
    /// If not provided, the default is 10. The maximum page size that will be
    /// returned is 100.
    ///
    /// The size of each page can be smaller than the requested page size and can
    /// include zero. For example, you could request 100 attachments on one page,
    /// receive 0, and then on the next page, receive 90.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAttachmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAttachmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAttachmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListAttachmentsRequest"
    }
}

/// The response message for the ListAttachments endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAttachmentsResponse {
    /// The list of attachments associated with a case.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub attachments: std::vec::Vec<crate::model::Attachment>,

    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.attachments.list` requests. If unspecified,
    /// there are no more results to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAttachmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attachments][crate::model::ListAttachmentsResponse::attachments].
    pub fn set_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Attachment>,
    {
        use std::iter::Iterator;
        self.attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAttachmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAttachmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListAttachmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAttachmentsResponse {
    type PageItem = crate::model::Attachment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.attachments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A Case is an object that contains the details of a support case. It
/// contains fields for the time it was created, its priority, its
/// classification, and more. Cases can also have comments and attachments that
/// get added over time.
///
/// A case is parented by a Google Cloud organization or project.
///
/// Organizations are identified by a number, so the name of a case parented by
/// an organization would look like this:
///
/// ```norust
/// organizations/123/cases/456
/// ```
///
/// Projects have two unique identifiers, an ID and a number, and they look like
/// this:
///
/// ```norust
/// projects/abc/cases/456
/// ```
///
/// ```norust
/// projects/123/cases/456
/// ```
///
/// You can use either of them when calling the API. To learn more
/// about project identifiers, see [AIP-2510](https://google.aip.dev/cloud/2510).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Case {
    /// Identifier. The resource name for the case.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The short summary of the issue reported in this case.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    /// A broad description of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub description: std::string::String,

    /// The issue classification applicable to this case.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub classification: std::option::Option<crate::model::CaseClassification>,

    /// The timezone of the user who created the support case.
    /// It should be in a format IANA recognizes: <https://www.iana.org/time-zones>.
    /// There is no additional validation done by the API.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub time_zone: std::string::String,

    /// The email addresses to receive updates on this case.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub subscriber_email_addresses: std::vec::Vec<std::string::String>,

    /// Output only. The current status of the support case.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state: crate::model::case::State,

    /// Output only. The time this case was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this case was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The user who created the case.
    ///
    /// Note: The name and email will be obfuscated if the case was created by
    /// Google Support.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creator: std::option::Option<crate::model::Actor>,

    /// A user-supplied email address to send case update notifications for. This
    /// should only be used in BYOID flows, where we cannot infer the user's email
    /// address directly from their EUCs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub contact_email: std::string::String,

    /// Whether the case is currently escalated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub escalated: bool,

    /// Whether this case was created for internal API testing and should not be
    /// acted on by the support team.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub test_case: bool,

    /// The language the user has requested to receive support in. This should be a
    /// BCP 47 language code (e.g., `"en"`, `"zh-CN"`, `"zh-TW"`, `"ja"`, `"ko"`).
    /// If no language or an unsupported language is specified, this field defaults
    /// to English (en).
    ///
    /// Language selection during case creation may affect your available support
    /// options. For a list of supported languages and their support working hours,
    /// see: <https://cloud.google.com/support/docs/language-working-hours>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub language_code: std::string::String,

    /// The priority of this case.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub priority: crate::model::case::Priority,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Case {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Case::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Case::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Case::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [classification][crate::model::Case::classification].
    pub fn set_classification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CaseClassification>,
    {
        self.classification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [classification][crate::model::Case::classification].
    pub fn set_or_clear_classification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CaseClassification>,
    {
        self.classification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_zone][crate::model::Case::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [subscriber_email_addresses][crate::model::Case::subscriber_email_addresses].
    pub fn set_subscriber_email_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subscriber_email_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::Case::state].
    pub fn set_state<T: std::convert::Into<crate::model::case::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Case::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Case::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Case::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Case::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Case::creator].
    pub fn set_creator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creator][crate::model::Case::creator].
    pub fn set_or_clear_creator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contact_email][crate::model::Case::contact_email].
    pub fn set_contact_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.contact_email = v.into();
        self
    }

    /// Sets the value of [escalated][crate::model::Case::escalated].
    pub fn set_escalated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.escalated = v.into();
        self
    }

    /// Sets the value of [test_case][crate::model::Case::test_case].
    pub fn set_test_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.test_case = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Case::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::Case::priority].
    pub fn set_priority<T: std::convert::Into<crate::model::case::Priority>>(
        mut self,
        v: T,
    ) -> Self {
        self.priority = v.into();
        self
    }
}

impl wkt::message::Message for Case {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.Case"
    }
}

/// Defines additional types related to [Case].
pub mod case {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a support case.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Case is in an unknown state.
        Unspecified,
        /// The case has been created but no one is assigned to work on it yet.
        New,
        /// The case is currently being handled by Google support.
        InProgressGoogleSupport,
        /// Google is waiting for a response.
        ActionRequired,
        /// A solution has been offered for the case, but it isn't yet closed.
        SolutionProvided,
        /// The case has been resolved.
        Closed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::New => std::option::Option::Some(1),
                Self::InProgressGoogleSupport => std::option::Option::Some(2),
                Self::ActionRequired => std::option::Option::Some(3),
                Self::SolutionProvided => std::option::Option::Some(4),
                Self::Closed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::New => std::option::Option::Some("NEW"),
                Self::InProgressGoogleSupport => {
                    std::option::Option::Some("IN_PROGRESS_GOOGLE_SUPPORT")
                }
                Self::ActionRequired => std::option::Option::Some("ACTION_REQUIRED"),
                Self::SolutionProvided => std::option::Option::Some("SOLUTION_PROVIDED"),
                Self::Closed => std::option::Option::Some("CLOSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::New,
                2 => Self::InProgressGoogleSupport,
                3 => Self::ActionRequired,
                4 => Self::SolutionProvided,
                5 => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NEW" => Self::New,
                "IN_PROGRESS_GOOGLE_SUPPORT" => Self::InProgressGoogleSupport,
                "ACTION_REQUIRED" => Self::ActionRequired,
                "SOLUTION_PROVIDED" => Self::SolutionProvided,
                "CLOSED" => Self::Closed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::New => serializer.serialize_i32(1),
                Self::InProgressGoogleSupport => serializer.serialize_i32(2),
                Self::ActionRequired => serializer.serialize_i32(3),
                Self::SolutionProvided => serializer.serialize_i32(4),
                Self::Closed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.support.v2.Case.State",
            ))
        }
    }

    /// The case Priority. P0 is most urgent and P4 the least.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Priority {
        /// Priority is undefined or has not been set yet.
        Unspecified,
        /// Extreme impact on a production service. Service is hard down.
        P0,
        /// Critical impact on a production service. Service is currently unusable.
        P1,
        /// Severe impact on a production service. Service is usable but greatly
        /// impaired.
        P2,
        /// Medium impact on a production service.  Service is available, but
        /// moderately impaired.
        P3,
        /// General questions or minor issues.  Production service is fully
        /// available.
        P4,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Priority::value] or
        /// [Priority::name].
        UnknownValue(priority::UnknownValue),
    }

    #[doc(hidden)]
    pub mod priority {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Priority {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::P0 => std::option::Option::Some(1),
                Self::P1 => std::option::Option::Some(2),
                Self::P2 => std::option::Option::Some(3),
                Self::P3 => std::option::Option::Some(4),
                Self::P4 => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                Self::P0 => std::option::Option::Some("P0"),
                Self::P1 => std::option::Option::Some("P1"),
                Self::P2 => std::option::Option::Some("P2"),
                Self::P3 => std::option::Option::Some("P3"),
                Self::P4 => std::option::Option::Some("P4"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Priority {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Priority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Priority {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::P0,
                2 => Self::P1,
                3 => Self::P2,
                4 => Self::P3,
                5 => Self::P4,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Priority {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                "P0" => Self::P0,
                "P1" => Self::P1,
                "P2" => Self::P2,
                "P3" => Self::P3,
                "P4" => Self::P4,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Priority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::P0 => serializer.serialize_i32(1),
                Self::P1 => serializer.serialize_i32(2),
                Self::P2 => serializer.serialize_i32(3),
                Self::P3 => serializer.serialize_i32(4),
                Self::P4 => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Priority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                ".google.cloud.support.v2.Case.Priority",
            ))
        }
    }
}

/// A Case Classification represents the topic that a case is about. It's very
/// important to use accurate classifications, because they're
/// used to route your cases to specialists who can help you.
///
/// A classification always has an ID that is its unique identifier.
/// A valid ID is required when creating a case.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CaseClassification {
    /// The unique ID for a classification. Must be specified for case creation.
    ///
    /// To retrieve valid classification IDs for case creation, use
    /// `caseClassifications.search`.
    ///
    /// Classification IDs returned by `caseClassifications.search` are guaranteed
    /// to be valid for at least 6 months. If a given classification is
    /// deactiveated, it will immediately stop being returned. After 6 months,
    /// `case.create` requests using the classification ID will fail.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub id: std::string::String,

    /// A display name for the classification.
    ///
    /// The display name is not static and can change. To uniquely and consistently
    /// identify classifications, use the `CaseClassification.id` field.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CaseClassification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::CaseClassification::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::CaseClassification::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for CaseClassification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.CaseClassification"
    }
}

/// The request message for the GetCase endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCaseRequest {
    /// Required. The full name of a case to be retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.GetCaseRequest"
    }
}

/// The request message for the CreateCase endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCaseRequest {
    /// Required. The name of the parent under which the case should be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The case to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub case: std::option::Option<crate::model::Case>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [case][crate::model::CreateCaseRequest::case].
    pub fn set_case<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Case>,
    {
        self.case = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [case][crate::model::CreateCaseRequest::case].
    pub fn set_or_clear_case<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Case>,
    {
        self.case = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.CreateCaseRequest"
    }
}

/// The request message for the ListCases endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCasesRequest {
    /// Required. The name of a parent to list cases under.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// An expression used to filter cases.
    ///
    /// If it's an empty string, then no filtering happens. Otherwise, the endpoint
    /// returns the cases that match the filter.
    ///
    /// Expressions use the following fields separated by `AND` and specified with
    /// `=`:
    ///
    /// - `state`: Can be `OPEN` or `CLOSED`.
    /// - `priority`: Can be `P0`, `P1`, `P2`, `P3`, or `P4`. You
    ///   can specify multiple values for priority using the `OR` operator. For
    ///   example, `priority=P1 OR priority=P2`.
    /// - `creator.email`: The email address of the case creator.
    ///
    /// EXAMPLES:
    ///
    /// - `state=CLOSED`
    /// - `state=OPEN AND creator.email="tester@example.com"`
    /// - `state=OPEN AND (priority=P0 OR priority=P1)`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// The maximum number of cases fetched with each request. Defaults to 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListCasesRequest"
    }
}

/// The response message for the ListCases endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCasesResponse {
    /// The list of cases associated with the parent after any
    /// filters have been applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub cases: std::vec::Vec<crate::model::Case>,

    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.list` requests. If unspecified, there are no
    /// more results to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cases][crate::model::ListCasesResponse::cases].
    pub fn set_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Case>,
    {
        use std::iter::Iterator;
        self.cases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListCasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCasesResponse {
    type PageItem = crate::model::Case;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the SearchCases endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCasesRequest {
    /// The name of the parent resource to search for cases under.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// An expression used to filter cases.
    ///
    /// Expressions use the following fields separated by `AND` and specified with
    /// `=`:
    ///
    /// - `organization`: An organization name in the form
    ///   `organizations/<organization_id>`.
    /// - `project`: A project name in the form `projects/<project_id>`.
    /// - `state`: Can be `OPEN` or `CLOSED`.
    /// - `priority`: Can be `P0`, `P1`, `P2`, `P3`, or `P4`. You
    ///   can specify multiple values for priority using the `OR` operator. For
    ///   example, `priority=P1 OR priority=P2`.
    /// - `creator.email`: The email address of the case creator.
    ///
    /// You must specify either `organization` or `project`.
    ///
    /// To search across `displayName`, `description`, and comments, use a global
    /// restriction with no keyword or operator. For example, `"my search"`.
    ///
    /// To search only cases updated after a certain date, use `update_time`
    /// restricted with that particular date, time, and timezone in ISO datetime
    /// format. For example, `update_time>"2020-01-01T00:00:00-05:00"`.
    /// `update_time` only supports the greater than operator (`>`).
    ///
    /// Examples:
    ///
    /// - `organization="organizations/123456789"`
    /// - `project="projects/my-project-id"`
    /// - `project="projects/123456789"`
    /// - `organization="organizations/123456789" AND state=CLOSED`
    /// - `project="projects/my-project-id" AND creator.email="tester@example.com"`
    /// - `project="projects/my-project-id" AND (priority=P0 OR priority=P1)`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub query: std::string::String,

    /// The maximum number of cases fetched with each request. The default page
    /// size is 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchCasesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.SearchCasesRequest"
    }
}

/// The response message for the SearchCases endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCasesResponse {
    /// The list of cases associated with the parent after any
    /// filters have been applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub cases: std::vec::Vec<crate::model::Case>,

    /// A token to retrieve the next page of results. Set this in the
    /// `page_token` field of subsequent `cases.search` requests. If unspecified,
    /// there are no more results to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cases][crate::model::SearchCasesResponse::cases].
    pub fn set_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Case>,
    {
        use std::iter::Iterator;
        self.cases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.SearchCasesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchCasesResponse {
    type PageItem = crate::model::Case;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the EscalateCase endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EscalateCaseRequest {
    /// Required. The name of the case to be escalated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The escalation information to be sent with the escalation request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub escalation: std::option::Option<crate::model::Escalation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EscalateCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EscalateCaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [escalation][crate::model::EscalateCaseRequest::escalation].
    pub fn set_escalation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Escalation>,
    {
        self.escalation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [escalation][crate::model::EscalateCaseRequest::escalation].
    pub fn set_or_clear_escalation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Escalation>,
    {
        self.escalation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EscalateCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.EscalateCaseRequest"
    }
}

/// The request message for the UpdateCase endpoint
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateCaseRequest {
    /// Required. The case to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub case: std::option::Option<crate::model::Case>,

    /// A list of attributes of the case that should be updated. Supported values
    /// are `priority`, `display_name`, and `subscriber_email_addresses`. If no
    /// fields are specified, all supported fields are updated.
    ///
    /// Be careful - if you do not provide a field mask, then you might
    /// accidentally clear some fields. For example, if you leave the field mask
    /// empty and do not provide a value for `subscriber_email_addresses`, then
    /// `subscriber_email_addresses` is updated to empty.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [case][crate::model::UpdateCaseRequest::case].
    pub fn set_case<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Case>,
    {
        self.case = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [case][crate::model::UpdateCaseRequest::case].
    pub fn set_or_clear_case<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Case>,
    {
        self.case = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCaseRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCaseRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.UpdateCaseRequest"
    }
}

/// The request message for the CloseCase endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloseCaseRequest {
    /// Required. The name of the case to close.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloseCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CloseCaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CloseCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.CloseCaseRequest"
    }
}

/// The request message for the SearchCaseClassifications endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCaseClassificationsRequest {
    /// An expression used to filter case classifications.
    ///
    /// If it's an empty string, then no filtering happens. Otherwise, case
    /// classifications will be returned that match the filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub query: std::string::String,

    /// The maximum number of classifications fetched with each request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCaseClassificationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::SearchCaseClassificationsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchCaseClassificationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchCaseClassificationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchCaseClassificationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.SearchCaseClassificationsRequest"
    }
}

/// The response message for SearchCaseClassifications endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchCaseClassificationsResponse {
    /// The classifications retrieved.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub case_classifications: std::vec::Vec<crate::model::CaseClassification>,

    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `caseClassifications.list` requests. If unspecified,
    /// there are no more results to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchCaseClassificationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [case_classifications][crate::model::SearchCaseClassificationsResponse::case_classifications].
    pub fn set_case_classifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CaseClassification>,
    {
        use std::iter::Iterator;
        self.case_classifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchCaseClassificationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchCaseClassificationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.SearchCaseClassificationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchCaseClassificationsResponse {
    type PageItem = crate::model::CaseClassification;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.case_classifications
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A comment associated with a support case.
///
/// Case comments are the primary way for Google Support to communicate with a
/// user who has opened a case. When a user responds to Google Support, the
/// user's responses also appear as comments.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Comment {
    /// Output only. Identifier. The resource name of the comment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Output only. The time when the comment was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The user or Google Support agent who created the comment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub creator: std::option::Option<crate::model::Actor>,

    /// The full comment body.
    ///
    /// Maximum of 12800 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub body: std::string::String,

    /// Output only. DEPRECATED. DO NOT USE.
    ///
    /// A duplicate of the `body` field.
    ///
    /// This field is only present for legacy reasons.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    #[deprecated]
    pub plain_text_body: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Comment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Comment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Comment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Comment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Comment::creator].
    pub fn set_creator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creator][crate::model::Comment::creator].
    pub fn set_or_clear_creator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Actor>,
    {
        self.creator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [body][crate::model::Comment::body].
    pub fn set_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.body = v.into();
        self
    }

    /// Sets the value of [plain_text_body][crate::model::Comment::plain_text_body].
    #[deprecated]
    pub fn set_plain_text_body<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.plain_text_body = v.into();
        self
    }
}

impl wkt::message::Message for Comment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.Comment"
    }
}

/// The request message for the ListComments endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCommentsRequest {
    /// Required. The name of the case for which to list comments.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// The maximum number of comments to fetch. Defaults to 10.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// A token identifying the page of results to return. If unspecified, the
    /// first page is returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCommentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCommentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCommentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCommentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCommentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListCommentsRequest"
    }
}

/// The response message for the ListComments endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCommentsResponse {
    /// List of the comments associated with the case.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub comments: std::vec::Vec<crate::model::Comment>,

    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.comments.list` requests. If unspecified, there
    /// are no more results to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCommentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [comments][crate::model::ListCommentsResponse::comments].
    pub fn set_comments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Comment>,
    {
        use std::iter::Iterator;
        self.comments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCommentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCommentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.ListCommentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCommentsResponse {
    type PageItem = crate::model::Comment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.comments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the CreateComment endpoint.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCommentRequest {
    /// Required. The name of the case to which the comment should be added.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Required. The comment to be added.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub comment: std::option::Option<crate::model::Comment>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCommentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCommentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [comment][crate::model::CreateCommentRequest::comment].
    pub fn set_comment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Comment>,
    {
        self.comment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [comment][crate::model::CreateCommentRequest::comment].
    pub fn set_or_clear_comment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Comment>,
    {
        self.comment = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCommentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.CreateCommentRequest"
    }
}

/// An escalation of a support case.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Escalation {
    /// Required. The reason why the Case is being escalated.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub reason: crate::model::escalation::Reason,

    /// Required. A free text description to accompany the `reason` field above.
    /// Provides additional context on why the case is being escalated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub justification: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Escalation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reason][crate::model::Escalation::reason].
    pub fn set_reason<T: std::convert::Into<crate::model::escalation::Reason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [justification][crate::model::Escalation::justification].
    pub fn set_justification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.justification = v.into();
        self
    }
}

impl wkt::message::Message for Escalation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.support.v2.Escalation"
    }
}

/// Defines additional types related to [Escalation].
pub mod escalation {
    #[allow(unused_imports)]
    use super::*;

    /// An enum detailing the possible reasons a case may be escalated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Reason {
        /// The escalation reason is in an unknown state or has not been specified.
        Unspecified,
        /// The case is taking too long to resolve.
        ResolutionTime,
        /// The support agent does not have the expertise required to successfully
        /// resolve the issue.
        TechnicalExpertise,
        /// The issue is having a significant business impact.
        BusinessImpact,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Reason::value] or
        /// [Reason::name].
        UnknownValue(reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Reason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResolutionTime => std::option::Option::Some(1),
                Self::TechnicalExpertise => std::option::Option::Some(2),
                Self::BusinessImpact => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REASON_UNSPECIFIED"),
                Self::ResolutionTime => std::option::Option::Some("RESOLUTION_TIME"),
                Self::TechnicalExpertise => std::option::Option::Some("TECHNICAL_EXPERTISE"),
                Self::BusinessImpact => std::option::Option::Some("BUSINESS_IMPACT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Reason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Reason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Reason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResolutionTime,
                2 => Self::TechnicalExpertise,
                3 => Self::BusinessImpact,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Reason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REASON_UNSPECIFIED" => Self::Unspecified,
                "RESOLUTION_TIME" => Self::ResolutionTime,
                "TECHNICAL_EXPERTISE" => Self::TechnicalExpertise,
                "BUSINESS_IMPACT" => Self::BusinessImpact,
                _ => Self::UnknownValue(reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Reason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResolutionTime => serializer.serialize_i32(1),
                Self::TechnicalExpertise => serializer.serialize_i32(2),
                Self::BusinessImpact => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Reason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Reason>::new(
                ".google.cloud.support.v2.Escalation.Reason",
            ))
        }
    }
}
