// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Environment represents a user-visible compute infrastructure for analytics
/// within a lake.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Environment {
    /// Output only. The relative resource name of the environment, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the environment. This
    /// ID will be different if the environment is deleted and re-created with the
    /// same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Environment creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the environment was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the environment.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the environment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Current state of the environment.
    pub state: crate::model::State,

    /// Required. Infrastructure specification for the Environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub infrastructure_spec: std::option::Option<crate::model::environment::InfrastructureSpec>,

    /// Optional. Configuration for sessions created for this environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_spec: std::option::Option<crate::model::environment::SessionSpec>,

    /// Output only. Status of sessions created for this environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_status: std::option::Option<crate::model::environment::SessionStatus>,

    /// Output only. URI Endpoints to access sessions associated with the
    /// Environment.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoints: std::option::Option<crate::model::environment::Endpoints>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Environment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Environment::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Environment::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Environment::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Environment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Environment::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [infrastructure_spec][crate::model::Environment::infrastructure_spec].
    pub fn set_infrastructure_spec<
        T: std::convert::Into<std::option::Option<crate::model::environment::InfrastructureSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure_spec = v.into();
        self
    }

    /// Sets the value of [session_spec][crate::model::Environment::session_spec].
    pub fn set_session_spec<
        T: std::convert::Into<std::option::Option<crate::model::environment::SessionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_spec = v.into();
        self
    }

    /// Sets the value of [session_status][crate::model::Environment::session_status].
    pub fn set_session_status<
        T: std::convert::Into<std::option::Option<crate::model::environment::SessionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_status = v.into();
        self
    }

    /// Sets the value of [endpoints][crate::model::Environment::endpoints].
    pub fn set_endpoints<
        T: std::convert::Into<std::option::Option<crate::model::environment::Endpoints>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoints = v.into();
        self
    }
}

impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Environment"
    }
}

/// Defines additional types related to [Environment].
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the underlying infrastructure used to run workloads.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfrastructureSpec {
        /// Hardware config
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub resources:
            std::option::Option<crate::model::environment::infrastructure_spec::Resources>,

        /// Software config
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub runtime: std::option::Option<crate::model::environment::infrastructure_spec::Runtime>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfrastructureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resources][crate::model::environment::InfrastructureSpec::resources].
        ///
        /// Note that all the setters affecting `resources` are mutually
        /// exclusive.
        pub fn set_resources<
            T: std::convert::Into<
                    std::option::Option<crate::model::environment::infrastructure_spec::Resources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = v.into();
            self
        }

        /// The value of [resources][crate::model::environment::InfrastructureSpec::resources]
        /// if it holds a `Compute`, `None` if the field is not set or
        /// holds a different branch.
        pub fn compute(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::environment::infrastructure_spec::ComputeResources>,
        > {
            #[allow(unreachable_patterns)]
            self.resources.as_ref().and_then(|v| match v {
                crate::model::environment::infrastructure_spec::Resources::Compute(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resources][crate::model::environment::InfrastructureSpec::resources]
        /// to hold a `Compute`.
        ///
        /// Note that all the setters affecting `resources` are
        /// mutually exclusive.
        pub fn set_compute<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::environment::infrastructure_spec::ComputeResources,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = std::option::Option::Some(
                crate::model::environment::infrastructure_spec::Resources::Compute(v.into()),
            );
            self
        }

        /// Sets the value of [runtime][crate::model::environment::InfrastructureSpec::runtime].
        ///
        /// Note that all the setters affecting `runtime` are mutually
        /// exclusive.
        pub fn set_runtime<
            T: std::convert::Into<
                    std::option::Option<crate::model::environment::infrastructure_spec::Runtime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = v.into();
            self
        }

        /// The value of [runtime][crate::model::environment::InfrastructureSpec::runtime]
        /// if it holds a `OsImage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn os_image(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
        > {
            #[allow(unreachable_patterns)]
            self.runtime.as_ref().and_then(|v| match v {
                crate::model::environment::infrastructure_spec::Runtime::OsImage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [runtime][crate::model::environment::InfrastructureSpec::runtime]
        /// to hold a `OsImage`.
        ///
        /// Note that all the setters affecting `runtime` are
        /// mutually exclusive.
        pub fn set_os_image<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = std::option::Option::Some(
                crate::model::environment::infrastructure_spec::Runtime::OsImage(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InfrastructureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec"
        }
    }

    /// Defines additional types related to [InfrastructureSpec].
    pub mod infrastructure_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Compute resources associated with the analyze interactive workloads.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ComputeResources {
            /// Optional. Size in GB of the disk. Default is 100 GB.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disk_size_gb: i32,

            /// Optional. Total number of nodes in the sessions created for this
            /// environment.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub node_count: i32,

            /// Optional. Max configurable nodes.
            /// If max_node_count > node_count, then auto-scaling is enabled.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_node_count: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ComputeResources {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disk_size_gb][crate::model::environment::infrastructure_spec::ComputeResources::disk_size_gb].
            pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.disk_size_gb = v.into();
                self
            }

            /// Sets the value of [node_count][crate::model::environment::infrastructure_spec::ComputeResources::node_count].
            pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.node_count = v.into();
                self
            }

            /// Sets the value of [max_node_count][crate::model::environment::infrastructure_spec::ComputeResources::max_node_count].
            pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_node_count = v.into();
                self
            }
        }

        impl wkt::message::Message for ComputeResources {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec.ComputeResources"
            }
        }

        /// Software Runtime Configuration to run Analyze.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct OsImageRuntime {
            /// Required. Dataplex Image version.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub image_version: std::string::String,

            /// Optional. List of Java jars to be included in the runtime environment.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub java_libraries: std::vec::Vec<std::string::String>,

            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub python_packages: std::vec::Vec<std::string::String>,

            /// Optional. Spark properties to provide configuration for use in sessions
            /// created for this environment. The properties to set on daemon config
            /// files. Property keys are specified in `prefix:property` format. The
            /// prefix must be "spark".
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub properties: std::collections::HashMap<std::string::String, std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl OsImageRuntime {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [image_version][crate::model::environment::infrastructure_spec::OsImageRuntime::image_version].
            pub fn set_image_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.image_version = v.into();
                self
            }

            /// Sets the value of [java_libraries][crate::model::environment::infrastructure_spec::OsImageRuntime::java_libraries].
            pub fn set_java_libraries<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.java_libraries = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [python_packages][crate::model::environment::infrastructure_spec::OsImageRuntime::python_packages].
            pub fn set_python_packages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.python_packages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [properties][crate::model::environment::infrastructure_spec::OsImageRuntime::properties].
            pub fn set_properties<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for OsImageRuntime {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Environment.InfrastructureSpec.OsImageRuntime"
            }
        }

        /// Hardware config
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Resources {
            /// Optional. Compute resources needed for analyze interactive workloads.
            Compute(
                std::boxed::Box<crate::model::environment::infrastructure_spec::ComputeResources>,
            ),
        }

        /// Software config
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Runtime {
            /// Required. Software Runtime Configuration for analyze interactive
            /// workloads.
            OsImage(
                std::boxed::Box<crate::model::environment::infrastructure_spec::OsImageRuntime>,
            ),
        }
    }

    /// Configuration for sessions created for this environment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SessionSpec {
        /// Optional. The idle time configuration of the session. The session will be
        /// auto-terminated at the end of this period.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_idle_duration: std::option::Option<wkt::Duration>,

        /// Optional. If True, this causes sessions to be pre-created and available
        /// for faster startup to enable interactive exploration use-cases. This
        /// defaults to False to avoid additional billed charges. These can only be
        /// set to True for the environment with name set to "default", and with
        /// default configuration.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enable_fast_startup: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_idle_duration][crate::model::environment::SessionSpec::max_idle_duration].
        pub fn set_max_idle_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.max_idle_duration = v.into();
            self
        }

        /// Sets the value of [enable_fast_startup][crate::model::environment::SessionSpec::enable_fast_startup].
        pub fn set_enable_fast_startup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_fast_startup = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.SessionSpec"
        }
    }

    /// Status of sessions created for this environment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SessionStatus {
        /// Output only. Queries over sessions to mark whether the environment is
        /// currently active or not
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub active: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [active][crate::model::environment::SessionStatus::active].
        pub fn set_active<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.active = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.SessionStatus"
        }
    }

    /// URI Endpoints to access sessions associated with the Environment.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Endpoints {
        /// Output only. URI to serve notebook APIs
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub notebooks: std::string::String,

        /// Output only. URI to serve SQL APIs
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sql: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Endpoints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [notebooks][crate::model::environment::Endpoints::notebooks].
        pub fn set_notebooks<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.notebooks = v.into();
            self
        }

        /// Sets the value of [sql][crate::model::environment::Endpoints::sql].
        pub fn set_sql<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.sql = v.into();
            self
        }
    }

    impl wkt::message::Message for Endpoints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Environment.Endpoints"
        }
    }
}

/// Content represents a user-visible notebook or a sql script
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Content {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the content. This ID
    /// will be different if the content is deleted and re-created with the same
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The path for the Content file, represented as directory
    /// structure. Unique within a lake. Limited to alphanumerics, hyphens,
    /// underscores, dots and slashes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Output only. Content creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the content was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the content.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Only returned in `GetContent` requests and not in `ListContent` request.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::content::Data>,

    /// Types of content
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::content::Content>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Content {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Content::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Content::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Content::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Content::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Content::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Content::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Content::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Content::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::content::Data>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::Content::data]
    /// if it holds a `DataText`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::content::Data::DataText(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::Content::data]
    /// to hold a `DataText`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_data_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data = std::option::Option::Some(crate::model::content::Data::DataText(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Content::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<
        T: std::convert::Into<std::option::Option<crate::model::content::Content>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Content::content]
    /// if it holds a `SqlScript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_script(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::content::SqlScript>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::content::Content::SqlScript(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Content::content]
    /// to hold a `SqlScript`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_sql_script<
        T: std::convert::Into<std::boxed::Box<crate::model::content::SqlScript>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::content::Content::SqlScript(v.into()));
        self
    }

    /// The value of [content][crate::model::Content::content]
    /// if it holds a `Notebook`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::content::Notebook>> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::content::Content::Notebook(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Content::content]
    /// to hold a `Notebook`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_notebook<T: std::convert::Into<std::boxed::Box<crate::model::content::Notebook>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content =
            std::option::Option::Some(crate::model::content::Content::Notebook(v.into()));
        self
    }
}

impl wkt::message::Message for Content {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Content"
    }
}

/// Defines additional types related to [Content].
pub mod content {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the Sql Script content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlScript {
        /// Required. Query Engine to be used for the Sql Query.
        pub engine: crate::model::content::sql_script::QueryEngine,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlScript {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [engine][crate::model::content::SqlScript::engine].
        pub fn set_engine<T: std::convert::Into<crate::model::content::sql_script::QueryEngine>>(
            mut self,
            v: T,
        ) -> Self {
            self.engine = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlScript {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Content.SqlScript"
        }
    }

    /// Defines additional types related to [SqlScript].
    pub mod sql_script {
        #[allow(unused_imports)]
        use super::*;

        /// Query Engine Type of the SQL Script.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QueryEngine {
            /// Value was unspecified.
            Unspecified,
            /// Spark SQL Query.
            Spark,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [QueryEngine::value] or
            /// [QueryEngine::name].
            UnknownValue(query_engine::UnknownValue),
        }

        #[doc(hidden)]
        pub mod query_engine {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl QueryEngine {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Spark => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("QUERY_ENGINE_UNSPECIFIED"),
                    Self::Spark => std::option::Option::Some("SPARK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for QueryEngine {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for QueryEngine {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for QueryEngine {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    2 => Self::Spark,
                    _ => Self::UnknownValue(query_engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for QueryEngine {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "QUERY_ENGINE_UNSPECIFIED" => Self::Unspecified,
                    "SPARK" => Self::Spark,
                    _ => Self::UnknownValue(query_engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for QueryEngine {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Spark => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for QueryEngine {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<QueryEngine>::new(
                    ".google.cloud.dataplex.v1.Content.SqlScript.QueryEngine",
                ))
            }
        }
    }

    /// Configuration for Notebook content.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Notebook {
        /// Required. Kernel Type of the notebook.
        pub kernel_type: crate::model::content::notebook::KernelType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Notebook {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kernel_type][crate::model::content::Notebook::kernel_type].
        pub fn set_kernel_type<
            T: std::convert::Into<crate::model::content::notebook::KernelType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kernel_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Notebook {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Content.Notebook"
        }
    }

    /// Defines additional types related to [Notebook].
    pub mod notebook {
        #[allow(unused_imports)]
        use super::*;

        /// Kernel Type of the Jupyter notebook.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum KernelType {
            /// Kernel Type unspecified.
            Unspecified,
            /// Python 3 Kernel.
            Python3,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [KernelType::value] or
            /// [KernelType::name].
            UnknownValue(kernel_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod kernel_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl KernelType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Python3 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("KERNEL_TYPE_UNSPECIFIED"),
                    Self::Python3 => std::option::Option::Some("PYTHON3"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for KernelType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for KernelType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for KernelType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Python3,
                    _ => Self::UnknownValue(kernel_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for KernelType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "KERNEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "PYTHON3" => Self::Python3,
                    _ => Self::UnknownValue(kernel_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for KernelType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Python3 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for KernelType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<KernelType>::new(
                    ".google.cloud.dataplex.v1.Content.Notebook.KernelType",
                ))
            }
        }
    }

    /// Only returned in `GetContent` requests and not in `ListContent` request.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Data {
        /// Required. Content data in string format.
        DataText(std::string::String),
    }

    /// Types of content
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Content {
        /// Sql Script related configurations.
        SqlScript(std::boxed::Box<crate::model::content::SqlScript>),
        /// Notebook related configurations.
        Notebook(std::boxed::Box<crate::model::content::Notebook>),
    }
}

/// Represents an active analyze session running for a user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Session {
    /// Output only. The relative resource name of the content, of the form:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}/sessions/{session_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Email of user running the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_id: std::string::String,

    /// Output only. Session start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of Session
    pub state: crate::model::State,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::Session::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Session::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Session::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Session"
    }
}

/// AspectType is a template for creating Aspects, and represents the
/// JSON-schema for a given Entry, for example, BigQuery Table Schema.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AspectType {
    /// Output only. The relative resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the AspectType.
    /// If you delete and recreate the AspectType with the same name, then this ID
    /// will be different.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the AspectType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the AspectType was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the AspectType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the AspectType.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The service computes this checksum. The client may send it on update and
    /// delete requests to ensure it has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Defines the Authorization for this type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::aspect_type::Authorization>,

    /// Required. MetadataTemplate of the aspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_template: std::option::Option<crate::model::aspect_type::MetadataTemplate>,

    /// Output only. Denotes the transfer status of the Aspect Type. It is
    /// unspecified for Aspect Types created from Dataplex API.
    pub transfer_status: crate::model::TransferStatus,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AspectType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AspectType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::AspectType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AspectType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AspectType::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AspectType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AspectType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AspectType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::AspectType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::AspectType::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::aspect_type::Authorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }

    /// Sets the value of [metadata_template][crate::model::AspectType::metadata_template].
    pub fn set_metadata_template<
        T: std::convert::Into<std::option::Option<crate::model::aspect_type::MetadataTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_template = v.into();
        self
    }

    /// Sets the value of [transfer_status][crate::model::AspectType::transfer_status].
    pub fn set_transfer_status<T: std::convert::Into<crate::model::TransferStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for AspectType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AspectType"
    }
}

/// Defines additional types related to [AspectType].
pub mod aspect_type {
    #[allow(unused_imports)]
    use super::*;

    /// Autorization for an AspectType.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the EntryGroup to allow access
        /// to instantiate Aspects of Dataplex owned AspectTypes, only settable for
        /// Dataplex owned Types.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub alternate_use_permission: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authorization {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [alternate_use_permission][crate::model::aspect_type::Authorization::alternate_use_permission].
        pub fn set_alternate_use_permission<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.alternate_use_permission = v.into();
            self
        }
    }

    impl wkt::message::Message for Authorization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.AspectType.Authorization"
        }
    }

    /// MetadataTemplate definition for an AspectType.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetadataTemplate {
        /// Optional. Index is used to encode Template messages. The value of index
        /// can range between 1 and 2,147,483,647. Index must be unique within all
        /// fields in a Template. (Nested Templates can reuse indexes). Once a
        /// Template is defined, the index cannot be changed, because it identifies
        /// the field in the actual storage format. Index is a mandatory field, but
        /// it is optional for top level fields, and map/array "values" definitions.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub index: i32,

        /// Required. The name of the field.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Required. The datatype of this field. The following values are supported:
        ///
        /// Primitive types:
        ///
        /// * string
        /// * integer
        /// * boolean
        /// * double
        /// * datetime. Must be of the format RFC3339 UTC "Zulu" (Examples:
        ///   "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z").
        ///
        /// Complex types:
        ///
        /// * enum
        /// * array
        /// * map
        /// * record
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        /// Optional. Field definition. You must specify it if the type is record. It
        /// defines the nested fields.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub record_fields: std::vec::Vec<crate::model::aspect_type::MetadataTemplate>,

        /// Optional. The list of values for an enum type. You must define it if the
        /// type is enum.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub enum_values: std::vec::Vec<crate::model::aspect_type::metadata_template::EnumValue>,

        /// Optional. If the type is map, set map_items. map_items can refer to a
        /// primitive field or a complex (record only) field. To specify a primitive
        /// field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub map_items:
            std::option::Option<std::boxed::Box<crate::model::aspect_type::MetadataTemplate>>,

        /// Optional. If the type is array, set array_items. array_items can refer
        /// to a primitive field or a complex (record only) field. To specify a
        /// primitive field, you only need to set name and type in the nested
        /// MetadataTemplate. The recommended value for the name field is item, as
        /// this isn't used in the actual payload.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub array_items:
            std::option::Option<std::boxed::Box<crate::model::aspect_type::MetadataTemplate>>,

        /// Optional. You can use type id if this definition of the field needs to be
        /// reused later. The type id must be unique across the entire template. You
        /// can only specify it if the field type is record.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub type_id: std::string::String,

        /// Optional. A reference to another field definition (not an inline
        /// definition). The value must be equal to the value of an id field defined
        /// elsewhere in the MetadataTemplate. Only fields with record type can
        /// refer to other fields.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub type_ref: std::string::String,

        /// Optional. Specifies the constraints on this field.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub constraints:
            std::option::Option<crate::model::aspect_type::metadata_template::Constraints>,

        /// Optional. Specifies annotations on this field.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub annotations:
            std::option::Option<crate::model::aspect_type::metadata_template::Annotations>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MetadataTemplate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [index][crate::model::aspect_type::MetadataTemplate::index].
        pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }

        /// Sets the value of [name][crate::model::aspect_type::MetadataTemplate::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::aspect_type::MetadataTemplate::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [record_fields][crate::model::aspect_type::MetadataTemplate::record_fields].
        pub fn set_record_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aspect_type::MetadataTemplate>,
        {
            use std::iter::Iterator;
            self.record_fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enum_values][crate::model::aspect_type::MetadataTemplate::enum_values].
        pub fn set_enum_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::aspect_type::metadata_template::EnumValue>,
        {
            use std::iter::Iterator;
            self.enum_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [map_items][crate::model::aspect_type::MetadataTemplate::map_items].
        pub fn set_map_items<
            T: std::convert::Into<
                    std::option::Option<
                        std::boxed::Box<crate::model::aspect_type::MetadataTemplate>,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.map_items = v.into();
            self
        }

        /// Sets the value of [array_items][crate::model::aspect_type::MetadataTemplate::array_items].
        pub fn set_array_items<
            T: std::convert::Into<
                    std::option::Option<
                        std::boxed::Box<crate::model::aspect_type::MetadataTemplate>,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.array_items = v.into();
            self
        }

        /// Sets the value of [type_id][crate::model::aspect_type::MetadataTemplate::type_id].
        pub fn set_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.type_id = v.into();
            self
        }

        /// Sets the value of [type_ref][crate::model::aspect_type::MetadataTemplate::type_ref].
        pub fn set_type_ref<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.type_ref = v.into();
            self
        }

        /// Sets the value of [constraints][crate::model::aspect_type::MetadataTemplate::constraints].
        pub fn set_constraints<
            T: std::convert::Into<
                    std::option::Option<crate::model::aspect_type::metadata_template::Constraints>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.constraints = v.into();
            self
        }

        /// Sets the value of [annotations][crate::model::aspect_type::MetadataTemplate::annotations].
        pub fn set_annotations<
            T: std::convert::Into<
                    std::option::Option<crate::model::aspect_type::metadata_template::Annotations>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.annotations = v.into();
            self
        }
    }

    impl wkt::message::Message for MetadataTemplate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate"
        }
    }

    /// Defines additional types related to [MetadataTemplate].
    pub mod metadata_template {
        #[allow(unused_imports)]
        use super::*;

        /// Definition of Enumvalue, to be used for enum fields.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct EnumValue {
            /// Required. Index for the enum value. It can't be modified.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub index: i32,

            /// Required. Name of the enumvalue. This is the actual value that the
            /// aspect can contain.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            /// Optional. You can set this message if you need to deprecate an enum
            /// value.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub deprecated: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl EnumValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [index][crate::model::aspect_type::metadata_template::EnumValue::index].
            pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.index = v.into();
                self
            }

            /// Sets the value of [name][crate::model::aspect_type::metadata_template::EnumValue::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [deprecated][crate::model::aspect_type::metadata_template::EnumValue::deprecated].
            pub fn set_deprecated<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.deprecated = v.into();
                self
            }
        }

        impl wkt::message::Message for EnumValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.EnumValue"
            }
        }

        /// Definition of the constraints of a field.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Constraints {
            /// Optional. Marks this field as optional or required.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub required: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Constraints {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [required][crate::model::aspect_type::metadata_template::Constraints::required].
            pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.required = v.into();
                self
            }
        }

        impl wkt::message::Message for Constraints {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.Constraints"
            }
        }

        /// Definition of the annotations of a field.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Annotations {
            /// Optional. Marks a field as deprecated. You can include a deprecation
            /// message.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub deprecated: std::string::String,

            /// Optional. Display name for a field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub display_name: std::string::String,

            /// Optional. Description for a field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub description: std::string::String,

            /// Optional. Display order for a field. You can use this to reorder where
            /// a field is rendered.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub display_order: i32,

            /// Optional. You can use String Type annotations to specify special
            /// meaning to string fields. The following values are supported:
            ///
            /// * richText: The field must be interpreted as a rich text field.
            /// * url: A fully qualified URL link.
            /// * resource: A service qualified resource reference.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub string_type: std::string::String,

            /// Optional. Suggested hints for string fields. You can use them to
            /// suggest values to users through console.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub string_values: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Annotations {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [deprecated][crate::model::aspect_type::metadata_template::Annotations::deprecated].
            pub fn set_deprecated<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.deprecated = v.into();
                self
            }

            /// Sets the value of [display_name][crate::model::aspect_type::metadata_template::Annotations::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [description][crate::model::aspect_type::metadata_template::Annotations::description].
            pub fn set_description<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.description = v.into();
                self
            }

            /// Sets the value of [display_order][crate::model::aspect_type::metadata_template::Annotations::display_order].
            pub fn set_display_order<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.display_order = v.into();
                self
            }

            /// Sets the value of [string_type][crate::model::aspect_type::metadata_template::Annotations::string_type].
            pub fn set_string_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.string_type = v.into();
                self
            }

            /// Sets the value of [string_values][crate::model::aspect_type::metadata_template::Annotations::string_values].
            pub fn set_string_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.string_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Annotations {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.AspectType.MetadataTemplate.Annotations"
            }
        }
    }
}

/// An Entry Group represents a logical grouping of one or more Entries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntryGroup {
    /// Output only. The relative resource name of the EntryGroup, in the format
    /// projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the EntryGroup. If you
    /// delete and recreate the EntryGroup with the same name, this ID will be
    /// different.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the EntryGroup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the EntryGroup was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the EntryGroup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the EntryGroup.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the service, and might be sent on update and
    /// delete requests to ensure the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Denotes the transfer status of the Entry Group. It is
    /// unspecified for Entry Group created from Dataplex API.
    pub transfer_status: crate::model::TransferStatus,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::EntryGroup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntryGroup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EntryGroup::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntryGroup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntryGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::EntryGroup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [transfer_status][crate::model::EntryGroup::transfer_status].
    pub fn set_transfer_status<T: std::convert::Into<crate::model::TransferStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.transfer_status = v.into();
        self
    }
}

impl wkt::message::Message for EntryGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryGroup"
    }
}

/// Entry Type is a template for creating Entries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntryType {
    /// Output only. The relative resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the EntryType. This ID
    /// will be different if the EntryType is deleted and re-created with the same
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the EntryType was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the EntryType was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the EntryType.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the EntryType.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the service, and might be sent on
    /// update and delete requests to ensure the client has an up-to-date value
    /// before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Indicates the classes this Entry Type belongs to, for example,
    /// TABLE, DATABASE, MODEL.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub type_aliases: std::vec::Vec<std::string::String>,

    /// Optional. The platform that Entries of this type belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub platform: std::string::String,

    /// Optional. The system that Entries of this type belongs to. Examples include
    /// CloudSQL, MariaDB etc
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub system: std::string::String,

    /// AspectInfo for the entry type.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub required_aspects: std::vec::Vec<crate::model::entry_type::AspectInfo>,

    /// Immutable. Authorization defined for this type.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::entry_type::Authorization>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntryType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::EntryType::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EntryType::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EntryType::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntryType::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntryType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntryType::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::EntryType::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [type_aliases][crate::model::EntryType::type_aliases].
    pub fn set_type_aliases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.type_aliases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [platform][crate::model::EntryType::platform].
    pub fn set_platform<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [system][crate::model::EntryType::system].
    pub fn set_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [required_aspects][crate::model::EntryType::required_aspects].
    pub fn set_required_aspects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entry_type::AspectInfo>,
    {
        use std::iter::Iterator;
        self.required_aspects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [authorization][crate::model::EntryType::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::entry_type::Authorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }
}

impl wkt::message::Message for EntryType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryType"
    }
}

/// Defines additional types related to [EntryType].
pub mod entry_type {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AspectInfo {
        /// Required aspect type for the entry type.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AspectInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::entry_type::AspectInfo::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for AspectInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntryType.AspectInfo"
        }
    }

    /// Authorization for an Entry Type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Authorization {
        /// Immutable. The IAM permission grantable on the Entry Group to allow
        /// access to instantiate Entries of Dataplex owned Entry Types, only
        /// settable for Dataplex owned Types.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub alternate_use_permission: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Authorization {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [alternate_use_permission][crate::model::entry_type::Authorization::alternate_use_permission].
        pub fn set_alternate_use_permission<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.alternate_use_permission = v.into();
            self
        }
    }

    impl wkt::message::Message for Authorization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntryType.Authorization"
        }
    }
}

/// An aspect is a single piece of metadata describing an entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Aspect {
    /// Output only. The resource name of the type used to create this Aspect.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aspect_type: std::string::String,

    /// Output only. The path in the entry under which the aspect is attached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub path: std::string::String,

    /// Output only. The time when the Aspect was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Aspect was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The content of the aspect, according to its aspect type schema.
    /// The maximum size of the field is 120KB (encoded as UTF-8).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<wkt::Struct>,

    /// Optional. Information related to the source system of the aspect.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aspect_source: std::option::Option<crate::model::AspectSource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Aspect {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_type][crate::model::Aspect::aspect_type].
    pub fn set_aspect_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aspect_type = v.into();
        self
    }

    /// Sets the value of [path][crate::model::Aspect::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Aspect::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Aspect::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [data][crate::model::Aspect::data].
    pub fn set_data<T: std::convert::Into<std::option::Option<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [aspect_source][crate::model::Aspect::aspect_source].
    pub fn set_aspect_source<
        T: std::convert::Into<std::option::Option<crate::model::AspectSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aspect_source = v.into();
        self
    }
}

impl wkt::message::Message for Aspect {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Aspect"
    }
}

/// Information related to the source system of the aspect.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AspectSource {
    /// The time the aspect was created in the source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the aspect was last updated in the source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The version of the data format used to produce this data. This field is
    /// used to indicated when the underlying data format changes (e.g., schema
    /// modifications, changes to the source URL format definition, etc).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AspectSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::AspectSource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::AspectSource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [data_version][crate::model::AspectSource::data_version].
    pub fn set_data_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_version = v.into();
        self
    }
}

impl wkt::message::Message for AspectSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AspectSource"
    }
}

/// An entry is a representation of a data resource that can be described by
/// various metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entry {
    /// Identifier. The relative resource name of the entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}/entries/{entry_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. The relative resource name of the entry type that was
    /// used to create this entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_type: std::string::String,

    /// Output only. The time when the entry was created in Dataplex.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the entry was last updated in Dataplex.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The aspects that are attached to the entry. Depending on how the
    /// aspect is attached to the entry, the format of the aspect key can be one of
    /// the following:
    ///
    /// * If the aspect is attached directly to the entry:
    ///   `{project_id_or_number}.{location_id}.{aspect_type_id}`
    /// * If the aspect is attached to an entry's path:
    ///   `{project_id_or_number}.{location_id}.{aspect_type_id}@{path}`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub aspects: std::collections::HashMap<std::string::String, crate::model::Aspect>,

    /// Optional. Immutable. The resource name of the parent entry, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/entryGroups/{entry_group_id}/entries/{entry_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_entry: std::string::String,

    /// Optional. A name for the entry that can be referenced by an external
    /// system. For more information, see [Fully qualified
    /// names](https://cloud.google.com/data-catalog/docs/fully-qualified-names).
    /// The maximum size of the field is 4000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fully_qualified_name: std::string::String,

    /// Optional. Information related to the source system of the data resource
    /// that is represented by the entry.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_source: std::option::Option<crate::model::EntrySource>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entry_type][crate::model::Entry::entry_type].
    pub fn set_entry_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entry::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Entry::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [aspects][crate::model::Entry::aspects].
    pub fn set_aspects<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Aspect>,
    {
        use std::iter::Iterator;
        self.aspects = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [parent_entry][crate::model::Entry::parent_entry].
    pub fn set_parent_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_entry = v.into();
        self
    }

    /// Sets the value of [fully_qualified_name][crate::model::Entry::fully_qualified_name].
    pub fn set_fully_qualified_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_qualified_name = v.into();
        self
    }

    /// Sets the value of [entry_source][crate::model::Entry::entry_source].
    pub fn set_entry_source<
        T: std::convert::Into<std::option::Option<crate::model::EntrySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry_source = v.into();
        self
    }
}

impl wkt::message::Message for Entry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Entry"
    }
}

/// Information related to the source system of the data resource that is
/// represented by the entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntrySource {
    /// The name of the resource in the source system.
    /// Maximum length is 4,000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    /// The name of the source system.
    /// Maximum length is 64 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub system: std::string::String,

    /// The platform containing the source system.
    /// Maximum length is 64 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub platform: std::string::String,

    /// A user-friendly display name.
    /// Maximum length is 500 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// A description of the data resource.
    /// Maximum length is 2,000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// User-defined labels.
    /// The maximum size of keys and values is 128 characters each.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Immutable. The entries representing the ancestors of the data resource in
    /// the source system.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ancestors: std::vec::Vec<crate::model::entry_source::Ancestor>,

    /// The time when the resource was created in the source system.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the resource was last updated in the source system. If the
    /// entry exists in the system and its `EntrySource` has `update_time`
    /// populated, further updates to the `EntrySource` of the entry must provide
    /// incremental updates to its `update_time`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Location of the resource in the source system. You can search
    /// the entry by this location. By default, this should match the location of
    /// the entry group containing this entry. A different value allows capturing
    /// the source location for data external to Google Cloud.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntrySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource][crate::model::EntrySource::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [system][crate::model::EntrySource::system].
    pub fn set_system<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [platform][crate::model::EntrySource::platform].
    pub fn set_platform<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntrySource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::EntrySource::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EntrySource::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [ancestors][crate::model::EntrySource::ancestors].
    pub fn set_ancestors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entry_source::Ancestor>,
    {
        use std::iter::Iterator;
        self.ancestors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::EntrySource::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EntrySource::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::EntrySource::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for EntrySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntrySource"
    }
}

/// Defines additional types related to [EntrySource].
pub mod entry_source {
    #[allow(unused_imports)]
    use super::*;

    /// Information about individual items in the hierarchy that is associated with
    /// the data resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Ancestor {
        /// Optional. The name of the ancestor resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. The type of the ancestor resource.
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Ancestor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::entry_source::Ancestor::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::entry_source::Ancestor::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Ancestor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EntrySource.Ancestor"
        }
    }
}

/// Create EntryGroup Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntryGroupRequest {
    /// Required. The resource name of the entryGroup, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. EntryGroup identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_group_id: std::string::String,

    /// Required. EntryGroup Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_group_id][crate::model::CreateEntryGroupRequest::entry_group_id].
    pub fn set_entry_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_group_id = v.into();
        self
    }

    /// Sets the value of [entry_group][crate::model::CreateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T: std::convert::Into<std::option::Option<crate::model::EntryGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_group = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntryGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryGroupRequest"
    }
}

/// Update EntryGroup Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntryGroupRequest {
    /// Required. EntryGroup Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_group: std::option::Option<crate::model::EntryGroup>,

    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The service validates the request, without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_group][crate::model::UpdateEntryGroupRequest::entry_group].
    pub fn set_entry_group<T: std::convert::Into<std::option::Option<crate::model::EntryGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_group = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryGroupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntryGroupRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryGroupRequest"
    }
}

/// Delete EntryGroup Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryGroupRequest method returns an ABORTED error
    /// response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntryGroupRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryGroupRequest"
    }
}

/// List entryGroups request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryGroupsRequest {
    /// Required. The resource name of the entryGroup location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of EntryGroups to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryGroups. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntryGroups` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListEntryGroups` must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntryGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntryGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryGroupsRequest"
    }
}

/// List entry groups response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryGroupsResponse {
    /// Entry groups under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entry_groups: std::vec::Vec<crate::model::EntryGroup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_groups][crate::model::ListEntryGroupsResponse::entry_groups].
    pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryGroup>,
    {
        use std::iter::Iterator;
        self.entry_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEntryGroupsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntryGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryGroupsResponse {
    type PageItem = crate::model::EntryGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get EntryGroup request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntryGroupRequest {
    /// Required. The resource name of the EntryGroup:
    /// `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryGroupRequest"
    }
}

/// Create EntryType Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntryTypeRequest {
    /// Required. The resource name of the EntryType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. EntryType identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_type_id: std::string::String,

    /// Required. EntryType Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_type: std::option::Option<crate::model::EntryType>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_type_id][crate::model::CreateEntryTypeRequest::entry_type_id].
    pub fn set_entry_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_type_id = v.into();
        self
    }

    /// Sets the value of [entry_type][crate::model::CreateEntryTypeRequest::entry_type].
    pub fn set_entry_type<T: std::convert::Into<std::option::Option<crate::model::EntryType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntryTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryTypeRequest"
    }
}

/// Update EntryType Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntryTypeRequest {
    /// Required. EntryType Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry_type: std::option::Option<crate::model::EntryType>,

    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_type][crate::model::UpdateEntryTypeRequest::entry_type].
    pub fn set_entry_type<T: std::convert::Into<std::option::Option<crate::model::EntryType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry_type = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntryTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryTypeRequest"
    }
}

/// Delele EntryType Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteEntryTypeRequest method returns an ABORTED error response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntryTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryTypeRequest"
    }
}

/// List EntryTypes request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryTypesRequest {
    /// Required. The resource name of the EntryType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of EntryTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// EntryTypes. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntryTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provided to `ListEntryTypes` must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntryTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntryTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntryTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntryTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntryTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntryTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryTypesRequest"
    }
}

/// List EntryTypes response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntryTypesResponse {
    /// EntryTypes under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entry_types: std::vec::Vec<crate::model::EntryType>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntryTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry_types][crate::model::ListEntryTypesResponse::entry_types].
    pub fn set_entry_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntryType>,
    {
        use std::iter::Iterator;
        self.entry_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntryTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEntryTypesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntryTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntryTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntryTypesResponse {
    type PageItem = crate::model::EntryType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entry_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get EntryType request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntryTypeRequest {
    /// Required. The resource name of the EntryType:
    /// `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntryTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryTypeRequest"
    }
}

/// Create AspectType Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAspectTypeRequest {
    /// Required. The resource name of the AspectType, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. AspectType identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aspect_type_id: std::string::String,

    /// Required. AspectType Resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aspect_type: std::option::Option<crate::model::AspectType>,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAspectTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [aspect_type_id][crate::model::CreateAspectTypeRequest::aspect_type_id].
    pub fn set_aspect_type_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aspect_type_id = v.into();
        self
    }

    /// Sets the value of [aspect_type][crate::model::CreateAspectTypeRequest::aspect_type].
    pub fn set_aspect_type<T: std::convert::Into<std::option::Option<crate::model::AspectType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aspect_type = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAspectTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateAspectTypeRequest"
    }
}

/// Update AspectType Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAspectTypeRequest {
    /// Required. AspectType Resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aspect_type: std::option::Option<crate::model::AspectType>,

    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_type][crate::model::UpdateAspectTypeRequest::aspect_type].
    pub fn set_aspect_type<T: std::convert::Into<std::option::Option<crate::model::AspectType>>>(
        mut self,
        v: T,
    ) -> Self {
        self.aspect_type = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAspectTypeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAspectTypeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateAspectTypeRequest"
    }
}

/// Delele AspectType Request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteAspectTypeRequest method returns an ABORTED error
    /// response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAspectTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAspectTypeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteAspectTypeRequest"
    }
}

/// List AspectTypes request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAspectTypesRequest {
    /// Required. The resource name of the AspectType location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a Google Cloud region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of AspectTypes to return. The service may return
    /// fewer than this value. If unspecified, the service returns at most 10
    /// AspectTypes. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAspectTypes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters you provide to `ListAspectTypes` must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * labels.key1 = "value1"
    /// * labels:key1
    /// * name = "value"
    ///
    /// These restrictions can be conjoined with AND, OR, and NOT conjunctions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Orders the result by `name` or `create_time` fields.
    /// If not specified, the ordering is undefined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAspectTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAspectTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAspectTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAspectTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAspectTypesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAspectTypesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAspectTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAspectTypesRequest"
    }
}

/// List AspectTypes response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAspectTypesResponse {
    /// AspectTypes under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_types: std::vec::Vec<crate::model::AspectType>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAspectTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aspect_types][crate::model::ListAspectTypesResponse::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AspectType>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAspectTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListAspectTypesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAspectTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAspectTypesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAspectTypesResponse {
    type PageItem = crate::model::AspectType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.aspect_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get AspectType request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAspectTypeRequest {
    /// Required. The resource name of the AspectType:
    /// `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAspectTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAspectTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAspectTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetAspectTypeRequest"
    }
}

/// Create Entry request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntryRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Entry identifier. It has to be unique within an Entry Group.
    ///
    /// Entries corresponding to Google Cloud resources use an Entry ID format
    /// based on [full resource
    /// names](https://cloud.google.com/apis/design/resource_names#full_resource_name).
    /// The format is a full resource name of the resource without the
    /// prefix double slashes in the API service name part of the full resource
    /// name. This allows retrieval of entries using their associated resource
    /// name.
    ///
    /// For example, if the full resource name of a resource is
    /// `//library.googleapis.com/shelves/shelf1/books/book2`,
    /// then the suggested entry_id is
    /// `library.googleapis.com/shelves/shelf1/books/book2`.
    ///
    /// It is also suggested to follow the same convention for entries
    /// corresponding to resources from providers or systems other than Google
    /// Cloud.
    ///
    /// The maximum size of the field is 4000 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry_id: std::string::String,

    /// Required. Entry resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::Entry>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entry_id][crate::model::CreateEntryRequest::entry_id].
    pub fn set_entry_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry_id = v.into();
        self
    }

    /// Sets the value of [entry][crate::model::CreateEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntryRequest"
    }
}

/// Update Entry request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntryRequest {
    /// Required. Entry resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::Entry>,

    /// Optional. Mask of fields to update. To update Aspects, the update_mask must
    /// contain the value "aspects".
    ///
    /// If the update_mask is empty, the service will update all modifiable fields
    /// present in the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set to true and the entry doesn't exist, the service will
    /// create it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    /// Optional. If set to true and the aspect_keys specify aspect ranges, the
    /// service deletes any existing aspects from that range that weren't provided
    /// in the request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub delete_missing_aspects: bool,

    /// Optional. The map keys of the Aspects which the service should modify. It
    /// supports the following syntaxes:
    ///
    /// * `<aspect_type_reference>` - matches an aspect of the given type and empty
    ///   path.
    /// * `<aspect_type_reference>@path` - matches an aspect of the given type and
    ///   specified path. For example, to attach an aspect to a field that is
    ///   specified by the `schema` aspect, the path should have the format
    ///   `Schema.<field_name>`.
    /// * `<aspect_type_reference>@*` - matches aspects of the given type for all
    ///   paths.
    /// * `*@path` - matches aspects of all types on the given path.
    ///
    /// The service will not remove existing aspects matching the syntax unless
    /// `delete_missing_aspects` is set to true.
    ///
    /// If this field is left empty, the service treats it as specifying
    /// exactly those Aspects present in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_keys: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::UpdateEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntryRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateEntryRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [delete_missing_aspects][crate::model::UpdateEntryRequest::delete_missing_aspects].
    pub fn set_delete_missing_aspects<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.delete_missing_aspects = v.into();
        self
    }

    /// Sets the value of [aspect_keys][crate::model::UpdateEntryRequest::aspect_keys].
    pub fn set_aspect_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpdateEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntryRequest"
    }
}

/// Delete Entry request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntryRequest"
    }
}

/// List Entries request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntriesRequest {
    /// Required. The resource name of the parent Entry Group:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Number of items to return per page. If there are remaining
    /// results, the service returns a next_page_token. If unspecified, the service
    /// returns at most 10 Entries. The maximum value is 100; values above 100 will
    /// be coerced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntries` call. Provide
    /// this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter on the entries to return. Filters are case-sensitive.
    /// You can filter the request by the following fields:
    ///
    /// * entry_type
    /// * entry_source.display_name
    ///
    /// The comparison operators are =, !=, <, >, <=, >=. The service compares
    /// strings according to lexical order.
    ///
    /// You can use the logical operators AND, OR, NOT in the filter.
    ///
    /// You can use Wildcard "*", but for entry_type you need to provide the
    /// full project id or number.
    ///
    /// Example filter expressions:
    ///
    /// * "entry_source.display_name=AnExampleDisplayName"
    /// * "entry_type=projects/example-project/locations/global/entryTypes/example-entry_type"
    /// * "entry_type=projects/example-project/locations/us/entryTypes/a* OR
    ///   entry_type=projects/another-project/locations/*"
    /// * "NOT entry_source.display_name=AnotherExampleDisplayName"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntriesRequest"
    }
}

/// List Entries response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntriesResponse {
    /// The list of entries under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entries: std::vec::Vec<crate::model::Entry>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entries][crate::model::ListEntriesResponse::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntriesResponse {
    type PageItem = crate::model::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get Entry request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntryRequest {
    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. View to control which parts of an entry the service should
    /// return.
    pub view: crate::model::EntryView,

    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_types: std::vec::Vec<std::string::String>,

    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub paths: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetEntryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::EntryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [aspect_types][crate::model::GetEntryRequest::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::GetEntryRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntryRequest"
    }
}

/// Lookup Entry request using permissions in the source system.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LookupEntryRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. View to control which parts of an entry the service should
    /// return.
    pub view: crate::model::EntryView,

    /// Optional. Limits the aspects returned to the provided aspect types.
    /// It only works for CUSTOM view.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_types: std::vec::Vec<std::string::String>,

    /// Optional. Limits the aspects returned to those associated with the provided
    /// paths within the Entry. It only works for CUSTOM view.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub paths: std::vec::Vec<std::string::String>,

    /// Required. The resource name of the Entry:
    /// `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entry: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LookupEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LookupEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::LookupEntryRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::EntryView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [aspect_types][crate::model::LookupEntryRequest::aspect_types].
    pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::LookupEntryRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [entry][crate::model::LookupEntryRequest::entry].
    pub fn set_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry = v.into();
        self
    }
}

impl wkt::message::Message for LookupEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.LookupEntryRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntriesRequest {
    /// Required. The project to which the request should be attributed in the
    /// following form: `projects/{project}/locations/{location}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The query against which entries in scope should be matched.
    /// The query syntax is defined in [Search syntax for Dataplex
    /// Catalog](https://cloud.google.com/dataplex/docs/search-syntax).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// Optional. Number of results in the search page. If <=0, then defaults
    /// to 10. Max limit for page_size is 1000. Throws an invalid argument for
    /// page_size > 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `SearchEntries` call. Provide
    /// this to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Specifies the ordering of results.
    /// Supported values are:
    ///
    /// * `relevance` (default)
    /// * `last_modified_timestamp`
    /// * `last_modified_timestamp asc`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The scope under which the search should be operating. It must
    /// either be `organizations/<org_id>` or `projects/<project_ref>`. If it is
    /// unspecified, it defaults to the organization where the project provided in
    /// `name` is located.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub scope: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SearchEntriesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchEntriesRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchEntriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::SearchEntriesRequest::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesRequest"
    }
}

/// A single result of a SearchEntries request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntriesResult {
    /// Linked resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub linked_resource: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataplex_entry: std::option::Option<crate::model::Entry>,

    /// Snippets.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[deprecated]
    pub snippets: std::option::Option<crate::model::search_entries_result::Snippets>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linked_resource][crate::model::SearchEntriesResult::linked_resource].
    #[deprecated]
    pub fn set_linked_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.linked_resource = v.into();
        self
    }

    /// Sets the value of [dataplex_entry][crate::model::SearchEntriesResult::dataplex_entry].
    pub fn set_dataplex_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataplex_entry = v.into();
        self
    }

    /// Sets the value of [snippets][crate::model::SearchEntriesResult::snippets].
    #[deprecated]
    pub fn set_snippets<
        T: std::convert::Into<std::option::Option<crate::model::search_entries_result::Snippets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.snippets = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntriesResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResult"
    }
}

/// Defines additional types related to [SearchEntriesResult].
pub mod search_entries_result {
    #[allow(unused_imports)]
    use super::*;

    /// Snippets for the entry, contains HTML-style highlighting for
    /// matched tokens, will be used in UI.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    #[deprecated]
    pub struct Snippets {
        /// Entry
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        #[deprecated]
        pub dataplex_entry: std::option::Option<crate::model::Entry>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Snippets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataplex_entry][crate::model::search_entries_result::Snippets::dataplex_entry].
        #[deprecated]
        pub fn set_dataplex_entry<
            T: std::convert::Into<std::option::Option<crate::model::Entry>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.dataplex_entry = v.into();
            self
        }
    }

    impl wkt::message::Message for Snippets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResult.Snippets"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntriesResponse {
    /// The results matching the search query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub results: std::vec::Vec<crate::model::SearchEntriesResult>,

    /// The estimated total number of matching entries. This number isn't
    /// guaranteed to be accurate.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub total_size: i32,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach. Search results don't include
    /// data from these locations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchEntriesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchEntriesResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchEntriesResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::SearchEntriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SearchEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchEntriesResponse {
    type PageItem = crate::model::SearchEntriesResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// An object that describes the values that you want to set for an entry and its
/// attached aspects when you import metadata. Used when you run a metadata
/// import job. See
/// [CreateMetadataJob][google.cloud.dataplex.v1.CatalogService.CreateMetadataJob].
///
/// You provide a collection of import items in a metadata import file. For more
/// information about how to create a metadata import file, see [Metadata import
/// file](https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file).
///
/// [google.cloud.dataplex.v1.CatalogService.CreateMetadataJob]: crate::client::CatalogService::create_metadata_job
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportItem {
    /// Information about an entry and its attached aspects.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entry: std::option::Option<crate::model::Entry>,

    /// The fields to update, in paths that are relative to the `Entry` resource.
    /// Separate each field with a comma.
    ///
    /// In `FULL` entry sync mode, Dataplex includes the paths of all of the fields
    /// for an entry that can be modified, including aspects. This means that
    /// Dataplex replaces the existing entry with the entry in the metadata import
    /// file. All modifiable fields are updated, regardless of the fields that are
    /// listed in the update mask, and regardless of whether a field is present
    /// in the `entry` object.
    ///
    /// The `update_mask` field is ignored when an entry is created or re-created.
    ///
    /// In an aspect-only metadata job (when entry sync mode is `NONE`), set this
    /// value to `aspects`.
    ///
    /// Dataplex also determines which entries and aspects to modify by comparing
    /// the values and timestamps that you provide in the metadata import file with
    /// the values and timestamps that exist in your project. For more information,
    /// see [Comparison
    /// logic](https://cloud.google.com/dataplex/docs/import-metadata#data-modification-logic).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The aspects to modify. Supports the following syntaxes:
    ///
    /// * `{aspect_type_reference}`: matches aspects that belong to the specified
    ///   aspect type and are attached directly to the entry.
    /// * `{aspect_type_reference}@{path}`: matches aspects that belong to the
    ///   specified aspect type and path.
    /// * `{aspect_type_reference}@*` : matches aspects of the given type for all
    ///   paths.
    /// * `*@path` : matches aspects of all types on the given path.
    ///
    /// Replace `{aspect_type_reference}` with a reference to the aspect type, in
    /// the format
    /// `{project_id_or_number}.{location_id}.{aspect_type_id}`.
    ///
    /// In `FULL` entry sync mode, if you leave this field empty, it is treated as
    /// specifying exactly those aspects that are present within the specified
    /// entry. Dataplex implicitly adds the keys for all of the required aspects of
    /// an entry.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub aspect_keys: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportItem {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::ImportItem::entry].
    pub fn set_entry<T: std::convert::Into<std::option::Option<crate::model::Entry>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::ImportItem::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [aspect_keys][crate::model::ImportItem::aspect_keys].
    pub fn set_aspect_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aspect_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportItem {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ImportItem"
    }
}

/// Create metadata job request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMetadataJobRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The metadata job resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata_job: std::option::Option<crate::model::MetadataJob>,

    /// Optional. The metadata job ID. If not provided, a unique ID is generated
    /// with the prefix `metadata-job-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metadata_job_id: std::string::String,

    /// Optional. The service validates the request without performing any
    /// mutations. The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMetadataJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [metadata_job][crate::model::CreateMetadataJobRequest::metadata_job].
    pub fn set_metadata_job<
        T: std::convert::Into<std::option::Option<crate::model::MetadataJob>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metadata_job = v.into();
        self
    }

    /// Sets the value of [metadata_job_id][crate::model::CreateMetadataJobRequest::metadata_job_id].
    pub fn set_metadata_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metadata_job_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateMetadataJobRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateMetadataJobRequest"
    }
}

/// Get metadata job request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMetadataJobRequest {
    /// Required. The resource name of the metadata job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMetadataJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetMetadataJobRequest"
    }
}

/// List metadata jobs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataJobsRequest {
    /// Required. The resource name of the parent location, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of metadata jobs to return. The service might
    /// return fewer jobs than this value. If unspecified, at most 10 jobs are
    /// returned. The maximum value is 1,000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token received from a previous `ListMetadataJobs` call.
    /// Provide this token to retrieve the subsequent page of results. When
    /// paginating, all other parameters that are provided to the
    /// `ListMetadataJobs` request must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The service supports the following formats:
    ///
    /// * `labels.key1 = "value1"`
    /// * `labels:key1`
    /// * `name = "value"`
    ///
    /// You can combine filters with `AND`, `OR`, and `NOT` operators.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The field to sort the results by, either `name` or `create_time`.
    /// If not specified, the ordering is undefined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetadataJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMetadataJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMetadataJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMetadataJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMetadataJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMetadataJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMetadataJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListMetadataJobsRequest"
    }
}

/// List metadata jobs response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMetadataJobsResponse {
    /// Metadata jobs under the specified parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metadata_jobs: std::vec::Vec<crate::model::MetadataJob>,

    /// A token to retrieve the next page of results. If there are no more results
    /// in the list, the value is empty.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that the service couldn't reach.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMetadataJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metadata_jobs][crate::model::ListMetadataJobsResponse::metadata_jobs].
    pub fn set_metadata_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetadataJob>,
    {
        use std::iter::Iterator;
        self.metadata_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMetadataJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListMetadataJobsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMetadataJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListMetadataJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMetadataJobsResponse {
    type PageItem = crate::model::MetadataJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.metadata_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Cancel metadata job request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelMetadataJobRequest {
    /// Required. The resource name of the job, in the format
    /// `projects/{project_id_or_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelMetadataJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelMetadataJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelMetadataJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CancelMetadataJobRequest"
    }
}

/// A metadata job resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetadataJob {
    /// Output only. Identifier. The name of the resource that the configuration is
    /// applied to, in the format
    /// `projects/{project_number}/locations/{location_id}/metadataJobs/{metadata_job_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. A system-generated, globally unique ID for the metadata job.
    /// If the metadata job is deleted and then re-created with the same name, this
    /// ID is different.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the metadata job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the metadata job was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Metadata job type.
    #[serde(rename = "type")]
    pub r#type: crate::model::metadata_job::Type,

    /// Output only. Metadata job status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::metadata_job::Status>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::metadata_job::Spec>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::metadata_job::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetadataJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MetadataJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::MetadataJob::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MetadataJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::MetadataJob::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MetadataJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [r#type][crate::model::MetadataJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::metadata_job::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::MetadataJob::status].
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::metadata_job::Status>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::metadata_job::Spec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::MetadataJob::spec]
    /// if it holds a `ImportSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ImportJobSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Spec::ImportSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec]
    /// to hold a `ImportSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_import_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ImportJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::metadata_job::Spec::ImportSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::MetadataJob::spec]
    /// if it holds a `ExportSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ExportJobSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Spec::ExportSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::MetadataJob::spec]
    /// to hold a `ExportSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_export_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ExportJobSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::metadata_job::Spec::ExportSpec(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::MetadataJob::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::metadata_job::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::MetadataJob::result]
    /// if it holds a `ImportResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn import_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ImportJobResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Result::ImportResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MetadataJob::result]
    /// to hold a `ImportResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_import_result<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ImportJobResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::metadata_job::Result::ImportResult(v.into()));
        self
    }

    /// The value of [result][crate::model::MetadataJob::result]
    /// if it holds a `ExportResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::metadata_job::ExportJobResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::metadata_job::Result::ExportResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::MetadataJob::result]
    /// to hold a `ExportResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_export_result<
        T: std::convert::Into<std::boxed::Box<crate::model::metadata_job::ExportJobResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::metadata_job::Result::ExportResult(v.into()));
        self
    }
}

impl wkt::message::Message for MetadataJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob"
    }
}

/// Defines additional types related to [MetadataJob].
pub mod metadata_job {
    #[allow(unused_imports)]
    use super::*;

    /// Results from a metadata import job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportJobResult {
        /// Output only. The total number of entries that were deleted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub deleted_entries: i64,

        /// Output only. The total number of entries that were updated.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub updated_entries: i64,

        /// Output only. The total number of entries that were created.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub created_entries: i64,

        /// Output only. The total number of entries that were unchanged.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub unchanged_entries: i64,

        /// Output only. The total number of entries that were recreated.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub recreated_entries: i64,

        /// Output only. The time when the status was updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportJobResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deleted_entries][crate::model::metadata_job::ImportJobResult::deleted_entries].
        pub fn set_deleted_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.deleted_entries = v.into();
            self
        }

        /// Sets the value of [updated_entries][crate::model::metadata_job::ImportJobResult::updated_entries].
        pub fn set_updated_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.updated_entries = v.into();
            self
        }

        /// Sets the value of [created_entries][crate::model::metadata_job::ImportJobResult::created_entries].
        pub fn set_created_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.created_entries = v.into();
            self
        }

        /// Sets the value of [unchanged_entries][crate::model::metadata_job::ImportJobResult::unchanged_entries].
        pub fn set_unchanged_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.unchanged_entries = v.into();
            self
        }

        /// Sets the value of [recreated_entries][crate::model::metadata_job::ImportJobResult::recreated_entries].
        pub fn set_recreated_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.recreated_entries = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::metadata_job::ImportJobResult::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportJobResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobResult"
        }
    }

    /// Export Job Results. The result is based on the snapshot at the time when
    /// the job is created.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExportJobResult {
        /// Output only. The number of entries that have been exported.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub exported_entries: i64,

        /// Output only. The error message if the export job failed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExportJobResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [exported_entries][crate::model::metadata_job::ExportJobResult::exported_entries].
        pub fn set_exported_entries<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.exported_entries = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::metadata_job::ExportJobResult::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for ExportJobResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobResult"
        }
    }

    /// Job specification for a metadata import job.
    ///
    /// You can run the following kinds of metadata import jobs:
    ///
    /// * Full sync of entries with incremental import of their aspects.
    ///   Supported for custom entries.
    /// * Incremental import of aspects only. Supported for aspects that belong
    ///   to custom entries and system entries. For custom entries, you can modify
    ///   both optional aspects and required aspects. For system entries, you can
    ///   modify optional aspects.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ImportJobSpec {
        /// Optional. The URI of a Cloud Storage bucket or folder (beginning with
        /// `gs://` and ending with `/`) that contains the metadata import files for
        /// this job.
        ///
        /// A metadata import file defines the values to set for each of the entries
        /// and aspects in a metadata job. For more information about how to create a
        /// metadata import file and the file requirements, see [Metadata import
        /// file](https://cloud.google.com/dataplex/docs/import-metadata#metadata-import-file).
        ///
        /// You can provide multiple metadata import files in the same metadata job.
        /// The bucket or folder must contain at least one metadata import file, in
        /// JSON Lines format (either `.json` or `.jsonl` file extension).
        ///
        /// In `FULL` entry sync mode, don't save the metadata import file in a
        /// folder named `SOURCE_STORAGE_URI/deletions/`.
        ///
        /// **Caution**: If the metadata import file contains no data, all entries
        /// and aspects that belong to the job's scope are deleted.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_storage_uri: std::string::String,

        /// Optional. The time when the process that created the metadata import
        /// files began.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub source_create_time: std::option::Option<wkt::Timestamp>,

        /// Required. A boundary on the scope of impact that the metadata import job
        /// can have.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scope: std::option::Option<crate::model::metadata_job::import_job_spec::ImportJobScope>,

        /// Required. The sync mode for entries.
        pub entry_sync_mode: crate::model::metadata_job::import_job_spec::SyncMode,

        /// Required. The sync mode for aspects.
        pub aspect_sync_mode: crate::model::metadata_job::import_job_spec::SyncMode,

        /// Optional. The level of logs to write to Cloud Logging for this job.
        ///
        /// Debug-level logs provide highly-detailed information for
        /// troubleshooting, but their increased verbosity could incur [additional
        /// costs](https://cloud.google.com/stackdriver/pricing) that might not be
        /// merited for all jobs.
        ///
        /// If unspecified, defaults to `INFO`.
        pub log_level: crate::model::metadata_job::import_job_spec::LogLevel,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ImportJobSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_storage_uri][crate::model::metadata_job::ImportJobSpec::source_storage_uri].
        pub fn set_source_storage_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_storage_uri = v.into();
            self
        }

        /// Sets the value of [source_create_time][crate::model::metadata_job::ImportJobSpec::source_create_time].
        pub fn set_source_create_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source_create_time = v.into();
            self
        }

        /// Sets the value of [scope][crate::model::metadata_job::ImportJobSpec::scope].
        pub fn set_scope<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::metadata_job::import_job_spec::ImportJobScope,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scope = v.into();
            self
        }

        /// Sets the value of [entry_sync_mode][crate::model::metadata_job::ImportJobSpec::entry_sync_mode].
        pub fn set_entry_sync_mode<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::SyncMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entry_sync_mode = v.into();
            self
        }

        /// Sets the value of [aspect_sync_mode][crate::model::metadata_job::ImportJobSpec::aspect_sync_mode].
        pub fn set_aspect_sync_mode<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::SyncMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aspect_sync_mode = v.into();
            self
        }

        /// Sets the value of [log_level][crate::model::metadata_job::ImportJobSpec::log_level].
        pub fn set_log_level<
            T: std::convert::Into<crate::model::metadata_job::import_job_spec::LogLevel>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.log_level = v.into();
            self
        }
    }

    impl wkt::message::Message for ImportJobSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobSpec"
        }
    }

    /// Defines additional types related to [ImportJobSpec].
    pub mod import_job_spec {
        #[allow(unused_imports)]
        use super::*;

        /// A boundary on the scope of impact that the metadata import job can have.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ImportJobScope {
            /// Required. The entry group that is in scope for the import job,
            /// specified as a relative resource name in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryGroups/{entry_group_id}`.
            /// Only entries and aspects that belong to the specified entry group are
            /// affected by the job.
            ///
            /// Must contain exactly one element. The entry group and the job
            /// must be in the same location.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub entry_groups: std::vec::Vec<std::string::String>,

            /// Required. The entry types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/entryTypes/{entry_type_id}`.
            /// The job modifies only the entries and aspects that belong to these
            /// entry types.
            ///
            /// If the metadata import file attempts to modify an entry whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an entry type must either match the location of the
            /// job, or the entry type must be global.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub entry_types: std::vec::Vec<std::string::String>,

            /// Optional. The aspect types that are in scope for the import job,
            /// specified as relative resource names in the format
            /// `projects/{project_number_or_id}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
            /// The job modifies only the aspects that belong to these aspect types.
            ///
            /// This field is required when creating an aspect-only import job.
            ///
            /// If the metadata import file attempts to modify an aspect whose type
            /// isn't included in this list, the import job is halted before modifying
            /// any entries or aspects.
            ///
            /// The location of an aspect type must either match the location of the
            /// job, or the aspect type must be global.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub aspect_types: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ImportJobScope {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [entry_groups][crate::model::metadata_job::import_job_spec::ImportJobScope::entry_groups].
            pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_groups = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_types][crate::model::metadata_job::import_job_spec::ImportJobScope::entry_types].
            pub fn set_entry_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_types = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [aspect_types][crate::model::metadata_job::import_job_spec::ImportJobScope::aspect_types].
            pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.aspect_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ImportJobScope {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.ImportJobScope"
            }
        }

        /// Specifies how the entries and aspects in a metadata job are updated. For
        /// more information, see [Sync
        /// mode](https://cloud.google.com/dataplex/docs/import-metadata#sync-mode).
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SyncMode {
            /// Sync mode unspecified.
            Unspecified,
            /// All resources in the job's scope are modified. If a resource exists in
            /// Dataplex but isn't included in the metadata import file, the resource
            /// is deleted when you run the metadata job. Use this mode to perform a
            /// full sync of the set of entries in the job scope.
            ///
            /// This sync mode is supported for entries.
            Full,
            /// Only the resources that are explicitly included in the
            /// metadata import file are modified. Use this mode to modify a subset of
            /// resources while leaving unreferenced resources unchanged.
            ///
            /// This sync mode is supported for aspects.
            Incremental,
            /// If entry sync mode is `NONE`, then aspects are modified according
            /// to the aspect sync mode. Other metadata that belongs to entries in the
            /// job's scope isn't modified.
            ///
            /// This sync mode is supported for entries.
            None,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SyncMode::value] or
            /// [SyncMode::name].
            UnknownValue(sync_mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod sync_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SyncMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Full => std::option::Option::Some(1),
                    Self::Incremental => std::option::Option::Some(2),
                    Self::None => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SYNC_MODE_UNSPECIFIED"),
                    Self::Full => std::option::Option::Some("FULL"),
                    Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                    Self::None => std::option::Option::Some("NONE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SyncMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SyncMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SyncMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Full,
                    2 => Self::Incremental,
                    3 => Self::None,
                    _ => Self::UnknownValue(sync_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SyncMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SYNC_MODE_UNSPECIFIED" => Self::Unspecified,
                    "FULL" => Self::Full,
                    "INCREMENTAL" => Self::Incremental,
                    "NONE" => Self::None,
                    _ => Self::UnknownValue(sync_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SyncMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Full => serializer.serialize_i32(1),
                    Self::Incremental => serializer.serialize_i32(2),
                    Self::None => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SyncMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SyncMode>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.SyncMode",
                ))
            }
        }

        /// The level of logs to write to Cloud Logging for this job.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LogLevel {
            /// Log level unspecified.
            Unspecified,
            /// Debug-level logging. Captures detailed logs for each import item. Use
            /// debug-level logging to troubleshoot issues with specific import items.
            /// For example, use debug-level logging to identify resources that are
            /// missing from the job scope, entries or aspects that don't conform to
            /// the associated entry type or aspect type, or other misconfigurations
            /// with the metadata import file.
            ///
            /// Depending on the size of your metadata job and the number of logs that
            /// are generated, debug-level logging might incur
            /// [additional costs](https://cloud.google.com/stackdriver/pricing).
            Debug,
            /// Info-level logging. Captures logs at the overall job level. Includes
            /// aggregate logs about import items, but doesn't specify which import
            /// item has an error.
            Info,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LogLevel::value] or
            /// [LogLevel::name].
            UnknownValue(log_level::UnknownValue),
        }

        #[doc(hidden)]
        pub mod log_level {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LogLevel {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Debug => std::option::Option::Some(1),
                    Self::Info => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOG_LEVEL_UNSPECIFIED"),
                    Self::Debug => std::option::Option::Some("DEBUG"),
                    Self::Info => std::option::Option::Some("INFO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LogLevel {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LogLevel {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LogLevel {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Debug,
                    2 => Self::Info,
                    _ => Self::UnknownValue(log_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LogLevel {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOG_LEVEL_UNSPECIFIED" => Self::Unspecified,
                    "DEBUG" => Self::Debug,
                    "INFO" => Self::Info,
                    _ => Self::UnknownValue(log_level::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LogLevel {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Debug => serializer.serialize_i32(1),
                    Self::Info => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LogLevel {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogLevel>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.ImportJobSpec.LogLevel",
                ))
            }
        }
    }

    /// Export job specification.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExportJobSpec {
        /// Required. Selects the entries to be exported by this job.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub scope: std::option::Option<crate::model::metadata_job::export_job_spec::ExportJobScope>,

        /// Required. The root path of the exported metadata.
        /// Must be in the format: "gs://<bucket_id>"
        /// Or specify a customized prefix after the bucket:
        /// "gs://<bucket_id>/\<folder1\>/\<folder2\>/.../".
        /// The length limit of the customized prefix is 128 characters.
        /// The bucket must be in the same VPC-SC perimeter with the job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub output_path: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExportJobSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scope][crate::model::metadata_job::ExportJobSpec::scope].
        pub fn set_scope<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::metadata_job::export_job_spec::ExportJobScope,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scope = v.into();
            self
        }

        /// Sets the value of [output_path][crate::model::metadata_job::ExportJobSpec::output_path].
        pub fn set_output_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.output_path = v.into();
            self
        }
    }

    impl wkt::message::Message for ExportJobSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobSpec"
        }
    }

    /// Defines additional types related to [ExportJobSpec].
    pub mod export_job_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Scope of the export job.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ExportJobScope {
            /// Indicating if it is an organization level export job.
            ///
            /// - When set to true, exports all entries from entry groups and projects
            ///   sharing the same organization id of the Metadata Job. Only projects and
            ///   entry groups in the VPC-SC perimeter will be exported. The projects and
            ///   entry groups are ignored.
            /// - When set to false, one of the projects or entry groups must be
            ///   specified.
            /// - Default to false.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub organization_level: bool,

            /// The projects that are in the scope of the export job. Can either be
            /// project numbers or project IDs. If specified, only the entries from the
            /// specified projects will be exported. The projects must be in the same
            /// organization and in the VPC-SC perimeter. Either projects or
            /// entry_groups can be specified when organization_level_export is set to
            /// false.
            /// Must follow the format: "projects/<project_id_or_number>"
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub projects: std::vec::Vec<std::string::String>,

            /// The entry groups that are in scope for the export job. Optional. If
            /// specified, only entries in the specified entry groups will be exported
            /// by the job. Must be in the VPC-SC perimeter of the job. The location of
            /// the entry groups must be the same as the job. Either projects or
            /// entry_groups can be specified when organization_level_export is set to
            /// false. Must follow the format:
            /// "projects/<project_id_or_number>/locations/\<location\>/entryGroups/<entry_group_id>"
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub entry_groups: std::vec::Vec<std::string::String>,

            /// If specified, only entries of the specified types will be
            /// affected by the job.
            /// Must follow the format:
            /// "projects/<project_id_or_number>/locations/\<location\>/entryTypes/<entry_type_id>"
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub entry_types: std::vec::Vec<std::string::String>,

            /// The aspect types that are in scope for the export job.
            /// Optional. If specified, only aspects of the specified types will be
            /// affected by the job.
            /// Must follow the format:
            /// "projects/<project_id_or_number>/locations/\<location\>/aspectTypes/<aspect_type_id>"
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub aspect_types: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ExportJobScope {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [organization_level][crate::model::metadata_job::export_job_spec::ExportJobScope::organization_level].
            pub fn set_organization_level<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.organization_level = v.into();
                self
            }

            /// Sets the value of [projects][crate::model::metadata_job::export_job_spec::ExportJobScope::projects].
            pub fn set_projects<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.projects = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_groups][crate::model::metadata_job::export_job_spec::ExportJobScope::entry_groups].
            pub fn set_entry_groups<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_groups = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [entry_types][crate::model::metadata_job::export_job_spec::ExportJobScope::entry_types].
            pub fn set_entry_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.entry_types = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [aspect_types][crate::model::metadata_job::export_job_spec::ExportJobScope::aspect_types].
            pub fn set_aspect_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.aspect_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for ExportJobScope {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.ExportJobSpec.ExportJobScope"
            }
        }
    }

    /// Metadata job status.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Status {
        /// Output only. State of the metadata job.
        pub state: crate::model::metadata_job::status::State,

        /// Output only. Message relating to the progression of a metadata job.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Output only. Progress tracking.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub completion_percent: i32,

        /// Output only. The time when the status was updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::metadata_job::Status::state].
        pub fn set_state<T: std::convert::Into<crate::model::metadata_job::status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::metadata_job::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [completion_percent][crate::model::metadata_job::Status::completion_percent].
        pub fn set_completion_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.completion_percent = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::metadata_job::Status::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.MetadataJob.Status"
        }
    }

    /// Defines additional types related to [Status].
    pub mod status {
        #[allow(unused_imports)]
        use super::*;

        /// State of a metadata job.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// The job is queued.
            Queued,
            /// The job is running.
            Running,
            /// The job is being canceled.
            Canceling,
            /// The job is canceled.
            Canceled,
            /// The job succeeded.
            Succeeded,
            /// The job failed.
            Failed,
            /// The job completed with some errors.
            SucceededWithErrors,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Queued => std::option::Option::Some(1),
                    Self::Running => std::option::Option::Some(2),
                    Self::Canceling => std::option::Option::Some(3),
                    Self::Canceled => std::option::Option::Some(4),
                    Self::Succeeded => std::option::Option::Some(5),
                    Self::Failed => std::option::Option::Some(6),
                    Self::SucceededWithErrors => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Queued => std::option::Option::Some("QUEUED"),
                    Self::Running => std::option::Option::Some("RUNNING"),
                    Self::Canceling => std::option::Option::Some("CANCELING"),
                    Self::Canceled => std::option::Option::Some("CANCELED"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::SucceededWithErrors => std::option::Option::Some("SUCCEEDED_WITH_ERRORS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Queued,
                    2 => Self::Running,
                    3 => Self::Canceling,
                    4 => Self::Canceled,
                    5 => Self::Succeeded,
                    6 => Self::Failed,
                    7 => Self::SucceededWithErrors,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "QUEUED" => Self::Queued,
                    "RUNNING" => Self::Running,
                    "CANCELING" => Self::Canceling,
                    "CANCELED" => Self::Canceled,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    "SUCCEEDED_WITH_ERRORS" => Self::SucceededWithErrors,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Queued => serializer.serialize_i32(1),
                    Self::Running => serializer.serialize_i32(2),
                    Self::Canceling => serializer.serialize_i32(3),
                    Self::Canceled => serializer.serialize_i32(4),
                    Self::Succeeded => serializer.serialize_i32(5),
                    Self::Failed => serializer.serialize_i32(6),
                    Self::SucceededWithErrors => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.MetadataJob.Status.State",
                ))
            }
        }
    }

    /// Metadata job type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified.
        Unspecified,
        /// Import job.
        Import,
        /// Export job type.
        Export,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Import => std::option::Option::Some(1),
                Self::Export => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Import => std::option::Option::Some("IMPORT"),
                Self::Export => std::option::Option::Some("EXPORT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Import,
                2 => Self::Export,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMPORT" => Self::Import,
                "EXPORT" => Self::Export,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Import => serializer.serialize_i32(1),
                Self::Export => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.MetadataJob.Type",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Spec {
        /// Import job specification.
        ImportSpec(std::boxed::Box<crate::model::metadata_job::ImportJobSpec>),
        /// Export job specification.
        ExportSpec(std::boxed::Box<crate::model::metadata_job::ExportJobSpec>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. Import job result.
        ImportResult(std::boxed::Box<crate::model::metadata_job::ImportJobResult>),
        /// Output only. Export job result.
        ExportResult(std::boxed::Box<crate::model::metadata_job::ExportJobResult>),
    }
}

/// A Resource designed to manage encryption configurations for customers to
/// support Customer Managed Encryption Keys (CMEK).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Identifier. The resource name of the EncryptionConfig.
    /// Format:
    /// organizations/{organization}/locations/{location}/encryptionConfigs/{encryption_config}
    /// Global location is not supported.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If a key is chosen, it means that the customer is using CMEK.
    /// If a key is not chosen, it means that the customer is using Google managed
    /// encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Output only. The time when the Encryption configuration was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the Encryption configuration was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of encryption of the databases.
    pub encryption_state: crate::model::encryption_config::EncryptionState,

    /// Etag of the EncryptionConfig. This is a strong etag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Details of the failure if anything related to Cmek db fails.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub failure_details: std::option::Option<crate::model::encryption_config::FailureDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptionConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [key][crate::model::EncryptionConfig::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EncryptionConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EncryptionConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [encryption_state][crate::model::EncryptionConfig::encryption_state].
    pub fn set_encryption_state<
        T: std::convert::Into<crate::model::encryption_config::EncryptionState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_state = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::EncryptionConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [failure_details][crate::model::EncryptionConfig::failure_details].
    pub fn set_failure_details<
        T: std::convert::Into<std::option::Option<crate::model::encryption_config::FailureDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.failure_details = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EncryptionConfig"
    }
}

/// Defines additional types related to [EncryptionConfig].
pub mod encryption_config {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the failure if anything related to Cmek db fails.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailureDetails {
        /// Output only. The error code for the failure.
        pub error_code: crate::model::encryption_config::failure_details::ErrorCode,

        /// Output only. The error message will be shown to the user. Set only if the
        /// error code is REQUIRE_USER_ACTION.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error_message: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailureDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error_code][crate::model::encryption_config::FailureDetails::error_code].
        pub fn set_error_code<
            T: std::convert::Into<crate::model::encryption_config::failure_details::ErrorCode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.error_code = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::encryption_config::FailureDetails::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for FailureDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.EncryptionConfig.FailureDetails"
        }
    }

    /// Defines additional types related to [FailureDetails].
    pub mod failure_details {
        #[allow(unused_imports)]
        use super::*;

        /// Error code for the failure if anything related to Cmek db fails.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ErrorCode {
            /// The error code is not specified
            Unknown,
            /// Error because of internal server error, will be retried automatically..
            InternalError,
            /// User action is required to resolve the error.
            RequireUserAction,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ErrorCode::value] or
            /// [ErrorCode::name].
            UnknownValue(error_code::UnknownValue),
        }

        #[doc(hidden)]
        pub mod error_code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ErrorCode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unknown => std::option::Option::Some(0),
                    Self::InternalError => std::option::Option::Some(1),
                    Self::RequireUserAction => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unknown => std::option::Option::Some("UNKNOWN"),
                    Self::InternalError => std::option::Option::Some("INTERNAL_ERROR"),
                    Self::RequireUserAction => std::option::Option::Some("REQUIRE_USER_ACTION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ErrorCode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ErrorCode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ErrorCode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unknown,
                    1 => Self::InternalError,
                    2 => Self::RequireUserAction,
                    _ => Self::UnknownValue(error_code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ErrorCode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UNKNOWN" => Self::Unknown,
                    "INTERNAL_ERROR" => Self::InternalError,
                    "REQUIRE_USER_ACTION" => Self::RequireUserAction,
                    _ => Self::UnknownValue(error_code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ErrorCode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unknown => serializer.serialize_i32(0),
                    Self::InternalError => serializer.serialize_i32(1),
                    Self::RequireUserAction => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ErrorCode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                    ".google.cloud.dataplex.v1.EncryptionConfig.FailureDetails.ErrorCode",
                ))
            }
        }
    }

    /// State of encryption of the databases when EncryptionConfig is created or
    /// updated.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EncryptionState {
        /// State is not specified.
        Unspecified,
        /// The encryption state of the database when the EncryptionConfig is created
        /// or updated. If the encryption fails, it is retried indefinitely and the
        /// state is shown as ENCRYPTING.
        Encrypting,
        /// The encryption of data has completed successfully.
        Completed,
        /// The encryption of data has failed.
        /// The state is set to FAILED when the encryption fails due to reasons like
        /// permission issues, invalid key etc.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EncryptionState::value] or
        /// [EncryptionState::name].
        UnknownValue(encryption_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod encryption_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EncryptionState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Encrypting => std::option::Option::Some(1),
                Self::Completed => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENCRYPTION_STATE_UNSPECIFIED"),
                Self::Encrypting => std::option::Option::Some("ENCRYPTING"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EncryptionState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EncryptionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EncryptionState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Encrypting,
                2 => Self::Completed,
                3 => Self::Failed,
                _ => Self::UnknownValue(encryption_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EncryptionState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENCRYPTION_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENCRYPTING" => Self::Encrypting,
                "COMPLETED" => Self::Completed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(encryption_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EncryptionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Encrypting => serializer.serialize_i32(1),
                Self::Completed => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EncryptionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionState>::new(
                ".google.cloud.dataplex.v1.EncryptionConfig.EncryptionState",
            ))
        }
    }
}

/// Create EncryptionConfig Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEncryptionConfigRequest {
    /// Required. The location at which the EncryptionConfig is to be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID of the EncryptionConfig to create.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// and hyphens (-).
    /// The maximum size is 63 characters.
    /// The first character must be a letter.
    /// The last character must be a letter or a number.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub encryption_config_id: std::string::String,

    /// Required. The EncryptionConfig to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEncryptionConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [encryption_config_id][crate::model::CreateEncryptionConfigRequest::encryption_config_id].
    pub fn set_encryption_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config_id = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::CreateEncryptionConfigRequest::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEncryptionConfigRequest"
    }
}

/// Get EncryptionConfig Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEncryptionConfigRequest {
    /// Required. The name of the EncryptionConfig to fetch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEncryptionConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEncryptionConfigRequest"
    }
}

/// Update EncryptionConfig Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEncryptionConfigRequest {
    /// Required. The EncryptionConfig to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. Mask of fields to update.
    /// The service treats an omitted field mask as an implied field mask
    /// equivalent to all fields that are populated (have a non-empty value).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_config][crate::model::UpdateEncryptionConfigRequest::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEncryptionConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEncryptionConfigRequest"
    }
}

/// Delete EncryptionConfig Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEncryptionConfigRequest {
    /// Required. The name of the EncryptionConfig to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Etag of the EncryptionConfig. This is a strong etag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEncryptionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEncryptionConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEncryptionConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEncryptionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEncryptionConfigRequest"
    }
}

/// List EncryptionConfigs Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEncryptionConfigsRequest {
    /// Required. The location for which the EncryptionConfig is to be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of EncryptionConfigs to return. The service may
    /// return fewer than this value. If unspecified, at most 10 EncryptionConfigs
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEncryptionConfigs` call.
    /// Provide this to retrieve the subsequent page. When paginating, the
    /// parameters - filter and order_by provided to `ListEncryptionConfigs` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter the EncryptionConfigs to be returned.
    /// Using bare literals: (These values will be matched anywhere it may appear
    /// in the object's field values)
    ///
    /// * filter=some_value
    ///   Using fields: (These values will be matched only in the specified field)
    /// * filter=some_field=some_value
    ///   Supported fields:
    /// * name, key, create_time, update_time, encryption_state
    ///   Example:
    /// * filter=name=organizations/123/locations/us-central1/encryptionConfigs/test-config
    ///   conjunctions: (AND, OR, NOT)
    /// * filter=name=organizations/123/locations/us-central1/encryptionConfigs/test-config
    ///   AND mode=CMEK
    ///   logical operators: (>, <, >=, <=, !=, =, :),
    /// * filter=create_time>2024-05-01T00:00:00.000Z
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEncryptionConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEncryptionConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEncryptionConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEncryptionConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEncryptionConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEncryptionConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEncryptionConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEncryptionConfigsRequest"
    }
}

/// List EncryptionConfigs Response
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEncryptionConfigsResponse {
    /// The list of EncryptionConfigs under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub encryption_configs: std::vec::Vec<crate::model::EncryptionConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEncryptionConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_configs][crate::model::ListEncryptionConfigsResponse::encryption_configs].
    pub fn set_encryption_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EncryptionConfig>,
    {
        use std::iter::Iterator;
        self.encryption_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEncryptionConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListEncryptionConfigsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEncryptionConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEncryptionConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEncryptionConfigsResponse {
    type PageItem = crate::model::EncryptionConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.encryption_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Create content request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Content resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [content][crate::model::CreateContentRequest::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateContentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateContentRequest"
    }
}

/// Update content request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateContentRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::Content>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateContentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [content][crate::model::UpdateContentRequest::content].
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateContentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateContentRequest"
    }
}

/// Delete content request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteContentRequest"
    }
}

/// List content request. Returns the BASIC Content view.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContentRequest {
    /// Required. The resource name of the parent lake:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of content to return. The service may return fewer
    /// than this value. If unspecified, at most 10 content will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListContent` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListContent` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request. Filters are case-sensitive.
    /// The following formats are supported:
    ///
    /// labels.key1 = "value1"
    /// labels:key1
    /// type = "NOTEBOOK"
    /// type = "SQL_SCRIPT"
    ///
    /// These restrictions can be coinjoined with AND, OR and NOT conjunctions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContentRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContentRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListContentRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListContentRequest"
    }
}

/// List content response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListContentResponse {
    /// Content under the given parent lake.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub content: std::vec::Vec<crate::model::Content>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::ListContentResponse::content].
    pub fn set_content<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Content>,
    {
        use std::iter::Iterator;
        self.content = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListContentResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListContentResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListContentResponse {
    type PageItem = crate::model::Content;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.content
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get content request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetContentRequest {
    /// Required. The resource name of the content:
    /// projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Specify content view to make a partial request.
    pub view: crate::model::get_content_request::ContentView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetContentRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_content_request::ContentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetContentRequest"
    }
}

/// Defines additional types related to [GetContentRequest].
pub mod get_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies whether the request should return the full or the partial
    /// representation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContentView {
        /// Content view not specified. Defaults to BASIC.
        /// The API will default to the BASIC view.
        Unspecified,
        /// Will not return the `data_text` field.
        Basic,
        /// Returns the complete proto.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContentView::value] or
        /// [ContentView::name].
        UnknownValue(content_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod content_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContentView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTENT_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContentView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContentView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContentView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Full,
                _ => Self::UnknownValue(content_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContentView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTENT_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(content_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContentView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContentView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentView>::new(
                ".google.cloud.dataplex.v1.GetContentRequest.ContentView",
            ))
        }
    }
}

/// Spec for a data discovery scan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataDiscoverySpec {
    /// Optional. Configuration for metadata publishing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_publishing_config:
        std::option::Option<crate::model::data_discovery_spec::BigQueryPublishingConfig>,

    /// The configurations of the data discovery scan resource.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_config: std::option::Option<crate::model::data_discovery_spec::ResourceConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDiscoverySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_publishing_config][crate::model::DataDiscoverySpec::bigquery_publishing_config].
    pub fn set_bigquery_publishing_config<
        T: std::convert::Into<
                std::option::Option<crate::model::data_discovery_spec::BigQueryPublishingConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_publishing_config = v.into();
        self
    }

    /// Sets the value of [resource_config][crate::model::DataDiscoverySpec::resource_config].
    ///
    /// Note that all the setters affecting `resource_config` are mutually
    /// exclusive.
    pub fn set_resource_config<
        T: std::convert::Into<std::option::Option<crate::model::data_discovery_spec::ResourceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = v.into();
        self
    }

    /// The value of [resource_config][crate::model::DataDiscoverySpec::resource_config]
    /// if it holds a `StorageConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn storage_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>>
    {
        #[allow(unreachable_patterns)]
        self.resource_config.as_ref().and_then(|v| match v {
            crate::model::data_discovery_spec::ResourceConfig::StorageConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_config][crate::model::DataDiscoverySpec::resource_config]
    /// to hold a `StorageConfig`.
    ///
    /// Note that all the setters affecting `resource_config` are
    /// mutually exclusive.
    pub fn set_storage_config<
        T: std::convert::Into<std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_config = std::option::Option::Some(
            crate::model::data_discovery_spec::ResourceConfig::StorageConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataDiscoverySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec"
    }
}

/// Defines additional types related to [DataDiscoverySpec].
pub mod data_discovery_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Describes BigQuery publishing configurations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQueryPublishingConfig {
        /// Optional. Determines whether to  publish discovered tables as BigLake
        /// external tables or non-BigLake external tables.
        pub table_type: crate::model::data_discovery_spec::big_query_publishing_config::TableType,

        /// Optional. The BigQuery connection used to create BigLake tables.
        /// Must be in the form
        /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub connection: std::string::String,

        /// Optional. The location of the BigQuery dataset to publish BigLake
        /// external or non-BigLake external tables to.
        ///
        /// . If the Cloud Storage bucket is located in a multi-region bucket, then
        ///   BigQuery dataset can be in the same multi-region bucket or any single
        ///   region that is included in the same multi-region bucket. The datascan can
        ///   be created in any single region that is included in the same multi-region
        ///   bucket
        /// . If the Cloud Storage bucket is located in a dual-region bucket, then
        ///   BigQuery dataset can be located in regions that are included in the
        ///   dual-region bucket, or in a multi-region that includes the dual-region.
        ///   The datascan can be created in any single region that is included in the
        ///   same dual-region bucket.
        /// . If the Cloud Storage bucket is located in a single region, then
        ///   BigQuery dataset can be in the same single region or any multi-region
        ///   bucket that includes the same single region. The datascan will be created
        ///   in the same single region as the bucket.
        /// . If the BigQuery dataset is in single region, it must be in the same
        ///   single region as the datascan.
        ///
        /// For supported values, refer to
        /// <https://cloud.google.com/bigquery/docs/locations#supported_locations>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryPublishingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table_type][crate::model::data_discovery_spec::BigQueryPublishingConfig::table_type].
        pub fn set_table_type<
            T: std::convert::Into<
                    crate::model::data_discovery_spec::big_query_publishing_config::TableType,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.table_type = v.into();
            self
        }

        /// Sets the value of [connection][crate::model::data_discovery_spec::BigQueryPublishingConfig::connection].
        pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.connection = v.into();
            self
        }

        /// Sets the value of [location][crate::model::data_discovery_spec::BigQueryPublishingConfig::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryPublishingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.BigQueryPublishingConfig"
        }
    }

    /// Defines additional types related to [BigQueryPublishingConfig].
    pub mod big_query_publishing_config {
        #[allow(unused_imports)]
        use super::*;

        /// Determines how discovered tables are published.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TableType {
            /// Table type unspecified.
            Unspecified,
            /// Default. Discovered tables are published as BigQuery external tables
            /// whose data is accessed using the credentials of the user querying the
            /// table.
            External,
            /// Discovered tables are published as BigLake external tables whose data
            /// is accessed using the credentials of the associated BigQuery
            /// connection.
            Biglake,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TableType::value] or
            /// [TableType::name].
            UnknownValue(table_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod table_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TableType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::External => std::option::Option::Some(1),
                    Self::Biglake => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                    Self::External => std::option::Option::Some("EXTERNAL"),
                    Self::Biglake => std::option::Option::Some("BIGLAKE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TableType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TableType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TableType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::External,
                    2 => Self::Biglake,
                    _ => Self::UnknownValue(table_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TableType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "EXTERNAL" => Self::External,
                    "BIGLAKE" => Self::Biglake,
                    _ => Self::UnknownValue(table_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TableType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::External => serializer.serialize_i32(1),
                    Self::Biglake => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TableType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                    ".google.cloud.dataplex.v1.DataDiscoverySpec.BigQueryPublishingConfig.TableType"))
            }
        }
    }

    /// Configurations related to Cloud Storage as the data source.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StorageConfig {
        /// Optional. Defines the data to include during discovery when only a subset
        /// of the data should be considered. Provide a list of patterns that
        /// identify the data to include. For Cloud Storage bucket assets, these
        /// patterns are interpreted as glob patterns used to match object names. For
        /// BigQuery dataset assets, these patterns are interpreted as patterns to
        /// match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Defines the data to exclude during discovery. Provide a list of
        /// patterns that identify the data to exclude. For Cloud Storage bucket
        /// assets, these patterns are interpreted as glob patterns used to match
        /// object names. For BigQuery dataset assets, these patterns are interpreted
        /// as patterns to match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub csv_options:
            std::option::Option<crate::model::data_discovery_spec::storage_config::CsvOptions>,

        /// Optional. Configuration for JSON data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub json_options:
            std::option::Option<crate::model::data_discovery_spec::storage_config::JsonOptions>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StorageConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_patterns][crate::model::data_discovery_spec::StorageConfig::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::data_discovery_spec::StorageConfig::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::data_discovery_spec::StorageConfig::csv_options].
        pub fn set_csv_options<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_discovery_spec::storage_config::CsvOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.csv_options = v.into();
            self
        }

        /// Sets the value of [json_options][crate::model::data_discovery_spec::StorageConfig::json_options].
        pub fn set_json_options<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_discovery_spec::storage_config::JsonOptions,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.json_options = v.into();
            self
        }
    }

    impl wkt::message::Message for StorageConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig"
        }
    }

    /// Defines additional types related to [StorageConfig].
    pub mod storage_config {
        #[allow(unused_imports)]
        use super::*;

        /// Describes CSV and similar semi-structured data formats.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub header_rows: i32,

            /// Optional. The delimiter that is used to separate values. The default is
            /// `,` (comma).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data types for CSV data.
            /// If true, all columns are registered as strings.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub type_inference_disabled: bool,

            /// Optional. The character used to quote column values. Accepts `"`
            /// (double quotation mark) or `'` (single quotation mark). If unspecified,
            /// defaults to `"` (double quotation mark).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub quote: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::data_discovery_spec::storage_config::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::data_discovery_spec::storage_config::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::data_discovery_spec::storage_config::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [type_inference_disabled][crate::model::data_discovery_spec::storage_config::CsvOptions::type_inference_disabled].
            pub fn set_type_inference_disabled<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.type_inference_disabled = v.into();
                self
            }

            /// Sets the value of [quote][crate::model::data_discovery_spec::storage_config::CsvOptions::quote].
            pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.quote = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig.CsvOptions"
            }
        }

        /// Describes JSON data format.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data types for JSON data.
            /// If true, all columns are registered as their primitive types
            /// (strings, number, or boolean).
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub type_inference_disabled: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::data_discovery_spec::storage_config::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [type_inference_disabled][crate::model::data_discovery_spec::storage_config::JsonOptions::type_inference_disabled].
            pub fn set_type_inference_disabled<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.type_inference_disabled = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoverySpec.StorageConfig.JsonOptions"
            }
        }
    }

    /// The configurations of the data discovery scan resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceConfig {
        /// Cloud Storage related configurations.
        StorageConfig(std::boxed::Box<crate::model::data_discovery_spec::StorageConfig>),
    }
}

/// The output of a data discovery scan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataDiscoveryResult {
    /// Output only. Configuration for metadata publishing.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub bigquery_publishing:
        std::option::Option<crate::model::data_discovery_result::BigQueryPublishing>,

    /// Output only. Statistics of the DataDiscoveryScan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scan_statistics: std::option::Option<crate::model::data_discovery_result::ScanStatistics>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDiscoveryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_publishing][crate::model::DataDiscoveryResult::bigquery_publishing].
    pub fn set_bigquery_publishing<
        T: std::convert::Into<
                std::option::Option<crate::model::data_discovery_result::BigQueryPublishing>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bigquery_publishing = v.into();
        self
    }

    /// Sets the value of [scan_statistics][crate::model::DataDiscoveryResult::scan_statistics].
    pub fn set_scan_statistics<
        T: std::convert::Into<
                std::option::Option<crate::model::data_discovery_result::ScanStatistics>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scan_statistics = v.into();
        self
    }
}

impl wkt::message::Message for DataDiscoveryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult"
    }
}

/// Defines additional types related to [DataDiscoveryResult].
pub mod data_discovery_result {
    #[allow(unused_imports)]
    use super::*;

    /// Describes BigQuery publishing configurations.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct BigQueryPublishing {
        /// Output only. The BigQuery dataset the discovered tables are published to.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub dataset: std::string::String,

        /// Output only. The location of the BigQuery publishing dataset.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub location: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryPublishing {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset][crate::model::data_discovery_result::BigQueryPublishing::dataset].
        pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset = v.into();
            self
        }

        /// Sets the value of [location][crate::model::data_discovery_result::BigQueryPublishing::location].
        pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.location = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryPublishing {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult.BigQueryPublishing"
        }
    }

    /// Statistics of the DataDiscoveryScan.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ScanStatistics {
        /// The number of files scanned.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub scanned_file_count: i32,

        /// The data processed in bytes.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub data_processed_bytes: i64,

        /// The number of files excluded.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub files_excluded: i32,

        /// The number of tables created.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub tables_created: i32,

        /// The number of tables deleted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub tables_deleted: i32,

        /// The number of tables updated.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub tables_updated: i32,

        /// The number of filesets created.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub filesets_created: i32,

        /// The number of filesets deleted.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub filesets_deleted: i32,

        /// The number of filesets updated.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub filesets_updated: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScanStatistics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [scanned_file_count][crate::model::data_discovery_result::ScanStatistics::scanned_file_count].
        pub fn set_scanned_file_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.scanned_file_count = v.into();
            self
        }

        /// Sets the value of [data_processed_bytes][crate::model::data_discovery_result::ScanStatistics::data_processed_bytes].
        pub fn set_data_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.data_processed_bytes = v.into();
            self
        }

        /// Sets the value of [files_excluded][crate::model::data_discovery_result::ScanStatistics::files_excluded].
        pub fn set_files_excluded<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.files_excluded = v.into();
            self
        }

        /// Sets the value of [tables_created][crate::model::data_discovery_result::ScanStatistics::tables_created].
        pub fn set_tables_created<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_created = v.into();
            self
        }

        /// Sets the value of [tables_deleted][crate::model::data_discovery_result::ScanStatistics::tables_deleted].
        pub fn set_tables_deleted<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_deleted = v.into();
            self
        }

        /// Sets the value of [tables_updated][crate::model::data_discovery_result::ScanStatistics::tables_updated].
        pub fn set_tables_updated<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.tables_updated = v.into();
            self
        }

        /// Sets the value of [filesets_created][crate::model::data_discovery_result::ScanStatistics::filesets_created].
        pub fn set_filesets_created<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_created = v.into();
            self
        }

        /// Sets the value of [filesets_deleted][crate::model::data_discovery_result::ScanStatistics::filesets_deleted].
        pub fn set_filesets_deleted<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_deleted = v.into();
            self
        }

        /// Sets the value of [filesets_updated][crate::model::data_discovery_result::ScanStatistics::filesets_updated].
        pub fn set_filesets_updated<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.filesets_updated = v.into();
            self
        }
    }

    impl wkt::message::Message for ScanStatistics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataDiscoveryResult.ScanStatistics"
        }
    }
}

/// DataProfileScan related setting.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileSpec {
    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    ///   digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    ///
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub sampling_percent: f32,

    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a [WHERE clause in
    /// GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#where_clause).
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub row_filter: std::string::String,

    /// Optional. Actions to take upon job completion..
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_scan_actions: std::option::Option<crate::model::data_profile_spec::PostScanActions>,

    /// Optional. The fields to include in data profile.
    ///
    /// If not specified, all fields at the time of profile scan job execution are
    /// included, except for ones listed in `exclude_fields`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub include_fields: std::option::Option<crate::model::data_profile_spec::SelectedFields>,

    /// Optional. The fields to exclude from data profile.
    ///
    /// If specified, the fields will be excluded from data profile, regardless of
    /// `include_fields` value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub exclude_fields: std::option::Option<crate::model::data_profile_spec::SelectedFields>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sampling_percent][crate::model::DataProfileSpec::sampling_percent].
    pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.sampling_percent = v.into();
        self
    }

    /// Sets the value of [row_filter][crate::model::DataProfileSpec::row_filter].
    pub fn set_row_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.row_filter = v.into();
        self
    }

    /// Sets the value of [post_scan_actions][crate::model::DataProfileSpec::post_scan_actions].
    pub fn set_post_scan_actions<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_spec::PostScanActions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_scan_actions = v.into();
        self
    }

    /// Sets the value of [include_fields][crate::model::DataProfileSpec::include_fields].
    pub fn set_include_fields<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_spec::SelectedFields>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.include_fields = v.into();
        self
    }

    /// Sets the value of [exclude_fields][crate::model::DataProfileSpec::exclude_fields].
    pub fn set_exclude_fields<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_spec::SelectedFields>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exclude_fields = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec"
    }
}

/// Defines additional types related to [DataProfileSpec].
pub mod data_profile_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of post scan actions of DataProfileScan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery_export:
            std::option::Option<crate::model::data_profile_spec::post_scan_actions::BigQueryExport>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export][crate::model::data_profile_spec::PostScanActions::bigquery_export].
        pub fn set_bigquery_export<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_profile_spec::post_scan_actions::BigQueryExport,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bigquery_export = v.into();
            self
        }
    }

    impl wkt::message::Message for PostScanActions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.PostScanActions"
        }
    }

    /// Defines additional types related to [PostScanActions].
    pub mod post_scan_actions {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration of BigQuery export post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataProfileScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            /// or
            /// projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub results_table: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [results_table][crate::model::data_profile_spec::post_scan_actions::BigQueryExport::results_table].
            pub fn set_results_table<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.results_table = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.PostScanActions.BigQueryExport"
            }
        }
    }

    /// The specification for fields to include or exclude in data profile scan.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SelectedFields {
        /// Optional. Expected input is a list of fully qualified names of fields as
        /// in the schema.
        ///
        /// Only top-level field names for nested fields are supported.
        /// For instance, if 'x' is of nested field type, listing 'x' is supported
        /// but 'x.y.z' is not supported. Here 'y' and 'y.z' are nested fields of
        /// 'x'.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub field_names: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SelectedFields {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_names][crate::model::data_profile_spec::SelectedFields::field_names].
        pub fn set_field_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.field_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SelectedFields {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileSpec.SelectedFields"
        }
    }
}

/// DataProfileResult defines the output of DataProfileScan. Each field of the
/// table will have field type specific profile result.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataProfileResult {
    /// The count of rows scanned.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_count: i64,

    /// The profile information per field.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub profile: std::option::Option<crate::model::data_profile_result::Profile>,

    /// The data scanned for this result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scanned_data: std::option::Option<crate::model::ScannedData>,

    /// Output only. The result of post scan actions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_profile_result::PostScanActionsResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataProfileResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [row_count][crate::model::DataProfileResult::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [profile][crate::model::DataProfileResult::profile].
    pub fn set_profile<
        T: std::convert::Into<std::option::Option<crate::model::data_profile_result::Profile>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.profile = v.into();
        self
    }

    /// Sets the value of [scanned_data][crate::model::DataProfileResult::scanned_data].
    pub fn set_scanned_data<
        T: std::convert::Into<std::option::Option<crate::model::ScannedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_data = v.into();
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataProfileResult::post_scan_actions_result].
    pub fn set_post_scan_actions_result<
        T: std::convert::Into<
                std::option::Option<crate::model::data_profile_result::PostScanActionsResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_scan_actions_result = v.into();
        self
    }
}

impl wkt::message::Message for DataProfileResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult"
    }
}

/// Defines additional types related to [DataProfileResult].
pub mod data_profile_result {
    #[allow(unused_imports)]
    use super::*;

    /// Contains name, type, mode and field type specific profile information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Profile {
        /// List of fields with structural and profile information for each field.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub fields: std::vec::Vec<crate::model::data_profile_result::profile::Field>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Profile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fields][crate::model::data_profile_result::Profile::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::data_profile_result::profile::Field>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Profile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile"
        }
    }

    /// Defines additional types related to [Profile].
    pub mod profile {
        #[allow(unused_imports)]
        use super::*;

        /// A field within a table.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Field {
            /// The name of the field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,

            /// The data type retrieved from the schema of the data source. For
            /// instance, for a BigQuery native table, it is the [BigQuery Table
            /// Schema](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#tablefieldschema).
            /// For a Dataplex Entity, it is the [Entity
            /// Schema](https://cloud.google.com/dataplex/docs/reference/rpc/google.cloud.dataplex.v1#type_3).
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub r#type: std::string::String,

            /// The mode of the field. Possible values include:
            ///
            /// * REQUIRED, if it is a required field.
            /// * NULLABLE, if it is an optional field.
            /// * REPEATED, if it is a repeated field.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub mode: std::string::String,

            /// Profile information for the corresponding field.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub profile:
                std::option::Option<crate::model::data_profile_result::profile::field::ProfileInfo>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Field {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::data_profile_result::profile::Field::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::data_profile_result::profile::Field::type].
            pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [mode][crate::model::data_profile_result::profile::Field::mode].
            pub fn set_mode<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.mode = v.into();
                self
            }

            /// Sets the value of [profile][crate::model::data_profile_result::profile::Field::profile].
            pub fn set_profile<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_profile_result::profile::field::ProfileInfo,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.profile = v.into();
                self
            }
        }

        impl wkt::message::Message for Field {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field"
            }
        }

        /// Defines additional types related to [Field].
        pub mod field {
            #[allow(unused_imports)]
            use super::*;

            /// The profile information for each field type.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ProfileInfo {
                /// Ratio of rows with null value against total scanned rows.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                #[serde_as(as = "wkt::internal::F64")]
                pub null_ratio: f64,

                /// Ratio of rows with distinct values against total scanned rows.
                /// Not available for complex non-groupable field type, including RECORD,
                /// ARRAY, GEOGRAPHY, and JSON, as well as fields with REPEATABLE mode.
                #[serde(skip_serializing_if = "wkt::internal::is_default")]
                #[serde_as(as = "wkt::internal::F64")]
                pub distinct_ratio: f64,

                /// The list of top N non-null values, frequency and ratio with which
                /// they occur in the scanned data. N is 10 or equal to the number of
                /// distinct values in the field, whichever is smaller. Not available for
                /// complex non-groupable field type, including RECORD, ARRAY, GEOGRAPHY,
                /// and JSON, as well as fields with REPEATABLE mode.
                #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                pub top_n_values: std::vec::Vec<
                    crate::model::data_profile_result::profile::field::profile_info::TopNValue,
                >,

                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
                pub field_info: std::option::Option<
                    crate::model::data_profile_result::profile::field::profile_info::FieldInfo,
                >,

                #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ProfileInfo {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [null_ratio][crate::model::data_profile_result::profile::field::ProfileInfo::null_ratio].
                pub fn set_null_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.null_ratio = v.into();
                    self
                }

                /// Sets the value of [distinct_ratio][crate::model::data_profile_result::profile::field::ProfileInfo::distinct_ratio].
                pub fn set_distinct_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                    self.distinct_ratio = v.into();
                    self
                }

                /// Sets the value of [top_n_values][crate::model::data_profile_result::profile::field::ProfileInfo::top_n_values].
                pub fn set_top_n_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::data_profile_result::profile::field::profile_info::TopNValue>
                {
                    use std::iter::Iterator;
                    self.top_n_values = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info].
                ///
                /// Note that all the setters affecting `field_info` are mutually
                /// exclusive.
                pub fn set_field_info<T: std::convert::Into<std::option::Option<crate::model::data_profile_result::profile::field::profile_info::FieldInfo>>>(mut self, v: T) -> Self
                {
                    self.field_info = v.into();
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `StringProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn string_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::StringProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `StringProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_string_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::StringProfile(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `IntegerProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn integer_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::IntegerProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `IntegerProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_integer_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::IntegerProfile(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// if it holds a `DoubleProfile`, `None` if the field is not set or
                /// holds a different branch.
                pub fn double_profile(&self) -> std::option::Option<&std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>>{
                    #[allow(unreachable_patterns)]
                    self.field_info.as_ref().and_then(|v| match v {
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::DoubleProfile(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [field_info][crate::model::data_profile_result::profile::field::ProfileInfo::field_info]
                /// to hold a `DoubleProfile`.
                ///
                /// Note that all the setters affecting `field_info` are
                /// mutually exclusive.
                pub fn set_double_profile<T: std::convert::Into<std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>>>(mut self, v: T) -> Self{
                    self.field_info = std::option::Option::Some(
                        crate::model::data_profile_result::profile::field::profile_info::FieldInfo::DoubleProfile(
                            v.into()
                        )
                    );
                    self
                }
            }

            impl wkt::message::Message for ProfileInfo {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo"
                }
            }

            /// Defines additional types related to [ProfileInfo].
            pub mod profile_info {
                #[allow(unused_imports)]
                use super::*;

                /// The profile information for a string type field.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct StringFieldInfo {
                    /// Minimum length of non-null values in the scanned data.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "serde_with::DisplayFromStr")]
                    pub min_length: i64,

                    /// Maximum length of non-null values in the scanned data.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "serde_with::DisplayFromStr")]
                    pub max_length: i64,

                    /// Average length of non-null values in the scanned data.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub average_length: f64,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl StringFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [min_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::min_length].
                    pub fn set_min_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.min_length = v.into();
                        self
                    }

                    /// Sets the value of [max_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::max_length].
                    pub fn set_max_length<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.max_length = v.into();
                        self
                    }

                    /// Sets the value of [average_length][crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo::average_length].
                    pub fn set_average_length<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average_length = v.into();
                        self
                    }
                }

                impl wkt::message::Message for StringFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.StringFieldInfo"
                    }
                }

                /// The profile information for an integer type field.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct IntegerFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub average: f64,

                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub standard_deviation: f64,

                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "serde_with::DisplayFromStr")]
                    pub min: i64,

                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of approximate
                    /// quartile values for the scanned data, occurring in order Q1,
                    /// median, Q3.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
                    pub quartiles: std::vec::Vec<i64>,

                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "serde_with::DisplayFromStr")]
                    pub max: i64,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl IntegerFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [average][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::average].
                    pub fn set_average<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average = v.into();
                        self
                    }

                    /// Sets the value of [standard_deviation][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::standard_deviation].
                    pub fn set_standard_deviation<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.standard_deviation = v.into();
                        self
                    }

                    /// Sets the value of [min][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::min].
                    pub fn set_min<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.min = v.into();
                        self
                    }

                    /// Sets the value of [quartiles][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::quartiles].
                    pub fn set_quartiles<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<i64>,
                    {
                        use std::iter::Iterator;
                        self.quartiles = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [max][crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo::max].
                    pub fn set_max<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.max = v.into();
                        self
                    }
                }

                impl wkt::message::Message for IntegerFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.IntegerFieldInfo"
                    }
                }

                /// The profile information for a double type field.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct DoubleFieldInfo {
                    /// Average of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub average: f64,

                    /// Standard deviation of non-null values in the scanned data. NaN, if
                    /// the field has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub standard_deviation: f64,

                    /// Minimum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub min: f64,

                    /// A quartile divides the number of data points into four parts, or
                    /// quarters, of more-or-less equal size. Three main quartiles used
                    /// are: The first quartile (Q1) splits off the lowest 25% of data from
                    /// the highest 75%. It is also known as the lower or 25th empirical
                    /// quartile, as 25% of the data is below this point. The second
                    /// quartile (Q2) is the median of a data set. So, 50% of the data lies
                    /// below this point. The third quartile (Q3) splits off the highest
                    /// 25% of data from the lowest 75%. It is known as the upper or 75th
                    /// empirical quartile, as 75% of the data lies below this point.
                    /// Here, the quartiles is provided as an ordered list of quartile
                    /// values for the scanned data, occurring in order Q1, median, Q3.
                    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
                    #[serde_as(as = "std::vec::Vec<wkt::internal::F64>")]
                    pub quartiles: std::vec::Vec<f64>,

                    /// Maximum of non-null values in the scanned data. NaN, if the field
                    /// has a NaN.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub max: f64,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl DoubleFieldInfo {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [average][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::average].
                    pub fn set_average<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.average = v.into();
                        self
                    }

                    /// Sets the value of [standard_deviation][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::standard_deviation].
                    pub fn set_standard_deviation<T: std::convert::Into<f64>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.standard_deviation = v.into();
                        self
                    }

                    /// Sets the value of [min][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::min].
                    pub fn set_min<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.min = v.into();
                        self
                    }

                    /// Sets the value of [quartiles][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::quartiles].
                    pub fn set_quartiles<T, V>(mut self, v: T) -> Self
                    where
                        T: std::iter::IntoIterator<Item = V>,
                        V: std::convert::Into<f64>,
                    {
                        use std::iter::Iterator;
                        self.quartiles = v.into_iter().map(|i| i.into()).collect();
                        self
                    }

                    /// Sets the value of [max][crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo::max].
                    pub fn set_max<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.max = v.into();
                        self
                    }
                }

                impl wkt::message::Message for DoubleFieldInfo {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.DoubleFieldInfo"
                    }
                }

                /// Top N non-null values in the scanned data.
                #[serde_with::serde_as]
                #[derive(
                    Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize,
                )]
                #[serde(default, rename_all = "camelCase")]
                #[non_exhaustive]
                pub struct TopNValue {
                    /// String value of a top N non-null value.
                    #[serde(skip_serializing_if = "std::string::String::is_empty")]
                    pub value: std::string::String,

                    /// Count of the corresponding value in the scanned data.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "serde_with::DisplayFromStr")]
                    pub count: i64,

                    /// Ratio of the corresponding value in the field against the total
                    /// number of rows in the scanned data.
                    #[serde(skip_serializing_if = "wkt::internal::is_default")]
                    #[serde_as(as = "wkt::internal::F64")]
                    pub ratio: f64,

                    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                impl TopNValue {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [value][crate::model::data_profile_result::profile::field::profile_info::TopNValue::value].
                    pub fn set_value<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.value = v.into();
                        self
                    }

                    /// Sets the value of [count][crate::model::data_profile_result::profile::field::profile_info::TopNValue::count].
                    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                        self.count = v.into();
                        self
                    }

                    /// Sets the value of [ratio][crate::model::data_profile_result::profile::field::profile_info::TopNValue::ratio].
                    pub fn set_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                        self.ratio = v.into();
                        self
                    }
                }

                impl wkt::message::Message for TopNValue {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.Profile.Field.ProfileInfo.TopNValue"
                    }
                }

                /// Structural and profile information for specific field type. Not
                /// available, if mode is REPEATABLE.
                #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
                #[serde(rename_all = "camelCase")]
                #[non_exhaustive]
                pub enum FieldInfo {
                    /// String type field information.
                    StringProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::StringFieldInfo>),
                    /// Integer type field information.
                    IntegerProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::IntegerFieldInfo>),
                    /// Double type field information.
                    DoubleProfile(std::boxed::Box<crate::model::data_profile_result::profile::field::profile_info::DoubleFieldInfo>),
                }
            }
        }
    }

    /// The result of post scan actions of DataProfileScan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery_export_result: std::option::Option<
            crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_profile_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T: std::convert::Into<std::option::Option<crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult>>>(mut self, v: T) -> Self{
            self.bigquery_export_result = v.into();
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult"
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Output only. Execution state for the BigQuery exporting.
            pub state: crate::model::data_profile_result::post_scan_actions_result::big_query_export_result::State,

            /// Output only. Additional information about the BigQuery exporting.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub message: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_profile_result::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_profile_result::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult.BigQueryExportResult"
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataProfileResult.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }
}

/// DataQualityScan related setting.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualitySpec {
    /// Required. The list of rules to evaluate against a data source. At least one
    /// rule is required.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::DataQualityRule>,

    /// Optional. The percentage of the records to be selected from the dataset for
    /// DataScan.
    ///
    /// * Value can range between 0.0 and 100.0 with up to 3 significant decimal
    ///   digits.
    /// * Sampling is not applied if `sampling_percent` is not specified, 0 or
    ///
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub sampling_percent: f32,

    /// Optional. A filter applied to all rows in a single DataScan job.
    /// The filter needs to be a valid SQL expression for a [WHERE clause in
    /// GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#where_clause).
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub row_filter: std::string::String,

    /// Optional. Actions to take upon job completion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_scan_actions: std::option::Option<crate::model::data_quality_spec::PostScanActions>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualitySpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rules][crate::model::DataQualitySpec::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sampling_percent][crate::model::DataQualitySpec::sampling_percent].
    pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.sampling_percent = v.into();
        self
    }

    /// Sets the value of [row_filter][crate::model::DataQualitySpec::row_filter].
    pub fn set_row_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.row_filter = v.into();
        self
    }

    /// Sets the value of [post_scan_actions][crate::model::DataQualitySpec::post_scan_actions].
    pub fn set_post_scan_actions<
        T: std::convert::Into<std::option::Option<crate::model::data_quality_spec::PostScanActions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_scan_actions = v.into();
        self
    }
}

impl wkt::message::Message for DataQualitySpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec"
    }
}

/// Defines additional types related to [DataQualitySpec].
pub mod data_quality_spec {
    #[allow(unused_imports)]
    use super::*;

    /// The configuration of post scan actions of DataQualityScan.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostScanActions {
        /// Optional. If set, results will be exported to the provided BigQuery
        /// table.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery_export:
            std::option::Option<crate::model::data_quality_spec::post_scan_actions::BigQueryExport>,

        /// Optional. If set, results will be sent to the provided notification
        /// receipts upon triggers.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub notification_report: std::option::Option<
            crate::model::data_quality_spec::post_scan_actions::NotificationReport,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export][crate::model::data_quality_spec::PostScanActions::bigquery_export].
        pub fn set_bigquery_export<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_quality_spec::post_scan_actions::BigQueryExport,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bigquery_export = v.into();
            self
        }

        /// Sets the value of [notification_report][crate::model::data_quality_spec::PostScanActions::notification_report].
        pub fn set_notification_report<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::data_quality_spec::post_scan_actions::NotificationReport,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.notification_report = v.into();
            self
        }
    }

    impl wkt::message::Message for PostScanActions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions"
        }
    }

    /// Defines additional types related to [PostScanActions].
    pub mod post_scan_actions {
        #[allow(unused_imports)]
        use super::*;

        /// The configuration of BigQuery export post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BigQueryExport {
            /// Optional. The BigQuery table to export DataQualityScan results to.
            /// Format:
            /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            /// or
            /// projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub results_table: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [results_table][crate::model::data_quality_spec::post_scan_actions::BigQueryExport::results_table].
            pub fn set_results_table<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.results_table = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.BigQueryExport"
            }
        }

        /// The individuals or groups who are designated to receive notifications
        /// upon triggers.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Recipients {
            /// Optional. The email recipients who will receive the DataQualityScan
            /// results report.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub emails: std::vec::Vec<std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Recipients {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [emails][crate::model::data_quality_spec::post_scan_actions::Recipients::emails].
            pub fn set_emails<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.emails = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for Recipients {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.Recipients"
            }
        }

        /// This trigger is triggered when the DQ score in the job result is less
        /// than a specified input score.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ScoreThresholdTrigger {
            /// Optional. The score range is in [0,100].
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "wkt::internal::F32")]
            pub score_threshold: f32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ScoreThresholdTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [score_threshold][crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger::score_threshold].
            pub fn set_score_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.score_threshold = v.into();
                self
            }
        }

        impl wkt::message::Message for ScoreThresholdTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.ScoreThresholdTrigger"
            }
        }

        /// This trigger is triggered when the scan job itself fails, regardless of
        /// the result.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JobFailureTrigger {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JobFailureTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JobFailureTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.JobFailureTrigger"
            }
        }

        /// This trigger is triggered whenever a scan job run ends, regardless
        /// of the result.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JobEndTrigger {
            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JobEndTrigger {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for JobEndTrigger {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.JobEndTrigger"
            }
        }

        /// The configuration of notification report post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct NotificationReport {
            /// Required. The recipients who will receive the notification report.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub recipients:
                std::option::Option<crate::model::data_quality_spec::post_scan_actions::Recipients>,

            /// Optional. If set, report will be sent when score threshold is met.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub score_threshold_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger,
            >,

            /// Optional. If set, report will be sent when a scan job fails.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub job_failure_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger,
            >,

            /// Optional. If set, report will be sent when a scan job ends.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub job_end_trigger: std::option::Option<
                crate::model::data_quality_spec::post_scan_actions::JobEndTrigger,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NotificationReport {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [recipients][crate::model::data_quality_spec::post_scan_actions::NotificationReport::recipients].
            pub fn set_recipients<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_quality_spec::post_scan_actions::Recipients,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.recipients = v.into();
                self
            }

            /// Sets the value of [score_threshold_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::score_threshold_trigger].
            pub fn set_score_threshold_trigger<T: std::convert::Into<std::option::Option<crate::model::data_quality_spec::post_scan_actions::ScoreThresholdTrigger>>>(mut self, v: T) -> Self{
                self.score_threshold_trigger = v.into();
                self
            }

            /// Sets the value of [job_failure_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_failure_trigger].
            pub fn set_job_failure_trigger<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_quality_spec::post_scan_actions::JobFailureTrigger,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.job_failure_trigger = v.into();
                self
            }

            /// Sets the value of [job_end_trigger][crate::model::data_quality_spec::post_scan_actions::NotificationReport::job_end_trigger].
            pub fn set_job_end_trigger<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::data_quality_spec::post_scan_actions::JobEndTrigger,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.job_end_trigger = v.into();
                self
            }
        }

        impl wkt::message::Message for NotificationReport {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualitySpec.PostScanActions.NotificationReport"
            }
        }
    }
}

/// The output of a DataQualityScan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityResult {
    /// Output only. Overall data quality result -- `true` if all rules passed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub passed: bool,

    /// Output only. The overall data quality score.
    ///
    /// The score ranges between [0, 100] (up to two decimal points).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub score: std::option::Option<f32>,

    /// Output only. A list of results at the dimension level.
    ///
    /// A dimension will have a corresponding `DataQualityDimensionResult` if and
    /// only if there is at least one rule with the 'dimension' field set to it.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub dimensions: std::vec::Vec<crate::model::DataQualityDimensionResult>,

    /// Output only. A list of results at the column level.
    ///
    /// A column will have a corresponding `DataQualityColumnResult` if and only if
    /// there is at least one rule with the 'column' field set to it.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub columns: std::vec::Vec<crate::model::DataQualityColumnResult>,

    /// Output only. A list of all the rules in a job, and their results.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rules: std::vec::Vec<crate::model::DataQualityRuleResult>,

    /// Output only. The count of rows processed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub row_count: i64,

    /// Output only. The data scanned for this result.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scanned_data: std::option::Option<crate::model::ScannedData>,

    /// Output only. The result of post scan actions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_quality_result::PostScanActionsResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [passed][crate::model::DataQualityResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::DataQualityResult::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityDimensionResult>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [columns][crate::model::DataQualityResult::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityColumnResult>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rules][crate::model::DataQualityResult::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRuleResult>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [row_count][crate::model::DataQualityResult::row_count].
    pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.row_count = v.into();
        self
    }

    /// Sets the value of [scanned_data][crate::model::DataQualityResult::scanned_data].
    pub fn set_scanned_data<
        T: std::convert::Into<std::option::Option<crate::model::ScannedData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scanned_data = v.into();
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataQualityResult::post_scan_actions_result].
    pub fn set_post_scan_actions_result<
        T: std::convert::Into<
                std::option::Option<crate::model::data_quality_result::PostScanActionsResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_scan_actions_result = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult"
    }
}

/// Defines additional types related to [DataQualityResult].
pub mod data_quality_result {
    #[allow(unused_imports)]
    use super::*;

    /// The result of post scan actions of DataQualityScan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// Output only. The result of BigQuery export post scan action.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery_export_result: std::option::Option<
            crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_quality_result::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T: std::convert::Into<std::option::Option<crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult>>>(mut self, v: T) -> Self{
            self.bigquery_export_result = v.into();
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult"
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Output only. Execution state for the BigQuery exporting.
            pub state: crate::model::data_quality_result::post_scan_actions_result::big_query_export_result::State,

            /// Output only. Additional information about the BigQuery exporting.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub message: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_quality_result::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_quality_result::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult.BigQueryExportResult"
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataQualityResult.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }
}

/// DataQualityRuleResult provides a more detailed, per-rule view of the results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityRuleResult {
    /// Output only. The rule specified in the DataQualitySpec, as is.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::DataQualityRule>,

    /// Output only. Whether the rule passed or failed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub passed: bool,

    /// Output only. The number of rows a rule was evaluated against.
    ///
    /// This field is only valid for row-level type rules.
    ///
    /// Evaluated count can be configured to either
    ///
    /// * include all rows (default) - with `null` rows automatically failing rule
    ///   evaluation, or
    /// * exclude `null` rows from the `evaluated_count`, by setting
    ///   `ignore_nulls = true`.
    ///
    /// This field is not set for rule SqlAssertion.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub evaluated_count: i64,

    /// Output only. The number of rows which passed a rule evaluation.
    ///
    /// This field is only valid for row-level type rules.
    ///
    /// This field is not set for rule SqlAssertion.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub passed_count: i64,

    /// Output only. The number of rows with null values in the specified column.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub null_count: i64,

    /// Output only. The ratio of **passed_count / evaluated_count**.
    ///
    /// This field is only valid for row-level type rules.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub pass_ratio: f64,

    /// Output only. The query to find rows that did not pass this rule.
    ///
    /// This field is only valid for row-level type rules.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub failing_rows_query: std::string::String,

    /// Output only. The number of rows returned by the SQL statement in a SQL
    /// assertion rule.
    ///
    /// This field is only valid for SQL assertion rules.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub assertion_row_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityRuleResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::DataQualityRuleResult::rule].
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::DataQualityRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// Sets the value of [passed][crate::model::DataQualityRuleResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [evaluated_count][crate::model::DataQualityRuleResult::evaluated_count].
    pub fn set_evaluated_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.evaluated_count = v.into();
        self
    }

    /// Sets the value of [passed_count][crate::model::DataQualityRuleResult::passed_count].
    pub fn set_passed_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_count = v.into();
        self
    }

    /// Sets the value of [null_count][crate::model::DataQualityRuleResult::null_count].
    pub fn set_null_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.null_count = v.into();
        self
    }

    /// Sets the value of [pass_ratio][crate::model::DataQualityRuleResult::pass_ratio].
    pub fn set_pass_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pass_ratio = v.into();
        self
    }

    /// Sets the value of [failing_rows_query][crate::model::DataQualityRuleResult::failing_rows_query].
    pub fn set_failing_rows_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.failing_rows_query = v.into();
        self
    }

    /// Sets the value of [assertion_row_count][crate::model::DataQualityRuleResult::assertion_row_count].
    pub fn set_assertion_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.assertion_row_count = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityRuleResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRuleResult"
    }
}

/// DataQualityDimensionResult provides a more detailed, per-dimension view of
/// the results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityDimensionResult {
    /// Output only. The dimension config specified in the DataQualitySpec, as is.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dimension: std::option::Option<crate::model::DataQualityDimension>,

    /// Output only. Whether the dimension passed or failed.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub passed: bool,

    /// Output only. The dimension-level data quality score for this data scan job
    /// if and only if the 'dimension' field is set.
    ///
    /// The score ranges between [0, 100] (up to two decimal
    /// points).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityDimensionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimension][crate::model::DataQualityDimensionResult::dimension].
    pub fn set_dimension<
        T: std::convert::Into<std::option::Option<crate::model::DataQualityDimension>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dimension = v.into();
        self
    }

    /// Sets the value of [passed][crate::model::DataQualityDimensionResult::passed].
    pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.passed = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityDimensionResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityDimensionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityDimensionResult"
    }
}

/// A dimension captures data quality intent about a defined subset of the rules
/// specified.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityDimension {
    /// Optional. The dimension name a rule belongs to. Custom dimension name is
    /// supported with all uppercase letters and maximum length of 30 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityDimension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataQualityDimension::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityDimension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityDimension"
    }
}

/// A rule captures data quality intent about a data source.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityRule {
    /// Optional. The unnested column which this rule is evaluated against.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// Optional. Rows with `null` values will automatically fail a rule, unless
    /// `ignore_null` is `true`. In that case, such `null` rows are trivially
    /// considered passing.
    ///
    /// This field is only valid for the following type of rules:
    ///
    /// * RangeExpectation
    /// * RegexExpectation
    /// * SetExpectation
    /// * UniquenessExpectation
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ignore_null: bool,

    /// Required. The dimension a rule belongs to. Results are also aggregated at
    /// the dimension level. Supported dimensions are **["COMPLETENESS",
    /// "ACCURACY", "CONSISTENCY", "VALIDITY", "UNIQUENESS", "FRESHNESS",
    /// "VOLUME"]**
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dimension: std::string::String,

    /// Optional. The minimum ratio of **passing_rows / total_rows** required to
    /// pass this rule, with a range of [0.0, 1.0].
    ///
    /// 0 indicates default value (i.e. 1.0).
    ///
    /// This field is only valid for row-level type rules.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub threshold: f64,

    /// Optional. A mutable name for the rule.
    ///
    /// * The name must contain only letters (a-z, A-Z), numbers (0-9), or
    ///   hyphens (-).
    /// * The maximum length is 63 characters.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Description of the rule.
    ///
    /// * The maximum length is 1,024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Whether the Rule is active or suspended.
    /// Default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub suspended: bool,

    /// The rule-specific configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rule_type: std::option::Option<crate::model::data_quality_rule::RuleType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::DataQualityRule::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [ignore_null][crate::model::DataQualityRule::ignore_null].
    pub fn set_ignore_null<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_null = v.into();
        self
    }

    /// Sets the value of [dimension][crate::model::DataQualityRule::dimension].
    pub fn set_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dimension = v.into();
        self
    }

    /// Sets the value of [threshold][crate::model::DataQualityRule::threshold].
    pub fn set_threshold<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DataQualityRule::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataQualityRule::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [suspended][crate::model::DataQualityRule::suspended].
    pub fn set_suspended<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.suspended = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type].
    ///
    /// Note that all the setters affecting `rule_type` are mutually
    /// exclusive.
    pub fn set_rule_type<
        T: std::convert::Into<std::option::Option<crate::model::data_quality_rule::RuleType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = v.into();
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RangeExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn range_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RangeExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RangeExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_range_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RangeExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `NonNullExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn non_null_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::NonNullExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `NonNullExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_non_null_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::NonNullExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `SetExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn set_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::SetExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::SetExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `SetExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_set_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::SetExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::SetExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RegexExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RegexExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RegexExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_regex_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RegexExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `UniquenessExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn uniqueness_expectation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>>
    {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::UniquenessExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `UniquenessExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_uniqueness_expectation<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::UniquenessExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `StatisticRangeExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn statistic_range_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::StatisticRangeExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `StatisticRangeExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_statistic_range_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::StatisticRangeExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `RowConditionExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn row_condition_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::RowConditionExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `RowConditionExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_row_condition_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::RowConditionExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `TableConditionExpectation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table_condition_expectation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
    > {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::TableConditionExpectation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `TableConditionExpectation`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_table_condition_expectation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::TableConditionExpectation(v.into()),
        );
        self
    }

    /// The value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// if it holds a `SqlAssertion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn sql_assertion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>> {
        #[allow(unreachable_patterns)]
        self.rule_type.as_ref().and_then(|v| match v {
            crate::model::data_quality_rule::RuleType::SqlAssertion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule_type][crate::model::DataQualityRule::rule_type]
    /// to hold a `SqlAssertion`.
    ///
    /// Note that all the setters affecting `rule_type` are
    /// mutually exclusive.
    pub fn set_sql_assertion<
        T: std::convert::Into<std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = std::option::Option::Some(
            crate::model::data_quality_rule::RuleType::SqlAssertion(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataQualityRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule"
    }
}

/// Defines additional types related to [DataQualityRule].
pub mod data_quality_rule {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluates whether each column value lies between a specified range.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RangeExpectation {
        /// Optional. The minimum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub min_value: std::string::String,

        /// Optional. The maximum column value allowed for a row to pass this
        /// validation. At least one of `min_value` and `max_value` need to be
        /// provided.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub max_value: std::string::String,

        /// Optional. Whether each value needs to be strictly greater than ('>') the
        /// minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub strict_min_enabled: bool,

        /// Optional. Whether each value needs to be strictly lesser than ('<') the
        /// maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub strict_max_enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RangeExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_value][crate::model::data_quality_rule::RangeExpectation::min_value].
        pub fn set_min_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::data_quality_rule::RangeExpectation::max_value].
        pub fn set_max_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [strict_min_enabled][crate::model::data_quality_rule::RangeExpectation::strict_min_enabled].
        pub fn set_strict_min_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_min_enabled = v.into();
            self
        }

        /// Sets the value of [strict_max_enabled][crate::model::data_quality_rule::RangeExpectation::strict_max_enabled].
        pub fn set_strict_max_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_max_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for RangeExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RangeExpectation"
        }
    }

    /// Evaluates whether each column value is null.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NonNullExpectation {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NonNullExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for NonNullExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation"
        }
    }

    /// Evaluates whether each column value is contained by a specified set.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SetExpectation {
        /// Optional. Expected values for the column value.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub values: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SetExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [values][crate::model::data_quality_rule::SetExpectation::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SetExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.SetExpectation"
        }
    }

    /// Evaluates whether each column value matches a specified regex.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RegexExpectation {
        /// Optional. A regular expression the column value is expected to match.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub regex: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RegexExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [regex][crate::model::data_quality_rule::RegexExpectation::regex].
        pub fn set_regex<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.regex = v.into();
            self
        }
    }

    impl wkt::message::Message for RegexExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RegexExpectation"
        }
    }

    /// Evaluates whether the column has duplicates.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UniquenessExpectation {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UniquenessExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for UniquenessExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation"
        }
    }

    /// Evaluates whether the column aggregate statistic lies between a specified
    /// range.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StatisticRangeExpectation {
        /// Optional. The aggregate metric to evaluate.
        pub statistic:
            crate::model::data_quality_rule::statistic_range_expectation::ColumnStatistic,

        /// Optional. The minimum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub min_value: std::string::String,

        /// Optional. The maximum column statistic value allowed for a row to pass
        /// this validation.
        ///
        /// At least one of `min_value` and `max_value` need to be provided.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub max_value: std::string::String,

        /// Optional. Whether column statistic needs to be strictly greater than
        /// ('>') the minimum, or if equality is allowed.
        ///
        /// Only relevant if a `min_value` has been defined. Default = false.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub strict_min_enabled: bool,

        /// Optional. Whether column statistic needs to be strictly lesser than ('<')
        /// the maximum, or if equality is allowed.
        ///
        /// Only relevant if a `max_value` has been defined. Default = false.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub strict_max_enabled: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StatisticRangeExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [statistic][crate::model::data_quality_rule::StatisticRangeExpectation::statistic].
        pub fn set_statistic<
            T: std::convert::Into<
                    crate::model::data_quality_rule::statistic_range_expectation::ColumnStatistic,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.statistic = v.into();
            self
        }

        /// Sets the value of [min_value][crate::model::data_quality_rule::StatisticRangeExpectation::min_value].
        pub fn set_min_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.min_value = v.into();
            self
        }

        /// Sets the value of [max_value][crate::model::data_quality_rule::StatisticRangeExpectation::max_value].
        pub fn set_max_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.max_value = v.into();
            self
        }

        /// Sets the value of [strict_min_enabled][crate::model::data_quality_rule::StatisticRangeExpectation::strict_min_enabled].
        pub fn set_strict_min_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_min_enabled = v.into();
            self
        }

        /// Sets the value of [strict_max_enabled][crate::model::data_quality_rule::StatisticRangeExpectation::strict_max_enabled].
        pub fn set_strict_max_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.strict_max_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for StatisticRangeExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation"
        }
    }

    /// Defines additional types related to [StatisticRangeExpectation].
    pub mod statistic_range_expectation {
        #[allow(unused_imports)]
        use super::*;

        /// The list of aggregate metrics a rule can be evaluated against.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ColumnStatistic {
            /// Unspecified statistic type
            StatisticUndefined,
            /// Evaluate the column mean
            Mean,
            /// Evaluate the column min
            Min,
            /// Evaluate the column max
            Max,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ColumnStatistic::value] or
            /// [ColumnStatistic::name].
            UnknownValue(column_statistic::UnknownValue),
        }

        #[doc(hidden)]
        pub mod column_statistic {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ColumnStatistic {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::StatisticUndefined => std::option::Option::Some(0),
                    Self::Mean => std::option::Option::Some(1),
                    Self::Min => std::option::Option::Some(2),
                    Self::Max => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::StatisticUndefined => std::option::Option::Some("STATISTIC_UNDEFINED"),
                    Self::Mean => std::option::Option::Some("MEAN"),
                    Self::Min => std::option::Option::Some("MIN"),
                    Self::Max => std::option::Option::Some("MAX"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ColumnStatistic {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ColumnStatistic {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ColumnStatistic {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::StatisticUndefined,
                    1 => Self::Mean,
                    2 => Self::Min,
                    3 => Self::Max,
                    _ => Self::UnknownValue(column_statistic::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ColumnStatistic {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATISTIC_UNDEFINED" => Self::StatisticUndefined,
                    "MEAN" => Self::Mean,
                    "MIN" => Self::Min,
                    "MAX" => Self::Max,
                    _ => Self::UnknownValue(column_statistic::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ColumnStatistic {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::StatisticUndefined => serializer.serialize_i32(0),
                    Self::Mean => serializer.serialize_i32(1),
                    Self::Min => serializer.serialize_i32(2),
                    Self::Max => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ColumnStatistic {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ColumnStatistic>::new(
                    ".google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation.ColumnStatistic"))
            }
        }
    }

    /// Evaluates whether each row passes the specified condition.
    ///
    /// The SQL expression needs to use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)
    /// and should produce a boolean value per row as the result.
    ///
    /// Example: col1 >= 0 AND col2 < 10
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RowConditionExpectation {
        /// Optional. The SQL expression.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sql_expression: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RowConditionExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_expression][crate::model::data_quality_rule::RowConditionExpectation::sql_expression].
        pub fn set_sql_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_expression = v.into();
            self
        }
    }

    impl wkt::message::Message for RowConditionExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation"
        }
    }

    /// Evaluates whether the provided expression is true.
    ///
    /// The SQL expression needs to use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax)
    /// and should produce a scalar boolean result.
    ///
    /// Example: MIN(col1) >= 0
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TableConditionExpectation {
        /// Optional. The SQL expression.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sql_expression: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableConditionExpectation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_expression][crate::model::data_quality_rule::TableConditionExpectation::sql_expression].
        pub fn set_sql_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_expression = v.into();
            self
        }
    }

    impl wkt::message::Message for TableConditionExpectation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation"
        }
    }

    /// A SQL statement that is evaluated to return rows that match an invalid
    /// state. If any rows are are returned, this rule fails.
    ///
    /// The SQL statement must use [GoogleSQL
    /// syntax](https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax),
    /// and must not contain any semicolons.
    ///
    /// You can use the data reference parameter `${data()}` to reference the
    /// source table with all of its precondition filters applied. Examples of
    /// precondition filters include row filters, incremental data filters, and
    /// sampling. For more information, see [Data reference
    /// parameter](https://cloud.google.com/dataplex/docs/auto-data-quality-overview#data-reference-parameter).
    ///
    /// Example: `SELECT * FROM ${data()} WHERE price < 0`
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SqlAssertion {
        /// Optional. The SQL statement.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub sql_statement: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SqlAssertion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_statement][crate::model::data_quality_rule::SqlAssertion::sql_statement].
        pub fn set_sql_statement<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.sql_statement = v.into();
            self
        }
    }

    impl wkt::message::Message for SqlAssertion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataQualityRule.SqlAssertion"
        }
    }

    /// The rule-specific configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RuleType {
        /// Row-level rule which evaluates whether each column value lies between a
        /// specified range.
        RangeExpectation(std::boxed::Box<crate::model::data_quality_rule::RangeExpectation>),
        /// Row-level rule which evaluates whether each column value is null.
        NonNullExpectation(std::boxed::Box<crate::model::data_quality_rule::NonNullExpectation>),
        /// Row-level rule which evaluates whether each column value is contained by
        /// a specified set.
        SetExpectation(std::boxed::Box<crate::model::data_quality_rule::SetExpectation>),
        /// Row-level rule which evaluates whether each column value matches a
        /// specified regex.
        RegexExpectation(std::boxed::Box<crate::model::data_quality_rule::RegexExpectation>),
        /// Row-level rule which evaluates whether each column value is unique.
        UniquenessExpectation(
            std::boxed::Box<crate::model::data_quality_rule::UniquenessExpectation>,
        ),
        /// Aggregate rule which evaluates whether the column aggregate
        /// statistic lies between a specified range.
        StatisticRangeExpectation(
            std::boxed::Box<crate::model::data_quality_rule::StatisticRangeExpectation>,
        ),
        /// Row-level rule which evaluates whether each row in a table passes the
        /// specified condition.
        RowConditionExpectation(
            std::boxed::Box<crate::model::data_quality_rule::RowConditionExpectation>,
        ),
        /// Aggregate rule which evaluates whether the provided expression is true
        /// for a table.
        TableConditionExpectation(
            std::boxed::Box<crate::model::data_quality_rule::TableConditionExpectation>,
        ),
        /// Aggregate rule which evaluates the number of rows returned for the
        /// provided statement. If any rows are returned, this rule fails.
        SqlAssertion(std::boxed::Box<crate::model::data_quality_rule::SqlAssertion>),
    }
}

/// DataQualityColumnResult provides a more detailed, per-column view of
/// the results.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityColumnResult {
    /// Output only. The column specified in the DataQualityRule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// Output only. The column-level data quality score for this data scan job if
    /// and only if the 'column' field is set.
    ///
    /// The score ranges between between [0, 100] (up to two decimal
    /// points).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F32>")]
    pub score: std::option::Option<f32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityColumnResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [column][crate::model::DataQualityColumnResult::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [score][crate::model::DataQualityColumnResult::score].
    pub fn set_score<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityColumnResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityColumnResult"
    }
}

/// DataTaxonomy represents a set of hierarchical DataAttributes resources,
/// grouped with a common theme Eg: 'SensitiveDataTaxonomy' can have attributes
/// to manage PII data. It is defined at project level.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct DataTaxonomy {
    /// Output only. The relative resource name of the DataTaxonomy, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the dataTaxonomy. This
    /// ID will be different if the DataTaxonomy is deleted and re-created with the
    /// same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the DataTaxonomy was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataTaxonomy was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataTaxonomy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataTaxonomy.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The number of attributes in the DataTaxonomy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attribute_count: i32,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. The number of classes in the DataTaxonomy.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub class_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataTaxonomy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataTaxonomy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataTaxonomy::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataTaxonomy::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataTaxonomy::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataTaxonomy::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataTaxonomy::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataTaxonomy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attribute_count][crate::model::DataTaxonomy::attribute_count].
    pub fn set_attribute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.attribute_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataTaxonomy::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [class_count][crate::model::DataTaxonomy::class_count].
    pub fn set_class_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.class_count = v.into();
        self
    }
}

impl wkt::message::Message for DataTaxonomy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataTaxonomy"
    }
}

/// Denotes one dataAttribute in a dataTaxonomy, for example, PII.
/// DataAttribute resources can be defined in a hierarchy.
/// A single dataAttribute resource can contain specs of multiple types
///
/// ```norust
/// PII
///   - ResourceAccessSpec :
///                 - readers :foo@bar.com
///   - DataAccessSpec :
///                 - readers :bar@foo.com
/// ```
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct DataAttribute {
    /// Output only. The relative resource name of the dataAttribute, of the form:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the DataAttribute.
    /// This ID will be different if the DataAttribute is deleted and re-created
    /// with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the DataAttribute was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataAttribute was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataAttribute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataAttribute.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The ID of the parent DataAttribute resource, should belong to the
    /// same data taxonomy. Circular dependency in parent chain is not valid.
    /// Maximum depth of the hierarchy allowed is 4.
    /// [a -> b -> c -> d -> e, depth = 4]
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent_id: std::string::String,

    /// Output only. The number of child attributes present for this attribute.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub attribute_count: i32,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Specified when applied to a resource (eg: Cloud Storage bucket,
    /// BigQuery dataset, BigQuery table).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_access_spec: std::option::Option<crate::model::ResourceAccessSpec>,

    /// Optional. Specified when applied to data stored on the resource (eg: rows,
    /// columns in BigQuery Tables).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_access_spec: std::option::Option<crate::model::DataAccessSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataAttribute::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataAttribute::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataAttribute::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataAttribute::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataAttribute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataAttribute::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataAttribute::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [parent_id][crate::model::DataAttribute::parent_id].
    pub fn set_parent_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent_id = v.into();
        self
    }

    /// Sets the value of [attribute_count][crate::model::DataAttribute::attribute_count].
    pub fn set_attribute_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.attribute_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DataAttribute::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [resource_access_spec][crate::model::DataAttribute::resource_access_spec].
    pub fn set_resource_access_spec<
        T: std::convert::Into<std::option::Option<crate::model::ResourceAccessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_access_spec = v.into();
        self
    }

    /// Sets the value of [data_access_spec][crate::model::DataAttribute::data_access_spec].
    pub fn set_data_access_spec<
        T: std::convert::Into<std::option::Option<crate::model::DataAccessSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_access_spec = v.into();
        self
    }
}

impl wkt::message::Message for DataAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAttribute"
    }
}

/// DataAttributeBinding represents binding of attributes to resources. Eg: Bind
/// 'CustomerInfo' entity with 'PII' attribute.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct DataAttributeBinding {
    /// Output only. The relative resource name of the Data Attribute Binding, of
    /// the form:
    /// projects/{project_number}/locations/{location}/dataAttributeBindings/{data_attribute_binding_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the
    /// DataAttributeBinding. This ID will be different if the DataAttributeBinding
    /// is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the DataAttributeBinding was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataAttributeBinding was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the DataAttributeBinding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the DataAttributeBinding.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// This checksum is computed by the server based on the value of other
    /// fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    /// Etags must be used when calling the DeleteDataAttributeBinding and the
    /// UpdateDataAttributeBinding method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. List of attributes to be associated with the resource, provided
    /// in the form:
    /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attributes: std::vec::Vec<std::string::String>,

    /// Optional. The list of paths for items within the associated resource (eg.
    /// columns and partitions within a table) along with attribute bindings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub paths: std::vec::Vec<crate::model::data_attribute_binding::Path>,

    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub resource_reference:
        std::option::Option<crate::model::data_attribute_binding::ResourceReference>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAttributeBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataAttributeBinding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataAttributeBinding::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataAttributeBinding::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataAttributeBinding::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataAttributeBinding::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataAttributeBinding::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataAttributeBinding::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::DataAttributeBinding::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::DataAttributeBinding::attributes].
    pub fn set_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paths][crate::model::DataAttributeBinding::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::data_attribute_binding::Path>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_reference][crate::model::DataAttributeBinding::resource_reference].
    ///
    /// Note that all the setters affecting `resource_reference` are mutually
    /// exclusive.
    pub fn set_resource_reference<
        T: std::convert::Into<
                std::option::Option<crate::model::data_attribute_binding::ResourceReference>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_reference = v.into();
        self
    }

    /// The value of [resource_reference][crate::model::DataAttributeBinding::resource_reference]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.resource_reference.as_ref().and_then(|v| match v {
            crate::model::data_attribute_binding::ResourceReference::Resource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [resource_reference][crate::model::DataAttributeBinding::resource_reference]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `resource_reference` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_reference = std::option::Option::Some(
            crate::model::data_attribute_binding::ResourceReference::Resource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataAttributeBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAttributeBinding"
    }
}

/// Defines additional types related to [DataAttributeBinding].
pub mod data_attribute_binding {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a subresource of the given resource, and associated bindings
    /// with it. Currently supported subresources are column and partition schema
    /// fields within a table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Path {
        /// Required. The name identifier of the path.
        /// Nested columns should be of the form: 'address.city'.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. List of attributes to be associated with the path of the
        /// resource, provided in the form:
        /// projects/{project}/locations/{location}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub attributes: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Path {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::data_attribute_binding::Path::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [attributes][crate::model::data_attribute_binding::Path::attributes].
        pub fn set_attributes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.attributes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Path {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataAttributeBinding.Path"
        }
    }

    /// The reference to the resource that is associated to attributes, or
    /// the query to match resources and associate attributes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ResourceReference {
        /// Optional. Immutable. The resource name of the resource that is associated
        /// to attributes. Presently, only entity resource is supported in the form:
        /// projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/entities/{entity_id}
        /// Must belong in the same project and region as the attribute binding, and
        /// there can only exist one active binding for a resource.
        Resource(std::string::String),
    }
}

/// Create DataTaxonomy request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct CreateDataTaxonomyRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. DataTaxonomy identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_taxonomy_id: std::string::String,

    /// Required. DataTaxonomy resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_taxonomy: std::option::Option<crate::model::DataTaxonomy>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataTaxonomyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_taxonomy_id][crate::model::CreateDataTaxonomyRequest::data_taxonomy_id].
    pub fn set_data_taxonomy_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_taxonomy_id = v.into();
        self
    }

    /// Sets the value of [data_taxonomy][crate::model::CreateDataTaxonomyRequest::data_taxonomy].
    pub fn set_data_taxonomy<
        T: std::convert::Into<std::option::Option<crate::model::DataTaxonomy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_taxonomy = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataTaxonomyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataTaxonomyRequest"
    }
}

/// Update DataTaxonomy request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct UpdateDataTaxonomyRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_taxonomy: std::option::Option<crate::model::DataTaxonomy>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataTaxonomyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [data_taxonomy][crate::model::UpdateDataTaxonomyRequest::data_taxonomy].
    pub fn set_data_taxonomy<
        T: std::convert::Into<std::option::Option<crate::model::DataTaxonomy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_taxonomy = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataTaxonomyRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataTaxonomyRequest"
    }
}

/// Get DataTaxonomy request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct GetDataTaxonomyRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataTaxonomyRequest"
    }
}

/// List DataTaxonomies request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataTaxonomiesRequest {
    /// Required. The resource name of the DataTaxonomy location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of DataTaxonomies to return. The service may
    /// return fewer than this value. If unspecified, at most 10 DataTaxonomies
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous ` ListDataTaxonomies` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to ` ListDataTaxonomies` must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataTaxonomiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataTaxonomiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataTaxonomiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataTaxonomiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataTaxonomiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataTaxonomiesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataTaxonomiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataTaxonomiesRequest"
    }
}

/// List DataTaxonomies response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataTaxonomiesResponse {
    /// DataTaxonomies under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_taxonomies: std::vec::Vec<crate::model::DataTaxonomy>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataTaxonomiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_taxonomies][crate::model::ListDataTaxonomiesResponse::data_taxonomies].
    pub fn set_data_taxonomies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataTaxonomy>,
    {
        use std::iter::Iterator;
        self.data_taxonomies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataTaxonomiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataTaxonomiesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataTaxonomiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataTaxonomiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataTaxonomiesResponse {
    type PageItem = crate::model::DataTaxonomy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_taxonomies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Delete DataTaxonomy request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
#[deprecated]
pub struct DeleteDataTaxonomyRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value,the DeleteDataTaxonomy method returns an ABORTED error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataTaxonomyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataTaxonomyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataTaxonomyRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataTaxonomyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataTaxonomyRequest"
    }
}

/// Create DataAttribute request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataAttributeRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. DataAttribute identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the DataTaxonomy.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_attribute_id: std::string::String,

    /// Required. DataAttribute resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_attribute: std::option::Option<crate::model::DataAttribute>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataAttributeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_attribute_id][crate::model::CreateDataAttributeRequest::data_attribute_id].
    pub fn set_data_attribute_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_id = v.into();
        self
    }

    /// Sets the value of [data_attribute][crate::model::CreateDataAttributeRequest::data_attribute].
    pub fn set_data_attribute<
        T: std::convert::Into<std::option::Option<crate::model::DataAttribute>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataAttributeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataAttributeRequest"
    }
}

/// Update DataAttribute request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDataAttributeRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_attribute: std::option::Option<crate::model::DataAttribute>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataAttributeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [data_attribute][crate::model::UpdateDataAttributeRequest::data_attribute].
    pub fn set_data_attribute<
        T: std::convert::Into<std::option::Option<crate::model::DataAttribute>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataAttributeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataAttributeRequest"
    }
}

/// Get DataAttribute request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataAttributeRequest {
    /// Required. The resource name of the dataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataAttributeRequest"
    }
}

/// List DataAttributes request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataAttributesRequest {
    /// Required. The resource name of the DataTaxonomy:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{data_taxonomy_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of DataAttributes to return. The service may
    /// return fewer than this value. If unspecified, at most 10 dataAttributes
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataAttributes` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataAttributes` must match the call that
    /// provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataAttributesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataAttributesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataAttributesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataAttributesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataAttributesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataAttributesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributesRequest"
    }
}

/// List DataAttributes response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataAttributesResponse {
    /// DataAttributes under the given parent DataTaxonomy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_attributes: std::vec::Vec<crate::model::DataAttribute>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_attributes][crate::model::ListDataAttributesResponse::data_attributes].
    pub fn set_data_attributes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataAttribute>,
    {
        use std::iter::Iterator;
        self.data_attributes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataAttributesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataAttributesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataAttributesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataAttributesResponse {
    type PageItem = crate::model::DataAttribute;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_attributes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Delete DataAttribute request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataAttributeRequest {
    /// Required. The resource name of the DataAttribute:
    /// projects/{project_number}/locations/{location_id}/dataTaxonomies/{dataTaxonomy}/attributes/{data_attribute_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttribute method returns an ABORTED error response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataAttributeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataAttributeRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataAttributeRequest"
    }
}

/// Create DataAttributeBinding request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataAttributeBindingRequest {
    /// Required. The resource name of the parent data taxonomy
    /// projects/{project_number}/locations/{location_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. DataAttributeBinding identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the Location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_attribute_binding_id: std::string::String,

    /// Required. DataAttributeBinding resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_attribute_binding: std::option::Option<crate::model::DataAttributeBinding>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataAttributeBindingRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_attribute_binding_id][crate::model::CreateDataAttributeBindingRequest::data_attribute_binding_id].
    pub fn set_data_attribute_binding_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_binding_id = v.into();
        self
    }

    /// Sets the value of [data_attribute_binding][crate::model::CreateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_data_attribute_binding<
        T: std::convert::Into<std::option::Option<crate::model::DataAttributeBinding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_binding = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataAttributeBindingRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataAttributeBindingRequest"
    }
}

/// Update DataAttributeBinding request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDataAttributeBindingRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_attribute_binding: std::option::Option<crate::model::DataAttributeBinding>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataAttributeBindingRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [data_attribute_binding][crate::model::UpdateDataAttributeBindingRequest::data_attribute_binding].
    pub fn set_data_attribute_binding<
        T: std::convert::Into<std::option::Option<crate::model::DataAttributeBinding>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_attribute_binding = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataAttributeBindingRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataAttributeBindingRequest"
    }
}

/// Get DataAttributeBinding request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataAttributeBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataAttributeBindingRequest"
    }
}

/// List DataAttributeBindings request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataAttributeBindingsRequest {
    /// Required. The resource name of the Location:
    /// projects/{project_number}/locations/{location_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of DataAttributeBindings to return. The service
    /// may return fewer than this value. If unspecified, at most 10
    /// DataAttributeBindings will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataAttributeBindings`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListDataAttributeBindings` must match the
    /// call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    /// Filter using resource: filter=resource:"resource-name"
    /// Filter using attribute: filter=attributes:"attribute-name"
    /// Filter using attribute in paths list:
    /// filter=paths.attributes:"attribute-name"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributeBindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataAttributeBindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataAttributeBindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataAttributeBindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataAttributeBindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataAttributeBindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataAttributeBindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributeBindingsRequest"
    }
}

/// List DataAttributeBindings response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataAttributeBindingsResponse {
    /// DataAttributeBindings under the given parent Location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_attribute_bindings: std::vec::Vec<crate::model::DataAttributeBinding>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataAttributeBindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_attribute_bindings][crate::model::ListDataAttributeBindingsResponse::data_attribute_bindings].
    pub fn set_data_attribute_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataAttributeBinding>,
    {
        use std::iter::Iterator;
        self.data_attribute_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataAttributeBindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListDataAttributeBindingsResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataAttributeBindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataAttributeBindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataAttributeBindingsResponse {
    type PageItem = crate::model::DataAttributeBinding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_attribute_bindings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Delete DataAttributeBinding request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataAttributeBindingRequest {
    /// Required. The resource name of the DataAttributeBinding:
    /// projects/{project_number}/locations/{location_id}/dataAttributeBindings/{data_attribute_binding_id}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If the client provided etag value does not match the current etag
    /// value, the DeleteDataAttributeBindingRequest method returns an ABORTED
    /// error response. Etags must be used when calling the
    /// DeleteDataAttributeBinding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataAttributeBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataAttributeBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteDataAttributeBindingRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataAttributeBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataAttributeBindingRequest"
    }
}

/// Create dataScan request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDataScanRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. DataScan resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_scan: std::option::Option<crate::model::DataScan>,

    /// Required. DataScan identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_scan_id: std::string::String,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDataScanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_scan][crate::model::CreateDataScanRequest::data_scan].
    pub fn set_data_scan<T: std::convert::Into<std::option::Option<crate::model::DataScan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_scan = v.into();
        self
    }

    /// Sets the value of [data_scan_id][crate::model::CreateDataScanRequest::data_scan_id].
    pub fn set_data_scan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_scan_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateDataScanRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateDataScanRequest"
    }
}

/// Update dataScan request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDataScanRequest {
    /// Required. DataScan resource to be updated.
    ///
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data_scan: std::option::Option<crate::model::DataScan>,

    /// Optional. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is `false`.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scan][crate::model::UpdateDataScanRequest::data_scan].
    pub fn set_data_scan<T: std::convert::Into<std::option::Option<crate::model::DataScan>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_scan = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDataScanRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateDataScanRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateDataScanRequest"
    }
}

/// Delete dataScan request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set to true, any child resources of this data scan will also
    /// be deleted. (Otherwise, the request will only work if the data scan has no
    /// child resources.)
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteDataScanRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteDataScanRequest"
    }
}

/// Get dataScan request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataScanRequest {
    /// Required. The resource name of the dataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Select the DataScan view to return. Defaults to `BASIC`.
    pub view: crate::model::get_data_scan_request::DataScanView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDataScanRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_data_scan_request::DataScanView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataScanRequest"
    }
}

/// Defines additional types related to [GetDataScanRequest].
pub mod get_data_scan_request {
    #[allow(unused_imports)]
    use super::*;

    /// DataScan view options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataScanView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Basic view that does not include *spec* and *result*.
        Basic,
        /// Include everything.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataScanView::value] or
        /// [DataScanView::name].
        UnknownValue(data_scan_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_scan_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataScanView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SCAN_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataScanView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataScanView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataScanView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                10 => Self::Full,
                _ => Self::UnknownValue(data_scan_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataScanView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SCAN_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(data_scan_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataScanView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataScanView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanView>::new(
                ".google.cloud.dataplex.v1.GetDataScanRequest.DataScanView",
            ))
        }
    }
}

/// List dataScans request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataScansRequest {
    /// Required. The resource name of the parent location:
    /// `projects/{project}/locations/{location_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of dataScans to return. The service may return
    /// fewer than this value. If unspecified, at most 500 scans will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataScans` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListDataScans` must match the call that provided the
    /// page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields (`name` or `create_time`) for the result.
    /// If not specified, the ordering is undefined.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataScansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataScansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataScansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataScansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDataScansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScansRequest"
    }
}

/// List dataScans response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataScansResponse {
    /// DataScans (`BASIC` view only) under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_scans: std::vec::Vec<crate::model::DataScan>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scans][crate::model::ListDataScansResponse::data_scans].
    pub fn set_data_scans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataScan>,
    {
        use std::iter::Iterator;
        self.data_scans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataScansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDataScansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDataScansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataScansResponse {
    type PageItem = crate::model::DataScan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_scans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Run DataScan Request
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunDataScanRequest {
    /// Required. The resource name of the DataScan:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`.
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    ///
    /// Only **OnDemand** data scans are allowed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDataScanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunDataScanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RunDataScanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunDataScanRequest"
    }
}

/// Run DataScan Response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunDataScanResponse {
    /// DataScanJob created by RunDataScan request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::DataScanJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDataScanResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::RunDataScanResponse::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::DataScanJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for RunDataScanResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunDataScanResponse"
    }
}

/// Get DataScanJob request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDataScanJobRequest {
    /// Required. The resource name of the DataScanJob:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}/jobs/{data_scan_job_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Select the DataScanJob view to return. Defaults to `BASIC`.
    pub view: crate::model::get_data_scan_job_request::DataScanJobView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDataScanJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDataScanJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetDataScanJobRequest::view].
    pub fn set_view<
        T: std::convert::Into<crate::model::get_data_scan_job_request::DataScanJobView>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetDataScanJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetDataScanJobRequest"
    }
}

/// Defines additional types related to [GetDataScanJobRequest].
pub mod get_data_scan_job_request {
    #[allow(unused_imports)]
    use super::*;

    /// DataScanJob view options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataScanJobView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Basic view that does not include *spec* and *result*.
        Basic,
        /// Include everything.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataScanJobView::value] or
        /// [DataScanJobView::name].
        UnknownValue(data_scan_job_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_scan_job_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataScanJobView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_SCAN_JOB_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataScanJobView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataScanJobView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataScanJobView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                10 => Self::Full,
                _ => Self::UnknownValue(data_scan_job_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataScanJobView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_SCAN_JOB_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(data_scan_job_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataScanJobView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataScanJobView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanJobView>::new(
                ".google.cloud.dataplex.v1.GetDataScanJobRequest.DataScanJobView",
            ))
        }
    }
}

/// List DataScanJobs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataScanJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project}/locations/{location_id}/dataScans/{data_scan_id}`
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of DataScanJobs to return. The service may return
    /// fewer than this value. If unspecified, at most 10 DataScanJobs will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListDataScanJobs` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListDataScanJobs` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the ListDataScanJobs
    /// request.
    ///
    /// If unspecified, all datascan jobs will be returned. Multiple filters can be
    /// applied (with `AND`, `OR` logical operators). Filters are case-sensitive.
    ///
    /// Allowed fields are:
    ///
    /// - `start_time`
    /// - `end_time`
    ///
    /// `start_time` and `end_time` expect RFC-3339 formatted strings (e.g.
    /// 2018-10-08T18:30:00-07:00).
    ///
    /// For instance, 'start_time > 2018-10-08T00:00:00.123456789Z AND end_time <
    /// 2018-10-09T00:00:00.123456789Z' limits results to DataScanJobs between
    /// specified start and end times.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScanJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDataScanJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDataScanJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDataScanJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDataScanJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScanJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScanJobsRequest"
    }
}

/// List DataScanJobs response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDataScanJobsResponse {
    /// DataScanJobs (`BASIC` view only) under a given dataScan.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_scan_jobs: std::vec::Vec<crate::model::DataScanJob>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDataScanJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_scan_jobs][crate::model::ListDataScanJobsResponse::data_scan_jobs].
    pub fn set_data_scan_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataScanJob>,
    {
        use std::iter::Iterator;
        self.data_scan_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDataScanJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDataScanJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListDataScanJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDataScanJobsResponse {
    type PageItem = crate::model::DataScanJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.data_scan_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request details for generating data quality rule recommendations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateDataQualityRulesRequest {
    /// Required. The name must be one of the following:
    ///
    /// * The name of a data scan with at least one successful, completed data
    ///   profiling job
    /// * The name of a successful, completed data profiling job (a data scan job
    ///   where the job type is data profiling)
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDataQualityRulesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateDataQualityRulesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GenerateDataQualityRulesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GenerateDataQualityRulesRequest"
    }
}

/// Response details for data quality rule recommendations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateDataQualityRulesResponse {
    /// The data quality rules that Dataplex generates based on the results
    /// of a data profiling scan.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rule: std::vec::Vec<crate::model::DataQualityRule>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateDataQualityRulesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::GenerateDataQualityRulesResponse::rule].
    pub fn set_rule<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataQualityRule>,
    {
        use std::iter::Iterator;
        self.rule = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateDataQualityRulesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GenerateDataQualityRulesResponse"
    }
}

/// Represents a user-visible job which provides the insights for the related
/// data source.
///
/// For example:
///
/// * Data quality: generates queries based on the rules and runs against the
///   data to get data quality check results. For more information, see [Auto
///   data quality
///   overview](https://cloud.google.com/dataplex/docs/auto-data-quality-overview).
/// * Data profile: analyzes the data in tables and generates insights about
///   the structure, content and relationships (such as null percent,
///   cardinality, min/max/mean, etc). For more information, see [About data
///   profiling](https://cloud.google.com/dataplex/docs/data-profiling-overview).
/// * Data discovery: scans data in Cloud Storage buckets to extract and then
///   catalog metadata. For more information, see [Discover and catalog Cloud
///   Storage data](https://cloud.google.com/bigquery/docs/automatic-discovery).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataScan {
    /// Output only. Identifier. The relative resource name of the scan, of the
    /// form: `projects/{project}/locations/{location_id}/dataScans/{datascan_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the scan. This ID will
    /// be different if the scan is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. Description of the scan.
    ///
    /// * Must be between 1-1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    ///
    /// * Must be between 1-256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User-defined labels for the scan.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Current state of the DataScan.
    pub state: crate::model::State,

    /// Output only. The time when the scan was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the scan was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The data source for DataScan.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub data: std::option::Option<crate::model::DataSource>,

    /// Optional. DataScan execution settings.
    ///
    /// If not specified, the fields in it will use their default values.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_spec: std::option::Option<crate::model::data_scan::ExecutionSpec>,

    /// Output only. Status of the data scan execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_status: std::option::Option<crate::model::data_scan::ExecutionStatus>,

    /// Output only. The type of DataScan.
    #[serde(rename = "type")]
    pub r#type: crate::model::DataScanType,

    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::data_scan::Spec>,

    /// The result of the data scan.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::data_scan::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataScan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataScan::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DataScan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::DataScan::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DataScan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::DataScan::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScan::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::DataScan::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [data][crate::model::DataScan::data].
    pub fn set_data<T: std::convert::Into<std::option::Option<crate::model::DataSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [execution_spec][crate::model::DataScan::execution_spec].
    pub fn set_execution_spec<
        T: std::convert::Into<std::option::Option<crate::model::data_scan::ExecutionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_spec = v.into();
        self
    }

    /// Sets the value of [execution_status][crate::model::DataScan::execution_status].
    pub fn set_execution_status<
        T: std::convert::Into<std::option::Option<crate::model::data_scan::ExecutionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_status = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataScan::type].
    pub fn set_type<T: std::convert::Into<crate::model::DataScanType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::DataScan::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<T: std::convert::Into<std::option::Option<crate::model::data_scan::Spec>>>(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataQualitySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualitySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataQualitySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataQualitySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_quality_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataQualitySpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataProfileSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataProfileSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataProfileSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_profile_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataProfileSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScan::spec]
    /// if it holds a `DataDiscoverySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoverySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan::Spec::DataDiscoverySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScan::spec]
    /// to hold a `DataDiscoverySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_discovery_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan::Spec::DataDiscoverySpec(v.into()));
        self
    }

    /// Sets the value of [result][crate::model::DataScan::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualityResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataQualityResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataQualityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan::Result::DataQualityResult(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataProfileResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataProfileResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataProfileResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan::Result::DataProfileResult(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScan::result]
    /// if it holds a `DataDiscoveryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoveryResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan::Result::DataDiscoveryResult(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScan::result]
    /// to hold a `DataDiscoveryResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_discovery_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoveryResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan::Result::DataDiscoveryResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScan"
    }
}

/// Defines additional types related to [DataScan].
pub mod data_scan {
    #[allow(unused_imports)]
    use super::*;

    /// DataScan execution settings.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecutionSpec {
        /// Optional. Spec related to how often and when a scan should be triggered.
        ///
        /// If not specified, the default is `OnDemand`, which means the scan will
        /// not run until the user calls `RunDataScan` API.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::Trigger>,

        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub incremental: std::option::Option<crate::model::data_scan::execution_spec::Incremental>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [trigger][crate::model::data_scan::ExecutionSpec::trigger].
        pub fn set_trigger<T: std::convert::Into<std::option::Option<crate::model::Trigger>>>(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// Sets the value of [incremental][crate::model::data_scan::ExecutionSpec::incremental].
        ///
        /// Note that all the setters affecting `incremental` are mutually
        /// exclusive.
        pub fn set_incremental<
            T: std::convert::Into<
                    std::option::Option<crate::model::data_scan::execution_spec::Incremental>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.incremental = v.into();
            self
        }

        /// The value of [incremental][crate::model::data_scan::ExecutionSpec::incremental]
        /// if it holds a `Field`, `None` if the field is not set or
        /// holds a different branch.
        pub fn field(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.incremental.as_ref().and_then(|v| match v {
                crate::model::data_scan::execution_spec::Incremental::Field(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [incremental][crate::model::data_scan::ExecutionSpec::incremental]
        /// to hold a `Field`.
        ///
        /// Note that all the setters affecting `incremental` are
        /// mutually exclusive.
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.incremental = std::option::Option::Some(
                crate::model::data_scan::execution_spec::Incremental::Field(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ExecutionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScan.ExecutionSpec"
        }
    }

    /// Defines additional types related to [ExecutionSpec].
    pub mod execution_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Spec related to incremental scan of the data
        ///
        /// When an option is selected for incremental scan, it cannot be unset or
        /// changed. If not specified, a data scan will run for all data in the
        /// table.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Incremental {
            /// Immutable. The unnested field (of type *Date* or *Timestamp*) that
            /// contains values which monotonically increase over time.
            ///
            /// If not specified, a data scan will run for all data in the table.
            Field(std::string::String),
        }
    }

    /// Status of the data scan execution.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecutionStatus {
        /// Optional. The time when the latest DataScanJob started.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub latest_job_start_time: std::option::Option<wkt::Timestamp>,

        /// Optional. The time when the latest DataScanJob ended.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub latest_job_end_time: std::option::Option<wkt::Timestamp>,

        /// Optional. The time when the DataScanJob execution was created.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub latest_job_create_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [latest_job_start_time][crate::model::data_scan::ExecutionStatus::latest_job_start_time].
        pub fn set_latest_job_start_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.latest_job_start_time = v.into();
            self
        }

        /// Sets the value of [latest_job_end_time][crate::model::data_scan::ExecutionStatus::latest_job_end_time].
        pub fn set_latest_job_end_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.latest_job_end_time = v.into();
            self
        }

        /// Sets the value of [latest_job_create_time][crate::model::data_scan::ExecutionStatus::latest_job_create_time].
        pub fn set_latest_job_create_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.latest_job_create_time = v.into();
            self
        }
    }

    impl wkt::message::Message for ExecutionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScan.ExecutionStatus"
        }
    }

    /// Data scan related setting.
    /// The settings are required and immutable. After you configure the settings
    /// for one type of data scan, you can't change the data scan to a different
    /// type of data scan.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Spec {
        /// Settings for a data quality scan.
        DataQualitySpec(std::boxed::Box<crate::model::DataQualitySpec>),
        /// Settings for a data profile scan.
        DataProfileSpec(std::boxed::Box<crate::model::DataProfileSpec>),
        /// Settings for a data discovery scan.
        DataDiscoverySpec(std::boxed::Box<crate::model::DataDiscoverySpec>),
    }

    /// The result of the data scan.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        DataQualityResult(std::boxed::Box<crate::model::DataQualityResult>),
        /// Output only. The result of a data profile scan.
        DataProfileResult(std::boxed::Box<crate::model::DataProfileResult>),
        /// Output only. The result of a data discovery scan.
        DataDiscoveryResult(std::boxed::Box<crate::model::DataDiscoveryResult>),
    }
}

/// A DataScanJob represents an instance of DataScan execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataScanJob {
    /// Output only. Identifier. The relative resource name of the DataScanJob, of
    /// the form:
    /// `projects/{project}/locations/{location_id}/dataScans/{datascan_id}/jobs/{job_id}`,
    /// where `project` refers to a *project_id* or *project_number* and
    /// `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the DataScanJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the DataScanJob was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataScanJob was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the DataScanJob ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Execution state for the DataScanJob.
    pub state: crate::model::data_scan_job::State,

    /// Output only. Additional information about the current state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Output only. The type of the parent DataScan.
    #[serde(rename = "type")]
    pub r#type: crate::model::DataScanType,

    /// Data scan related setting.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub spec: std::option::Option<crate::model::data_scan_job::Spec>,

    /// The result of the data scan.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::data_scan_job::Result>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScanJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DataScanJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::DataScanJob::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScanJob::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::DataScanJob::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DataScanJob::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataScanJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_scan_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::DataScanJob::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataScanJob::type].
    pub fn set_type<T: std::convert::Into<crate::model::DataScanType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec].
    ///
    /// Note that all the setters affecting `spec` are mutually
    /// exclusive.
    pub fn set_spec<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_job::Spec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = v.into();
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataQualitySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualitySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataQualitySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataQualitySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_quality_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualitySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan_job::Spec::DataQualitySpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataProfileSpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileSpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataProfileSpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataProfileSpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_profile_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec =
            std::option::Option::Some(crate::model::data_scan_job::Spec::DataProfileSpec(v.into()));
        self
    }

    /// The value of [spec][crate::model::DataScanJob::spec]
    /// if it holds a `DataDiscoverySpec`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_spec(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoverySpec>> {
        #[allow(unreachable_patterns)]
        self.spec.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Spec::DataDiscoverySpec(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [spec][crate::model::DataScanJob::spec]
    /// to hold a `DataDiscoverySpec`.
    ///
    /// Note that all the setters affecting `spec` are
    /// mutually exclusive.
    pub fn set_data_discovery_spec<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spec = std::option::Option::Some(
            crate::model::data_scan_job::Spec::DataDiscoverySpec(v.into()),
        );
        self
    }

    /// Sets the value of [result][crate::model::DataScanJob::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_job::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataQualityResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataQualityResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataQualityResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataQualityResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataQualityResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataProfileResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataProfileResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataProfileResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataProfileResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataProfileResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::DataScanJob::result]
    /// if it holds a `DataDiscoveryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_discovery_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiscoveryResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_job::Result::DataDiscoveryResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanJob::result]
    /// to hold a `DataDiscoveryResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_discovery_result<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiscoveryResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::data_scan_job::Result::DataDiscoveryResult(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScanJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScanJob"
    }
}

/// Defines additional types related to [DataScanJob].
pub mod data_scan_job {
    #[allow(unused_imports)]
    use super::*;

    /// Execution state for the DataScanJob.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The DataScanJob state is unspecified.
        Unspecified,
        /// The DataScanJob is running.
        Running,
        /// The DataScanJob is canceling.
        Canceling,
        /// The DataScanJob cancellation was successful.
        Cancelled,
        /// The DataScanJob completed successfully.
        Succeeded,
        /// The DataScanJob is no longer running due to an error.
        Failed,
        /// The DataScanJob has been created but not started to run yet.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Canceling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Pending => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Canceling => std::option::Option::Some("CANCELING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Canceling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                5 => Self::Failed,
                7 => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "CANCELING" => Self::Canceling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Canceling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Pending => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.DataScanJob.State",
            ))
        }
    }

    /// Data scan related setting.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Spec {
        /// Output only. Settings for a data quality scan.
        DataQualitySpec(std::boxed::Box<crate::model::DataQualitySpec>),
        /// Output only. Settings for a data profile scan.
        DataProfileSpec(std::boxed::Box<crate::model::DataProfileSpec>),
        /// Output only. Settings for a data discovery scan.
        DataDiscoverySpec(std::boxed::Box<crate::model::DataDiscoverySpec>),
    }

    /// The result of the data scan.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Output only. The result of a data quality scan.
        DataQualityResult(std::boxed::Box<crate::model::DataQualityResult>),
        /// Output only. The result of a data profile scan.
        DataProfileResult(std::boxed::Box<crate::model::DataProfileResult>),
        /// Output only. The result of a data discovery scan.
        DataDiscoveryResult(std::boxed::Box<crate::model::DataDiscoveryResult>),
    }
}

/// The payload associated with Discovery data processing.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The id of the associated lake.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lake_id: std::string::String,

    /// The id of the associated zone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone_id: std::string::String,

    /// The id of the associated asset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_id: std::string::String,

    /// The data location associated with the event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_location: std::string::String,

    /// The id of the associated datascan for standalone discovery.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datascan_id: std::string::String,

    /// The type of the event being logged.
    #[serde(rename = "type")]
    pub r#type: crate::model::discovery_event::EventType,

    /// Additional details about the event.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::discovery_event::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::DiscoveryEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [lake_id][crate::model::DiscoveryEvent::lake_id].
    pub fn set_lake_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake_id = v.into();
        self
    }

    /// Sets the value of [zone_id][crate::model::DiscoveryEvent::zone_id].
    pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_id = v.into();
        self
    }

    /// Sets the value of [asset_id][crate::model::DiscoveryEvent::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [data_location][crate::model::DiscoveryEvent::data_location].
    pub fn set_data_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_location = v.into();
        self
    }

    /// Sets the value of [datascan_id][crate::model::DiscoveryEvent::datascan_id].
    pub fn set_datascan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datascan_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DiscoveryEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::discovery_event::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::ConfigDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Config(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Config`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_config<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::ConfigDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Config(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Entity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::EntityDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Entity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Entity`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_entity<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::EntityDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Entity(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Partition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::PartitionDetails>>
    {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Partition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Partition`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_partition<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::PartitionDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Partition(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Action`, `None` if the field is not set or
    /// holds a different branch.
    pub fn action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::ActionDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Action(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Action`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_action<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::ActionDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Action(v.into()));
        self
    }

    /// The value of [details][crate::model::DiscoveryEvent::details]
    /// if it holds a `Table`, `None` if the field is not set or
    /// holds a different branch.
    pub fn table(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::discovery_event::TableDetails>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::discovery_event::Details::Table(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::DiscoveryEvent::details]
    /// to hold a `Table`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_table<
        T: std::convert::Into<std::boxed::Box<crate::model::discovery_event::TableDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::discovery_event::Details::Table(v.into()));
        self
    }
}

impl wkt::message::Message for DiscoveryEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent"
    }
}

/// Defines additional types related to [DiscoveryEvent].
pub mod discovery_event {
    #[allow(unused_imports)]
    use super::*;

    /// Details about configuration events.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConfigDetails {
        /// A list of discovery configuration parameters in effect.
        /// The keys are the field paths within DiscoverySpec.
        /// Eg. includePatterns, excludePatterns, csvOptions.disableTypeInference,
        /// etc.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConfigDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameters][crate::model::discovery_event::ConfigDetails::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for ConfigDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.ConfigDetails"
        }
    }

    /// Details about the entity.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EntityDetails {
        /// The name of the entity resource.
        /// The name is the fully-qualified resource name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity: std::string::String,

        /// The type of the entity resource.
        #[serde(rename = "type")]
        pub r#type: crate::model::discovery_event::EntityType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EntityDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity][crate::model::discovery_event::EntityDetails::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::EntityDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EntityType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for EntityDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.EntityDetails"
        }
    }

    /// Details about the published table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TableDetails {
        /// The fully-qualified resource name of the table resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        /// The type of the table resource.
        #[serde(rename = "type")]
        pub r#type: crate::model::discovery_event::TableType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::discovery_event::TableDetails::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::TableDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::TableType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for TableDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.TableDetails"
        }
    }

    /// Details about the partition.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PartitionDetails {
        /// The name to the partition resource.
        /// The name is the fully-qualified resource name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub partition: std::string::String,

        /// The name to the containing entity resource.
        /// The name is the fully-qualified resource name.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity: std::string::String,

        /// The type of the containing entity resource.
        #[serde(rename = "type")]
        pub r#type: crate::model::discovery_event::EntityType,

        /// The locations of the data items (e.g., a Cloud Storage objects) sampled
        /// for metadata inference.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PartitionDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [partition][crate::model::discovery_event::PartitionDetails::partition].
        pub fn set_partition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.partition = v.into();
            self
        }

        /// Sets the value of [entity][crate::model::discovery_event::PartitionDetails::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::discovery_event::PartitionDetails::type].
        pub fn set_type<T: std::convert::Into<crate::model::discovery_event::EntityType>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [sampled_data_locations][crate::model::discovery_event::PartitionDetails::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PartitionDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.PartitionDetails"
        }
    }

    /// Details about the action.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ActionDetails {
        /// The type of action.
        /// Eg. IncompatibleDataSchema, InvalidDataFormat
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        /// The human readable issue associated with the action.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub issue: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ActionDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::discovery_event::ActionDetails::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [issue][crate::model::discovery_event::ActionDetails::issue].
        pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.issue = v.into();
            self
        }
    }

    impl wkt::message::Message for ActionDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DiscoveryEvent.ActionDetails"
        }
    }

    /// The type of the event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// An event representing discovery configuration in effect.
        Config,
        /// An event representing a metadata entity being created.
        EntityCreated,
        /// An event representing a metadata entity being updated.
        EntityUpdated,
        /// An event representing a metadata entity being deleted.
        EntityDeleted,
        /// An event representing a partition being created.
        PartitionCreated,
        /// An event representing a partition being updated.
        PartitionUpdated,
        /// An event representing a partition being deleted.
        PartitionDeleted,
        /// An event representing a table being published.
        TablePublished,
        /// An event representing a table being updated.
        TableUpdated,
        /// An event representing a table being skipped in publishing.
        TableIgnored,
        /// An event representing a table being deleted.
        TableDeleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Config => std::option::Option::Some(1),
                Self::EntityCreated => std::option::Option::Some(2),
                Self::EntityUpdated => std::option::Option::Some(3),
                Self::EntityDeleted => std::option::Option::Some(4),
                Self::PartitionCreated => std::option::Option::Some(5),
                Self::PartitionUpdated => std::option::Option::Some(6),
                Self::PartitionDeleted => std::option::Option::Some(7),
                Self::TablePublished => std::option::Option::Some(10),
                Self::TableUpdated => std::option::Option::Some(11),
                Self::TableIgnored => std::option::Option::Some(12),
                Self::TableDeleted => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::Config => std::option::Option::Some("CONFIG"),
                Self::EntityCreated => std::option::Option::Some("ENTITY_CREATED"),
                Self::EntityUpdated => std::option::Option::Some("ENTITY_UPDATED"),
                Self::EntityDeleted => std::option::Option::Some("ENTITY_DELETED"),
                Self::PartitionCreated => std::option::Option::Some("PARTITION_CREATED"),
                Self::PartitionUpdated => std::option::Option::Some("PARTITION_UPDATED"),
                Self::PartitionDeleted => std::option::Option::Some("PARTITION_DELETED"),
                Self::TablePublished => std::option::Option::Some("TABLE_PUBLISHED"),
                Self::TableUpdated => std::option::Option::Some("TABLE_UPDATED"),
                Self::TableIgnored => std::option::Option::Some("TABLE_IGNORED"),
                Self::TableDeleted => std::option::Option::Some("TABLE_DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Config,
                2 => Self::EntityCreated,
                3 => Self::EntityUpdated,
                4 => Self::EntityDeleted,
                5 => Self::PartitionCreated,
                6 => Self::PartitionUpdated,
                7 => Self::PartitionDeleted,
                10 => Self::TablePublished,
                11 => Self::TableUpdated,
                12 => Self::TableIgnored,
                13 => Self::TableDeleted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONFIG" => Self::Config,
                "ENTITY_CREATED" => Self::EntityCreated,
                "ENTITY_UPDATED" => Self::EntityUpdated,
                "ENTITY_DELETED" => Self::EntityDeleted,
                "PARTITION_CREATED" => Self::PartitionCreated,
                "PARTITION_UPDATED" => Self::PartitionUpdated,
                "PARTITION_DELETED" => Self::PartitionDeleted,
                "TABLE_PUBLISHED" => Self::TablePublished,
                "TABLE_UPDATED" => Self::TableUpdated,
                "TABLE_IGNORED" => Self::TableIgnored,
                "TABLE_DELETED" => Self::TableDeleted,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Config => serializer.serialize_i32(1),
                Self::EntityCreated => serializer.serialize_i32(2),
                Self::EntityUpdated => serializer.serialize_i32(3),
                Self::EntityDeleted => serializer.serialize_i32(4),
                Self::PartitionCreated => serializer.serialize_i32(5),
                Self::PartitionUpdated => serializer.serialize_i32(6),
                Self::PartitionDeleted => serializer.serialize_i32(7),
                Self::TablePublished => serializer.serialize_i32(10),
                Self::TableUpdated => serializer.serialize_i32(11),
                Self::TableIgnored => serializer.serialize_i32(12),
                Self::TableDeleted => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.EventType",
            ))
        }
    }

    /// The type of the entity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityType {
        /// An unspecified event type.
        Unspecified,
        /// Entities representing structured data.
        Table,
        /// Entities representing unstructured data.
        Fileset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityType::value] or
        /// [EntityType::name].
        UnknownValue(entity_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Fileset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Fileset => std::option::Option::Some("FILESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Fileset,
                _ => Self::UnknownValue(entity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "FILESET" => Self::Fileset,
                _ => Self::UnknownValue(entity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Fileset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.EntityType",
            ))
        }
    }

    /// The type of the published table.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TableType {
        /// An unspecified table type.
        Unspecified,
        /// External table type.
        ExternalTable,
        /// BigLake table type.
        BiglakeTable,
        /// Object table type for unstructured data.
        ObjectTable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TableType::value] or
        /// [TableType::name].
        UnknownValue(table_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod table_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TableType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExternalTable => std::option::Option::Some(1),
                Self::BiglakeTable => std::option::Option::Some(2),
                Self::ObjectTable => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TABLE_TYPE_UNSPECIFIED"),
                Self::ExternalTable => std::option::Option::Some("EXTERNAL_TABLE"),
                Self::BiglakeTable => std::option::Option::Some("BIGLAKE_TABLE"),
                Self::ObjectTable => std::option::Option::Some("OBJECT_TABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TableType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TableType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TableType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExternalTable,
                2 => Self::BiglakeTable,
                3 => Self::ObjectTable,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TableType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TABLE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "EXTERNAL_TABLE" => Self::ExternalTable,
                "BIGLAKE_TABLE" => Self::BiglakeTable,
                "OBJECT_TABLE" => Self::ObjectTable,
                _ => Self::UnknownValue(table_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TableType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExternalTable => serializer.serialize_i32(1),
                Self::BiglakeTable => serializer.serialize_i32(2),
                Self::ObjectTable => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TableType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TableType>::new(
                ".google.cloud.dataplex.v1.DiscoveryEvent.TableType",
            ))
        }
    }

    /// Additional details about the event.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Details about discovery configuration in effect.
        Config(std::boxed::Box<crate::model::discovery_event::ConfigDetails>),
        /// Details about the entity associated with the event.
        Entity(std::boxed::Box<crate::model::discovery_event::EntityDetails>),
        /// Details about the partition associated with the event.
        Partition(std::boxed::Box<crate::model::discovery_event::PartitionDetails>),
        /// Details about the action associated with the event.
        Action(std::boxed::Box<crate::model::discovery_event::ActionDetails>),
        /// Details about the BigQuery table publishing associated with the event.
        Table(std::boxed::Box<crate::model::discovery_event::TableDetails>),
    }
}

/// The payload associated with Job logs that contains events describing jobs
/// that have run within a Lake.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The unique id identifying the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The time when the job started running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the job ended running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The job state on completion.
    pub state: crate::model::job_event::State,

    /// The number of retries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub retries: i32,

    /// The type of the job.
    #[serde(rename = "type")]
    pub r#type: crate::model::job_event::Type,

    /// The service used to execute the job.
    pub service: crate::model::job_event::Service,

    /// The reference to the job within the service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_job: std::string::String,

    /// Job execution trigger.
    pub execution_trigger: crate::model::job_event::ExecutionTrigger,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::JobEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobEvent::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::JobEvent::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::JobEvent::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::JobEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [retries][crate::model::JobEvent::retries].
    pub fn set_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retries = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::JobEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::job_event::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [service][crate::model::JobEvent::service].
    pub fn set_service<T: std::convert::Into<crate::model::job_event::Service>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_job][crate::model::JobEvent::service_job].
    pub fn set_service_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_job = v.into();
        self
    }

    /// Sets the value of [execution_trigger][crate::model::JobEvent::execution_trigger].
    pub fn set_execution_trigger<
        T: std::convert::Into<crate::model::job_event::ExecutionTrigger>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_trigger = v.into();
        self
    }
}

impl wkt::message::Message for JobEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.JobEvent"
    }
}

/// Defines additional types related to [JobEvent].
pub mod job_event {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified job type.
        Unspecified,
        /// Spark jobs.
        Spark,
        /// Notebook jobs.
        Notebook,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Spark => std::option::Option::Some(1),
                Self::Notebook => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Spark => std::option::Option::Some("SPARK"),
                Self::Notebook => std::option::Option::Some("NOTEBOOK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Spark,
                2 => Self::Notebook,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SPARK" => Self::Spark,
                "NOTEBOOK" => Self::Notebook,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Spark => serializer.serialize_i32(1),
                Self::Notebook => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.JobEvent.Type",
            ))
        }
    }

    /// The completion status of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified job state.
        Unspecified,
        /// Job successfully completed.
        Succeeded,
        /// Job was unsuccessful.
        Failed,
        /// Job was cancelled by the user.
        Cancelled,
        /// Job was cancelled or aborted via the service executing the job.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Succeeded => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Aborted => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Succeeded,
                2 => Self::Failed,
                3 => Self::Cancelled,
                4 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Succeeded => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Aborted => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.JobEvent.State",
            ))
        }
    }

    /// The service used to execute the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Unspecified service.
        Unspecified,
        /// Cloud Dataproc.
        Dataproc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dataproc => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::Dataproc => std::option::Option::Some("DATAPROC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "DATAPROC" => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dataproc => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.dataplex.v1.JobEvent.Service",
            ))
        }
    }

    /// Job Execution trigger.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionTrigger {
        /// The job execution trigger is unspecified.
        Unspecified,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig,
        /// The job was triggered by the explicit call of Task API.
        RunRequest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExecutionTrigger::value] or
        /// [ExecutionTrigger::name].
        UnknownValue(execution_trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod execution_trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExecutionTrigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TaskConfig => std::option::Option::Some(1),
                Self::RunRequest => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXECUTION_TRIGGER_UNSPECIFIED"),
                Self::TaskConfig => std::option::Option::Some("TASK_CONFIG"),
                Self::RunRequest => std::option::Option::Some("RUN_REQUEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExecutionTrigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExecutionTrigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExecutionTrigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TaskConfig,
                2 => Self::RunRequest,
                _ => Self::UnknownValue(execution_trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExecutionTrigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXECUTION_TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "TASK_CONFIG" => Self::TaskConfig,
                "RUN_REQUEST" => Self::RunRequest,
                _ => Self::UnknownValue(execution_trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExecutionTrigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TaskConfig => serializer.serialize_i32(1),
                Self::RunRequest => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExecutionTrigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExecutionTrigger>::new(
                ".google.cloud.dataplex.v1.JobEvent.ExecutionTrigger",
            ))
        }
    }
}

/// These messages contain information about sessions within an environment.
/// The monitored resource is 'Environment'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SessionEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The information about the user that created the session. It will be the
    /// email address of the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_id: std::string::String,

    /// Unique identifier for the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_id: std::string::String,

    /// The type of the event.
    #[serde(rename = "type")]
    pub r#type: crate::model::session_event::EventType,

    /// The status of the event.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub event_succeeded: bool,

    /// If the session is associated with an environment with fast startup enabled,
    /// and was created before being assigned to a user.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub fast_startup_enabled: bool,

    /// The idle duration of a warm pooled session before it is assigned to user.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub unassigned_duration: std::option::Option<wkt::Duration>,

    /// Additional information about the Query metadata.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub detail: std::option::Option<crate::model::session_event::Detail>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::SessionEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::SessionEvent::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::SessionEvent::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SessionEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::session_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [event_succeeded][crate::model::SessionEvent::event_succeeded].
    pub fn set_event_succeeded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.event_succeeded = v.into();
        self
    }

    /// Sets the value of [fast_startup_enabled][crate::model::SessionEvent::fast_startup_enabled].
    pub fn set_fast_startup_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.fast_startup_enabled = v.into();
        self
    }

    /// Sets the value of [unassigned_duration][crate::model::SessionEvent::unassigned_duration].
    pub fn set_unassigned_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.unassigned_duration = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::SessionEvent::detail].
    ///
    /// Note that all the setters affecting `detail` are mutually
    /// exclusive.
    pub fn set_detail<
        T: std::convert::Into<std::option::Option<crate::model::session_event::Detail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail = v.into();
        self
    }

    /// The value of [detail][crate::model::SessionEvent::detail]
    /// if it holds a `Query`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::session_event::QueryDetail>> {
        #[allow(unreachable_patterns)]
        self.detail.as_ref().and_then(|v| match v {
            crate::model::session_event::Detail::Query(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [detail][crate::model::SessionEvent::detail]
    /// to hold a `Query`.
    ///
    /// Note that all the setters affecting `detail` are
    /// mutually exclusive.
    pub fn set_query<
        T: std::convert::Into<std::boxed::Box<crate::model::session_event::QueryDetail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail =
            std::option::Option::Some(crate::model::session_event::Detail::Query(v.into()));
        self
    }
}

impl wkt::message::Message for SessionEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.SessionEvent"
    }
}

/// Defines additional types related to [SessionEvent].
pub mod session_event {
    #[allow(unused_imports)]
    use super::*;

    /// Execution details of the query.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct QueryDetail {
        /// The unique Query id identifying the query.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_id: std::string::String,

        /// The query text executed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub query_text: std::string::String,

        /// Query Execution engine.
        pub engine: crate::model::session_event::query_detail::Engine,

        /// Time taken for execution of the query.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub duration: std::option::Option<wkt::Duration>,

        /// The size of results the query produced.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub result_size_bytes: i64,

        /// The data processed by the query.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub data_processed_bytes: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_id][crate::model::session_event::QueryDetail::query_id].
        pub fn set_query_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_id = v.into();
            self
        }

        /// Sets the value of [query_text][crate::model::session_event::QueryDetail::query_text].
        pub fn set_query_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_text = v.into();
            self
        }

        /// Sets the value of [engine][crate::model::session_event::QueryDetail::engine].
        pub fn set_engine<
            T: std::convert::Into<crate::model::session_event::query_detail::Engine>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.engine = v.into();
            self
        }

        /// Sets the value of [duration][crate::model::session_event::QueryDetail::duration].
        pub fn set_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.duration = v.into();
            self
        }

        /// Sets the value of [result_size_bytes][crate::model::session_event::QueryDetail::result_size_bytes].
        pub fn set_result_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.result_size_bytes = v.into();
            self
        }

        /// Sets the value of [data_processed_bytes][crate::model::session_event::QueryDetail::data_processed_bytes].
        pub fn set_data_processed_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.data_processed_bytes = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.SessionEvent.QueryDetail"
        }
    }

    /// Defines additional types related to [QueryDetail].
    pub mod query_detail {
        #[allow(unused_imports)]
        use super::*;

        /// Query Execution engine.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Engine {
            /// An unspecified Engine type.
            Unspecified,
            /// Spark-sql engine is specified in Query.
            SparkSql,
            /// BigQuery engine is specified in Query.
            Bigquery,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Engine::value] or
            /// [Engine::name].
            UnknownValue(engine::UnknownValue),
        }

        #[doc(hidden)]
        pub mod engine {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Engine {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SparkSql => std::option::Option::Some(1),
                    Self::Bigquery => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENGINE_UNSPECIFIED"),
                    Self::SparkSql => std::option::Option::Some("SPARK_SQL"),
                    Self::Bigquery => std::option::Option::Some("BIGQUERY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Engine {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Engine {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Engine {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SparkSql,
                    2 => Self::Bigquery,
                    _ => Self::UnknownValue(engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Engine {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENGINE_UNSPECIFIED" => Self::Unspecified,
                    "SPARK_SQL" => Self::SparkSql,
                    "BIGQUERY" => Self::Bigquery,
                    _ => Self::UnknownValue(engine::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Engine {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SparkSql => serializer.serialize_i32(1),
                    Self::Bigquery => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Engine {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Engine>::new(
                    ".google.cloud.dataplex.v1.SessionEvent.QueryDetail.Engine",
                ))
            }
        }
    }

    /// The type of the event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Event when the session is assigned to a user.
        Start,
        /// Event for stop of a session.
        Stop,
        /// Query events in the session.
        Query,
        /// Event for creation of a cluster. It is not yet assigned to a user.
        /// This comes before START in the sequence
        Create,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Start => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::Query => std::option::Option::Some(3),
                Self::Create => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::Start => std::option::Option::Some("START"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::Query => std::option::Option::Some("QUERY"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Start,
                2 => Self::Stop,
                3 => Self::Query,
                4 => Self::Create,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "START" => Self::Start,
                "STOP" => Self::Stop,
                "QUERY" => Self::Query,
                "CREATE" => Self::Create,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Start => serializer.serialize_i32(1),
                Self::Stop => serializer.serialize_i32(2),
                Self::Query => serializer.serialize_i32(3),
                Self::Create => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.SessionEvent.EventType",
            ))
        }
    }

    /// Additional information about the Query metadata.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Detail {
        /// The execution details of the query.
        Query(std::boxed::Box<crate::model::session_event::QueryDetail>),
    }
}

/// Payload associated with Governance related log events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GovernanceEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::governance_event::EventType,

    /// Entity resource information if the log event is associated with a
    /// specific entity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity: std::option::Option<crate::model::governance_event::Entity>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GovernanceEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::GovernanceEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::GovernanceEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<crate::model::governance_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::GovernanceEvent::entity].
    pub fn set_entity<
        T: std::convert::Into<std::option::Option<crate::model::governance_event::Entity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity = v.into();
        self
    }
}

impl wkt::message::Message for GovernanceEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GovernanceEvent"
    }
}

/// Defines additional types related to [GovernanceEvent].
pub mod governance_event {
    #[allow(unused_imports)]
    use super::*;

    /// Information about Entity resource that the log event is associated with.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Entity {
        /// The Entity resource the log event is associated with.
        /// Format:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub entity: std::string::String,

        /// Type of entity.
        pub entity_type: crate::model::governance_event::entity::EntityType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Entity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity][crate::model::governance_event::Entity::entity].
        pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity = v.into();
            self
        }

        /// Sets the value of [entity_type][crate::model::governance_event::Entity::entity_type].
        pub fn set_entity_type<
            T: std::convert::Into<crate::model::governance_event::entity::EntityType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.entity_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Entity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.GovernanceEvent.Entity"
        }
    }

    /// Defines additional types related to [Entity].
    pub mod entity {
        #[allow(unused_imports)]
        use super::*;

        /// Type of entity.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EntityType {
            /// An unspecified Entity type.
            Unspecified,
            /// Table entity type.
            Table,
            /// Fileset entity type.
            Fileset,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EntityType::value] or
            /// [EntityType::name].
            UnknownValue(entity_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod entity_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EntityType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Table => std::option::Option::Some(1),
                    Self::Fileset => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENTITY_TYPE_UNSPECIFIED"),
                    Self::Table => std::option::Option::Some("TABLE"),
                    Self::Fileset => std::option::Option::Some("FILESET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EntityType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EntityType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EntityType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Table,
                    2 => Self::Fileset,
                    _ => Self::UnknownValue(entity_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EntityType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENTITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TABLE" => Self::Table,
                    "FILESET" => Self::Fileset,
                    _ => Self::UnknownValue(entity_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EntityType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Table => serializer.serialize_i32(1),
                    Self::Fileset => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EntityType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityType>::new(
                    ".google.cloud.dataplex.v1.GovernanceEvent.Entity.EntityType",
                ))
            }
        }
    }

    /// Type of governance log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Resource IAM policy update event.
        ResourceIamPolicyUpdate,
        /// BigQuery table create event.
        BigqueryTableCreate,
        /// BigQuery table update event.
        BigqueryTableUpdate,
        /// BigQuery table delete event.
        BigqueryTableDelete,
        /// BigQuery connection create event.
        BigqueryConnectionCreate,
        /// BigQuery connection update event.
        BigqueryConnectionUpdate,
        /// BigQuery connection delete event.
        BigqueryConnectionDelete,
        /// BigQuery taxonomy created.
        BigqueryTaxonomyCreate,
        /// BigQuery policy tag created.
        BigqueryPolicyTagCreate,
        /// BigQuery policy tag deleted.
        BigqueryPolicyTagDelete,
        /// BigQuery set iam policy for policy tag.
        BigqueryPolicyTagSetIamPolicy,
        /// Access policy update event.
        AccessPolicyUpdate,
        /// Number of resources matched with particular Query.
        GovernanceRuleMatchedResources,
        /// Rule processing exceeds the allowed limit.
        GovernanceRuleSearchLimitExceeds,
        /// Rule processing errors.
        GovernanceRuleErrors,
        /// Governance rule processing Event.
        GovernanceRuleProcessing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceIamPolicyUpdate => std::option::Option::Some(1),
                Self::BigqueryTableCreate => std::option::Option::Some(2),
                Self::BigqueryTableUpdate => std::option::Option::Some(3),
                Self::BigqueryTableDelete => std::option::Option::Some(4),
                Self::BigqueryConnectionCreate => std::option::Option::Some(5),
                Self::BigqueryConnectionUpdate => std::option::Option::Some(6),
                Self::BigqueryConnectionDelete => std::option::Option::Some(7),
                Self::BigqueryTaxonomyCreate => std::option::Option::Some(10),
                Self::BigqueryPolicyTagCreate => std::option::Option::Some(11),
                Self::BigqueryPolicyTagDelete => std::option::Option::Some(12),
                Self::BigqueryPolicyTagSetIamPolicy => std::option::Option::Some(13),
                Self::AccessPolicyUpdate => std::option::Option::Some(14),
                Self::GovernanceRuleMatchedResources => std::option::Option::Some(15),
                Self::GovernanceRuleSearchLimitExceeds => std::option::Option::Some(16),
                Self::GovernanceRuleErrors => std::option::Option::Some(17),
                Self::GovernanceRuleProcessing => std::option::Option::Some(18),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::ResourceIamPolicyUpdate => {
                    std::option::Option::Some("RESOURCE_IAM_POLICY_UPDATE")
                }
                Self::BigqueryTableCreate => std::option::Option::Some("BIGQUERY_TABLE_CREATE"),
                Self::BigqueryTableUpdate => std::option::Option::Some("BIGQUERY_TABLE_UPDATE"),
                Self::BigqueryTableDelete => std::option::Option::Some("BIGQUERY_TABLE_DELETE"),
                Self::BigqueryConnectionCreate => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_CREATE")
                }
                Self::BigqueryConnectionUpdate => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_UPDATE")
                }
                Self::BigqueryConnectionDelete => {
                    std::option::Option::Some("BIGQUERY_CONNECTION_DELETE")
                }
                Self::BigqueryTaxonomyCreate => {
                    std::option::Option::Some("BIGQUERY_TAXONOMY_CREATE")
                }
                Self::BigqueryPolicyTagCreate => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_CREATE")
                }
                Self::BigqueryPolicyTagDelete => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_DELETE")
                }
                Self::BigqueryPolicyTagSetIamPolicy => {
                    std::option::Option::Some("BIGQUERY_POLICY_TAG_SET_IAM_POLICY")
                }
                Self::AccessPolicyUpdate => std::option::Option::Some("ACCESS_POLICY_UPDATE"),
                Self::GovernanceRuleMatchedResources => {
                    std::option::Option::Some("GOVERNANCE_RULE_MATCHED_RESOURCES")
                }
                Self::GovernanceRuleSearchLimitExceeds => {
                    std::option::Option::Some("GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS")
                }
                Self::GovernanceRuleErrors => std::option::Option::Some("GOVERNANCE_RULE_ERRORS"),
                Self::GovernanceRuleProcessing => {
                    std::option::Option::Some("GOVERNANCE_RULE_PROCESSING")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceIamPolicyUpdate,
                2 => Self::BigqueryTableCreate,
                3 => Self::BigqueryTableUpdate,
                4 => Self::BigqueryTableDelete,
                5 => Self::BigqueryConnectionCreate,
                6 => Self::BigqueryConnectionUpdate,
                7 => Self::BigqueryConnectionDelete,
                10 => Self::BigqueryTaxonomyCreate,
                11 => Self::BigqueryPolicyTagCreate,
                12 => Self::BigqueryPolicyTagDelete,
                13 => Self::BigqueryPolicyTagSetIamPolicy,
                14 => Self::AccessPolicyUpdate,
                15 => Self::GovernanceRuleMatchedResources,
                16 => Self::GovernanceRuleSearchLimitExceeds,
                17 => Self::GovernanceRuleErrors,
                18 => Self::GovernanceRuleProcessing,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_IAM_POLICY_UPDATE" => Self::ResourceIamPolicyUpdate,
                "BIGQUERY_TABLE_CREATE" => Self::BigqueryTableCreate,
                "BIGQUERY_TABLE_UPDATE" => Self::BigqueryTableUpdate,
                "BIGQUERY_TABLE_DELETE" => Self::BigqueryTableDelete,
                "BIGQUERY_CONNECTION_CREATE" => Self::BigqueryConnectionCreate,
                "BIGQUERY_CONNECTION_UPDATE" => Self::BigqueryConnectionUpdate,
                "BIGQUERY_CONNECTION_DELETE" => Self::BigqueryConnectionDelete,
                "BIGQUERY_TAXONOMY_CREATE" => Self::BigqueryTaxonomyCreate,
                "BIGQUERY_POLICY_TAG_CREATE" => Self::BigqueryPolicyTagCreate,
                "BIGQUERY_POLICY_TAG_DELETE" => Self::BigqueryPolicyTagDelete,
                "BIGQUERY_POLICY_TAG_SET_IAM_POLICY" => Self::BigqueryPolicyTagSetIamPolicy,
                "ACCESS_POLICY_UPDATE" => Self::AccessPolicyUpdate,
                "GOVERNANCE_RULE_MATCHED_RESOURCES" => Self::GovernanceRuleMatchedResources,
                "GOVERNANCE_RULE_SEARCH_LIMIT_EXCEEDS" => Self::GovernanceRuleSearchLimitExceeds,
                "GOVERNANCE_RULE_ERRORS" => Self::GovernanceRuleErrors,
                "GOVERNANCE_RULE_PROCESSING" => Self::GovernanceRuleProcessing,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceIamPolicyUpdate => serializer.serialize_i32(1),
                Self::BigqueryTableCreate => serializer.serialize_i32(2),
                Self::BigqueryTableUpdate => serializer.serialize_i32(3),
                Self::BigqueryTableDelete => serializer.serialize_i32(4),
                Self::BigqueryConnectionCreate => serializer.serialize_i32(5),
                Self::BigqueryConnectionUpdate => serializer.serialize_i32(6),
                Self::BigqueryConnectionDelete => serializer.serialize_i32(7),
                Self::BigqueryTaxonomyCreate => serializer.serialize_i32(10),
                Self::BigqueryPolicyTagCreate => serializer.serialize_i32(11),
                Self::BigqueryPolicyTagDelete => serializer.serialize_i32(12),
                Self::BigqueryPolicyTagSetIamPolicy => serializer.serialize_i32(13),
                Self::AccessPolicyUpdate => serializer.serialize_i32(14),
                Self::GovernanceRuleMatchedResources => serializer.serialize_i32(15),
                Self::GovernanceRuleSearchLimitExceeds => serializer.serialize_i32(16),
                Self::GovernanceRuleErrors => serializer.serialize_i32(17),
                Self::GovernanceRuleProcessing => serializer.serialize_i32(18),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.GovernanceEvent.EventType",
            ))
        }
    }
}

/// These messages contain information about the execution of a datascan.
/// The monitored resource is 'DataScan'
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataScanEvent {
    /// The data source of the data scan
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_source: std::string::String,

    /// The identifier of the specific data scan job this log entry is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The time when the data scan job was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the data scan job started to run.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the data scan job finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The type of the data scan.
    #[serde(rename = "type")]
    pub r#type: crate::model::data_scan_event::ScanType,

    /// The status of the data scan job.
    pub state: crate::model::data_scan_event::State,

    /// The message describing the data scan job event.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// A version identifier of the spec which was used to execute this job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub spec_version: std::string::String,

    /// The trigger type of the data scan job.
    pub trigger: crate::model::data_scan_event::Trigger,

    /// The scope of the data scan (e.g. full, incremental).
    pub scope: crate::model::data_scan_event::Scope,

    /// The result of post scan actions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub post_scan_actions_result:
        std::option::Option<crate::model::data_scan_event::PostScanActionsResult>,

    /// The result of the data scan job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub result: std::option::Option<crate::model::data_scan_event::Result>,

    /// The applied configs in the data scan job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub applied_configs: std::option::Option<crate::model::data_scan_event::AppliedConfigs>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataScanEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_source][crate::model::DataScanEvent::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::DataScanEvent::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DataScanEvent::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::DataScanEvent::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::DataScanEvent::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::DataScanEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::data_scan_event::ScanType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DataScanEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::data_scan_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [message][crate::model::DataScanEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [spec_version][crate::model::DataScanEvent::spec_version].
    pub fn set_spec_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.spec_version = v.into();
        self
    }

    /// Sets the value of [trigger][crate::model::DataScanEvent::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::data_scan_event::Trigger>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::DataScanEvent::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::data_scan_event::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// Sets the value of [post_scan_actions_result][crate::model::DataScanEvent::post_scan_actions_result].
    pub fn set_post_scan_actions_result<
        T: std::convert::Into<
                std::option::Option<crate::model::data_scan_event::PostScanActionsResult>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.post_scan_actions_result = v.into();
        self
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_event::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DataScanEvent::result]
    /// if it holds a `DataProfile`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_scan_event::DataProfileResult>>
    {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::Result::DataProfile(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result]
    /// to hold a `DataProfile`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_profile<
        T: std::convert::Into<std::boxed::Box<crate::model::data_scan_event::DataProfileResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan_event::Result::DataProfile(v.into()));
        self
    }

    /// The value of [result][crate::model::DataScanEvent::result]
    /// if it holds a `DataQuality`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::data_scan_event::DataQualityResult>>
    {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::Result::DataQuality(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DataScanEvent::result]
    /// to hold a `DataQuality`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_data_quality<
        T: std::convert::Into<std::boxed::Box<crate::model::data_scan_event::DataQualityResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result =
            std::option::Option::Some(crate::model::data_scan_event::Result::DataQuality(v.into()));
        self
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs].
    ///
    /// Note that all the setters affecting `applied_configs` are mutually
    /// exclusive.
    pub fn set_applied_configs<
        T: std::convert::Into<std::option::Option<crate::model::data_scan_event::AppliedConfigs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = v.into();
        self
    }

    /// The value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// if it holds a `DataProfileConfigs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_profile_configs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
    > {
        #[allow(unreachable_patterns)]
        self.applied_configs.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::AppliedConfigs::DataProfileConfigs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// to hold a `DataProfileConfigs`.
    ///
    /// Note that all the setters affecting `applied_configs` are
    /// mutually exclusive.
    pub fn set_data_profile_configs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = std::option::Option::Some(
            crate::model::data_scan_event::AppliedConfigs::DataProfileConfigs(v.into()),
        );
        self
    }

    /// The value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// if it holds a `DataQualityConfigs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_quality_configs(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
    > {
        #[allow(unreachable_patterns)]
        self.applied_configs.as_ref().and_then(|v| match v {
            crate::model::data_scan_event::AppliedConfigs::DataQualityConfigs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [applied_configs][crate::model::DataScanEvent::applied_configs]
    /// to hold a `DataQualityConfigs`.
    ///
    /// Note that all the setters affecting `applied_configs` are
    /// mutually exclusive.
    pub fn set_data_quality_configs<
        T: std::convert::Into<
                std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.applied_configs = std::option::Option::Some(
            crate::model::data_scan_event::AppliedConfigs::DataQualityConfigs(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DataScanEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent"
    }
}

/// Defines additional types related to [DataScanEvent].
pub mod data_scan_event {
    #[allow(unused_imports)]
    use super::*;

    /// Data profile result for data scan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataProfileResult {
        /// The count of rows processed in the data scan job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub row_count: i64,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataProfileResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_count][crate::model::data_scan_event::DataProfileResult::row_count].
        pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_count = v.into();
            self
        }
    }

    impl wkt::message::Message for DataProfileResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataProfileResult"
        }
    }

    /// Data quality result for data scan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataQualityResult {
        /// The count of rows processed in the data scan job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub row_count: i64,

        /// Whether the data quality result was `pass` or not.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub passed: bool,

        /// The result of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the bool value depicting whether the dimension result was
        /// `pass` or not.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub dimension_passed: std::collections::HashMap<std::string::String, bool>,

        /// The table-level data quality score for the data scan job.
        ///
        /// The data quality score ranges between [0, 100] (up to two decimal
        /// points).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F32")]
        pub score: f32,

        /// The score of each dimension for data quality result.
        /// The key of the map is the name of the dimension.
        /// The value is the data quality score for the dimension.
        ///
        /// The score ranges between [0, 100] (up to two decimal
        /// points).
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F32>")]
        pub dimension_score: std::collections::HashMap<std::string::String, f32>,

        /// The score of each column scanned in the data scan job.
        /// The key of the map is the name of the column.
        /// The value is the data quality score for the column.
        ///
        /// The score ranges between [0, 100] (up to two decimal
        /// points).
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F32>")]
        pub column_score: std::collections::HashMap<std::string::String, f32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataQualityResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_count][crate::model::data_scan_event::DataQualityResult::row_count].
        pub fn set_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.row_count = v.into();
            self
        }

        /// Sets the value of [passed][crate::model::data_scan_event::DataQualityResult::passed].
        pub fn set_passed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.passed = v.into();
            self
        }

        /// Sets the value of [dimension_passed][crate::model::data_scan_event::DataQualityResult::dimension_passed].
        pub fn set_dimension_passed<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<bool>,
        {
            use std::iter::Iterator;
            self.dimension_passed = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [score][crate::model::data_scan_event::DataQualityResult::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [dimension_score][crate::model::data_scan_event::DataQualityResult::dimension_score].
        pub fn set_dimension_score<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.dimension_score = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [column_score][crate::model::data_scan_event::DataQualityResult::column_score].
        pub fn set_column_score<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f32>,
        {
            use std::iter::Iterator;
            self.column_score = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for DataQualityResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataQualityResult"
        }
    }

    /// Applied configs for data profile type data scan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataProfileAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F32")]
        pub sampling_percent: f32,

        /// Boolean indicating whether a row filter was applied in the DataScan job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub row_filter_applied: bool,

        /// Boolean indicating whether a column filter was applied in the DataScan
        /// job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub column_filter_applied: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataProfileAppliedConfigs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampling_percent][crate::model::data_scan_event::DataProfileAppliedConfigs::sampling_percent].
        pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sampling_percent = v.into();
            self
        }

        /// Sets the value of [row_filter_applied][crate::model::data_scan_event::DataProfileAppliedConfigs::row_filter_applied].
        pub fn set_row_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.row_filter_applied = v.into();
            self
        }

        /// Sets the value of [column_filter_applied][crate::model::data_scan_event::DataProfileAppliedConfigs::column_filter_applied].
        pub fn set_column_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.column_filter_applied = v.into();
            self
        }
    }

    impl wkt::message::Message for DataProfileAppliedConfigs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataProfileAppliedConfigs"
        }
    }

    /// Applied configs for data quality type data scan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataQualityAppliedConfigs {
        /// The percentage of the records selected from the dataset for DataScan.
        ///
        /// * Value ranges between 0.0 and 100.0.
        /// * Value 0.0 or 100.0 imply that sampling was not applied.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::F32")]
        pub sampling_percent: f32,

        /// Boolean indicating whether a row filter was applied in the DataScan job.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub row_filter_applied: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataQualityAppliedConfigs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampling_percent][crate::model::data_scan_event::DataQualityAppliedConfigs::sampling_percent].
        pub fn set_sampling_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.sampling_percent = v.into();
            self
        }

        /// Sets the value of [row_filter_applied][crate::model::data_scan_event::DataQualityAppliedConfigs::row_filter_applied].
        pub fn set_row_filter_applied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.row_filter_applied = v.into();
            self
        }
    }

    impl wkt::message::Message for DataQualityAppliedConfigs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.DataQualityAppliedConfigs"
        }
    }

    /// Post scan actions result for data scan job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PostScanActionsResult {
        /// The result of BigQuery export post scan action.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery_export_result: std::option::Option<
            crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult,
        >,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PostScanActionsResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bigquery_export_result][crate::model::data_scan_event::PostScanActionsResult::bigquery_export_result].
        pub fn set_bigquery_export_result<T: std::convert::Into<std::option::Option<crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult>>>(mut self, v: T) -> Self{
            self.bigquery_export_result = v.into();
            self
        }
    }

    impl wkt::message::Message for PostScanActionsResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult"
        }
    }

    /// Defines additional types related to [PostScanActionsResult].
    pub mod post_scan_actions_result {
        #[allow(unused_imports)]
        use super::*;

        /// The result of BigQuery export post scan action.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BigQueryExportResult {

            /// Execution state for the BigQuery exporting.
            pub state: crate::model::data_scan_event::post_scan_actions_result::big_query_export_result::State,

            /// Additional information about the BigQuery exporting.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub message: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BigQueryExportResult {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [state][crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult::state].
            pub fn set_state<T: std::convert::Into<crate::model::data_scan_event::post_scan_actions_result::big_query_export_result::State>>(mut self, v: T) -> Self{
                self.state = v.into();
                self
            }

            /// Sets the value of [message][crate::model::data_scan_event::post_scan_actions_result::BigQueryExportResult::message].
            pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.message = v.into();
                self
            }
        }

        impl wkt::message::Message for BigQueryExportResult {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult.BigQueryExportResult"
            }
        }

        /// Defines additional types related to [BigQueryExportResult].
        pub mod big_query_export_result {
            #[allow(unused_imports)]
            use super::*;

            /// Execution state for the exporting.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum State {
                /// The exporting state is unspecified.
                Unspecified,
                /// The exporting completed successfully.
                Succeeded,
                /// The exporting is no longer running due to an error.
                Failed,
                /// The exporting is skipped due to no valid scan result to export
                /// (usually caused by scan failed).
                Skipped,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [State::value] or
                /// [State::name].
                UnknownValue(state::UnknownValue),
            }

            #[doc(hidden)]
            pub mod state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl State {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Succeeded => std::option::Option::Some(1),
                        Self::Failed => std::option::Option::Some(2),
                        Self::Skipped => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                        Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                        Self::Failed => std::option::Option::Some("FAILED"),
                        Self::Skipped => std::option::Option::Some("SKIPPED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for State {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for State {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for State {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Succeeded,
                        2 => Self::Failed,
                        3 => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for State {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "STATE_UNSPECIFIED" => Self::Unspecified,
                        "SUCCEEDED" => Self::Succeeded,
                        "FAILED" => Self::Failed,
                        "SKIPPED" => Self::Skipped,
                        _ => Self::UnknownValue(state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for State {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Succeeded => serializer.serialize_i32(1),
                        Self::Failed => serializer.serialize_i32(2),
                        Self::Skipped => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for State {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                        ".google.cloud.dataplex.v1.DataScanEvent.PostScanActionsResult.BigQueryExportResult.State"))
                }
            }
        }
    }

    /// The type of the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ScanType {
        /// An unspecified data scan type.
        Unspecified,
        /// Data scan for data profile.
        DataProfile,
        /// Data scan for data quality.
        DataQuality,
        /// Data scan for data discovery.
        DataDiscovery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ScanType::value] or
        /// [ScanType::name].
        UnknownValue(scan_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scan_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ScanType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DataProfile => std::option::Option::Some(1),
                Self::DataQuality => std::option::Option::Some(2),
                Self::DataDiscovery => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCAN_TYPE_UNSPECIFIED"),
                Self::DataProfile => std::option::Option::Some("DATA_PROFILE"),
                Self::DataQuality => std::option::Option::Some("DATA_QUALITY"),
                Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ScanType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ScanType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ScanType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DataProfile,
                2 => Self::DataQuality,
                4 => Self::DataDiscovery,
                _ => Self::UnknownValue(scan_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ScanType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCAN_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DATA_PROFILE" => Self::DataProfile,
                "DATA_QUALITY" => Self::DataQuality,
                "DATA_DISCOVERY" => Self::DataDiscovery,
                _ => Self::UnknownValue(scan_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ScanType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DataProfile => serializer.serialize_i32(1),
                Self::DataQuality => serializer.serialize_i32(2),
                Self::DataDiscovery => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ScanType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ScanType>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.ScanType",
            ))
        }
    }

    /// The job state of the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified job state.
        Unspecified,
        /// Data scan job started.
        Started,
        /// Data scan job successfully completed.
        Succeeded,
        /// Data scan job was unsuccessful.
        Failed,
        /// Data scan job was cancelled.
        Cancelled,
        /// Data scan job was createed.
        Created,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Created => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Created => std::option::Option::Some("CREATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Started,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelled,
                5 => Self::Created,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                "CREATED" => Self::Created,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Created => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.State",
            ))
        }
    }

    /// The trigger type for the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// An unspecified trigger type.
        Unspecified,
        /// Data scan triggers on demand.
        OnDemand,
        /// Data scan triggers as per schedule.
        Schedule,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Schedule => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Schedule => std::option::Option::Some("SCHEDULE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Schedule,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "SCHEDULE" => Self::Schedule,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Schedule => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.Trigger",
            ))
        }
    }

    /// The scope of job for the data scan.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// An unspecified scope type.
        Unspecified,
        /// Data scan runs on all of the data.
        Full,
        /// Data scan runs on incremental data.
        Incremental,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::Incremental => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Full,
                2 => Self::Incremental,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "FULL" => Self::Full,
                "INCREMENTAL" => Self::Incremental,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::Incremental => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.cloud.dataplex.v1.DataScanEvent.Scope",
            ))
        }
    }

    /// The result of the data scan job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Result {
        /// Data profile result for data profile type data scan.
        DataProfile(std::boxed::Box<crate::model::data_scan_event::DataProfileResult>),
        /// Data quality result for data quality type data scan.
        DataQuality(std::boxed::Box<crate::model::data_scan_event::DataQualityResult>),
    }

    /// The applied configs in the data scan job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AppliedConfigs {
        /// Applied configs for data profile type data scan.
        DataProfileConfigs(
            std::boxed::Box<crate::model::data_scan_event::DataProfileAppliedConfigs>,
        ),
        /// Applied configs for data quality type data scan.
        DataQualityConfigs(
            std::boxed::Box<crate::model::data_scan_event::DataQualityAppliedConfigs>,
        ),
    }
}

/// Information about the result of a data quality rule for data quality scan.
/// The monitored resource is 'DataScan'.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataQualityScanRuleResult {
    /// Identifier of the specific data scan job this log entry is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// The data source of the data scan (e.g. BigQuery table name).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_source: std::string::String,

    /// The column which this rule is evaluated against.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub column: std::string::String,

    /// The name of the data quality rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_name: std::string::String,

    /// The type of the data quality rule.
    pub rule_type: crate::model::data_quality_scan_rule_result::RuleType,

    /// The evaluation type of the data quality rule.
    pub evalution_type: crate::model::data_quality_scan_rule_result::EvaluationType,

    /// The dimension of the data quality rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rule_dimension: std::string::String,

    /// The passing threshold ([0.0, 100.0]) of the data quality rule.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub threshold_percent: f64,

    /// The result of the data quality rule.
    pub result: crate::model::data_quality_scan_rule_result::Result,

    /// The number of rows evaluated against the data quality rule.
    /// This field is only valid for rules of PER_ROW evaluation type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub evaluated_row_count: i64,

    /// The number of rows which passed a rule evaluation.
    /// This field is only valid for rules of PER_ROW evaluation type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub passed_row_count: i64,

    /// The number of rows with null values in the specified column.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub null_row_count: i64,

    /// The number of rows returned by the SQL statement in a SQL assertion rule.
    /// This field is only valid for SQL assertion rules.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub assertion_row_count: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataQualityScanRuleResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_id][crate::model::DataQualityScanRuleResult::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [data_source][crate::model::DataQualityScanRuleResult::data_source].
    pub fn set_data_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_source = v.into();
        self
    }

    /// Sets the value of [column][crate::model::DataQualityScanRuleResult::column].
    pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.column = v.into();
        self
    }

    /// Sets the value of [rule_name][crate::model::DataQualityScanRuleResult::rule_name].
    pub fn set_rule_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_name = v.into();
        self
    }

    /// Sets the value of [rule_type][crate::model::DataQualityScanRuleResult::rule_type].
    pub fn set_rule_type<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::RuleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule_type = v.into();
        self
    }

    /// Sets the value of [evalution_type][crate::model::DataQualityScanRuleResult::evalution_type].
    pub fn set_evalution_type<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::EvaluationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evalution_type = v.into();
        self
    }

    /// Sets the value of [rule_dimension][crate::model::DataQualityScanRuleResult::rule_dimension].
    pub fn set_rule_dimension<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rule_dimension = v.into();
        self
    }

    /// Sets the value of [threshold_percent][crate::model::DataQualityScanRuleResult::threshold_percent].
    pub fn set_threshold_percent<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.threshold_percent = v.into();
        self
    }

    /// Sets the value of [result][crate::model::DataQualityScanRuleResult::result].
    pub fn set_result<
        T: std::convert::Into<crate::model::data_quality_scan_rule_result::Result>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [evaluated_row_count][crate::model::DataQualityScanRuleResult::evaluated_row_count].
    pub fn set_evaluated_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.evaluated_row_count = v.into();
        self
    }

    /// Sets the value of [passed_row_count][crate::model::DataQualityScanRuleResult::passed_row_count].
    pub fn set_passed_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.passed_row_count = v.into();
        self
    }

    /// Sets the value of [null_row_count][crate::model::DataQualityScanRuleResult::null_row_count].
    pub fn set_null_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.null_row_count = v.into();
        self
    }

    /// Sets the value of [assertion_row_count][crate::model::DataQualityScanRuleResult::assertion_row_count].
    pub fn set_assertion_row_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.assertion_row_count = v.into();
        self
    }
}

impl wkt::message::Message for DataQualityScanRuleResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataQualityScanRuleResult"
    }
}

/// Defines additional types related to [DataQualityScanRuleResult].
pub mod data_quality_scan_rule_result {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the data quality rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RuleType {
        /// An unspecified rule type.
        Unspecified,
        /// See
        /// [DataQualityRule.NonNullExpectation][google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.NonNullExpectation]: crate::model::data_quality_rule::NonNullExpectation
        NonNullExpectation,
        /// See
        /// [DataQualityRule.RangeExpectation][google.cloud.dataplex.v1.DataQualityRule.RangeExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RangeExpectation]: crate::model::data_quality_rule::RangeExpectation
        RangeExpectation,
        /// See
        /// [DataQualityRule.RegexExpectation][google.cloud.dataplex.v1.DataQualityRule.RegexExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RegexExpectation]: crate::model::data_quality_rule::RegexExpectation
        RegexExpectation,
        /// See
        /// [DataQualityRule.RowConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.RowConditionExpectation]: crate::model::data_quality_rule::RowConditionExpectation
        RowConditionExpectation,
        /// See
        /// [DataQualityRule.SetExpectation][google.cloud.dataplex.v1.DataQualityRule.SetExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.SetExpectation]: crate::model::data_quality_rule::SetExpectation
        SetExpectation,
        /// See
        /// [DataQualityRule.StatisticRangeExpectation][google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.StatisticRangeExpectation]: crate::model::data_quality_rule::StatisticRangeExpectation
        StatisticRangeExpectation,
        /// See
        /// [DataQualityRule.TableConditionExpectation][google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.TableConditionExpectation]: crate::model::data_quality_rule::TableConditionExpectation
        TableConditionExpectation,
        /// See
        /// [DataQualityRule.UniquenessExpectation][google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.UniquenessExpectation]: crate::model::data_quality_rule::UniquenessExpectation
        UniquenessExpectation,
        /// See
        /// [DataQualityRule.SqlAssertion][google.cloud.dataplex.v1.DataQualityRule.SqlAssertion].
        ///
        /// [google.cloud.dataplex.v1.DataQualityRule.SqlAssertion]: crate::model::data_quality_rule::SqlAssertion
        SqlAssertion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RuleType::value] or
        /// [RuleType::name].
        UnknownValue(rule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RuleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NonNullExpectation => std::option::Option::Some(1),
                Self::RangeExpectation => std::option::Option::Some(2),
                Self::RegexExpectation => std::option::Option::Some(3),
                Self::RowConditionExpectation => std::option::Option::Some(4),
                Self::SetExpectation => std::option::Option::Some(5),
                Self::StatisticRangeExpectation => std::option::Option::Some(6),
                Self::TableConditionExpectation => std::option::Option::Some(7),
                Self::UniquenessExpectation => std::option::Option::Some(8),
                Self::SqlAssertion => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RULE_TYPE_UNSPECIFIED"),
                Self::NonNullExpectation => std::option::Option::Some("NON_NULL_EXPECTATION"),
                Self::RangeExpectation => std::option::Option::Some("RANGE_EXPECTATION"),
                Self::RegexExpectation => std::option::Option::Some("REGEX_EXPECTATION"),
                Self::RowConditionExpectation => {
                    std::option::Option::Some("ROW_CONDITION_EXPECTATION")
                }
                Self::SetExpectation => std::option::Option::Some("SET_EXPECTATION"),
                Self::StatisticRangeExpectation => {
                    std::option::Option::Some("STATISTIC_RANGE_EXPECTATION")
                }
                Self::TableConditionExpectation => {
                    std::option::Option::Some("TABLE_CONDITION_EXPECTATION")
                }
                Self::UniquenessExpectation => std::option::Option::Some("UNIQUENESS_EXPECTATION"),
                Self::SqlAssertion => std::option::Option::Some("SQL_ASSERTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RuleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RuleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RuleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NonNullExpectation,
                2 => Self::RangeExpectation,
                3 => Self::RegexExpectation,
                4 => Self::RowConditionExpectation,
                5 => Self::SetExpectation,
                6 => Self::StatisticRangeExpectation,
                7 => Self::TableConditionExpectation,
                8 => Self::UniquenessExpectation,
                9 => Self::SqlAssertion,
                _ => Self::UnknownValue(rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RuleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NON_NULL_EXPECTATION" => Self::NonNullExpectation,
                "RANGE_EXPECTATION" => Self::RangeExpectation,
                "REGEX_EXPECTATION" => Self::RegexExpectation,
                "ROW_CONDITION_EXPECTATION" => Self::RowConditionExpectation,
                "SET_EXPECTATION" => Self::SetExpectation,
                "STATISTIC_RANGE_EXPECTATION" => Self::StatisticRangeExpectation,
                "TABLE_CONDITION_EXPECTATION" => Self::TableConditionExpectation,
                "UNIQUENESS_EXPECTATION" => Self::UniquenessExpectation,
                "SQL_ASSERTION" => Self::SqlAssertion,
                _ => Self::UnknownValue(rule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RuleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NonNullExpectation => serializer.serialize_i32(1),
                Self::RangeExpectation => serializer.serialize_i32(2),
                Self::RegexExpectation => serializer.serialize_i32(3),
                Self::RowConditionExpectation => serializer.serialize_i32(4),
                Self::SetExpectation => serializer.serialize_i32(5),
                Self::StatisticRangeExpectation => serializer.serialize_i32(6),
                Self::TableConditionExpectation => serializer.serialize_i32(7),
                Self::UniquenessExpectation => serializer.serialize_i32(8),
                Self::SqlAssertion => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RuleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RuleType>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.RuleType",
            ))
        }
    }

    /// The evaluation type of the data quality rule.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationType {
        /// An unspecified evaluation type.
        Unspecified,
        /// The rule evaluation is done at per row level.
        PerRow,
        /// The rule evaluation is done for an aggregate of rows.
        Aggregate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationType::value] or
        /// [EvaluationType::name].
        UnknownValue(evaluation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PerRow => std::option::Option::Some(1),
                Self::Aggregate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_TYPE_UNSPECIFIED"),
                Self::PerRow => std::option::Option::Some("PER_ROW"),
                Self::Aggregate => std::option::Option::Some("AGGREGATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PerRow,
                2 => Self::Aggregate,
                _ => Self::UnknownValue(evaluation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PER_ROW" => Self::PerRow,
                "AGGREGATE" => Self::Aggregate,
                _ => Self::UnknownValue(evaluation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PerRow => serializer.serialize_i32(1),
                Self::Aggregate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationType>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.EvaluationType",
            ))
        }
    }

    /// Whether the data quality rule passed or failed.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// An unspecified result.
        Unspecified,
        /// The data quality rule passed.
        Passed,
        /// The data quality rule failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Passed => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Passed,
                2 => Self::Failed,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Passed => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.cloud.dataplex.v1.DataQualityScanRuleResult.Result",
            ))
        }
    }
}

/// Payload associated with Business Glossary related log events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BusinessGlossaryEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::business_glossary_event::EventType,

    /// Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BusinessGlossaryEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::BusinessGlossaryEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::BusinessGlossaryEvent::event_type].
    pub fn set_event_type<
        T: std::convert::Into<crate::model::business_glossary_event::EventType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::BusinessGlossaryEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for BusinessGlossaryEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.BusinessGlossaryEvent"
    }
}

/// Defines additional types related to [BusinessGlossaryEvent].
pub mod business_glossary_event {
    #[allow(unused_imports)]
    use super::*;

    /// Type of glossary log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// Glossary create event.
        GlossaryCreate,
        /// Glossary update event.
        GlossaryUpdate,
        /// Glossary delete event.
        GlossaryDelete,
        /// Glossary category create event.
        GlossaryCategoryCreate,
        /// Glossary category update event.
        GlossaryCategoryUpdate,
        /// Glossary category delete event.
        GlossaryCategoryDelete,
        /// Glossary term create event.
        GlossaryTermCreate,
        /// Glossary term update event.
        GlossaryTermUpdate,
        /// Glossary term delete event.
        GlossaryTermDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GlossaryCreate => std::option::Option::Some(1),
                Self::GlossaryUpdate => std::option::Option::Some(2),
                Self::GlossaryDelete => std::option::Option::Some(3),
                Self::GlossaryCategoryCreate => std::option::Option::Some(4),
                Self::GlossaryCategoryUpdate => std::option::Option::Some(5),
                Self::GlossaryCategoryDelete => std::option::Option::Some(6),
                Self::GlossaryTermCreate => std::option::Option::Some(7),
                Self::GlossaryTermUpdate => std::option::Option::Some(8),
                Self::GlossaryTermDelete => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::GlossaryCreate => std::option::Option::Some("GLOSSARY_CREATE"),
                Self::GlossaryUpdate => std::option::Option::Some("GLOSSARY_UPDATE"),
                Self::GlossaryDelete => std::option::Option::Some("GLOSSARY_DELETE"),
                Self::GlossaryCategoryCreate => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_CREATE")
                }
                Self::GlossaryCategoryUpdate => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_UPDATE")
                }
                Self::GlossaryCategoryDelete => {
                    std::option::Option::Some("GLOSSARY_CATEGORY_DELETE")
                }
                Self::GlossaryTermCreate => std::option::Option::Some("GLOSSARY_TERM_CREATE"),
                Self::GlossaryTermUpdate => std::option::Option::Some("GLOSSARY_TERM_UPDATE"),
                Self::GlossaryTermDelete => std::option::Option::Some("GLOSSARY_TERM_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GlossaryCreate,
                2 => Self::GlossaryUpdate,
                3 => Self::GlossaryDelete,
                4 => Self::GlossaryCategoryCreate,
                5 => Self::GlossaryCategoryUpdate,
                6 => Self::GlossaryCategoryDelete,
                7 => Self::GlossaryTermCreate,
                8 => Self::GlossaryTermUpdate,
                9 => Self::GlossaryTermDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GLOSSARY_CREATE" => Self::GlossaryCreate,
                "GLOSSARY_UPDATE" => Self::GlossaryUpdate,
                "GLOSSARY_DELETE" => Self::GlossaryDelete,
                "GLOSSARY_CATEGORY_CREATE" => Self::GlossaryCategoryCreate,
                "GLOSSARY_CATEGORY_UPDATE" => Self::GlossaryCategoryUpdate,
                "GLOSSARY_CATEGORY_DELETE" => Self::GlossaryCategoryDelete,
                "GLOSSARY_TERM_CREATE" => Self::GlossaryTermCreate,
                "GLOSSARY_TERM_UPDATE" => Self::GlossaryTermUpdate,
                "GLOSSARY_TERM_DELETE" => Self::GlossaryTermDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GlossaryCreate => serializer.serialize_i32(1),
                Self::GlossaryUpdate => serializer.serialize_i32(2),
                Self::GlossaryDelete => serializer.serialize_i32(3),
                Self::GlossaryCategoryCreate => serializer.serialize_i32(4),
                Self::GlossaryCategoryUpdate => serializer.serialize_i32(5),
                Self::GlossaryCategoryDelete => serializer.serialize_i32(6),
                Self::GlossaryTermCreate => serializer.serialize_i32(7),
                Self::GlossaryTermUpdate => serializer.serialize_i32(8),
                Self::GlossaryTermDelete => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.BusinessGlossaryEvent.EventType",
            ))
        }
    }
}

/// Payload associated with Entry related log events.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EntryLinkEvent {
    /// The log message.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::entry_link_event::EventType,

    /// Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub resource: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EntryLinkEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::EntryLinkEvent::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::EntryLinkEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<crate::model::entry_link_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::EntryLinkEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for EntryLinkEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.EntryLinkEvent"
    }
}

/// Defines additional types related to [EntryLinkEvent].
pub mod entry_link_event {
    #[allow(unused_imports)]
    use super::*;

    /// Type of entry link log event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// An unspecified event type.
        Unspecified,
        /// EntryLink create event.
        EntryLinkCreate,
        /// EntryLink delete event.
        EntryLinkDelete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EntryLinkCreate => std::option::Option::Some(1),
                Self::EntryLinkDelete => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::EntryLinkCreate => std::option::Option::Some("ENTRY_LINK_CREATE"),
                Self::EntryLinkDelete => std::option::Option::Some("ENTRY_LINK_DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EntryLinkCreate,
                2 => Self::EntryLinkDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ENTRY_LINK_CREATE" => Self::EntryLinkCreate,
                "ENTRY_LINK_DELETE" => Self::EntryLinkDelete,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EntryLinkCreate => serializer.serialize_i32(1),
                Self::EntryLinkDelete => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.dataplex.v1.EntryLinkEvent.EventType",
            ))
        }
    }
}

/// Create a metadata entity request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntityRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Entity resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity: std::option::Option<crate::model::Entity>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::CreateEntityRequest::entity].
    pub fn set_entity<T: std::convert::Into<std::option::Option<crate::model::Entity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEntityRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEntityRequest"
    }
}

/// Update a metadata entity request.
/// The exiting entity will be fully replaced by the entity in the request.
/// The entity ID is mutable. To modify the ID, use the current entity ID in the
/// request URL and specify the new ID in the request body.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntityRequest {
    /// Required. Update description.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entity: std::option::Option<crate::model::Entity>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity][crate::model::UpdateEntityRequest::entity].
    pub fn set_entity<T: std::convert::Into<std::option::Option<crate::model::Entity>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEntityRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEntityRequest"
    }
}

/// Delete a metadata entity request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteEntityRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEntityRequest"
    }
}

/// List metadata entities request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitiesRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Specify the entity view to make a partial list request.
    pub view: crate::model::list_entities_request::EntityView,

    /// Optional. Maximum number of entities to return. The service may return
    /// fewer than this value. If unspecified, 100 entities will be returned by
    /// default. The maximum value is 500; larger values will will be truncated to
    /// 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEntities` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListEntities` must match the call that provided the
    /// page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The following filter parameters can be added to the URL to limit
    /// the entities returned by the API:
    ///
    /// - Entity ID: ?filter="id=entityID"
    /// - Asset ID: ?filter="asset=assetID"
    /// - Data path ?filter="data_path=gs://my-bucket"
    /// - Is HIVE compatible: ?filter="hive_compatible=true"
    /// - Is BigQuery compatible: ?filter="bigquery_compatible=true"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListEntitiesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::list_entities_request::EntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntitiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntitiesRequest"
    }
}

/// Defines additional types related to [ListEntitiesRequest].
pub mod list_entities_request {
    #[allow(unused_imports)]
    use super::*;

    /// Entity views.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityView {
        /// The default unset value. Return both table and fileset entities
        /// if unspecified.
        Unspecified,
        /// Only list table entities.
        Tables,
        /// Only list fileset entities.
        Filesets,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityView::value] or
        /// [EntityView::name].
        UnknownValue(entity_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tables => std::option::Option::Some(1),
                Self::Filesets => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_VIEW_UNSPECIFIED"),
                Self::Tables => std::option::Option::Some("TABLES"),
                Self::Filesets => std::option::Option::Some("FILESETS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tables,
                2 => Self::Filesets,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
                "TABLES" => Self::Tables,
                "FILESETS" => Self::Filesets,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tables => serializer.serialize_i32(1),
                Self::Filesets => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityView>::new(
                ".google.cloud.dataplex.v1.ListEntitiesRequest.EntityView",
            ))
        }
    }
}

/// List metadata entities response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitiesResponse {
    /// Entities in the specified parent zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entities: std::vec::Vec<crate::model::Entity>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entities][crate::model::ListEntitiesResponse::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEntitiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitiesResponse {
    type PageItem = crate::model::Entity;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entities
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get metadata entity request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntityRequest {
    /// Required. The resource name of the entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}.`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Used to select the subset of entity information to return.
    /// Defaults to `BASIC`.
    pub view: crate::model::get_entity_request::EntityView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetEntityRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_entity_request::EntityView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetEntityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEntityRequest"
    }
}

/// Defines additional types related to [GetEntityRequest].
pub mod get_entity_request {
    #[allow(unused_imports)]
    use super::*;

    /// Entity views for get entity partial result.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityView {
        /// The API will default to the `BASIC` view.
        Unspecified,
        /// Minimal view that does not include the schema.
        Basic,
        /// Include basic information and schema.
        Schema,
        /// Include everything. Currently, this is the same as the SCHEMA view.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityView::value] or
        /// [EntityView::name].
        UnknownValue(entity_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod entity_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EntityView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Schema => std::option::Option::Some(2),
                Self::Full => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Schema => std::option::Option::Some("SCHEMA"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EntityView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EntityView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EntityView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Schema,
                4 => Self::Full,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EntityView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "SCHEMA" => Self::Schema,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(entity_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EntityView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Schema => serializer.serialize_i32(2),
                Self::Full => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EntityView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityView>::new(
                ".google.cloud.dataplex.v1.GetEntityRequest.EntityView",
            ))
        }
    }
}

/// List metadata partitions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPartitionsRequest {
    /// Required. The resource name of the parent entity:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of partitions to return. The service may return
    /// fewer than this value. If unspecified, 100 partitions will be returned by
    /// default. The maximum page size is 500; larger values will will be truncated
    /// to 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListPartitions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListPartitions` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter the partitions returned to the caller using a key value
    /// pair expression. Supported operators and syntax:
    ///
    /// - logic operators: AND, OR
    /// - comparison operators: <, >, >=, <= ,=, !=
    /// - LIKE operators:
    ///   - The right hand of a LIKE operator supports "." and
    ///     "*" for wildcard searches, for example "value1 LIKE ".*oo.*"
    /// - parenthetical grouping: ( )
    ///
    /// Sample filter expression: `?filter="key1 < value1 OR key2 > value2"
    ///
    /// **Notes:**
    ///
    /// - Keys to the left of operators are case insensitive.
    /// - Partition results are sorted first by creation time, then by
    ///   lexicographic order.
    /// - Up to 20 key value filter pairs are allowed, but due to performance
    ///   considerations, only the first 10 will be used as a filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPartitionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPartitionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPartitionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPartitionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPartitionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListPartitionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListPartitionsRequest"
    }
}

/// Create metadata partition request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePartitionRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Partition resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub partition: std::option::Option<crate::model::Partition>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePartitionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [partition][crate::model::CreatePartitionRequest::partition].
    pub fn set_partition<T: std::convert::Into<std::option::Option<crate::model::Partition>>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreatePartitionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreatePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreatePartitionRequest"
    }
}

/// Delete metadata partition request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePartitionRequest {
    /// Required. The resource name of the partition.
    /// format:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The etag associated with the partition.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeletePartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeletePartitionRequest::etag].
    #[deprecated]
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeletePartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeletePartitionRequest"
    }
}

/// List metadata partitions response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPartitionsResponse {
    /// Partitions under the specified parent entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partitions: std::vec::Vec<crate::model::Partition>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// remaining results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListPartitionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [partitions][crate::model::ListPartitionsResponse::partitions].
    pub fn set_partitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Partition>,
    {
        use std::iter::Iterator;
        self.partitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPartitionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListPartitionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListPartitionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPartitionsResponse {
    type PageItem = crate::model::Partition;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.partitions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get metadata partition request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPartitionRequest {
    /// Required. The resource name of the partition:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}/partitions/{partition_value_path}`.
    /// The {partition_value_path} segment consists of an ordered sequence of
    /// partition values separated by "/". All values must be provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetPartitionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPartitionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPartitionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetPartitionRequest"
    }
}

/// Represents tables and fileset metadata contained within a zone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entity {
    /// Output only. The resource name of the entity, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Display name must be shorter than or equal to 256 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Optional. User friendly longer description text. Must be shorter than or
    /// equal to 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The time when the entity was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the entity was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. A user-provided entity ID. It is mutable, and will be used as the
    /// published table name. Specifying a new ID in an update entity
    /// request will override the existing value.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and
    /// underscores, and consist of 256 or fewer characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Optional. The etag associated with the entity, which can be retrieved with
    /// a [GetEntity][] request. Required for update and delete requests.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Required. Immutable. The type of entity.
    #[serde(rename = "type")]
    pub r#type: crate::model::entity::Type,

    /// Required. Immutable. The ID of the asset associated with the storage
    /// location containing the entity data. The entity must be with in the same
    /// zone with the asset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset: std::string::String,

    /// Required. Immutable. The storage path of the entity data.
    /// For Cloud Storage data, this is the fully-qualified path to the entity,
    /// such as `gs://bucket/path/to/data`. For BigQuery data, this is the name of
    /// the table resource, such as
    /// `projects/project_id/datasets/dataset_id/tables/table_id`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_path: std::string::String,

    /// Optional. The set of items within the data path constituting the data in
    /// the entity, represented as a glob path. Example:
    /// `gs://bucket/path/to/data/**/*.csv`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub data_path_pattern: std::string::String,

    /// Output only. The name of the associated Data Catalog entry.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub catalog_entry: std::string::String,

    /// Required. Immutable. Identifies the storage system of the entity data.
    pub system: crate::model::StorageSystem,

    /// Required. Identifies the storage format of the entity data.
    /// It does not apply to entities with data stored in BigQuery.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub format: std::option::Option<crate::model::StorageFormat>,

    /// Output only. Metadata stores that the entity is compatible with.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compatibility: std::option::Option<crate::model::entity::CompatibilityStatus>,

    /// Output only. Identifies the access mechanism to the entity. Not user
    /// settable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub access: std::option::Option<crate::model::StorageAccess>,

    /// Output only. System generated unique ID for the Entity. This ID will be
    /// different if the Entity is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Required. The description of the data structure and layout.
    /// The schema is not included in list responses. It is only included in
    /// `SCHEMA` and `FULL` entity views of a `GetEntity` response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schema: std::option::Option<crate::model::Schema>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entity::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Entity::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Entity::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entity::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Entity::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Entity::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Entity::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Entity::type].
    pub fn set_type<T: std::convert::Into<crate::model::entity::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::Entity::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_path][crate::model::Entity::data_path].
    pub fn set_data_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_path = v.into();
        self
    }

    /// Sets the value of [data_path_pattern][crate::model::Entity::data_path_pattern].
    pub fn set_data_path_pattern<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_path_pattern = v.into();
        self
    }

    /// Sets the value of [catalog_entry][crate::model::Entity::catalog_entry].
    pub fn set_catalog_entry<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog_entry = v.into();
        self
    }

    /// Sets the value of [system][crate::model::Entity::system].
    pub fn set_system<T: std::convert::Into<crate::model::StorageSystem>>(mut self, v: T) -> Self {
        self.system = v.into();
        self
    }

    /// Sets the value of [format][crate::model::Entity::format].
    pub fn set_format<T: std::convert::Into<std::option::Option<crate::model::StorageFormat>>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [compatibility][crate::model::Entity::compatibility].
    pub fn set_compatibility<
        T: std::convert::Into<std::option::Option<crate::model::entity::CompatibilityStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compatibility = v.into();
        self
    }

    /// Sets the value of [access][crate::model::Entity::access].
    pub fn set_access<T: std::convert::Into<std::option::Option<crate::model::StorageAccess>>>(
        mut self,
        v: T,
    ) -> Self {
        self.access = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Entity::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Entity::schema].
    pub fn set_schema<T: std::convert::Into<std::option::Option<crate::model::Schema>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schema = v.into();
        self
    }
}

impl wkt::message::Message for Entity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Entity"
    }
}

/// Defines additional types related to [Entity].
pub mod entity {
    #[allow(unused_imports)]
    use super::*;

    /// Provides compatibility information for various metadata stores.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CompatibilityStatus {
        /// Output only. Whether this entity is compatible with Hive Metastore.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub hive_metastore:
            std::option::Option<crate::model::entity::compatibility_status::Compatibility>,

        /// Output only. Whether this entity is compatible with BigQuery.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub bigquery:
            std::option::Option<crate::model::entity::compatibility_status::Compatibility>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompatibilityStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hive_metastore][crate::model::entity::CompatibilityStatus::hive_metastore].
        pub fn set_hive_metastore<
            T: std::convert::Into<
                    std::option::Option<crate::model::entity::compatibility_status::Compatibility>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.hive_metastore = v.into();
            self
        }

        /// Sets the value of [bigquery][crate::model::entity::CompatibilityStatus::bigquery].
        pub fn set_bigquery<
            T: std::convert::Into<
                    std::option::Option<crate::model::entity::compatibility_status::Compatibility>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.bigquery = v.into();
            self
        }
    }

    impl wkt::message::Message for CompatibilityStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Entity.CompatibilityStatus"
        }
    }

    /// Defines additional types related to [CompatibilityStatus].
    pub mod compatibility_status {
        #[allow(unused_imports)]
        use super::*;

        /// Provides compatibility information for a specific metadata store.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Compatibility {
            /// Output only. Whether the entity is compatible and can be represented in
            /// the metadata store.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub compatible: bool,

            /// Output only. Provides additional detail if the entity is incompatible
            /// with the metadata store.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub reason: std::string::String,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Compatibility {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [compatible][crate::model::entity::compatibility_status::Compatibility::compatible].
            pub fn set_compatible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.compatible = v.into();
                self
            }

            /// Sets the value of [reason][crate::model::entity::compatibility_status::Compatibility::reason].
            pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.reason = v.into();
                self
            }
        }

        impl wkt::message::Message for Compatibility {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Entity.CompatibilityStatus.Compatibility"
            }
        }
    }

    /// The type of entity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type unspecified.
        Unspecified,
        /// Structured and semi-structured data.
        Table,
        /// Unstructured data.
        Fileset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Table => std::option::Option::Some(1),
                Self::Fileset => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Table => std::option::Option::Some("TABLE"),
                Self::Fileset => std::option::Option::Some("FILESET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Table,
                2 => Self::Fileset,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "TABLE" => Self::Table,
                "FILESET" => Self::Fileset,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Table => serializer.serialize_i32(1),
                Self::Fileset => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Entity.Type",
            ))
        }
    }
}

/// Represents partition metadata contained within entity instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Partition {
    /// Output only. Partition values used in the HTTP URL must be
    /// double encoded. For example, `url_encode(url_encode(value))` can be used
    /// to encode "US:CA/CA#Sunnyvale so that the request URL ends
    /// with "/partitions/US%253ACA/CA%2523Sunnyvale".
    /// The name field in the response retains the encoded format.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. The set of values representing the partition, which
    /// correspond to the partition schema defined in the parent entity.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The location of the entity data within the partition,
    /// for example, `gs://bucket/path/to/entity/key1=value1/key2=value2`. Or
    /// `projects/<project_id>/datasets/<dataset_id>/tables/<table_id>`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Optional. The etag for this partition.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Partition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Partition::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [values][crate::model::Partition::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location][crate::model::Partition::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Partition::etag].
    #[deprecated]
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Partition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Partition"
    }
}

/// Schema information describing the structure and layout of the data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Schema {
    /// Required. Set to `true` if user-managed or `false` if managed by Dataplex.
    /// The default is `false` (managed by Dataplex).
    ///
    /// - Set to `false`to enable Dataplex discovery to update the schema.
    ///   including new data discovery, schema inference, and schema evolution.
    ///   Users retain the ability to input and edit the schema. Dataplex
    ///   treats schema input by the user as though produced
    ///   by a previous Dataplex discovery operation, and it will
    ///   evolve the schema and take action based on that treatment.
    ///
    /// - Set to `true` to fully manage the entity
    ///   schema. This setting guarantees that Dataplex will not
    ///   change schema fields.
    ///
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub user_managed: bool,

    /// Optional. The sequence of fields describing data in table entities.
    /// **Note:** BigQuery SchemaFields are immutable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<crate::model::schema::SchemaField>,

    /// Optional. The sequence of fields describing the partition structure in
    /// entities. If this field is empty, there are no partitions within the data.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub partition_fields: std::vec::Vec<crate::model::schema::PartitionField>,

    /// Optional. The structure of paths containing partition data within the
    /// entity.
    pub partition_style: crate::model::schema::PartitionStyle,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Schema {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_managed][crate::model::Schema::user_managed].
    pub fn set_user_managed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.user_managed = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::Schema::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::SchemaField>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partition_fields][crate::model::Schema::partition_fields].
    pub fn set_partition_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::schema::PartitionField>,
    {
        use std::iter::Iterator;
        self.partition_fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partition_style][crate::model::Schema::partition_style].
    pub fn set_partition_style<T: std::convert::Into<crate::model::schema::PartitionStyle>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition_style = v.into();
        self
    }
}

impl wkt::message::Message for Schema {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Schema"
    }
}

/// Defines additional types related to [Schema].
pub mod schema {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a column field within a table schema.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SchemaField {
        /// Required. The name of the field. Must contain only letters, numbers and
        /// underscores, with a maximum length of 767 characters,
        /// and must begin with a letter or underscore.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Optional. User friendly field description. Must be less than or equal to
        /// 1024 characters.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// Required. The type of field.
        #[serde(rename = "type")]
        pub r#type: crate::model::schema::Type,

        /// Required. Additional field semantics.
        pub mode: crate::model::schema::Mode,

        /// Optional. Any nested field for complex types.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub fields: std::vec::Vec<crate::model::schema::SchemaField>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SchemaField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::SchemaField::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::schema::SchemaField::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::schema::SchemaField::type].
        pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [mode][crate::model::schema::SchemaField::mode].
        pub fn set_mode<T: std::convert::Into<crate::model::schema::Mode>>(mut self, v: T) -> Self {
            self.mode = v.into();
            self
        }

        /// Sets the value of [fields][crate::model::schema::SchemaField::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::schema::SchemaField>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SchemaField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Schema.SchemaField"
        }
    }

    /// Represents a key field within the entity's partition structure. You could
    /// have up to 20 partition fields, but only the first 10 partitions have the
    /// filtering ability due to performance consideration. **Note:**
    /// Partition fields are immutable.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PartitionField {
        /// Required. Partition field name must consist of letters, numbers, and
        /// underscores only, with a maximum of length of 256 characters, and must
        /// begin with a letter or underscore..
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Required. Immutable. The type of field.
        #[serde(rename = "type")]
        pub r#type: crate::model::schema::Type,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PartitionField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::schema::PartitionField::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::schema::PartitionField::type].
        pub fn set_type<T: std::convert::Into<crate::model::schema::Type>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for PartitionField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Schema.PartitionField"
        }
    }

    /// Type information for fields in schemas and partition schemas.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// SchemaType unspecified.
        Unspecified,
        /// Boolean field.
        Boolean,
        /// Single byte numeric field.
        Byte,
        /// 16-bit numeric field.
        Int16,
        /// 32-bit numeric field.
        Int32,
        /// 64-bit numeric field.
        Int64,
        /// Floating point numeric field.
        Float,
        /// Double precision numeric field.
        Double,
        /// Real value numeric field.
        Decimal,
        /// Sequence of characters field.
        String,
        /// Sequence of bytes field.
        Binary,
        /// Date and time field.
        Timestamp,
        /// Date field.
        Date,
        /// Time field.
        Time,
        /// Structured field. Nested fields that define the structure of the map.
        /// If all nested fields are nullable, this field represents a union.
        Record,
        /// Null field that does not have values.
        Null,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Boolean => std::option::Option::Some(1),
                Self::Byte => std::option::Option::Some(2),
                Self::Int16 => std::option::Option::Some(3),
                Self::Int32 => std::option::Option::Some(4),
                Self::Int64 => std::option::Option::Some(5),
                Self::Float => std::option::Option::Some(6),
                Self::Double => std::option::Option::Some(7),
                Self::Decimal => std::option::Option::Some(8),
                Self::String => std::option::Option::Some(9),
                Self::Binary => std::option::Option::Some(10),
                Self::Timestamp => std::option::Option::Some(11),
                Self::Date => std::option::Option::Some(12),
                Self::Time => std::option::Option::Some(13),
                Self::Record => std::option::Option::Some(14),
                Self::Null => std::option::Option::Some(100),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Boolean => std::option::Option::Some("BOOLEAN"),
                Self::Byte => std::option::Option::Some("BYTE"),
                Self::Int16 => std::option::Option::Some("INT16"),
                Self::Int32 => std::option::Option::Some("INT32"),
                Self::Int64 => std::option::Option::Some("INT64"),
                Self::Float => std::option::Option::Some("FLOAT"),
                Self::Double => std::option::Option::Some("DOUBLE"),
                Self::Decimal => std::option::Option::Some("DECIMAL"),
                Self::String => std::option::Option::Some("STRING"),
                Self::Binary => std::option::Option::Some("BINARY"),
                Self::Timestamp => std::option::Option::Some("TIMESTAMP"),
                Self::Date => std::option::Option::Some("DATE"),
                Self::Time => std::option::Option::Some("TIME"),
                Self::Record => std::option::Option::Some("RECORD"),
                Self::Null => std::option::Option::Some("NULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Boolean,
                2 => Self::Byte,
                3 => Self::Int16,
                4 => Self::Int32,
                5 => Self::Int64,
                6 => Self::Float,
                7 => Self::Double,
                8 => Self::Decimal,
                9 => Self::String,
                10 => Self::Binary,
                11 => Self::Timestamp,
                12 => Self::Date,
                13 => Self::Time,
                14 => Self::Record,
                100 => Self::Null,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "BOOLEAN" => Self::Boolean,
                "BYTE" => Self::Byte,
                "INT16" => Self::Int16,
                "INT32" => Self::Int32,
                "INT64" => Self::Int64,
                "FLOAT" => Self::Float,
                "DOUBLE" => Self::Double,
                "DECIMAL" => Self::Decimal,
                "STRING" => Self::String,
                "BINARY" => Self::Binary,
                "TIMESTAMP" => Self::Timestamp,
                "DATE" => Self::Date,
                "TIME" => Self::Time,
                "RECORD" => Self::Record,
                "NULL" => Self::Null,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Boolean => serializer.serialize_i32(1),
                Self::Byte => serializer.serialize_i32(2),
                Self::Int16 => serializer.serialize_i32(3),
                Self::Int32 => serializer.serialize_i32(4),
                Self::Int64 => serializer.serialize_i32(5),
                Self::Float => serializer.serialize_i32(6),
                Self::Double => serializer.serialize_i32(7),
                Self::Decimal => serializer.serialize_i32(8),
                Self::String => serializer.serialize_i32(9),
                Self::Binary => serializer.serialize_i32(10),
                Self::Timestamp => serializer.serialize_i32(11),
                Self::Date => serializer.serialize_i32(12),
                Self::Time => serializer.serialize_i32(13),
                Self::Record => serializer.serialize_i32(14),
                Self::Null => serializer.serialize_i32(100),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Schema.Type",
            ))
        }
    }

    /// Additional qualifiers to define field semantics.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Mode unspecified.
        Unspecified,
        /// The field has required semantics.
        Required,
        /// The field has optional semantics, and may be null.
        Nullable,
        /// The field has repeated (0 or more) semantics, and is a list of values.
        Repeated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Required => std::option::Option::Some(1),
                Self::Nullable => std::option::Option::Some(2),
                Self::Repeated => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Required => std::option::Option::Some("REQUIRED"),
                Self::Nullable => std::option::Option::Some("NULLABLE"),
                Self::Repeated => std::option::Option::Some("REPEATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Required,
                2 => Self::Nullable,
                3 => Self::Repeated,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "REQUIRED" => Self::Required,
                "NULLABLE" => Self::Nullable,
                "REPEATED" => Self::Repeated,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Required => serializer.serialize_i32(1),
                Self::Nullable => serializer.serialize_i32(2),
                Self::Repeated => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.dataplex.v1.Schema.Mode",
            ))
        }
    }

    /// The structure of paths within the entity, which represent partitions.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PartitionStyle {
        /// PartitionStyle unspecified
        Unspecified,
        /// Partitions are hive-compatible.
        /// Examples: `gs://bucket/path/to/table/dt=2019-10-31/lang=en`,
        /// `gs://bucket/path/to/table/dt=2019-10-31/lang=en/late`.
        HiveCompatible,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PartitionStyle::value] or
        /// [PartitionStyle::name].
        UnknownValue(partition_style::UnknownValue),
    }

    #[doc(hidden)]
    pub mod partition_style {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PartitionStyle {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HiveCompatible => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PARTITION_STYLE_UNSPECIFIED"),
                Self::HiveCompatible => std::option::Option::Some("HIVE_COMPATIBLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PartitionStyle {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PartitionStyle {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PartitionStyle {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HiveCompatible,
                _ => Self::UnknownValue(partition_style::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PartitionStyle {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PARTITION_STYLE_UNSPECIFIED" => Self::Unspecified,
                "HIVE_COMPATIBLE" => Self::HiveCompatible,
                _ => Self::UnknownValue(partition_style::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PartitionStyle {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HiveCompatible => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PartitionStyle {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionStyle>::new(
                ".google.cloud.dataplex.v1.Schema.PartitionStyle",
            ))
        }
    }
}

/// Describes the format of the data within its storage location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageFormat {
    /// Output only. The data format associated with the stored data, which
    /// represents content type values. The value is inferred from mime type.
    pub format: crate::model::storage_format::Format,

    /// Optional. The compression type associated with the stored data.
    /// If unspecified, the data is uncompressed.
    pub compression_format: crate::model::storage_format::CompressionFormat,

    /// Required. The mime type descriptor for the data. Must match the pattern
    /// {type}/{subtype}. Supported values:
    ///
    /// - application/x-parquet
    /// - application/x-avro
    /// - application/x-orc
    /// - application/x-tfrecord
    /// - application/x-parquet+iceberg
    /// - application/x-avro+iceberg
    /// - application/x-orc+iceberg
    /// - application/json
    /// - application/{subtypes}
    /// - text/csv
    /// - text/\<subtypes\>
    /// - image/{image subtype}
    /// - video/{video subtype}
    /// - audio/{audio subtype}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub mime_type: std::string::String,

    /// Additional format-specific options.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub options: std::option::Option<crate::model::storage_format::Options>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageFormat {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [format][crate::model::StorageFormat::format].
    pub fn set_format<T: std::convert::Into<crate::model::storage_format::Format>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [compression_format][crate::model::StorageFormat::compression_format].
    pub fn set_compression_format<
        T: std::convert::Into<crate::model::storage_format::CompressionFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compression_format = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::StorageFormat::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [options][crate::model::StorageFormat::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::storage_format::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Csv`, `None` if the field is not set or
    /// holds a different branch.
    pub fn csv(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::CsvOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Csv(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Csv`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_csv<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::CsvOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Csv(v.into()));
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Json`, `None` if the field is not set or
    /// holds a different branch.
    pub fn json(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::JsonOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Json(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Json`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_json<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::JsonOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Json(v.into()));
        self
    }

    /// The value of [options][crate::model::StorageFormat::options]
    /// if it holds a `Iceberg`, `None` if the field is not set or
    /// holds a different branch.
    pub fn iceberg(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::storage_format::IcebergOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::storage_format::Options::Iceberg(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::StorageFormat::options]
    /// to hold a `Iceberg`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_iceberg<
        T: std::convert::Into<std::boxed::Box<crate::model::storage_format::IcebergOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options =
            std::option::Option::Some(crate::model::storage_format::Options::Iceberg(v.into()));
        self
    }
}

impl wkt::message::Message for StorageFormat {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat"
    }
}

/// Defines additional types related to [StorageFormat].
pub mod storage_format {
    #[allow(unused_imports)]
    use super::*;

    /// Describes CSV and similar semi-structured data formats.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CsvOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII",
        /// "UTF-8", and "ISO-8859-1". Defaults to UTF-8 if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub encoding: std::string::String,

        /// Optional. The number of rows to interpret as header rows that should be
        /// skipped when reading data rows. Defaults to 0.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub header_rows: i32,

        /// Optional. The delimiter used to separate values. Defaults to ','.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub delimiter: std::string::String,

        /// Optional. The character used to quote column values. Accepts '"'
        /// (double quotation mark) or ''' (single quotation mark). Defaults to
        /// '"' (double quotation mark) if unspecified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub quote: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CsvOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::storage_format::CsvOptions::encoding].
        pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.encoding = v.into();
            self
        }

        /// Sets the value of [header_rows][crate::model::storage_format::CsvOptions::header_rows].
        pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.header_rows = v.into();
            self
        }

        /// Sets the value of [delimiter][crate::model::storage_format::CsvOptions::delimiter].
        pub fn set_delimiter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.delimiter = v.into();
            self
        }

        /// Sets the value of [quote][crate::model::storage_format::CsvOptions::quote].
        pub fn set_quote<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.quote = v.into();
            self
        }
    }

    impl wkt::message::Message for CsvOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.CsvOptions"
        }
    }

    /// Describes JSON data format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct JsonOptions {
        /// Optional. The character encoding of the data. Accepts "US-ASCII", "UTF-8"
        /// and "ISO-8859-1". Defaults to UTF-8 if not specified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub encoding: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl JsonOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::storage_format::JsonOptions::encoding].
        pub fn set_encoding<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.encoding = v.into();
            self
        }
    }

    impl wkt::message::Message for JsonOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.JsonOptions"
        }
    }

    /// Describes Iceberg data format.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IcebergOptions {
        /// Optional. The location of where the iceberg metadata is present, must be
        /// within the table path
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub metadata_location: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IcebergOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata_location][crate::model::storage_format::IcebergOptions::metadata_location].
        pub fn set_metadata_location<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.metadata_location = v.into();
            self
        }
    }

    impl wkt::message::Message for IcebergOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.StorageFormat.IcebergOptions"
        }
    }

    /// The specific file format of the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Format {
        /// Format unspecified.
        Unspecified,
        /// Parquet-formatted structured data.
        Parquet,
        /// Avro-formatted structured data.
        Avro,
        /// Orc-formatted structured data.
        Orc,
        /// Csv-formatted semi-structured data.
        Csv,
        /// Json-formatted semi-structured data.
        Json,
        /// Image data formats (such as jpg and png).
        Image,
        /// Audio data formats (such as mp3, and wav).
        Audio,
        /// Video data formats (such as mp4 and mpg).
        Video,
        /// Textual data formats (such as txt and xml).
        Text,
        /// TensorFlow record format.
        Tfrecord,
        /// Data that doesn't match a specific format.
        Other,
        /// Data of an unknown format.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Format::value] or
        /// [Format::name].
        UnknownValue(format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Format {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Parquet => std::option::Option::Some(1),
                Self::Avro => std::option::Option::Some(2),
                Self::Orc => std::option::Option::Some(3),
                Self::Csv => std::option::Option::Some(100),
                Self::Json => std::option::Option::Some(101),
                Self::Image => std::option::Option::Some(200),
                Self::Audio => std::option::Option::Some(201),
                Self::Video => std::option::Option::Some(202),
                Self::Text => std::option::Option::Some(203),
                Self::Tfrecord => std::option::Option::Some(204),
                Self::Other => std::option::Option::Some(1000),
                Self::Unknown => std::option::Option::Some(1001),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FORMAT_UNSPECIFIED"),
                Self::Parquet => std::option::Option::Some("PARQUET"),
                Self::Avro => std::option::Option::Some("AVRO"),
                Self::Orc => std::option::Option::Some("ORC"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Image => std::option::Option::Some("IMAGE"),
                Self::Audio => std::option::Option::Some("AUDIO"),
                Self::Video => std::option::Option::Some("VIDEO"),
                Self::Text => std::option::Option::Some("TEXT"),
                Self::Tfrecord => std::option::Option::Some("TFRECORD"),
                Self::Other => std::option::Option::Some("OTHER"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Format {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Format {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Format {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Parquet,
                2 => Self::Avro,
                3 => Self::Orc,
                100 => Self::Csv,
                101 => Self::Json,
                200 => Self::Image,
                201 => Self::Audio,
                202 => Self::Video,
                203 => Self::Text,
                204 => Self::Tfrecord,
                1000 => Self::Other,
                1001 => Self::Unknown,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Format {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PARQUET" => Self::Parquet,
                "AVRO" => Self::Avro,
                "ORC" => Self::Orc,
                "CSV" => Self::Csv,
                "JSON" => Self::Json,
                "IMAGE" => Self::Image,
                "AUDIO" => Self::Audio,
                "VIDEO" => Self::Video,
                "TEXT" => Self::Text,
                "TFRECORD" => Self::Tfrecord,
                "OTHER" => Self::Other,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Format {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Parquet => serializer.serialize_i32(1),
                Self::Avro => serializer.serialize_i32(2),
                Self::Orc => serializer.serialize_i32(3),
                Self::Csv => serializer.serialize_i32(100),
                Self::Json => serializer.serialize_i32(101),
                Self::Image => serializer.serialize_i32(200),
                Self::Audio => serializer.serialize_i32(201),
                Self::Video => serializer.serialize_i32(202),
                Self::Text => serializer.serialize_i32(203),
                Self::Tfrecord => serializer.serialize_i32(204),
                Self::Other => serializer.serialize_i32(1000),
                Self::Unknown => serializer.serialize_i32(1001),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Format {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Format>::new(
                ".google.cloud.dataplex.v1.StorageFormat.Format",
            ))
        }
    }

    /// The specific compressed file format of the data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompressionFormat {
        /// CompressionFormat unspecified. Implies uncompressed data.
        Unspecified,
        /// GZip compressed set of files.
        Gzip,
        /// BZip2 compressed set of files.
        Bzip2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CompressionFormat::value] or
        /// [CompressionFormat::name].
        UnknownValue(compression_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod compression_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CompressionFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gzip => std::option::Option::Some(2),
                Self::Bzip2 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPRESSION_FORMAT_UNSPECIFIED"),
                Self::Gzip => std::option::Option::Some("GZIP"),
                Self::Bzip2 => std::option::Option::Some("BZIP2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CompressionFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CompressionFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CompressionFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Gzip,
                3 => Self::Bzip2,
                _ => Self::UnknownValue(compression_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CompressionFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPRESSION_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "GZIP" => Self::Gzip,
                "BZIP2" => Self::Bzip2,
                _ => Self::UnknownValue(compression_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CompressionFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gzip => serializer.serialize_i32(2),
                Self::Bzip2 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CompressionFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CompressionFormat>::new(
                ".google.cloud.dataplex.v1.StorageFormat.CompressionFormat",
            ))
        }
    }

    /// Additional format-specific options.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Options {
        /// Optional. Additional information about CSV formatted data.
        Csv(std::boxed::Box<crate::model::storage_format::CsvOptions>),
        /// Optional. Additional information about CSV formatted data.
        Json(std::boxed::Box<crate::model::storage_format::JsonOptions>),
        /// Optional. Additional information about iceberg tables.
        Iceberg(std::boxed::Box<crate::model::storage_format::IcebergOptions>),
    }
}

/// Describes the access mechanism of the data within its storage location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StorageAccess {
    /// Output only. Describes the read access mechanism of the data. Not user
    /// settable.
    pub read: crate::model::storage_access::AccessMode,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StorageAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [read][crate::model::StorageAccess::read].
    pub fn set_read<T: std::convert::Into<crate::model::storage_access::AccessMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.read = v.into();
        self
    }
}

impl wkt::message::Message for StorageAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.StorageAccess"
    }
}

/// Defines additional types related to [StorageAccess].
pub mod storage_access {
    #[allow(unused_imports)]
    use super::*;

    /// Access Mode determines how data stored within the Entity is read.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessMode {
        /// Access mode unspecified.
        Unspecified,
        /// Default. Data is accessed directly using storage APIs.
        Direct,
        /// Data is accessed through a managed interface using BigQuery APIs.
        Managed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AccessMode::value] or
        /// [AccessMode::name].
        UnknownValue(access_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod access_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AccessMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Direct => std::option::Option::Some(1),
                Self::Managed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCESS_MODE_UNSPECIFIED"),
                Self::Direct => std::option::Option::Some("DIRECT"),
                Self::Managed => std::option::Option::Some("MANAGED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AccessMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AccessMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AccessMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Direct,
                2 => Self::Managed,
                _ => Self::UnknownValue(access_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AccessMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCESS_MODE_UNSPECIFIED" => Self::Unspecified,
                "DIRECT" => Self::Direct,
                "MANAGED" => Self::Managed,
                _ => Self::UnknownValue(access_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AccessMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Direct => serializer.serialize_i32(1),
                Self::Managed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AccessMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessMode>::new(
                ".google.cloud.dataplex.v1.StorageAccess.AccessMode",
            ))
        }
    }
}

/// DataScan scheduling and trigger settings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trigger {
    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::trigger::Mode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trigger {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::Trigger::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<T: std::convert::Into<std::option::Option<crate::model::trigger::Mode>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::Trigger::mode]
    /// if it holds a `OnDemand`, `None` if the field is not set or
    /// holds a different branch.
    pub fn on_demand(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::trigger::OnDemand>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::trigger::Mode::OnDemand(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Trigger::mode]
    /// to hold a `OnDemand`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_on_demand<
        T: std::convert::Into<std::boxed::Box<crate::model::trigger::OnDemand>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(crate::model::trigger::Mode::OnDemand(v.into()));
        self
    }

    /// The value of [mode][crate::model::Trigger::mode]
    /// if it holds a `Schedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn schedule(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::trigger::Schedule>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::trigger::Mode::Schedule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::Trigger::mode]
    /// to hold a `Schedule`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_schedule<T: std::convert::Into<std::boxed::Box<crate::model::trigger::Schedule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(crate::model::trigger::Mode::Schedule(v.into()));
        self
    }
}

impl wkt::message::Message for Trigger {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Trigger"
    }
}

/// Defines additional types related to [Trigger].
pub mod trigger {
    #[allow(unused_imports)]
    use super::*;

    /// The scan runs once via `RunDataScan` API.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct OnDemand {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OnDemand {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for OnDemand {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Trigger.OnDemand"
        }
    }

    /// The scan is scheduled to run periodically.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Schedule {
        /// Required. [Cron](https://en.wikipedia.org/wiki/Cron) schedule for running
        /// scans periodically.
        ///
        /// To explicitly set a timezone in the cron tab, apply a prefix in the
        /// cron tab: **"CRON_TZ=${IANA_TIME_ZONE}"** or **"TZ=${IANA_TIME_ZONE}"**.
        /// The **${IANA_TIME_ZONE}** may only be a valid string from IANA time zone
        /// database
        /// ([wikipedia](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List)).
        /// For example, `CRON_TZ=America/New_York 1 * * * *`, or
        /// `TZ=America/New_York 1 * * * *`.
        ///
        /// This field is required for Schedule scans.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cron: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cron][crate::model::trigger::Schedule::cron].
        pub fn set_cron<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cron = v.into();
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Trigger.Schedule"
        }
    }

    /// DataScan scheduling and trigger settings.
    ///
    /// If not specified, the default is `onDemand`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// The scan runs once via `RunDataScan` API.
        OnDemand(std::boxed::Box<crate::model::trigger::OnDemand>),
        /// The scan is scheduled to run periodically.
        Schedule(std::boxed::Box<crate::model::trigger::Schedule>),
    }
}

/// The data source for DataScan.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataSource {
    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::data_source::Source>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::DataSource::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::data_source::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DataSource::source]
    /// if it holds a `Entity`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::data_source::Source::Entity(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DataSource::source]
    /// to hold a `Entity`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::data_source::Source::Entity(v.into()));
        self
    }

    /// The value of [source][crate::model::DataSource::source]
    /// if it holds a `Resource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn resource(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::data_source::Source::Resource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DataSource::source]
    /// to hold a `Resource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::data_source::Source::Resource(v.into()));
        self
    }
}

impl wkt::message::Message for DataSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataSource"
    }
}

/// Defines additional types related to [DataSource].
pub mod data_source {
    #[allow(unused_imports)]
    use super::*;

    /// The source is required and immutable. Once it is set, it cannot be change
    /// to others.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Immutable. The Dataplex entity that represents the data source (e.g.
        /// BigQuery table) for DataScan, of the form:
        /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/entities/{entity_id}`.
        Entity(std::string::String),
        /// Immutable. The service-qualified full resource name of the cloud resource
        /// for a DataScan job to scan against. The field could be: BigQuery table of
        /// type "TABLE" for DataProfileScan/DataQualityScan Format:
        /// //bigquery.googleapis.com/projects/PROJECT_ID/datasets/DATASET_ID/tables/TABLE_ID
        Resource(std::string::String),
    }
}

/// The data scanned during processing (e.g. in incremental DataScan)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ScannedData {
    /// The range of scanned data
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub data_range: std::option::Option<crate::model::scanned_data::DataRange>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ScannedData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_range][crate::model::ScannedData::data_range].
    ///
    /// Note that all the setters affecting `data_range` are mutually
    /// exclusive.
    pub fn set_data_range<
        T: std::convert::Into<std::option::Option<crate::model::scanned_data::DataRange>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_range = v.into();
        self
    }

    /// The value of [data_range][crate::model::ScannedData::data_range]
    /// if it holds a `IncrementalField`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incremental_field(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::scanned_data::IncrementalField>> {
        #[allow(unreachable_patterns)]
        self.data_range.as_ref().and_then(|v| match v {
            crate::model::scanned_data::DataRange::IncrementalField(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_range][crate::model::ScannedData::data_range]
    /// to hold a `IncrementalField`.
    ///
    /// Note that all the setters affecting `data_range` are
    /// mutually exclusive.
    pub fn set_incremental_field<
        T: std::convert::Into<std::boxed::Box<crate::model::scanned_data::IncrementalField>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_range = std::option::Option::Some(
            crate::model::scanned_data::DataRange::IncrementalField(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ScannedData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ScannedData"
    }
}

/// Defines additional types related to [ScannedData].
pub mod scanned_data {
    #[allow(unused_imports)]
    use super::*;

    /// A data range denoted by a pair of start/end values of a field.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IncrementalField {
        /// The field that contains values which monotonically increases over time
        /// (e.g. a timestamp column).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub field: std::string::String,

        /// Value that marks the start of the range.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub start: std::string::String,

        /// Value that marks the end of the range.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub end: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncrementalField {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field][crate::model::scanned_data::IncrementalField::field].
        pub fn set_field<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.field = v.into();
            self
        }

        /// Sets the value of [start][crate::model::scanned_data::IncrementalField::start].
        pub fn set_start<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.start = v.into();
            self
        }

        /// Sets the value of [end][crate::model::scanned_data::IncrementalField::end].
        pub fn set_end<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.end = v.into();
            self
        }
    }

    impl wkt::message::Message for IncrementalField {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.ScannedData.IncrementalField"
        }
    }

    /// The range of scanned data
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum DataRange {
        /// The range denoted by values of an incremental field
        IncrementalField(std::boxed::Box<crate::model::scanned_data::IncrementalField>),
    }
}

/// A lake is a centralized repository for managing enterprise data across the
/// organization distributed across many cloud projects, and stored in a variety
/// of storage services such as Google Cloud Storage and BigQuery. The resources
/// attached to a lake are referred to as managed resources. Data within these
/// managed resources can be structured or unstructured. A lake provides data
/// admins with tools to organize, secure and manage their data at scale, and
/// provides data scientists and data engineers an integrated experience to
/// easily search, discover, analyze and transform data and associated metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Lake {
    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the lake. This ID will
    /// be different if the lake is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the lake was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the lake was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User-defined labels for the lake.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the lake.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Current state of the lake.
    pub state: crate::model::State,

    /// Output only. Service account associated with this lake. This service
    /// account must be authorized to access or operate on resources managed by the
    /// lake.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. Settings to manage lake and Dataproc Metastore service instance
    /// association.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metastore: std::option::Option<crate::model::lake::Metastore>,

    /// Output only. Aggregated status of the underlying assets of the lake.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset_status: std::option::Option<crate::model::AssetStatus>,

    /// Output only. Metastore status of the lake.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metastore_status: std::option::Option<crate::model::lake::MetastoreStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Lake {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Lake::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Lake::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Lake::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Lake::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Lake::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Lake::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Lake::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Lake::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Lake::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [metastore][crate::model::Lake::metastore].
    pub fn set_metastore<
        T: std::convert::Into<std::option::Option<crate::model::lake::Metastore>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metastore = v.into();
        self
    }

    /// Sets the value of [asset_status][crate::model::Lake::asset_status].
    pub fn set_asset_status<
        T: std::convert::Into<std::option::Option<crate::model::AssetStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_status = v.into();
        self
    }

    /// Sets the value of [metastore_status][crate::model::Lake::metastore_status].
    pub fn set_metastore_status<
        T: std::convert::Into<std::option::Option<crate::model::lake::MetastoreStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_status = v.into();
        self
    }
}

impl wkt::message::Message for Lake {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Lake"
    }
}

/// Defines additional types related to [Lake].
pub mod lake {
    #[allow(unused_imports)]
    use super::*;

    /// Settings to manage association of Dataproc Metastore with a lake.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metastore {
        /// Optional. A relative reference to the Dataproc Metastore
        /// (<https://cloud.google.com/dataproc-metastore/docs>) service associated
        /// with the lake:
        /// `projects/{project_id}/locations/{location_id}/services/{service_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metastore {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::lake::Metastore::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }
    }

    impl wkt::message::Message for Metastore {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Lake.Metastore"
        }
    }

    /// Status of Lake and Dataproc Metastore service instance association.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MetastoreStatus {
        /// Current state of association.
        pub state: crate::model::lake::metastore_status::State,

        /// Additional information about the current status.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Last update time of the metastore status of the lake.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The URI of the endpoint used to access the Metastore service.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub endpoint: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MetastoreStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::lake::MetastoreStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::lake::metastore_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::lake::MetastoreStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::lake::MetastoreStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [endpoint][crate::model::lake::MetastoreStatus::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }
    }

    impl wkt::message::Message for MetastoreStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Lake.MetastoreStatus"
        }
    }

    /// Defines additional types related to [MetastoreStatus].
    pub mod metastore_status {
        #[allow(unused_imports)]
        use super::*;

        /// Current state of association.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unspecified.
            Unspecified,
            /// A Metastore service instance is not associated with the lake.
            None,
            /// A Metastore service instance is attached to the lake.
            Ready,
            /// Attach/detach is in progress.
            Updating,
            /// Attach/detach could not be done due to errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::None => std::option::Option::Some(1),
                    Self::Ready => std::option::Option::Some(2),
                    Self::Updating => std::option::Option::Some(3),
                    Self::Error => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::None => std::option::Option::Some("NONE"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Updating => std::option::Option::Some("UPDATING"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::None,
                    2 => Self::Ready,
                    3 => Self::Updating,
                    4 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "NONE" => Self::None,
                    "READY" => Self::Ready,
                    "UPDATING" => Self::Updating,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::None => serializer.serialize_i32(1),
                    Self::Ready => serializer.serialize_i32(2),
                    Self::Updating => serializer.serialize_i32(3),
                    Self::Error => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Lake.MetastoreStatus.State",
                ))
            }
        }
    }
}

/// Aggregated status of the underlying assets of a lake or zone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AssetStatus {
    /// Last update time of the status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Number of active assets.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub active_assets: i32,

    /// Number of assets that are in process of updating the security policy on
    /// attached resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub security_policy_applying_assets: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AssetStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::AssetStatus::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [active_assets][crate::model::AssetStatus::active_assets].
    pub fn set_active_assets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.active_assets = v.into();
        self
    }

    /// Sets the value of [security_policy_applying_assets][crate::model::AssetStatus::security_policy_applying_assets].
    pub fn set_security_policy_applying_assets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.security_policy_applying_assets = v.into();
        self
    }
}

impl wkt::message::Message for AssetStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.AssetStatus"
    }
}

/// A zone represents a logical group of related assets within a lake. A zone can
/// be used to map to organizational structure or represent stages of data
/// readiness from raw to curated. It provides managing behavior that is shared
/// or inherited by all contained assets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Zone {
    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the zone. This ID will
    /// be different if the zone is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the zone was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the zone was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the zone.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the zone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Current state of the zone.
    pub state: crate::model::State,

    /// Required. Immutable. The type of the zone.
    #[serde(rename = "type")]
    pub r#type: crate::model::zone::Type,

    /// Optional. Specification of the discovery feature applied to data in this
    /// zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_spec: std::option::Option<crate::model::zone::DiscoverySpec>,

    /// Required. Specification of the resources that are referenced by the assets
    /// within this zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_spec: std::option::Option<crate::model::zone::ResourceSpec>,

    /// Output only. Aggregated status of the underlying assets of the zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset_status: std::option::Option<crate::model::AssetStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Zone {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Zone::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Zone::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Zone::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Zone::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Zone::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Zone::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Zone::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Zone::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Zone::type].
    pub fn set_type<T: std::convert::Into<crate::model::zone::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [discovery_spec][crate::model::Zone::discovery_spec].
    pub fn set_discovery_spec<
        T: std::convert::Into<std::option::Option<crate::model::zone::DiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_spec = v.into();
        self
    }

    /// Sets the value of [resource_spec][crate::model::Zone::resource_spec].
    pub fn set_resource_spec<
        T: std::convert::Into<std::option::Option<crate::model::zone::ResourceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_spec = v.into();
        self
    }

    /// Sets the value of [asset_status][crate::model::Zone::asset_status].
    pub fn set_asset_status<
        T: std::convert::Into<std::option::Option<crate::model::AssetStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.asset_status = v.into();
        self
    }
}

impl wkt::message::Message for Zone {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Zone"
    }
}

/// Defines additional types related to [Zone].
pub mod zone {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for resources attached as assets within a zone.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceSpec {
        /// Required. Immutable. The location type of the resources that are allowed
        /// to be attached to the assets within this zone.
        pub location_type: crate::model::zone::resource_spec::LocationType,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [location_type][crate::model::zone::ResourceSpec::location_type].
        pub fn set_location_type<
            T: std::convert::Into<crate::model::zone::resource_spec::LocationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.location_type = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Zone.ResourceSpec"
        }
    }

    /// Defines additional types related to [ResourceSpec].
    pub mod resource_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Location type of the resources attached to a zone.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum LocationType {
            /// Unspecified location type.
            Unspecified,
            /// Resources that are associated with a single region.
            SingleRegion,
            /// Resources that are associated with a multi-region location.
            MultiRegion,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [LocationType::value] or
            /// [LocationType::name].
            UnknownValue(location_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod location_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl LocationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SingleRegion => std::option::Option::Some(1),
                    Self::MultiRegion => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("LOCATION_TYPE_UNSPECIFIED"),
                    Self::SingleRegion => std::option::Option::Some("SINGLE_REGION"),
                    Self::MultiRegion => std::option::Option::Some("MULTI_REGION"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for LocationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for LocationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for LocationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SingleRegion,
                    2 => Self::MultiRegion,
                    _ => Self::UnknownValue(location_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for LocationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "LOCATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SINGLE_REGION" => Self::SingleRegion,
                    "MULTI_REGION" => Self::MultiRegion,
                    _ => Self::UnknownValue(location_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for LocationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SingleRegion => serializer.serialize_i32(1),
                    Self::MultiRegion => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for LocationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationType>::new(
                    ".google.cloud.dataplex.v1.Zone.ResourceSpec.LocationType",
                ))
            }
        }
    }

    /// Settings to manage the metadata discovery and publishing in a zone.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DiscoverySpec {
        /// Required. Whether discovery is enabled.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered. For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub csv_options: std::option::Option<crate::model::zone::discovery_spec::CsvOptions>,

        /// Optional. Configuration for Json data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub json_options: std::option::Option<crate::model::zone::discovery_spec::JsonOptions>,

        /// Determines when discovery is triggered.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::zone::discovery_spec::Trigger>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoverySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::zone::DiscoverySpec::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [include_patterns][crate::model::zone::DiscoverySpec::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::zone::DiscoverySpec::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::zone::DiscoverySpec::csv_options].
        pub fn set_csv_options<
            T: std::convert::Into<std::option::Option<crate::model::zone::discovery_spec::CsvOptions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.csv_options = v.into();
            self
        }

        /// Sets the value of [json_options][crate::model::zone::DiscoverySpec::json_options].
        pub fn set_json_options<
            T: std::convert::Into<
                    std::option::Option<crate::model::zone::discovery_spec::JsonOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.json_options = v.into();
            self
        }

        /// Sets the value of [trigger][crate::model::zone::DiscoverySpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::zone::discovery_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::zone::DiscoverySpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::zone::discovery_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::zone::DiscoverySpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::zone::discovery_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DiscoverySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec"
        }
    }

    /// Defines additional types related to [DiscoverySpec].
    pub mod discovery_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Describe CSV and similar semi-structured data formats.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub header_rows: i32,

            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disable_type_inference: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::zone::discovery_spec::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::zone::discovery_spec::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::zone::discovery_spec::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::zone::discovery_spec::CsvOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec.CsvOptions"
            }
        }

        /// Describe JSON data format.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disable_type_inference: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::zone::discovery_spec::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::zone::discovery_spec::JsonOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Zone.DiscoverySpec.JsonOptions"
            }
        }

        /// Determines when discovery is triggered.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes.
            ///
            /// To explicitly set a timezone to the cron tab, apply a prefix in the
            /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}".
            /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
            /// database. For example, `CRON_TZ=America/New_York 1 * * * *`, or
            /// `TZ=America/New_York 1 * * * *`.
            Schedule(std::string::String),
        }
    }

    /// Type of zone.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Zone type not specified.
        Unspecified,
        /// A zone that contains data that needs further processing before it is
        /// considered generally ready for consumption and analytics workloads.
        Raw,
        /// A zone that contains data that is considered to be ready for broader
        /// consumption and analytics workloads. Curated structured data stored in
        /// Cloud Storage must conform to certain file formats (parquet, avro and
        /// orc) and organized in a hive-compatible directory layout.
        Curated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Raw => std::option::Option::Some(1),
                Self::Curated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Raw => std::option::Option::Some("RAW"),
                Self::Curated => std::option::Option::Some("CURATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Raw,
                2 => Self::Curated,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "RAW" => Self::Raw,
                "CURATED" => Self::Curated,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Raw => serializer.serialize_i32(1),
                Self::Curated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataplex.v1.Zone.Type",
            ))
        }
    }
}

/// Action represents an issue requiring administrator action for resolution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Action {
    /// The category of issue associated with the action.
    pub category: crate::model::action::Category,

    /// Detailed description of the issue requiring action.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub issue: std::string::String,

    /// The time that the issue was detected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub detect_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The relative resource name of the action, of the form:
    /// `projects/{project}/locations/{location}/lakes/{lake}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/actions/{action}`
    /// `projects/{project}/locations/{location}/lakes/{lake}/zones/{zone}/assets/{asset}/actions/{action}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The relative resource name of the lake, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lake: std::string::String,

    /// Output only. The relative resource name of the zone, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset: std::string::String,

    /// The list of data locations associated with this action. Cloud Storage
    /// locations are represented as URI paths(E.g.
    /// `gs://bucket/table1/year=2020/month=Jan/`). BigQuery locations refer to
    /// resource names(E.g.
    /// `bigquery.googleapis.com/projects/project-id/datasets/dataset-id`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_locations: std::vec::Vec<std::string::String>,

    /// Additional details about the action based on the action category.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::action::Details>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Action {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [category][crate::model::Action::category].
    pub fn set_category<T: std::convert::Into<crate::model::action::Category>>(
        mut self,
        v: T,
    ) -> Self {
        self.category = v.into();
        self
    }

    /// Sets the value of [issue][crate::model::Action::issue].
    pub fn set_issue<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issue = v.into();
        self
    }

    /// Sets the value of [detect_time][crate::model::Action::detect_time].
    pub fn set_detect_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.detect_time = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Action::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [lake][crate::model::Action::lake].
    pub fn set_lake<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Action::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::Action::asset].
    pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [data_locations][crate::model::Action::data_locations].
    pub fn set_data_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [details][crate::model::Action::details].
    ///
    /// Note that all the setters affecting `details` are mutually
    /// exclusive.
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::action::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataFormat`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_format(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataFormat>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataFormat(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataFormat`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_format<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataFormat>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::InvalidDataFormat(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `IncompatibleDataSchema`, `None` if the field is not set or
    /// holds a different branch.
    pub fn incompatible_data_schema(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::IncompatibleDataSchema>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::IncompatibleDataSchema(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `IncompatibleDataSchema`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_incompatible_data_schema<
        T: std::convert::Into<std::boxed::Box<crate::model::action::IncompatibleDataSchema>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::IncompatibleDataSchema(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataPartition`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_partition(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataPartition>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataPartition(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataPartition`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_partition<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataPartition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::InvalidDataPartition(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `MissingData`, `None` if the field is not set or
    /// holds a different branch.
    pub fn missing_data(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::MissingData>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::MissingData(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `MissingData`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_missing_data<
        T: std::convert::Into<std::boxed::Box<crate::model::action::MissingData>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::MissingData(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `MissingResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn missing_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::MissingResource>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::MissingResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `MissingResource`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_missing_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::action::MissingResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details =
            std::option::Option::Some(crate::model::action::Details::MissingResource(v.into()));
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `UnauthorizedResource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unauthorized_resource(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::UnauthorizedResource>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::UnauthorizedResource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `UnauthorizedResource`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_unauthorized_resource<
        T: std::convert::Into<std::boxed::Box<crate::model::action::UnauthorizedResource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::UnauthorizedResource(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `FailedSecurityPolicyApply`, `None` if the field is not set or
    /// holds a different branch.
    pub fn failed_security_policy_apply(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>>
    {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::FailedSecurityPolicyApply(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `FailedSecurityPolicyApply`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_failed_security_policy_apply<
        T: std::convert::Into<std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::FailedSecurityPolicyApply(v.into()),
        );
        self
    }

    /// The value of [details][crate::model::Action::details]
    /// if it holds a `InvalidDataOrganization`, `None` if the field is not set or
    /// holds a different branch.
    pub fn invalid_data_organization(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::action::InvalidDataOrganization>> {
        #[allow(unreachable_patterns)]
        self.details.as_ref().and_then(|v| match v {
            crate::model::action::Details::InvalidDataOrganization(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [details][crate::model::Action::details]
    /// to hold a `InvalidDataOrganization`.
    ///
    /// Note that all the setters affecting `details` are
    /// mutually exclusive.
    pub fn set_invalid_data_organization<
        T: std::convert::Into<std::boxed::Box<crate::model::action::InvalidDataOrganization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = std::option::Option::Some(
            crate::model::action::Details::InvalidDataOrganization(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Action {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Action"
    }
}

/// Defines additional types related to [Action].
pub mod action {
    #[allow(unused_imports)]
    use super::*;

    /// Action details for resource references in assets that cannot be located.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MissingResource {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MissingResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MissingResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.MissingResource"
        }
    }

    /// Action details for unauthorized resource issues raised to indicate that the
    /// service account associated with the lake instance is not authorized to
    /// access or manage the resource associated with an asset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct UnauthorizedResource {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UnauthorizedResource {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for UnauthorizedResource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.UnauthorizedResource"
        }
    }

    /// Failed to apply security policy to the managed resource(s) under a
    /// lake, zone or an asset. For a lake or zone resource, one or more underlying
    /// assets has a failure applying security policy to the associated managed
    /// resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FailedSecurityPolicyApply {
        /// Resource name of one of the assets with failing security policy
        /// application. Populated for a lake or zone resource only.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub asset: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FailedSecurityPolicyApply {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [asset][crate::model::action::FailedSecurityPolicyApply::asset].
        pub fn set_asset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.asset = v.into();
            self
        }
    }

    impl wkt::message::Message for FailedSecurityPolicyApply {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.FailedSecurityPolicyApply"
        }
    }

    /// Action details for invalid or unsupported data files detected by discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InvalidDataFormat {
        /// The list of data locations sampled and used for format/schema
        /// inference.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        /// The expected data format of the entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub expected_format: std::string::String,

        /// The new unexpected data format within the entity.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub new_format: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataFormat {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sampled_data_locations][crate::model::action::InvalidDataFormat::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [expected_format][crate::model::action::InvalidDataFormat::expected_format].
        pub fn set_expected_format<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.expected_format = v.into();
            self
        }

        /// Sets the value of [new_format][crate::model::action::InvalidDataFormat::new_format].
        pub fn set_new_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.new_format = v.into();
            self
        }
    }

    impl wkt::message::Message for InvalidDataFormat {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataFormat"
        }
    }

    /// Action details for incompatible schemas detected by discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct IncompatibleDataSchema {
        /// The name of the table containing invalid data.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub table: std::string::String,

        /// The existing and expected schema of the table. The schema is provided as
        /// a JSON formatted structure listing columns and data types.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub existing_schema: std::string::String,

        /// The new and incompatible schema within the table. The schema is provided
        /// as a JSON formatted structured listing columns and data types.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub new_schema: std::string::String,

        /// The list of data locations sampled and used for format/schema
        /// inference.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub sampled_data_locations: std::vec::Vec<std::string::String>,

        /// Whether the action relates to a schema that is incompatible or modified.
        pub schema_change: crate::model::action::incompatible_data_schema::SchemaChange,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncompatibleDataSchema {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [table][crate::model::action::IncompatibleDataSchema::table].
        pub fn set_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table = v.into();
            self
        }

        /// Sets the value of [existing_schema][crate::model::action::IncompatibleDataSchema::existing_schema].
        pub fn set_existing_schema<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.existing_schema = v.into();
            self
        }

        /// Sets the value of [new_schema][crate::model::action::IncompatibleDataSchema::new_schema].
        pub fn set_new_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.new_schema = v.into();
            self
        }

        /// Sets the value of [sampled_data_locations][crate::model::action::IncompatibleDataSchema::sampled_data_locations].
        pub fn set_sampled_data_locations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.sampled_data_locations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [schema_change][crate::model::action::IncompatibleDataSchema::schema_change].
        pub fn set_schema_change<
            T: std::convert::Into<crate::model::action::incompatible_data_schema::SchemaChange>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.schema_change = v.into();
            self
        }
    }

    impl wkt::message::Message for IncompatibleDataSchema {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.IncompatibleDataSchema"
        }
    }

    /// Defines additional types related to [IncompatibleDataSchema].
    pub mod incompatible_data_schema {
        #[allow(unused_imports)]
        use super::*;

        /// Whether the action relates to a schema that is incompatible or modified.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SchemaChange {
            /// Schema change unspecified.
            Unspecified,
            /// Newly discovered schema is incompatible with existing schema.
            Incompatible,
            /// Newly discovered schema has changed from existing schema for data in a
            /// curated zone.
            Modified,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SchemaChange::value] or
            /// [SchemaChange::name].
            UnknownValue(schema_change::UnknownValue),
        }

        #[doc(hidden)]
        pub mod schema_change {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SchemaChange {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Incompatible => std::option::Option::Some(1),
                    Self::Modified => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCHEMA_CHANGE_UNSPECIFIED"),
                    Self::Incompatible => std::option::Option::Some("INCOMPATIBLE"),
                    Self::Modified => std::option::Option::Some("MODIFIED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SchemaChange {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SchemaChange {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SchemaChange {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Incompatible,
                    2 => Self::Modified,
                    _ => Self::UnknownValue(schema_change::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SchemaChange {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCHEMA_CHANGE_UNSPECIFIED" => Self::Unspecified,
                    "INCOMPATIBLE" => Self::Incompatible,
                    "MODIFIED" => Self::Modified,
                    _ => Self::UnknownValue(schema_change::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SchemaChange {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Incompatible => serializer.serialize_i32(1),
                    Self::Modified => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SchemaChange {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SchemaChange>::new(
                    ".google.cloud.dataplex.v1.Action.IncompatibleDataSchema.SchemaChange",
                ))
            }
        }
    }

    /// Action details for invalid or unsupported partitions detected by discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InvalidDataPartition {
        /// The issue type of InvalidDataPartition.
        pub expected_structure: crate::model::action::invalid_data_partition::PartitionStructure,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataPartition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expected_structure][crate::model::action::InvalidDataPartition::expected_structure].
        pub fn set_expected_structure<
            T: std::convert::Into<crate::model::action::invalid_data_partition::PartitionStructure>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.expected_structure = v.into();
            self
        }
    }

    impl wkt::message::Message for InvalidDataPartition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataPartition"
        }
    }

    /// Defines additional types related to [InvalidDataPartition].
    pub mod invalid_data_partition {
        #[allow(unused_imports)]
        use super::*;

        /// The expected partition structure.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PartitionStructure {
            /// PartitionStructure unspecified.
            Unspecified,
            /// Consistent hive-style partition definition (both raw and curated zone).
            ConsistentKeys,
            /// Hive style partition definition (curated zone only).
            HiveStyleKeys,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [PartitionStructure::value] or
            /// [PartitionStructure::name].
            UnknownValue(partition_structure::UnknownValue),
        }

        #[doc(hidden)]
        pub mod partition_structure {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl PartitionStructure {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ConsistentKeys => std::option::Option::Some(1),
                    Self::HiveStyleKeys => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("PARTITION_STRUCTURE_UNSPECIFIED")
                    }
                    Self::ConsistentKeys => std::option::Option::Some("CONSISTENT_KEYS"),
                    Self::HiveStyleKeys => std::option::Option::Some("HIVE_STYLE_KEYS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for PartitionStructure {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for PartitionStructure {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for PartitionStructure {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ConsistentKeys,
                    2 => Self::HiveStyleKeys,
                    _ => Self::UnknownValue(partition_structure::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for PartitionStructure {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PARTITION_STRUCTURE_UNSPECIFIED" => Self::Unspecified,
                    "CONSISTENT_KEYS" => Self::ConsistentKeys,
                    "HIVE_STYLE_KEYS" => Self::HiveStyleKeys,
                    _ => Self::UnknownValue(partition_structure::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for PartitionStructure {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ConsistentKeys => serializer.serialize_i32(1),
                    Self::HiveStyleKeys => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for PartitionStructure {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<PartitionStructure>::new(
                    ".google.cloud.dataplex.v1.Action.InvalidDataPartition.PartitionStructure",
                ))
            }
        }
    }

    /// Action details for absence of data detected by discovery.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MissingData {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MissingData {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for MissingData {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.MissingData"
        }
    }

    /// Action details for invalid data arrangement.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InvalidDataOrganization {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InvalidDataOrganization {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for InvalidDataOrganization {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Action.InvalidDataOrganization"
        }
    }

    /// The category of issues.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Category {
        /// Unspecified category.
        Unspecified,
        /// Resource management related issues.
        ResourceManagement,
        /// Security policy related issues.
        SecurityPolicy,
        /// Data and discovery related issues.
        DataDiscovery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Category::value] or
        /// [Category::name].
        UnknownValue(category::UnknownValue),
    }

    #[doc(hidden)]
    pub mod category {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Category {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceManagement => std::option::Option::Some(1),
                Self::SecurityPolicy => std::option::Option::Some(2),
                Self::DataDiscovery => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CATEGORY_UNSPECIFIED"),
                Self::ResourceManagement => std::option::Option::Some("RESOURCE_MANAGEMENT"),
                Self::SecurityPolicy => std::option::Option::Some("SECURITY_POLICY"),
                Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Category {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Category {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Category {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ResourceManagement,
                2 => Self::SecurityPolicy,
                3 => Self::DataDiscovery,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Category {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CATEGORY_UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_MANAGEMENT" => Self::ResourceManagement,
                "SECURITY_POLICY" => Self::SecurityPolicy,
                "DATA_DISCOVERY" => Self::DataDiscovery,
                _ => Self::UnknownValue(category::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Category {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceManagement => serializer.serialize_i32(1),
                Self::SecurityPolicy => serializer.serialize_i32(2),
                Self::DataDiscovery => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Category {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Category>::new(
                ".google.cloud.dataplex.v1.Action.Category",
            ))
        }
    }

    /// Additional details about the action based on the action category.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Details {
        /// Details for issues related to invalid or unsupported data formats.
        InvalidDataFormat(std::boxed::Box<crate::model::action::InvalidDataFormat>),
        /// Details for issues related to incompatible schemas detected within data.
        IncompatibleDataSchema(std::boxed::Box<crate::model::action::IncompatibleDataSchema>),
        /// Details for issues related to invalid or unsupported data partition
        /// structure.
        InvalidDataPartition(std::boxed::Box<crate::model::action::InvalidDataPartition>),
        /// Details for issues related to absence of data within managed resources.
        MissingData(std::boxed::Box<crate::model::action::MissingData>),
        /// Details for issues related to absence of a managed resource.
        MissingResource(std::boxed::Box<crate::model::action::MissingResource>),
        /// Details for issues related to lack of permissions to access data
        /// resources.
        UnauthorizedResource(std::boxed::Box<crate::model::action::UnauthorizedResource>),
        /// Details for issues related to applying security policy.
        FailedSecurityPolicyApply(std::boxed::Box<crate::model::action::FailedSecurityPolicyApply>),
        /// Details for issues related to invalid data arrangement.
        InvalidDataOrganization(std::boxed::Box<crate::model::action::InvalidDataOrganization>),
    }
}

/// An asset represents a cloud resource that is being managed within a lake as a
/// member of a zone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Asset {
    /// Output only. The relative resource name of the asset, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. System generated globally unique ID for the asset. This ID
    /// will be different if the asset is deleted and re-created with the same
    /// name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the asset was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the asset was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User defined labels for the asset.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Description of the asset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Current state of the asset.
    pub state: crate::model::State,

    /// Required. Specification of the resource that is referenced by this asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_spec: std::option::Option<crate::model::asset::ResourceSpec>,

    /// Output only. Status of the resource referenced by this asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub resource_status: std::option::Option<crate::model::asset::ResourceStatus>,

    /// Output only. Status of the security policy applied to resource referenced
    /// by this asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub security_status: std::option::Option<crate::model::asset::SecurityStatus>,

    /// Optional. Specification of the discovery feature applied to data referenced
    /// by this asset. When this spec is left unset, the asset will use the spec
    /// set on the parent zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_spec: std::option::Option<crate::model::asset::DiscoverySpec>,

    /// Output only. Status of the discovery feature applied to data referenced by
    /// this asset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub discovery_status: std::option::Option<crate::model::asset::DiscoveryStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Asset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Asset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Asset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Asset::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Asset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Asset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Asset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Asset::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Asset::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [resource_spec][crate::model::Asset::resource_spec].
    pub fn set_resource_spec<
        T: std::convert::Into<std::option::Option<crate::model::asset::ResourceSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_spec = v.into();
        self
    }

    /// Sets the value of [resource_status][crate::model::Asset::resource_status].
    pub fn set_resource_status<
        T: std::convert::Into<std::option::Option<crate::model::asset::ResourceStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_status = v.into();
        self
    }

    /// Sets the value of [security_status][crate::model::Asset::security_status].
    pub fn set_security_status<
        T: std::convert::Into<std::option::Option<crate::model::asset::SecurityStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.security_status = v.into();
        self
    }

    /// Sets the value of [discovery_spec][crate::model::Asset::discovery_spec].
    pub fn set_discovery_spec<
        T: std::convert::Into<std::option::Option<crate::model::asset::DiscoverySpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_spec = v.into();
        self
    }

    /// Sets the value of [discovery_status][crate::model::Asset::discovery_status].
    pub fn set_discovery_status<
        T: std::convert::Into<std::option::Option<crate::model::asset::DiscoveryStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.discovery_status = v.into();
        self
    }
}

impl wkt::message::Message for Asset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Asset"
    }
}

/// Defines additional types related to [Asset].
pub mod asset {
    #[allow(unused_imports)]
    use super::*;

    /// Security policy status of the asset. Data security policy, i.e., readers,
    /// writers & owners, should be specified in the lake/zone/asset IAM policy.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SecurityStatus {
        /// The current state of the security policy applied to the attached
        /// resource.
        pub state: crate::model::asset::security_status::State,

        /// Additional information about the current state.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Last update time of the status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SecurityStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::SecurityStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::security_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::SecurityStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::SecurityStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SecurityStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.SecurityStatus"
        }
    }

    /// Defines additional types related to [SecurityStatus].
    pub mod security_status {
        #[allow(unused_imports)]
        use super::*;

        /// The state of the security policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// Security policy has been successfully applied to the attached resource.
            Ready,
            /// Security policy is in the process of being applied to the attached
            /// resource.
            Applying,
            /// Security policy could not be applied to the attached resource due to
            /// errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ready => std::option::Option::Some(1),
                    Self::Applying => std::option::Option::Some(2),
                    Self::Error => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Applying => std::option::Option::Some("APPLYING"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ready,
                    2 => Self::Applying,
                    3 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "READY" => Self::Ready,
                    "APPLYING" => Self::Applying,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ready => serializer.serialize_i32(1),
                    Self::Applying => serializer.serialize_i32(2),
                    Self::Error => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.SecurityStatus.State",
                ))
            }
        }
    }

    /// Settings to manage the metadata discovery and publishing for an asset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DiscoverySpec {
        /// Optional. Whether discovery is enabled.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub enabled: bool,

        /// Optional. The list of patterns to apply for selecting data to include
        /// during discovery if only a subset of the data should considered.  For
        /// Cloud Storage bucket assets, these are interpreted as glob patterns used
        /// to match object names. For BigQuery dataset assets, these are interpreted
        /// as patterns to match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub include_patterns: std::vec::Vec<std::string::String>,

        /// Optional. The list of patterns to apply for selecting data to exclude
        /// during discovery.  For Cloud Storage bucket assets, these are interpreted
        /// as glob patterns used to match object names. For BigQuery dataset assets,
        /// these are interpreted as patterns to match table names.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub exclude_patterns: std::vec::Vec<std::string::String>,

        /// Optional. Configuration for CSV data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub csv_options: std::option::Option<crate::model::asset::discovery_spec::CsvOptions>,

        /// Optional. Configuration for Json data.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub json_options: std::option::Option<crate::model::asset::discovery_spec::JsonOptions>,

        /// Determines when discovery is triggered.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::asset::discovery_spec::Trigger>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoverySpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::asset::DiscoverySpec::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [include_patterns][crate::model::asset::DiscoverySpec::include_patterns].
        pub fn set_include_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.include_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclude_patterns][crate::model::asset::DiscoverySpec::exclude_patterns].
        pub fn set_exclude_patterns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.exclude_patterns = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [csv_options][crate::model::asset::DiscoverySpec::csv_options].
        pub fn set_csv_options<
            T: std::convert::Into<
                    std::option::Option<crate::model::asset::discovery_spec::CsvOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.csv_options = v.into();
            self
        }

        /// Sets the value of [json_options][crate::model::asset::DiscoverySpec::json_options].
        pub fn set_json_options<
            T: std::convert::Into<
                    std::option::Option<crate::model::asset::discovery_spec::JsonOptions>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.json_options = v.into();
            self
        }

        /// Sets the value of [trigger][crate::model::asset::DiscoverySpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::asset::discovery_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::asset::DiscoverySpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::asset::discovery_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::asset::DiscoverySpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::asset::discovery_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for DiscoverySpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec"
        }
    }

    /// Defines additional types related to [DiscoverySpec].
    pub mod discovery_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Describe CSV and similar semi-structured data formats.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CsvOptions {
            /// Optional. The number of rows to interpret as header rows that should be
            /// skipped when reading data rows.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub header_rows: i32,

            /// Optional. The delimiter being used to separate values. This defaults to
            /// ','.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub delimiter: std::string::String,

            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for CSV data.
            /// If true, all columns will be registered as strings.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disable_type_inference: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CsvOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header_rows][crate::model::asset::discovery_spec::CsvOptions::header_rows].
            pub fn set_header_rows<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.header_rows = v.into();
                self
            }

            /// Sets the value of [delimiter][crate::model::asset::discovery_spec::CsvOptions::delimiter].
            pub fn set_delimiter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.delimiter = v.into();
                self
            }

            /// Sets the value of [encoding][crate::model::asset::discovery_spec::CsvOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::asset::discovery_spec::CsvOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for CsvOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec.CsvOptions"
            }
        }

        /// Describe JSON data format.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct JsonOptions {
            /// Optional. The character encoding of the data. The default is UTF-8.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub encoding: std::string::String,

            /// Optional. Whether to disable the inference of data type for Json data.
            /// If true, all columns will be registered as their primitive types
            /// (strings, number or boolean).
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub disable_type_inference: bool,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl JsonOptions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::asset::discovery_spec::JsonOptions::encoding].
            pub fn set_encoding<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// Sets the value of [disable_type_inference][crate::model::asset::discovery_spec::JsonOptions::disable_type_inference].
            pub fn set_disable_type_inference<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disable_type_inference = v.into();
                self
            }
        }

        impl wkt::message::Message for JsonOptions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoverySpec.JsonOptions"
            }
        }

        /// Determines when discovery is triggered.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running discovery periodically. Successive discovery runs must be
            /// scheduled at least 60 minutes apart. The default value is to run
            /// discovery every 60 minutes.
            ///
            /// To explicitly set a timezone to the cron tab, apply a prefix in the
            /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or TZ=${IANA_TIME_ZONE}".
            /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
            /// database. For example, `CRON_TZ=America/New_York 1 * * * *`, or
            /// `TZ=America/New_York 1 * * * *`.
            Schedule(std::string::String),
        }
    }

    /// Identifies the cloud resource that is referenced by this asset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceSpec {
        /// Immutable. Relative name of the cloud resource that contains the data
        /// that is being managed within a lake. For example:
        /// `projects/{project_number}/buckets/{bucket_id}`
        /// `projects/{project_number}/datasets/{dataset_id}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Required. Immutable. Type of resource.
        #[serde(rename = "type")]
        pub r#type: crate::model::asset::resource_spec::Type,

        /// Optional. Determines how read permissions are handled for each asset and
        /// their associated tables. Only available to storage buckets assets.
        pub read_access_mode: crate::model::asset::resource_spec::AccessMode,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::asset::ResourceSpec::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::asset::ResourceSpec::type].
        pub fn set_type<T: std::convert::Into<crate::model::asset::resource_spec::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [read_access_mode][crate::model::asset::ResourceSpec::read_access_mode].
        pub fn set_read_access_mode<
            T: std::convert::Into<crate::model::asset::resource_spec::AccessMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.read_access_mode = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.ResourceSpec"
        }
    }

    /// Defines additional types related to [ResourceSpec].
    pub mod resource_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Type of resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Type not specified.
            Unspecified,
            /// Cloud Storage bucket.
            StorageBucket,
            /// BigQuery dataset.
            BigqueryDataset,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::StorageBucket => std::option::Option::Some(1),
                    Self::BigqueryDataset => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::StorageBucket => std::option::Option::Some("STORAGE_BUCKET"),
                    Self::BigqueryDataset => std::option::Option::Some("BIGQUERY_DATASET"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::StorageBucket,
                    2 => Self::BigqueryDataset,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "STORAGE_BUCKET" => Self::StorageBucket,
                    "BIGQUERY_DATASET" => Self::BigqueryDataset,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::StorageBucket => serializer.serialize_i32(1),
                    Self::BigqueryDataset => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceSpec.Type",
                ))
            }
        }

        /// Access Mode determines how data stored within the resource is read. This
        /// is only applicable to storage bucket assets.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AccessMode {
            /// Access mode unspecified.
            Unspecified,
            /// Default. Data is accessed directly using storage APIs.
            Direct,
            /// Data is accessed through a managed interface using BigQuery APIs.
            Managed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AccessMode::value] or
            /// [AccessMode::name].
            UnknownValue(access_mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod access_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl AccessMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Direct => std::option::Option::Some(1),
                    Self::Managed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ACCESS_MODE_UNSPECIFIED"),
                    Self::Direct => std::option::Option::Some("DIRECT"),
                    Self::Managed => std::option::Option::Some("MANAGED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for AccessMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for AccessMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for AccessMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Direct,
                    2 => Self::Managed,
                    _ => Self::UnknownValue(access_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for AccessMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ACCESS_MODE_UNSPECIFIED" => Self::Unspecified,
                    "DIRECT" => Self::Direct,
                    "MANAGED" => Self::Managed,
                    _ => Self::UnknownValue(access_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for AccessMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Direct => serializer.serialize_i32(1),
                    Self::Managed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for AccessMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AccessMode>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceSpec.AccessMode",
                ))
            }
        }
    }

    /// Status of the resource referenced by an asset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ResourceStatus {
        /// The current state of the managed resource.
        pub state: crate::model::asset::resource_status::State,

        /// Additional information about the current state.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Last update time of the status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. Service account associated with the BigQuery Connection.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub managed_access_identity: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::ResourceStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::resource_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::ResourceStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::ResourceStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [managed_access_identity][crate::model::asset::ResourceStatus::managed_access_identity].
        pub fn set_managed_access_identity<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.managed_access_identity = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.ResourceStatus"
        }
    }

    /// Defines additional types related to [ResourceStatus].
    pub mod resource_status {
        #[allow(unused_imports)]
        use super::*;

        /// The state of a resource.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State unspecified.
            Unspecified,
            /// Resource does not have any errors.
            Ready,
            /// Resource has errors.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Ready => std::option::Option::Some(1),
                    Self::Error => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Error => std::option::Option::Some("ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Ready,
                    2 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "READY" => Self::Ready,
                    "ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Ready => serializer.serialize_i32(1),
                    Self::Error => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.ResourceStatus.State",
                ))
            }
        }
    }

    /// Status of discovery for an asset.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DiscoveryStatus {
        /// The current status of the discovery feature.
        pub state: crate::model::asset::discovery_status::State,

        /// Additional information about the current state.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// Last update time of the status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// The start time of the last discovery run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_run_time: std::option::Option<wkt::Timestamp>,

        /// Data Stats of the asset reported by discovery.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub stats: std::option::Option<crate::model::asset::discovery_status::Stats>,

        /// The duration of the last discovery run.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub last_run_duration: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiscoveryStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::asset::DiscoveryStatus::state].
        pub fn set_state<T: std::convert::Into<crate::model::asset::discovery_status::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [message][crate::model::asset::DiscoveryStatus::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::asset::DiscoveryStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [last_run_time][crate::model::asset::DiscoveryStatus::last_run_time].
        pub fn set_last_run_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_run_time = v.into();
            self
        }

        /// Sets the value of [stats][crate::model::asset::DiscoveryStatus::stats].
        pub fn set_stats<
            T: std::convert::Into<std::option::Option<crate::model::asset::discovery_status::Stats>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.stats = v.into();
            self
        }

        /// Sets the value of [last_run_duration][crate::model::asset::DiscoveryStatus::last_run_duration].
        pub fn set_last_run_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_run_duration = v.into();
            self
        }
    }

    impl wkt::message::Message for DiscoveryStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoveryStatus"
        }
    }

    /// Defines additional types related to [DiscoveryStatus].
    pub mod discovery_status {
        #[allow(unused_imports)]
        use super::*;

        /// The aggregated data statistics for the asset reported by discovery.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Stats {
            /// The count of data items within the referenced resource.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub data_items: i64,

            /// The number of stored data bytes within the referenced resource.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub data_size: i64,

            /// The count of table entities within the referenced resource.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub tables: i64,

            /// The count of fileset entities within the referenced resource.
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            #[serde_as(as = "serde_with::DisplayFromStr")]
            pub filesets: i64,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Stats {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_items][crate::model::asset::discovery_status::Stats::data_items].
            pub fn set_data_items<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.data_items = v.into();
                self
            }

            /// Sets the value of [data_size][crate::model::asset::discovery_status::Stats::data_size].
            pub fn set_data_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.data_size = v.into();
                self
            }

            /// Sets the value of [tables][crate::model::asset::discovery_status::Stats::tables].
            pub fn set_tables<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.tables = v.into();
                self
            }

            /// Sets the value of [filesets][crate::model::asset::discovery_status::Stats::filesets].
            pub fn set_filesets<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.filesets = v.into();
                self
            }
        }

        impl wkt::message::Message for Stats {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Asset.DiscoveryStatus.Stats"
            }
        }

        /// Current state of discovery.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// State is unspecified.
            Unspecified,
            /// Discovery for the asset is scheduled.
            Scheduled,
            /// Discovery for the asset is running.
            InProgress,
            /// Discovery for the asset is currently paused (e.g. due to a lack
            /// of available resources). It will be automatically resumed.
            Paused,
            /// Discovery for the asset is disabled.
            Disabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Scheduled => std::option::Option::Some(1),
                    Self::InProgress => std::option::Option::Some(2),
                    Self::Paused => std::option::Option::Some(3),
                    Self::Disabled => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                    Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                    Self::Paused => std::option::Option::Some("PAUSED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Scheduled,
                    2 => Self::InProgress,
                    3 => Self::Paused,
                    5 => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "SCHEDULED" => Self::Scheduled,
                    "IN_PROGRESS" => Self::InProgress,
                    "PAUSED" => Self::Paused,
                    "DISABLED" => Self::Disabled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Scheduled => serializer.serialize_i32(1),
                    Self::InProgress => serializer.serialize_i32(2),
                    Self::Paused => serializer.serialize_i32(3),
                    Self::Disabled => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataplex.v1.Asset.DiscoveryStatus.State",
                ))
            }
        }
    }
}

/// ResourceAccessSpec holds the access control configuration to be enforced
/// on the resources, for example, Cloud Storage bucket, BigQuery dataset,
/// BigQuery table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResourceAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on the resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub readers: std::vec::Vec<std::string::String>,

    /// Optional. The set of principals to be granted writer role on the resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub writers: std::vec::Vec<std::string::String>,

    /// Optional. The set of principals to be granted owner role on the resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub owners: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceAccessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [readers][crate::model::ResourceAccessSpec::readers].
    pub fn set_readers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.readers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [writers][crate::model::ResourceAccessSpec::writers].
    pub fn set_writers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.writers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [owners][crate::model::ResourceAccessSpec::owners].
    pub fn set_owners<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.owners = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ResourceAccessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ResourceAccessSpec"
    }
}

/// DataAccessSpec holds the access control configuration to be enforced on data
/// stored within resources (eg: rows, columns in BigQuery Tables). When
/// associated with data, the data is only accessible to
/// principals explicitly granted access through the DataAccessSpec. Principals
/// with access to the containing resource are not implicitly granted access.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataAccessSpec {
    /// Optional. The format of strings follows the pattern followed by IAM in the
    /// bindings. user:{email}, serviceAccount:{email} group:{email}.
    /// The set of principals to be granted reader role on data
    /// stored within resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub readers: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataAccessSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [readers][crate::model::DataAccessSpec::readers].
    pub fn set_readers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.readers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataAccessSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DataAccessSpec"
    }
}

/// Create lake request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateLakeRequest {
    /// Required. The resource name of the lake location, of the form:
    /// projects/{project_number}/locations/{location_id}
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Lake identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the customer project / location.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub lake_id: std::string::String,

    /// Required. Lake resource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lake: std::option::Option<crate::model::Lake>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLakeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [lake_id][crate::model::CreateLakeRequest::lake_id].
    pub fn set_lake_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.lake_id = v.into();
        self
    }

    /// Sets the value of [lake][crate::model::CreateLakeRequest::lake].
    pub fn set_lake<T: std::convert::Into<std::option::Option<crate::model::Lake>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lake = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateLakeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateLakeRequest"
    }
}

/// Update lake request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateLakeRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lake: std::option::Option<crate::model::Lake>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateLakeRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [lake][crate::model::UpdateLakeRequest::lake].
    pub fn set_lake<T: std::convert::Into<std::option::Option<crate::model::Lake>>>(
        mut self,
        v: T,
    ) -> Self {
        self.lake = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateLakeRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateLakeRequest"
    }
}

/// Delete lake request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLakeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteLakeRequest"
    }
}

/// List lakes request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLakesRequest {
    /// Required. The resource name of the lake location, of the form:
    /// `projects/{project_number}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of Lakes to return. The service may return fewer
    /// than this value. If unspecified, at most 10 lakes will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListLakes` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListLakes` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLakesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLakesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLakesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLakesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListLakesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListLakesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakesRequest"
    }
}

/// List lakes response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLakesResponse {
    /// Lakes under the given parent location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub lakes: std::vec::Vec<crate::model::Lake>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [lakes][crate::model::ListLakesResponse::lakes].
    pub fn set_lakes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Lake>,
    {
        use std::iter::Iterator;
        self.lakes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLakesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListLakesResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListLakesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLakesResponse {
    type PageItem = crate::model::Lake;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.lakes
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// List lake actions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLakeActionsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListLakeActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListLakeActions` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLakeActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLakeActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLakeActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLakeActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLakeActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListLakeActionsRequest"
    }
}

/// List actions response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListActionsResponse {
    /// Actions under the given parent lake/zone/asset.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub actions: std::vec::Vec<crate::model::Action>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListActionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [actions][crate::model::ListActionsResponse::actions].
    pub fn set_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Action>,
    {
        use std::iter::Iterator;
        self.actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListActionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListActionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListActionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListActionsResponse {
    type PageItem = crate::model::Action;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.actions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get lake request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLakeRequest {
    /// Required. The resource name of the lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLakeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLakeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLakeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetLakeRequest"
    }
}

/// Create zone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateZoneRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Zone identifier.
    /// This ID will be used to generate names such as database and dataset names
    /// when publishing metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique across all lakes from all locations in a project.
    /// * Must not be one of the reserved IDs (i.e. "default", "global-temp")
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone_id: std::string::String,

    /// Required. Zone resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zone: std::option::Option<crate::model::Zone>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateZoneRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [zone_id][crate::model::CreateZoneRequest::zone_id].
    pub fn set_zone_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateZoneRequest::zone].
    pub fn set_zone<T: std::convert::Into<std::option::Option<crate::model::Zone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateZoneRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateZoneRequest"
    }
}

/// Update zone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateZoneRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zone: std::option::Option<crate::model::Zone>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateZoneRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateZoneRequest::zone].
    pub fn set_zone<T: std::convert::Into<std::option::Option<crate::model::Zone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateZoneRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateZoneRequest"
    }
}

/// Delete zone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteZoneRequest"
    }
}

/// List zones request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListZonesRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of zones to return. The service may return fewer
    /// than this value. If unspecified, at most 10 zones will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZonesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListZonesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListZonesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListZonesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListZonesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListZonesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListZonesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZonesRequest"
    }
}

/// List zones response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListZonesResponse {
    /// Zones under the given parent lake.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub zones: std::vec::Vec<crate::model::Zone>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZonesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zones][crate::model::ListZonesResponse::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Zone>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListZonesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListZonesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZonesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListZonesResponse {
    type PageItem = crate::model::Zone;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.zones
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// List zone actions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListZoneActionsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZoneActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListZoneActions` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListZoneActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListZoneActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListZoneActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListZoneActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListZoneActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListZoneActionsRequest"
    }
}

/// Get zone request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetZoneRequest {
    /// Required. The resource name of the zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetZoneRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetZoneRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetZoneRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetZoneRequest"
    }
}

/// Create asset request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAssetRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Asset identifier.
    /// This ID will be used to generate names such as table names when publishing
    /// metadata to Hive Metastore and BigQuery.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    /// * Must be between 1-63 characters.
    /// * Must be unique within the zone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub asset_id: std::string::String,

    /// Required. Asset resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAssetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [asset_id][crate::model::CreateAssetRequest::asset_id].
    pub fn set_asset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.asset_id = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::CreateAssetRequest::asset].
    pub fn set_asset<T: std::convert::Into<std::option::Option<crate::model::Asset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateAssetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateAssetRequest"
    }
}

/// Update asset request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAssetRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub asset: std::option::Option<crate::model::Asset>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateAssetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [asset][crate::model::UpdateAssetRequest::asset].
    pub fn set_asset<T: std::convert::Into<std::option::Option<crate::model::Asset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.asset = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateAssetRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateAssetRequest"
    }
}

/// Delete asset request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteAssetRequest"
    }
}

/// List assets request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAssetsRequest {
    /// Required. The resource name of the parent zone:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of asset to return. The service may return fewer
    /// than this value. If unspecified, at most 10 assets will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAssets` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListAssets` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAssetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListAssetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetsRequest"
    }
}

/// List assets response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAssetsResponse {
    /// Asset under the given parent zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub assets: std::vec::Vec<crate::model::Asset>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [assets][crate::model::ListAssetsResponse::assets].
    pub fn set_assets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Asset>,
    {
        use std::iter::Iterator;
        self.assets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAssetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAssetsResponse {
    type PageItem = crate::model::Asset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.assets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// List asset actions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAssetActionsRequest {
    /// Required. The resource name of the parent asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of actions to return. The service may return fewer
    /// than this value. If unspecified, at most 10 actions will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListAssetActions` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListAssetActions` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAssetActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAssetActionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAssetActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAssetActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAssetActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListAssetActionsRequest"
    }
}

/// Get asset request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAssetRequest {
    /// Required. The resource name of the asset:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/zones/{zone_id}/assets/{asset_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAssetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAssetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAssetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetAssetRequest"
    }
}

/// Represents the metadata of a long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.OperationMetadata"
    }
}

/// Create task request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTaskRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Task identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub task_id: std::string::String,

    /// Required. Task resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub task: std::option::Option<crate::model::Task>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTaskRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [task_id][crate::model::CreateTaskRequest::task_id].
    pub fn set_task_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.task_id = v.into();
        self
    }

    /// Sets the value of [task][crate::model::CreateTaskRequest::task].
    pub fn set_task<T: std::convert::Into<std::option::Option<crate::model::Task>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateTaskRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateTaskRequest"
    }
}

/// Update task request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTaskRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub task: std::option::Option<crate::model::Task>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTaskRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [task][crate::model::UpdateTaskRequest::task].
    pub fn set_task<T: std::convert::Into<std::option::Option<crate::model::Task>>>(
        mut self,
        v: T,
    ) -> Self {
        self.task = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateTaskRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateTaskRequest"
    }
}

/// Delete task request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteTaskRequest"
    }
}

/// List tasks request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of tasks to return. The service may return fewer
    /// than this value. If unspecified, at most 10 tasks will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListZones` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListZones` must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTasksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTasksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTasksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTasksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTasksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTasksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListTasksRequest"
    }
}

/// List tasks response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTasksResponse {
    /// Tasks under the given parent lake.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tasks: std::vec::Vec<crate::model::Task>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTasksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tasks][crate::model::ListTasksResponse::tasks].
    pub fn set_tasks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Task>,
    {
        use std::iter::Iterator;
        self.tasks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTasksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable_locations][crate::model::ListTasksResponse::unreachable_locations].
    pub fn set_unreachable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTasksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListTasksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTasksResponse {
    type PageItem = crate::model::Task;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tasks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get task request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{tasks_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetTaskRequest"
    }
}

/// Get job request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetJobRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunTaskRequest {
    /// Required. The resource name of the task:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. User-defined labels for the task. If the map is left empty, the
    /// task will run with existing labels from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// labels. If the map contains an entry with an existing label key in task
    /// definition, the task will run with new label value for that entry. Clearing
    /// an existing label will require label value to be explicitly set to a hyphen
    /// "-". The label value cannot be empty.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Execution spec arguments. If the map is left empty, the task will
    /// run with existing execution spec args from task definition. If the map
    /// contains an entry with a new key, the same will be added to existing set of
    /// args. If the map contains an entry with an existing arg key in task
    /// definition, the task will run with new arg value for that entry. Clearing
    /// an existing arg will require arg value to be explicitly set to a hyphen
    /// "-". The arg value cannot be empty.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub args: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTaskRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunTaskRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::RunTaskRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [args][crate::model::RunTaskRequest::args].
    pub fn set_args<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RunTaskRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunTaskRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RunTaskResponse {
    /// Jobs created by RunTask API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunTaskResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job][crate::model::RunTaskResponse::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }
}

impl wkt::message::Message for RunTaskResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.RunTaskResponse"
    }
}

/// List jobs request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of jobs to return. The service may return fewer
    /// than this value. If unspecified, at most 10 jobs will be returned. The
    /// maximum value is 1000; values above 1000 will be coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListJobs` call. Provide this
    /// to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListJobs` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListJobsRequest"
    }
}

/// List jobs response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// Jobs under a given task.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Cancel task jobs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelJobRequest {
    /// Required. The resource name of the job:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/task/{task_id}/job/{job_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CancelJobRequest"
    }
}

/// Create environment request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Environment identifier.
    ///
    /// * Must contain only lowercase letters, numbers and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the lake.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub environment_id: std::string::String,

    /// Required. Environment resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment: std::option::Option<crate::model::Environment>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment_id][crate::model::CreateEnvironmentRequest::environment_id].
    pub fn set_environment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment_id = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<
        T: std::convert::Into<std::option::Option<crate::model::Environment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateEnvironmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.CreateEnvironmentRequest"
    }
}

/// Update environment request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// Required. Mask of fields to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in `update_mask` are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment: std::option::Option<crate::model::Environment>,

    /// Optional. Only validate the request, but do not perform mutations.
    /// The default is false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<
        T: std::convert::Into<std::option::Option<crate::model::Environment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateEnvironmentRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.UpdateEnvironmentRequest"
    }
}

/// Delete environment request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.DeleteEnvironmentRequest"
    }
}

/// List environments request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// Required. The resource name of the parent lake:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of environments to return. The service may return
    /// fewer than this value. If unspecified, at most 10 environments will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListEnvironments` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListEnvironments` must match the call that provided
    /// the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEnvironmentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEnvironmentsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEnvironmentsRequest"
    }
}

/// List environments response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// Environments under the given parent lake.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListEnvironmentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Get environment request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// Required. The resource name of the environment:
    /// `projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environments/{environment_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.GetEnvironmentRequest"
    }
}

/// List sessions request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// Required. The resource name of the parent environment:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of sessions to return. The service may return
    /// fewer than this value. If unspecified, at most 10 sessions will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListSessions` call. Provide
    /// this to retrieve the subsequent page. When paginating, all other parameters
    /// provided to `ListSessions` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filter request. The following `mode` filter is supported to
    /// return only the sessions belonging to the requester when the mode is USER
    /// and return sessions of all the users when the mode is ADMIN. When no filter
    /// is sent default to USER mode. NOTE: When the mode is ADMIN, the requester
    /// should have `dataplex.environments.listAllSessions` permission to list all
    /// sessions, in absence of the permission, the request fails.
    ///
    /// mode = ADMIN | USER
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListSessionsRequest"
    }
}

/// List sessions response.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// Sessions under a given environment.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A task represents a user-visible job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Task {
    /// Output only. The relative resource name of the task, of the form:
    /// projects/{project_number}/locations/{location_id}/lakes/{lake_id}/
    /// tasks/{task_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the task. This ID will
    /// be different if the task is deleted and re-created with the same name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the task was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the task was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Description of the task.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. User friendly display name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Current state of the task.
    pub state: crate::model::State,

    /// Optional. User-defined labels for the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Spec related to how often and when a task should be triggered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trigger_spec: std::option::Option<crate::model::task::TriggerSpec>,

    /// Required. Spec related to how a task is executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_spec: std::option::Option<crate::model::task::ExecutionSpec>,

    /// Output only. Status of the latest task executions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_status: std::option::Option<crate::model::task::ExecutionStatus>,

    /// Task template specific user-specified config.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::task::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Task {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Task::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Task::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Task::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Task::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Task::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Task::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Task::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Task::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [trigger_spec][crate::model::Task::trigger_spec].
    pub fn set_trigger_spec<
        T: std::convert::Into<std::option::Option<crate::model::task::TriggerSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.trigger_spec = v.into();
        self
    }

    /// Sets the value of [execution_spec][crate::model::Task::execution_spec].
    pub fn set_execution_spec<
        T: std::convert::Into<std::option::Option<crate::model::task::ExecutionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_spec = v.into();
        self
    }

    /// Sets the value of [execution_status][crate::model::Task::execution_status].
    pub fn set_execution_status<
        T: std::convert::Into<std::option::Option<crate::model::task::ExecutionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_status = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Task::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::task::Config>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::Task::config]
    /// if it holds a `Spark`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::task::SparkTaskConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::task::Config::Spark(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Task::config]
    /// to hold a `Spark`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_spark<
        T: std::convert::Into<std::boxed::Box<crate::model::task::SparkTaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::task::Config::Spark(v.into()));
        self
    }

    /// The value of [config][crate::model::Task::config]
    /// if it holds a `Notebook`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::task::NotebookTaskConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::task::Config::Notebook(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Task::config]
    /// to hold a `Notebook`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_notebook<
        T: std::convert::Into<std::boxed::Box<crate::model::task::NotebookTaskConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(crate::model::task::Config::Notebook(v.into()));
        self
    }
}

impl wkt::message::Message for Task {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Task"
    }
}

/// Defines additional types related to [Task].
pub mod task {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the underlying infrastructure used to run workloads.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InfrastructureSpec {
        /// Hardware config.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub resources: std::option::Option<crate::model::task::infrastructure_spec::Resources>,

        /// Software config.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub runtime: std::option::Option<crate::model::task::infrastructure_spec::Runtime>,

        /// Networking config.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub network: std::option::Option<crate::model::task::infrastructure_spec::Network>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InfrastructureSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resources][crate::model::task::InfrastructureSpec::resources].
        ///
        /// Note that all the setters affecting `resources` are mutually
        /// exclusive.
        pub fn set_resources<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Resources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = v.into();
            self
        }

        /// The value of [resources][crate::model::task::InfrastructureSpec::resources]
        /// if it holds a `Batch`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>,
        > {
            #[allow(unreachable_patterns)]
            self.resources.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Resources::Batch(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [resources][crate::model::task::InfrastructureSpec::resources]
        /// to hold a `Batch`.
        ///
        /// Note that all the setters affecting `resources` are
        /// mutually exclusive.
        pub fn set_batch<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.resources = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Resources::Batch(v.into()),
            );
            self
        }

        /// Sets the value of [runtime][crate::model::task::InfrastructureSpec::runtime].
        ///
        /// Note that all the setters affecting `runtime` are mutually
        /// exclusive.
        pub fn set_runtime<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Runtime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = v.into();
            self
        }

        /// The value of [runtime][crate::model::task::InfrastructureSpec::runtime]
        /// if it holds a `ContainerImage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn container_image(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
        > {
            #[allow(unreachable_patterns)]
            self.runtime.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Runtime::ContainerImage(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [runtime][crate::model::task::InfrastructureSpec::runtime]
        /// to hold a `ContainerImage`.
        ///
        /// Note that all the setters affecting `runtime` are
        /// mutually exclusive.
        pub fn set_container_image<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.runtime = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Runtime::ContainerImage(v.into()),
            );
            self
        }

        /// Sets the value of [network][crate::model::task::InfrastructureSpec::network].
        ///
        /// Note that all the setters affecting `network` are mutually
        /// exclusive.
        pub fn set_network<
            T: std::convert::Into<
                    std::option::Option<crate::model::task::infrastructure_spec::Network>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network = v.into();
            self
        }

        /// The value of [network][crate::model::task::InfrastructureSpec::network]
        /// if it holds a `VpcNetwork`, `None` if the field is not set or
        /// holds a different branch.
        pub fn vpc_network(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>,
        > {
            #[allow(unreachable_patterns)]
            self.network.as_ref().and_then(|v| match v {
                crate::model::task::infrastructure_spec::Network::VpcNetwork(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [network][crate::model::task::InfrastructureSpec::network]
        /// to hold a `VpcNetwork`.
        ///
        /// Note that all the setters affecting `network` are
        /// mutually exclusive.
        pub fn set_vpc_network<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.network = std::option::Option::Some(
                crate::model::task::infrastructure_spec::Network::VpcNetwork(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InfrastructureSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec"
        }
    }

    /// Defines additional types related to [InfrastructureSpec].
    pub mod infrastructure_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Batch compute resources associated with the task.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct BatchComputeResources {
            /// Optional. Total number of job executors.
            /// Executor Count should be between 2 and 100. [Default=2]
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub executors_count: i32,

            /// Optional. Max configurable executors.
            /// If max_executors_count > executors_count, then auto-scaling is enabled.
            /// Max Executor Count should be between 2 and 1000. [Default=1000]
            #[serde(skip_serializing_if = "wkt::internal::is_default")]
            pub max_executors_count: i32,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BatchComputeResources {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [executors_count][crate::model::task::infrastructure_spec::BatchComputeResources::executors_count].
            pub fn set_executors_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.executors_count = v.into();
                self
            }

            /// Sets the value of [max_executors_count][crate::model::task::infrastructure_spec::BatchComputeResources::max_executors_count].
            pub fn set_max_executors_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.max_executors_count = v.into();
                self
            }
        }

        impl wkt::message::Message for BatchComputeResources {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.BatchComputeResources"
            }
        }

        /// Container Image Runtime Configuration used with Batch execution.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct ContainerImageRuntime {
            /// Optional. Container image to use.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub image: std::string::String,

            /// Optional. A list of Java JARS to add to the classpath.
            /// Valid input includes Cloud Storage URIs to Jar binaries.
            /// For example, gs://bucket-name/my/path/to/file.jar
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub java_jars: std::vec::Vec<std::string::String>,

            /// Optional. A list of python packages to be installed.
            /// Valid formats include Cloud Storage URI to a PIP installable library.
            /// For example, gs://bucket-name/my/path/to/lib.tar.gz
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub python_packages: std::vec::Vec<std::string::String>,

            /// Optional. Override to common configuration of open source components
            /// installed on the Dataproc cluster. The properties to set on daemon
            /// config files. Property keys are specified in `prefix:property` format,
            /// for example `core:hadoop.tmp.dir`. For more information, see [Cluster
            /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
            #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
            pub properties: std::collections::HashMap<std::string::String, std::string::String>,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ContainerImageRuntime {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [image][crate::model::task::infrastructure_spec::ContainerImageRuntime::image].
            pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.image = v.into();
                self
            }

            /// Sets the value of [java_jars][crate::model::task::infrastructure_spec::ContainerImageRuntime::java_jars].
            pub fn set_java_jars<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.java_jars = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [python_packages][crate::model::task::infrastructure_spec::ContainerImageRuntime::python_packages].
            pub fn set_python_packages<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.python_packages = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [properties][crate::model::task::infrastructure_spec::ContainerImageRuntime::properties].
            pub fn set_properties<T, K, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = (K, V)>,
                K: std::convert::Into<std::string::String>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
                self
            }
        }

        impl wkt::message::Message for ContainerImageRuntime {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.ContainerImageRuntime"
            }
        }

        /// Cloud VPC Network used to run the infrastructure.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct VpcNetwork {
            /// Optional. List of network tags to apply to the job.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub network_tags: std::vec::Vec<std::string::String>,

            /// The Cloud VPC network identifier.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub network_name: std::option::Option<
                crate::model::task::infrastructure_spec::vpc_network::NetworkName,
            >,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VpcNetwork {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [network_tags][crate::model::task::infrastructure_spec::VpcNetwork::network_tags].
            pub fn set_network_tags<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.network_tags = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name].
            ///
            /// Note that all the setters affecting `network_name` are mutually
            /// exclusive.
            pub fn set_network_name<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::task::infrastructure_spec::vpc_network::NetworkName,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.network_name = v.into();
                self
            }

            /// The value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// if it holds a `Network`, `None` if the field is not set or
            /// holds a different branch.
            pub fn network(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.network_name.as_ref().and_then(|v| match v {
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::Network(
                        v,
                    ) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// to hold a `Network`.
            ///
            /// Note that all the setters affecting `network_name` are
            /// mutually exclusive.
            pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.network_name = std::option::Option::Some(
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::Network(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// if it holds a `SubNetwork`, `None` if the field is not set or
            /// holds a different branch.
            pub fn sub_network(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.network_name.as_ref().and_then(|v| match v {
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::SubNetwork(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [network_name][crate::model::task::infrastructure_spec::VpcNetwork::network_name]
            /// to hold a `SubNetwork`.
            ///
            /// Note that all the setters affecting `network_name` are
            /// mutually exclusive.
            pub fn set_sub_network<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.network_name = std::option::Option::Some(
                    crate::model::task::infrastructure_spec::vpc_network::NetworkName::SubNetwork(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for VpcNetwork {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataplex.v1.Task.InfrastructureSpec.VpcNetwork"
            }
        }

        /// Defines additional types related to [VpcNetwork].
        pub mod vpc_network {
            #[allow(unused_imports)]
            use super::*;

            /// The Cloud VPC network identifier.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum NetworkName {
                /// Optional. The Cloud VPC network in which the job is run. By default,
                /// the Cloud VPC network named Default within the project is used.
                Network(std::string::String),
                /// Optional. The Cloud VPC sub-network in which the job is run.
                SubNetwork(std::string::String),
            }
        }

        /// Hardware config.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Resources {
            /// Compute resources needed for a Task when using Dataproc Serverless.
            Batch(std::boxed::Box<crate::model::task::infrastructure_spec::BatchComputeResources>),
        }

        /// Software config.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Runtime {
            /// Container Image Runtime Configuration.
            ContainerImage(
                std::boxed::Box<crate::model::task::infrastructure_spec::ContainerImageRuntime>,
            ),
        }

        /// Networking config.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Network {
            /// Vpc network.
            VpcNetwork(std::boxed::Box<crate::model::task::infrastructure_spec::VpcNetwork>),
        }
    }

    /// Task scheduling and trigger settings.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TriggerSpec {
        /// Required. Immutable. Trigger type of the user-specified Task.
        #[serde(rename = "type")]
        pub r#type: crate::model::task::trigger_spec::Type,

        /// Optional. The first run of the task will be after this time.
        /// If not specified, the task will run shortly after being submitted if
        /// ON_DEMAND and based on the schedule if RECURRING.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Optional. Prevent the task from executing.
        /// This does not cancel already running tasks. It is intended to temporarily
        /// disable RECURRING tasks.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub disabled: bool,

        /// Optional. Number of retry attempts before aborting.
        /// Set to zero to never attempt to retry a failed task.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_retries: i32,

        /// Trigger only applies for RECURRING tasks.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub trigger: std::option::Option<crate::model::task::trigger_spec::Trigger>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TriggerSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::task::TriggerSpec::type].
        pub fn set_type<T: std::convert::Into<crate::model::task::trigger_spec::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::task::TriggerSpec::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [disabled][crate::model::task::TriggerSpec::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [max_retries][crate::model::task::TriggerSpec::max_retries].
        pub fn set_max_retries<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_retries = v.into();
            self
        }

        /// Sets the value of [trigger][crate::model::task::TriggerSpec::trigger].
        ///
        /// Note that all the setters affecting `trigger` are mutually
        /// exclusive.
        pub fn set_trigger<
            T: std::convert::Into<std::option::Option<crate::model::task::trigger_spec::Trigger>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.trigger = v.into();
            self
        }

        /// The value of [trigger][crate::model::task::TriggerSpec::trigger]
        /// if it holds a `Schedule`, `None` if the field is not set or
        /// holds a different branch.
        pub fn schedule(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.trigger.as_ref().and_then(|v| match v {
                crate::model::task::trigger_spec::Trigger::Schedule(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [trigger][crate::model::task::TriggerSpec::trigger]
        /// to hold a `Schedule`.
        ///
        /// Note that all the setters affecting `trigger` are
        /// mutually exclusive.
        pub fn set_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.trigger = std::option::Option::Some(
                crate::model::task::trigger_spec::Trigger::Schedule(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for TriggerSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.TriggerSpec"
        }
    }

    /// Defines additional types related to [TriggerSpec].
    pub mod trigger_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Determines how often and when the job will run.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unspecified trigger type.
            Unspecified,
            /// The task runs one-time shortly after Task Creation.
            OnDemand,
            /// The task is scheduled to run periodically.
            Recurring,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::OnDemand => std::option::Option::Some(1),
                    Self::Recurring => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                    Self::Recurring => std::option::Option::Some("RECURRING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::OnDemand,
                    2 => Self::Recurring,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "ON_DEMAND" => Self::OnDemand,
                    "RECURRING" => Self::Recurring,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::OnDemand => serializer.serialize_i32(1),
                    Self::Recurring => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dataplex.v1.Task.TriggerSpec.Type",
                ))
            }
        }

        /// Trigger only applies for RECURRING tasks.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Trigger {
            /// Optional. Cron schedule (<https://en.wikipedia.org/wiki/Cron>) for
            /// running tasks periodically. To explicitly set a timezone to the cron
            /// tab, apply a prefix in the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or
            /// "TZ=${IANA_TIME_ZONE}". The ${IANA_TIME_ZONE} may only be a valid
            /// string from IANA time zone database. For example,
            /// `CRON_TZ=America/New_York 1 * * * *`, or `TZ=America/New_York 1 * * *
            /// *`. This field is required for RECURRING tasks.
            Schedule(std::string::String),
        }
    }

    /// Execution related settings, like retry and service_account.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecutionSpec {
        /// Optional. The arguments to pass to the task.
        /// The args can use placeholders of the format ${placeholder} as
        /// part of key/value string. These will be interpolated before passing the
        /// args to the driver. Currently supported placeholders:
        ///
        /// - ${task_id}
        /// - ${job_time}
        ///   To pass positional args, set the key as TASK_ARGS. The value should be a
        ///   comma-separated string of all the positional arguments. To use a
        ///   delimiter other than comma, refer to
        ///   <https://cloud.google.com/sdk/gcloud/reference/topic/escaping>. In case of
        ///   other keys being present in the args, then TASK_ARGS will be passed as
        ///   the last argument.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub args: std::collections::HashMap<std::string::String, std::string::String>,

        /// Required. Service account to use to execute a task.
        /// If not provided, the default Compute service account for the project is
        /// used.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_account: std::string::String,

        /// Optional. The project in which jobs are run. By default, the project
        /// containing the Lake is used. If a project is provided, the
        /// [ExecutionSpec.service_account][google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]
        /// must belong to this project.
        ///
        /// [google.cloud.dataplex.v1.Task.ExecutionSpec.service_account]: crate::model::task::ExecutionSpec::service_account
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project: std::string::String,

        /// Optional. The maximum duration after which the job execution is expired.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub max_job_execution_lifetime: std::option::Option<wkt::Duration>,

        /// Optional. The Cloud KMS key to use for encryption, of the form:
        /// `projects/{project_number}/locations/{location_id}/keyRings/{key-ring-name}/cryptoKeys/{key-name}`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [args][crate::model::task::ExecutionSpec::args].
        pub fn set_args<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.args = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [service_account][crate::model::task::ExecutionSpec::service_account].
        pub fn set_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account = v.into();
            self
        }

        /// Sets the value of [project][crate::model::task::ExecutionSpec::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [max_job_execution_lifetime][crate::model::task::ExecutionSpec::max_job_execution_lifetime].
        pub fn set_max_job_execution_lifetime<
            T: std::convert::Into<std::option::Option<wkt::Duration>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.max_job_execution_lifetime = v.into();
            self
        }

        /// Sets the value of [kms_key][crate::model::task::ExecutionSpec::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }
    }

    impl wkt::message::Message for ExecutionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.ExecutionSpec"
        }
    }

    /// User-specified config for running a Spark task.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SparkTaskConfig {
        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_uris: std::vec::Vec<std::string::String>,

        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub archive_uris: std::vec::Vec<std::string::String>,

        /// Optional. Infrastructure specification for the execution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub infrastructure_spec: std::option::Option<crate::model::task::InfrastructureSpec>,

        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub driver: std::option::Option<crate::model::task::spark_task_config::Driver>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SparkTaskConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [file_uris][crate::model::task::SparkTaskConfig::file_uris].
        pub fn set_file_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [archive_uris][crate::model::task::SparkTaskConfig::archive_uris].
        pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.archive_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [infrastructure_spec][crate::model::task::SparkTaskConfig::infrastructure_spec].
        pub fn set_infrastructure_spec<
            T: std::convert::Into<std::option::Option<crate::model::task::InfrastructureSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.infrastructure_spec = v.into();
            self
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver].
        ///
        /// Note that all the setters affecting `driver` are mutually
        /// exclusive.
        pub fn set_driver<
            T: std::convert::Into<std::option::Option<crate::model::task::spark_task_config::Driver>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.driver = v.into();
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `MainJarFileUri`, `None` if the field is not set or
        /// holds a different branch.
        pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::MainJarFileUri(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `MainJarFileUri`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::MainJarFileUri(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `MainClass`, `None` if the field is not set or
        /// holds a different branch.
        pub fn main_class(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::MainClass(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `MainClass`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::MainClass(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `PythonScriptFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn python_script_file(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::PythonScriptFile(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `PythonScriptFile`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_python_script_file<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::PythonScriptFile(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `SqlScriptFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_script_file(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::SqlScriptFile(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `SqlScriptFile`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_sql_script_file<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::SqlScriptFile(v.into()),
            );
            self
        }

        /// The value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// if it holds a `SqlScript`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sql_script(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.driver.as_ref().and_then(|v| match v {
                crate::model::task::spark_task_config::Driver::SqlScript(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [driver][crate::model::task::SparkTaskConfig::driver]
        /// to hold a `SqlScript`.
        ///
        /// Note that all the setters affecting `driver` are
        /// mutually exclusive.
        pub fn set_sql_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.driver = std::option::Option::Some(
                crate::model::task::spark_task_config::Driver::SqlScript(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for SparkTaskConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.SparkTaskConfig"
        }
    }

    /// Defines additional types related to [SparkTaskConfig].
    pub mod spark_task_config {
        #[allow(unused_imports)]
        use super::*;

        /// Required. The specification of the main method to call to drive the
        /// job. Specify either the jar file that contains the main class or the
        /// main class name.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Driver {
            /// The Cloud Storage URI of the jar file that contains the main class.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            MainJarFileUri(std::string::String),
            /// The name of the driver's main class. The jar file that contains the
            /// class must be in the default CLASSPATH or specified in
            /// `jar_file_uris`.
            /// The execution args are passed in as a sequence of named process
            /// arguments (`--key=value`).
            MainClass(std::string::String),
            /// The Gcloud Storage URI of the main Python file to use as the driver.
            /// Must be a .py file. The execution args are passed in as a sequence of
            /// named process arguments (`--key=value`).
            PythonScriptFile(std::string::String),
            /// A reference to a query file. This should be the Cloud Storage URI of
            /// the query file. The execution args are used to declare a set of script
            /// variables (`set key="value";`).
            SqlScriptFile(std::string::String),
            /// The query text.
            /// The execution args are used to declare a set of script variables
            /// (`set key="value";`).
            SqlScript(std::string::String),
        }
    }

    /// Config for running scheduled notebooks.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NotebookTaskConfig {
        /// Required. Path to input notebook. This can be the Cloud Storage URI of
        /// the notebook file or the path to a Notebook Content. The execution args
        /// are accessible as environment variables
        /// (`TASK_key=value`).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub notebook: std::string::String,

        /// Optional. Infrastructure specification for the execution.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub infrastructure_spec: std::option::Option<crate::model::task::InfrastructureSpec>,

        /// Optional. Cloud Storage URIs of files to be placed in the working
        /// directory of each executor.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub file_uris: std::vec::Vec<std::string::String>,

        /// Optional. Cloud Storage URIs of archives to be extracted into the working
        /// directory of each executor. Supported file types: .jar, .tar, .tar.gz,
        /// .tgz, and .zip.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub archive_uris: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NotebookTaskConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [notebook][crate::model::task::NotebookTaskConfig::notebook].
        pub fn set_notebook<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.notebook = v.into();
            self
        }

        /// Sets the value of [infrastructure_spec][crate::model::task::NotebookTaskConfig::infrastructure_spec].
        pub fn set_infrastructure_spec<
            T: std::convert::Into<std::option::Option<crate::model::task::InfrastructureSpec>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.infrastructure_spec = v.into();
            self
        }

        /// Sets the value of [file_uris][crate::model::task::NotebookTaskConfig::file_uris].
        pub fn set_file_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.file_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [archive_uris][crate::model::task::NotebookTaskConfig::archive_uris].
        pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.archive_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NotebookTaskConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.NotebookTaskConfig"
        }
    }

    /// Status of the task execution (e.g. Jobs).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExecutionStatus {
        /// Output only. Last update time of the status.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,

        /// Output only. latest job execution
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub latest_job: std::option::Option<crate::model::Job>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExecutionStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [update_time][crate::model::task::ExecutionStatus::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }

        /// Sets the value of [latest_job][crate::model::task::ExecutionStatus::latest_job].
        pub fn set_latest_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
            mut self,
            v: T,
        ) -> Self {
            self.latest_job = v.into();
            self
        }
    }

    impl wkt::message::Message for ExecutionStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataplex.v1.Task.ExecutionStatus"
        }
    }

    /// Task template specific user-specified config.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Config related to running custom Spark tasks.
        Spark(std::boxed::Box<crate::model::task::SparkTaskConfig>),
        /// Config related to running scheduled Notebooks.
        Notebook(std::boxed::Box<crate::model::task::NotebookTaskConfig>),
    }
}

/// A job represents an instance of a task.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Job {
    /// Output only. The relative resource name of the job, of the form:
    /// `projects/{project_number}/locations/{location_id}/lakes/{lake_id}/tasks/{task_id}/jobs/{job_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. System generated globally unique ID for the job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. The time when the job was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the job ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Execution state for the job.
    pub state: crate::model::job::State,

    /// Output only. The number of times the job has been retried (excluding the
    /// initial attempt).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub retry_count: u32,

    /// Output only. The underlying service running a job.
    pub service: crate::model::job::Service,

    /// Output only. The full resource name for the job run under a particular
    /// service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_job: std::string::String,

    /// Output only. Additional information about the current state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Output only. User-defined labels for the task.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Job execution trigger.
    pub trigger: crate::model::job::Trigger,

    /// Output only. Spec related to how a task is executed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_spec: std::option::Option<crate::model::task::ExecutionSpec>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Job::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Job::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Job::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Job::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Job::state].
    pub fn set_state<T: std::convert::Into<crate::model::job::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [retry_count][crate::model::Job::retry_count].
    pub fn set_retry_count<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.retry_count = v.into();
        self
    }

    /// Sets the value of [service][crate::model::Job::service].
    pub fn set_service<T: std::convert::Into<crate::model::job::Service>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [service_job][crate::model::Job::service_job].
    pub fn set_service_job<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_job = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Job::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [trigger][crate::model::Job::trigger].
    pub fn set_trigger<T: std::convert::Into<crate::model::job::Trigger>>(mut self, v: T) -> Self {
        self.trigger = v.into();
        self
    }

    /// Sets the value of [execution_spec][crate::model::Job::execution_spec].
    pub fn set_execution_spec<
        T: std::convert::Into<std::option::Option<crate::model::task::ExecutionSpec>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_spec = v.into();
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataplex.v1.Job"
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Service {
        /// Service used to run the job is unspecified.
        Unspecified,
        /// Dataproc service is used to run this job.
        Dataproc,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Service::value] or
        /// [Service::name].
        UnknownValue(service::UnknownValue),
    }

    #[doc(hidden)]
    pub mod service {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Service {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Dataproc => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVICE_UNSPECIFIED"),
                Self::Dataproc => std::option::Option::Some("DATAPROC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Service {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Service {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Service {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Service {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVICE_UNSPECIFIED" => Self::Unspecified,
                "DATAPROC" => Self::Dataproc,
                _ => Self::UnknownValue(service::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Service {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Dataproc => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Service {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Service>::new(
                ".google.cloud.dataplex.v1.Job.Service",
            ))
        }
    }

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The job state is unknown.
        Unspecified,
        /// The job is running.
        Running,
        /// The job is cancelling.
        Cancelling,
        /// The job cancellation was successful.
        Cancelled,
        /// The job completed successfully.
        Succeeded,
        /// The job is no longer running due to an error.
        Failed,
        /// The job was cancelled outside of Dataplex.
        Aborted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Cancelling => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Aborted => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Aborted => std::option::Option::Some("ABORTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Cancelling,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "ABORTED" => Self::Aborted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Cancelling => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Aborted => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataplex.v1.Job.State",
            ))
        }
    }

    /// Job execution trigger.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Trigger {
        /// The trigger is unspecified.
        Unspecified,
        /// The job was triggered by Dataplex based on trigger spec from task
        /// definition.
        TaskConfig,
        /// The job was triggered by the explicit call of Task API.
        RunRequest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Trigger::value] or
        /// [Trigger::name].
        UnknownValue(trigger::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trigger {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Trigger {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TaskConfig => std::option::Option::Some(1),
                Self::RunRequest => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRIGGER_UNSPECIFIED"),
                Self::TaskConfig => std::option::Option::Some("TASK_CONFIG"),
                Self::RunRequest => std::option::Option::Some("RUN_REQUEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Trigger {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Trigger {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Trigger {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TaskConfig,
                2 => Self::RunRequest,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Trigger {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRIGGER_UNSPECIFIED" => Self::Unspecified,
                "TASK_CONFIG" => Self::TaskConfig,
                "RUN_REQUEST" => Self::RunRequest,
                _ => Self::UnknownValue(trigger::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Trigger {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TaskConfig => serializer.serialize_i32(1),
                Self::RunRequest => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Trigger {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Trigger>::new(
                ".google.cloud.dataplex.v1.Job.Trigger",
            ))
        }
    }
}

/// View for controlling which parts of an entry are to be returned.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum EntryView {
    /// Unspecified EntryView. Defaults to FULL.
    Unspecified,
    /// Returns entry only, without aspects.
    Basic,
    /// Returns all required aspects as well as the keys of all non-required
    /// aspects.
    Full,
    /// Returns aspects matching custom fields in GetEntryRequest. If the number of
    /// aspects exceeds 100, the first 100 will be returned.
    Custom,
    /// Returns all aspects. If the number of aspects exceeds 100, the first
    /// 100 will be returned.
    All,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [EntryView::value] or
    /// [EntryView::name].
    UnknownValue(entry_view::UnknownValue),
}

#[doc(hidden)]
pub mod entry_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl EntryView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::Custom => std::option::Option::Some(3),
            Self::All => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ENTRY_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::Custom => std::option::Option::Some("CUSTOM"),
            Self::All => std::option::Option::Some("ALL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for EntryView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for EntryView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for EntryView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            3 => Self::Custom,
            4 => Self::All,
            _ => Self::UnknownValue(entry_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for EntryView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ENTRY_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            "CUSTOM" => Self::Custom,
            "ALL" => Self::All,
            _ => Self::UnknownValue(entry_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for EntryView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::Custom => serializer.serialize_i32(3),
            Self::All => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for EntryView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntryView>::new(
            ".google.cloud.dataplex.v1.EntryView",
        ))
    }
}

/// Denotes the transfer status of a resource. It is unspecified for resources
/// created from Dataplex API.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransferStatus {
    /// The default value. It is set for resources that were not subject for
    /// migration from Data Catalog service.
    Unspecified,
    /// Indicates that a resource was migrated from Data Catalog service but it
    /// hasn't been transferred yet. In particular the resource cannot be updated
    /// from Dataplex API.
    Migrated,
    /// Indicates that a resource was transferred from Data Catalog service. The
    /// resource can only be updated from Dataplex API.
    Transferred,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransferStatus::value] or
    /// [TransferStatus::name].
    UnknownValue(transfer_status::UnknownValue),
}

#[doc(hidden)]
pub mod transfer_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransferStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Migrated => std::option::Option::Some(1),
            Self::Transferred => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSFER_STATUS_UNSPECIFIED"),
            Self::Migrated => std::option::Option::Some("TRANSFER_STATUS_MIGRATED"),
            Self::Transferred => std::option::Option::Some("TRANSFER_STATUS_TRANSFERRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransferStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransferStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransferStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Migrated,
            2 => Self::Transferred,
            _ => Self::UnknownValue(transfer_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransferStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSFER_STATUS_UNSPECIFIED" => Self::Unspecified,
            "TRANSFER_STATUS_MIGRATED" => Self::Migrated,
            "TRANSFER_STATUS_TRANSFERRED" => Self::Transferred,
            _ => Self::UnknownValue(transfer_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransferStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Migrated => serializer.serialize_i32(1),
            Self::Transferred => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransferStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransferStatus>::new(
            ".google.cloud.dataplex.v1.TransferStatus",
        ))
    }
}

/// The type of data scan.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataScanType {
    /// The data scan type is unspecified.
    Unspecified,
    /// Data quality scan.
    DataQuality,
    /// Data profile scan.
    DataProfile,
    /// Data discovery scan.
    DataDiscovery,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataScanType::value] or
    /// [DataScanType::name].
    UnknownValue(data_scan_type::UnknownValue),
}

#[doc(hidden)]
pub mod data_scan_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DataScanType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::DataQuality => std::option::Option::Some(1),
            Self::DataProfile => std::option::Option::Some(2),
            Self::DataDiscovery => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATA_SCAN_TYPE_UNSPECIFIED"),
            Self::DataQuality => std::option::Option::Some("DATA_QUALITY"),
            Self::DataProfile => std::option::Option::Some("DATA_PROFILE"),
            Self::DataDiscovery => std::option::Option::Some("DATA_DISCOVERY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DataScanType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DataScanType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DataScanType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::DataQuality,
            2 => Self::DataProfile,
            3 => Self::DataDiscovery,
            _ => Self::UnknownValue(data_scan_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DataScanType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATA_SCAN_TYPE_UNSPECIFIED" => Self::Unspecified,
            "DATA_QUALITY" => Self::DataQuality,
            "DATA_PROFILE" => Self::DataProfile,
            "DATA_DISCOVERY" => Self::DataDiscovery,
            _ => Self::UnknownValue(data_scan_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DataScanType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::DataQuality => serializer.serialize_i32(1),
            Self::DataProfile => serializer.serialize_i32(2),
            Self::DataDiscovery => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DataScanType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataScanType>::new(
            ".google.cloud.dataplex.v1.DataScanType",
        ))
    }
}

/// Identifies the cloud system that manages the data storage.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StorageSystem {
    /// Storage system unspecified.
    Unspecified,
    /// The entity data is contained within a Cloud Storage bucket.
    CloudStorage,
    /// The entity data is contained within a BigQuery dataset.
    Bigquery,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StorageSystem::value] or
    /// [StorageSystem::name].
    UnknownValue(storage_system::UnknownValue),
}

#[doc(hidden)]
pub mod storage_system {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StorageSystem {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CloudStorage => std::option::Option::Some(1),
            Self::Bigquery => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STORAGE_SYSTEM_UNSPECIFIED"),
            Self::CloudStorage => std::option::Option::Some("CLOUD_STORAGE"),
            Self::Bigquery => std::option::Option::Some("BIGQUERY"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StorageSystem {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StorageSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StorageSystem {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CloudStorage,
            2 => Self::Bigquery,
            _ => Self::UnknownValue(storage_system::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StorageSystem {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STORAGE_SYSTEM_UNSPECIFIED" => Self::Unspecified,
            "CLOUD_STORAGE" => Self::CloudStorage,
            "BIGQUERY" => Self::Bigquery,
            _ => Self::UnknownValue(storage_system::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StorageSystem {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CloudStorage => serializer.serialize_i32(1),
            Self::Bigquery => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StorageSystem {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageSystem>::new(
            ".google.cloud.dataplex.v1.StorageSystem",
        ))
    }
}

/// State of a resource.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// State is not specified.
    Unspecified,
    /// Resource is active, i.e., ready to use.
    Active,
    /// Resource is under creation.
    Creating,
    /// Resource is under deletion.
    Deleting,
    /// Resource is active but has unresolved actions.
    ActionRequired,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::Creating => std::option::Option::Some(2),
            Self::Deleting => std::option::Option::Some(3),
            Self::ActionRequired => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Creating => std::option::Option::Some("CREATING"),
            Self::Deleting => std::option::Option::Some("DELETING"),
            Self::ActionRequired => std::option::Option::Some("ACTION_REQUIRED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::Creating,
            3 => Self::Deleting,
            4 => Self::ActionRequired,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "ACTIVE" => Self::Active,
            "CREATING" => Self::Creating,
            "DELETING" => Self::Deleting,
            "ACTION_REQUIRED" => Self::ActionRequired,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::Creating => serializer.serialize_i32(2),
            Self::Deleting => serializer.serialize_i32(3),
            Self::ActionRequired => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.dataplex.v1.State",
        ))
    }
}
